// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmemotion.proto

#ifndef PROTOBUF_mmemotion_2eproto__INCLUDED
#define PROTOBUF_mmemotion_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "mmbuiltintype.pb.h"
#include "mmbase.pb.h"
// @@protoc_insertion_point(includes)
namespace micromsg {
class AdditionalContactList;
class AdditionalContactListDefaultTypeInternal;
extern AdditionalContactListDefaultTypeInternal _AdditionalContactList_default_instance_;
class BaseRequest;
class BaseRequestDefaultTypeInternal;
extern BaseRequestDefaultTypeInternal _BaseRequest_default_instance_;
class BaseResponse;
class BaseResponseDefaultTypeInternal;
extern BaseResponseDefaultTypeInternal _BaseResponse_default_instance_;
class BindEmailRequest;
class BindEmailRequestDefaultTypeInternal;
extern BindEmailRequestDefaultTypeInternal _BindEmailRequest_default_instance_;
class BindEmailResponse;
class BindEmailResponseDefaultTypeInternal;
extern BindEmailResponseDefaultTypeInternal _BindEmailResponse_default_instance_;
class BuiltinIP;
class BuiltinIPDefaultTypeInternal;
extern BuiltinIPDefaultTypeInternal _BuiltinIP_default_instance_;
class BuiltinIPList;
class BuiltinIPListDefaultTypeInternal;
extern BuiltinIPListDefaultTypeInternal _BuiltinIPList_default_instance_;
class CDNDnsInfo;
class CDNDnsInfoDefaultTypeInternal;
extern CDNDnsInfoDefaultTypeInternal _CDNDnsInfo_default_instance_;
class CancelPurchaseRequest;
class CancelPurchaseRequestDefaultTypeInternal;
extern CancelPurchaseRequestDefaultTypeInternal _CancelPurchaseRequest_default_instance_;
class CancelPurchaseResponse;
class CancelPurchaseResponseDefaultTypeInternal;
extern CancelPurchaseResponseDefaultTypeInternal _CancelPurchaseResponse_default_instance_;
class ChatRoomMemberData;
class ChatRoomMemberDataDefaultTypeInternal;
extern ChatRoomMemberDataDefaultTypeInternal _ChatRoomMemberData_default_instance_;
class ChatRoomMemberInfo;
class ChatRoomMemberInfoDefaultTypeInternal;
extern ChatRoomMemberInfoDefaultTypeInternal _ChatRoomMemberInfo_default_instance_;
class CmdItem;
class CmdItemDefaultTypeInternal;
extern CmdItemDefaultTypeInternal _CmdItem_default_instance_;
class CmdList;
class CmdListDefaultTypeInternal;
extern CmdListDefaultTypeInternal _CmdList_default_instance_;
class CustomizedInfo;
class CustomizedInfoDefaultTypeInternal;
extern CustomizedInfoDefaultTypeInternal _CustomizedInfo_default_instance_;
class DelMemberReq;
class DelMemberReqDefaultTypeInternal;
extern DelMemberReqDefaultTypeInternal _DelMemberReq_default_instance_;
class DelMemberResp;
class DelMemberRespDefaultTypeInternal;
extern DelMemberRespDefaultTypeInternal _DelMemberResp_default_instance_;
class DisturbSetting;
class DisturbSettingDefaultTypeInternal;
extern DisturbSettingDefaultTypeInternal _DisturbSetting_default_instance_;
class DisturbTimeSpan;
class DisturbTimeSpanDefaultTypeInternal;
extern DisturbTimeSpanDefaultTypeInternal _DisturbTimeSpan_default_instance_;
class EmotionBanner;
class EmotionBannerDefaultTypeInternal;
extern EmotionBannerDefaultTypeInternal _EmotionBanner_default_instance_;
class EmotionBannerImg;
class EmotionBannerImgDefaultTypeInternal;
extern EmotionBannerImgDefaultTypeInternal _EmotionBannerImg_default_instance_;
class EmotionCDNUrl;
class EmotionCDNUrlDefaultTypeInternal;
extern EmotionCDNUrlDefaultTypeInternal _EmotionCDNUrl_default_instance_;
class EmotionCell;
class EmotionCellDefaultTypeInternal;
extern EmotionCellDefaultTypeInternal _EmotionCell_default_instance_;
class EmotionDesc;
class EmotionDescDefaultTypeInternal;
extern EmotionDescDefaultTypeInternal _EmotionDesc_default_instance_;
class EmotionDetail;
class EmotionDetailDefaultTypeInternal;
extern EmotionDetailDefaultTypeInternal _EmotionDetail_default_instance_;
class EmotionMember;
class EmotionMemberDefaultTypeInternal;
extern EmotionMemberDefaultTypeInternal _EmotionMember_default_instance_;
class EmotionSummary;
class EmotionSummaryDefaultTypeInternal;
extern EmotionSummaryDefaultTypeInternal _EmotionSummary_default_instance_;
class ExchangeEmotionPackRequest;
class ExchangeEmotionPackRequestDefaultTypeInternal;
extern ExchangeEmotionPackRequestDefaultTypeInternal _ExchangeEmotionPackRequest_default_instance_;
class ExchangeEmotionPackResponse;
class ExchangeEmotionPackResponseDefaultTypeInternal;
extern ExchangeEmotionPackResponseDefaultTypeInternal _ExchangeEmotionPackResponse_default_instance_;
class GetEmotionDescRequest;
class GetEmotionDescRequestDefaultTypeInternal;
extern GetEmotionDescRequestDefaultTypeInternal _GetEmotionDescRequest_default_instance_;
class GetEmotionDescResponse;
class GetEmotionDescResponseDefaultTypeInternal;
extern GetEmotionDescResponseDefaultTypeInternal _GetEmotionDescResponse_default_instance_;
class GetEmotionDetailRequest;
class GetEmotionDetailRequestDefaultTypeInternal;
extern GetEmotionDetailRequestDefaultTypeInternal _GetEmotionDetailRequest_default_instance_;
class GetEmotionDetailResponse;
class GetEmotionDetailResponseDefaultTypeInternal;
extern GetEmotionDetailResponseDefaultTypeInternal _GetEmotionDetailResponse_default_instance_;
class GetEmotionListRequest;
class GetEmotionListRequestDefaultTypeInternal;
extern GetEmotionListRequestDefaultTypeInternal _GetEmotionListRequest_default_instance_;
class GetEmotionListResponse;
class GetEmotionListResponseDefaultTypeInternal;
extern GetEmotionListResponseDefaultTypeInternal _GetEmotionListResponse_default_instance_;
class GetLocationRequest;
class GetLocationRequestDefaultTypeInternal;
extern GetLocationRequestDefaultTypeInternal _GetLocationRequest_default_instance_;
class GetLocationResponse;
class GetLocationResponseDefaultTypeInternal;
extern GetLocationResponseDefaultTypeInternal _GetLocationResponse_default_instance_;
class GmailInfo;
class GmailInfoDefaultTypeInternal;
extern GmailInfoDefaultTypeInternal _GmailInfo_default_instance_;
class GmailList;
class GmailListDefaultTypeInternal;
extern GmailListDefaultTypeInternal _GmailList_default_instance_;
class HardDevice;
class HardDeviceDefaultTypeInternal;
extern HardDeviceDefaultTypeInternal _HardDevice_default_instance_;
class Host;
class HostDefaultTypeInternal;
extern HostDefaultTypeInternal _Host_default_instance_;
class HostList;
class HostListDefaultTypeInternal;
extern HostListDefaultTypeInternal _HostList_default_instance_;
class LangDesc;
class LangDescDefaultTypeInternal;
extern LangDescDefaultTypeInternal _LangDesc_default_instance_;
class LinkedinContactItem;
class LinkedinContactItemDefaultTypeInternal;
extern LinkedinContactItemDefaultTypeInternal _LinkedinContactItem_default_instance_;
class MemberReq;
class MemberReqDefaultTypeInternal;
extern MemberReqDefaultTypeInternal _MemberReq_default_instance_;
class MemberResp;
class MemberRespDefaultTypeInternal;
extern MemberRespDefaultTypeInternal _MemberResp_default_instance_;
class MemberStatus;
class MemberStatusDefaultTypeInternal;
extern MemberStatusDefaultTypeInternal _MemberStatus_default_instance_;
class ModContact;
class ModContactDefaultTypeInternal;
extern ModContactDefaultTypeInternal _ModContact_default_instance_;
class ModEmotionPackRequest;
class ModEmotionPackRequestDefaultTypeInternal;
extern ModEmotionPackRequestDefaultTypeInternal _ModEmotionPackRequest_default_instance_;
class ModEmotionPackResponse;
class ModEmotionPackResponseDefaultTypeInternal;
extern ModEmotionPackResponseDefaultTypeInternal _ModEmotionPackResponse_default_instance_;
class ModUserInfo;
class ModUserInfoDefaultTypeInternal;
extern ModUserInfoDefaultTypeInternal _ModUserInfo_default_instance_;
class NetworkControl;
class NetworkControlDefaultTypeInternal;
extern NetworkControlDefaultTypeInternal _NetworkControl_default_instance_;
class PackThumbExt;
class PackThumbExtDefaultTypeInternal;
extern PackThumbExtDefaultTypeInternal _PackThumbExt_default_instance_;
class PatternLockInfo;
class PatternLockInfoDefaultTypeInternal;
extern PatternLockInfoDefaultTypeInternal _PatternLockInfo_default_instance_;
class PluginKey;
class PluginKeyDefaultTypeInternal;
extern PluginKeyDefaultTypeInternal _PluginKey_default_instance_;
class PluginKeyList;
class PluginKeyListDefaultTypeInternal;
extern PluginKeyListDefaultTypeInternal _PluginKeyList_default_instance_;
class PositionInfo;
class PositionInfoDefaultTypeInternal;
extern PositionInfoDefaultTypeInternal _PositionInfo_default_instance_;
class PreparePurchaseRequest;
class PreparePurchaseRequestDefaultTypeInternal;
extern PreparePurchaseRequestDefaultTypeInternal _PreparePurchaseRequest_default_instance_;
class PreparePurchaseResponse;
class PreparePurchaseResponseDefaultTypeInternal;
extern PreparePurchaseResponseDefaultTypeInternal _PreparePurchaseResponse_default_instance_;
class RoomInfo;
class RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class SKBuiltinBuffer_t;
class SKBuiltinBuffer_tDefaultTypeInternal;
extern SKBuiltinBuffer_tDefaultTypeInternal _SKBuiltinBuffer_t_default_instance_;
class SKBuiltinChar_t;
class SKBuiltinChar_tDefaultTypeInternal;
extern SKBuiltinChar_tDefaultTypeInternal _SKBuiltinChar_t_default_instance_;
class SKBuiltinDouble64_t;
class SKBuiltinDouble64_tDefaultTypeInternal;
extern SKBuiltinDouble64_tDefaultTypeInternal _SKBuiltinDouble64_t_default_instance_;
class SKBuiltinFloat32_t;
class SKBuiltinFloat32_tDefaultTypeInternal;
extern SKBuiltinFloat32_tDefaultTypeInternal _SKBuiltinFloat32_t_default_instance_;
class SKBuiltinInt16_t;
class SKBuiltinInt16_tDefaultTypeInternal;
extern SKBuiltinInt16_tDefaultTypeInternal _SKBuiltinInt16_t_default_instance_;
class SKBuiltinInt32_t;
class SKBuiltinInt32_tDefaultTypeInternal;
extern SKBuiltinInt32_tDefaultTypeInternal _SKBuiltinInt32_t_default_instance_;
class SKBuiltinInt64_t;
class SKBuiltinInt64_tDefaultTypeInternal;
extern SKBuiltinInt64_tDefaultTypeInternal _SKBuiltinInt64_t_default_instance_;
class SKBuiltinInt8_t;
class SKBuiltinInt8_tDefaultTypeInternal;
extern SKBuiltinInt8_tDefaultTypeInternal _SKBuiltinInt8_t_default_instance_;
class SKBuiltinString_t;
class SKBuiltinString_tDefaultTypeInternal;
extern SKBuiltinString_tDefaultTypeInternal _SKBuiltinString_t_default_instance_;
class SKBuiltinUchar_t;
class SKBuiltinUchar_tDefaultTypeInternal;
extern SKBuiltinUchar_tDefaultTypeInternal _SKBuiltinUchar_t_default_instance_;
class SKBuiltinUint16_t;
class SKBuiltinUint16_tDefaultTypeInternal;
extern SKBuiltinUint16_tDefaultTypeInternal _SKBuiltinUint16_t_default_instance_;
class SKBuiltinUint32_t;
class SKBuiltinUint32_tDefaultTypeInternal;
extern SKBuiltinUint32_tDefaultTypeInternal _SKBuiltinUint32_t_default_instance_;
class SKBuiltinUint64_t;
class SKBuiltinUint64_tDefaultTypeInternal;
extern SKBuiltinUint64_tDefaultTypeInternal _SKBuiltinUint64_t_default_instance_;
class SKBuiltinUint8_t;
class SKBuiltinUint8_tDefaultTypeInternal;
extern SKBuiltinUint8_tDefaultTypeInternal _SKBuiltinUint8_t_default_instance_;
class SafeDevice;
class SafeDeviceDefaultTypeInternal;
extern SafeDeviceDefaultTypeInternal _SafeDevice_default_instance_;
class SafeDeviceList;
class SafeDeviceListDefaultTypeInternal;
extern SafeDeviceListDefaultTypeInternal _SafeDeviceList_default_instance_;
class ShakeSyncRequest;
class ShakeSyncRequestDefaultTypeInternal;
extern ShakeSyncRequestDefaultTypeInternal _ShakeSyncRequest_default_instance_;
class ShakeSyncResponse;
class ShakeSyncResponseDefaultTypeInternal;
extern ShakeSyncResponseDefaultTypeInternal _ShakeSyncResponse_default_instance_;
class ShowStyleKey;
class ShowStyleKeyDefaultTypeInternal;
extern ShowStyleKeyDefaultTypeInternal _ShowStyleKey_default_instance_;
class SnsUserInfo;
class SnsUserInfoDefaultTypeInternal;
extern SnsUserInfoDefaultTypeInternal _SnsUserInfo_default_instance_;
class StyleKeyVal;
class StyleKeyValDefaultTypeInternal;
extern StyleKeyValDefaultTypeInternal _StyleKeyVal_default_instance_;
class UserInfoExt;
class UserInfoExtDefaultTypeInternal;
extern UserInfoExtDefaultTypeInternal _UserInfoExt_default_instance_;
class VerifyEmotionPresentationRequest;
class VerifyEmotionPresentationRequestDefaultTypeInternal;
extern VerifyEmotionPresentationRequestDefaultTypeInternal _VerifyEmotionPresentationRequest_default_instance_;
class VerifyEmotionPresentationResponse;
class VerifyEmotionPresentationResponseDefaultTypeInternal;
extern VerifyEmotionPresentationResponseDefaultTypeInternal _VerifyEmotionPresentationResponse_default_instance_;
class VerifyPurchaseRequest;
class VerifyPurchaseRequestDefaultTypeInternal;
extern VerifyPurchaseRequestDefaultTypeInternal _VerifyPurchaseRequest_default_instance_;
class VerifyPurchaseResponse;
class VerifyPurchaseResponseDefaultTypeInternal;
extern VerifyPurchaseResponseDefaultTypeInternal _VerifyPurchaseResponse_default_instance_;
}  // namespace micromsg

namespace micromsg {

namespace protobuf_mmemotion_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mmemotion_2eproto

// ===================================================================

class EmotionCDNUrl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionCDNUrl) */ {
 public:
  EmotionCDNUrl();
  virtual ~EmotionCDNUrl();

  EmotionCDNUrl(const EmotionCDNUrl& from);

  inline EmotionCDNUrl& operator=(const EmotionCDNUrl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionCDNUrl& default_instance();

  static inline const EmotionCDNUrl* internal_default_instance() {
    return reinterpret_cast<const EmotionCDNUrl*>(
               &_EmotionCDNUrl_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(EmotionCDNUrl* other);

  // implements Message ----------------------------------------------

  inline EmotionCDNUrl* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionCDNUrl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionCDNUrl& from);
  void MergeFrom(const EmotionCDNUrl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionCDNUrl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Url = 1;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 1;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional string AesKey = 2;
  bool has_aeskey() const;
  void clear_aeskey();
  static const int kAesKeyFieldNumber = 2;
  const ::std::string& aeskey() const;
  void set_aeskey(const ::std::string& value);
  #if LANG_CXX11
  void set_aeskey(::std::string&& value);
  #endif
  void set_aeskey(const char* value);
  void set_aeskey(const char* value, size_t size);
  ::std::string* mutable_aeskey();
  ::std::string* release_aeskey();
  void set_allocated_aeskey(::std::string* aeskey);

  // required uint32 FileSize = 3;
  bool has_filesize() const;
  void clear_filesize();
  static const int kFileSizeFieldNumber = 3;
  ::google::protobuf::uint32 filesize() const;
  void set_filesize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionCDNUrl)
 private:
  void set_has_url();
  void clear_has_url();
  void set_has_aeskey();
  void clear_has_aeskey();
  void set_has_filesize();
  void clear_has_filesize();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::google::protobuf::internal::ArenaStringPtr aeskey_;
  ::google::protobuf::uint32 filesize_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionSummary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionSummary) */ {
 public:
  EmotionSummary();
  virtual ~EmotionSummary();

  EmotionSummary(const EmotionSummary& from);

  inline EmotionSummary& operator=(const EmotionSummary& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionSummary& default_instance();

  static inline const EmotionSummary* internal_default_instance() {
    return reinterpret_cast<const EmotionSummary*>(
               &_EmotionSummary_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(EmotionSummary* other);

  // implements Message ----------------------------------------------

  inline EmotionSummary* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionSummary* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionSummary& from);
  void MergeFrom(const EmotionSummary& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionSummary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductID = 1;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 1;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // optional string IconUrl = 2;
  bool has_iconurl() const;
  void clear_iconurl();
  static const int kIconUrlFieldNumber = 2;
  const ::std::string& iconurl() const;
  void set_iconurl(const ::std::string& value);
  #if LANG_CXX11
  void set_iconurl(::std::string&& value);
  #endif
  void set_iconurl(const char* value);
  void set_iconurl(const char* value, size_t size);
  ::std::string* mutable_iconurl();
  ::std::string* release_iconurl();
  void set_allocated_iconurl(::std::string* iconurl);

  // optional string PackName = 3;
  bool has_packname() const;
  void clear_packname();
  static const int kPackNameFieldNumber = 3;
  const ::std::string& packname() const;
  void set_packname(const ::std::string& value);
  #if LANG_CXX11
  void set_packname(::std::string&& value);
  #endif
  void set_packname(const char* value);
  void set_packname(const char* value, size_t size);
  ::std::string* mutable_packname();
  ::std::string* release_packname();
  void set_allocated_packname(::std::string* packname);

  // optional string PackDesc = 4;
  bool has_packdesc() const;
  void clear_packdesc();
  static const int kPackDescFieldNumber = 4;
  const ::std::string& packdesc() const;
  void set_packdesc(const ::std::string& value);
  #if LANG_CXX11
  void set_packdesc(::std::string&& value);
  #endif
  void set_packdesc(const char* value);
  void set_packdesc(const char* value, size_t size);
  ::std::string* mutable_packdesc();
  ::std::string* release_packdesc();
  void set_allocated_packdesc(::std::string* packdesc);

  // optional string PackAuthInfo = 5;
  bool has_packauthinfo() const;
  void clear_packauthinfo();
  static const int kPackAuthInfoFieldNumber = 5;
  const ::std::string& packauthinfo() const;
  void set_packauthinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_packauthinfo(::std::string&& value);
  #endif
  void set_packauthinfo(const char* value);
  void set_packauthinfo(const char* value, size_t size);
  ::std::string* mutable_packauthinfo();
  ::std::string* release_packauthinfo();
  void set_allocated_packauthinfo(::std::string* packauthinfo);

  // optional string PackPrice = 6;
  bool has_packprice() const;
  void clear_packprice();
  static const int kPackPriceFieldNumber = 6;
  const ::std::string& packprice() const;
  void set_packprice(const ::std::string& value);
  #if LANG_CXX11
  void set_packprice(::std::string&& value);
  #endif
  void set_packprice(const char* value);
  void set_packprice(const char* value, size_t size);
  ::std::string* mutable_packprice();
  ::std::string* release_packprice();
  void set_allocated_packprice(::std::string* packprice);

  // optional string CoverUrl = 9;
  bool has_coverurl() const;
  void clear_coverurl();
  static const int kCoverUrlFieldNumber = 9;
  const ::std::string& coverurl() const;
  void set_coverurl(const ::std::string& value);
  #if LANG_CXX11
  void set_coverurl(::std::string&& value);
  #endif
  void set_coverurl(const char* value);
  void set_coverurl(const char* value, size_t size);
  ::std::string* mutable_coverurl();
  ::std::string* release_coverurl();
  void set_allocated_coverurl(::std::string* coverurl);

  // optional string PackCopyright = 11;
  bool has_packcopyright() const;
  void clear_packcopyright();
  static const int kPackCopyrightFieldNumber = 11;
  const ::std::string& packcopyright() const;
  void set_packcopyright(const ::std::string& value);
  #if LANG_CXX11
  void set_packcopyright(::std::string&& value);
  #endif
  void set_packcopyright(const char* value);
  void set_packcopyright(const char* value, size_t size);
  ::std::string* mutable_packcopyright();
  ::std::string* release_packcopyright();
  void set_allocated_packcopyright(::std::string* packcopyright);

  // optional string PanelUrl = 13;
  bool has_panelurl() const;
  void clear_panelurl();
  static const int kPanelUrlFieldNumber = 13;
  const ::std::string& panelurl() const;
  void set_panelurl(const ::std::string& value);
  #if LANG_CXX11
  void set_panelurl(::std::string&& value);
  #endif
  void set_panelurl(const char* value);
  void set_panelurl(const char* value, size_t size);
  ::std::string* mutable_panelurl();
  ::std::string* release_panelurl();
  void set_allocated_panelurl(::std::string* panelurl);

  // optional string PriceNum = 14;
  bool has_pricenum() const;
  void clear_pricenum();
  static const int kPriceNumFieldNumber = 14;
  const ::std::string& pricenum() const;
  void set_pricenum(const ::std::string& value);
  #if LANG_CXX11
  void set_pricenum(::std::string&& value);
  #endif
  void set_pricenum(const char* value);
  void set_pricenum(const char* value, size_t size);
  ::std::string* mutable_pricenum();
  ::std::string* release_pricenum();
  void set_allocated_pricenum(::std::string* pricenum);

  // optional string PriceType = 15;
  bool has_pricetype() const;
  void clear_pricetype();
  static const int kPriceTypeFieldNumber = 15;
  const ::std::string& pricetype() const;
  void set_pricetype(const ::std::string& value);
  #if LANG_CXX11
  void set_pricetype(::std::string&& value);
  #endif
  void set_pricetype(const char* value);
  void set_pricetype(const char* value, size_t size);
  ::std::string* mutable_pricetype();
  ::std::string* release_pricetype();
  void set_allocated_pricetype(::std::string* pricetype);

  // optional string SendInfo = 16;
  bool has_sendinfo() const;
  void clear_sendinfo();
  static const int kSendInfoFieldNumber = 16;
  const ::std::string& sendinfo() const;
  void set_sendinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_sendinfo(::std::string&& value);
  #endif
  void set_sendinfo(const char* value);
  void set_sendinfo(const char* value, size_t size);
  ::std::string* mutable_sendinfo();
  ::std::string* release_sendinfo();
  void set_allocated_sendinfo(::std::string* sendinfo);

  // optional string TimeLimitStr = 17;
  bool has_timelimitstr() const;
  void clear_timelimitstr();
  static const int kTimeLimitStrFieldNumber = 17;
  const ::std::string& timelimitstr() const;
  void set_timelimitstr(const ::std::string& value);
  #if LANG_CXX11
  void set_timelimitstr(::std::string&& value);
  #endif
  void set_timelimitstr(const char* value);
  void set_timelimitstr(const char* value, size_t size);
  ::std::string* mutable_timelimitstr();
  ::std::string* release_timelimitstr();
  void set_allocated_timelimitstr(::std::string* timelimitstr);

  // optional string Introduce = 18;
  bool has_introduce() const;
  void clear_introduce();
  static const int kIntroduceFieldNumber = 18;
  const ::std::string& introduce() const;
  void set_introduce(const ::std::string& value);
  #if LANG_CXX11
  void set_introduce(::std::string&& value);
  #endif
  void set_introduce(const char* value);
  void set_introduce(const char* value, size_t size);
  ::std::string* mutable_introduce();
  ::std::string* release_introduce();
  void set_allocated_introduce(::std::string* introduce);

  // optional string TagUri = 19;
  bool has_taguri() const;
  void clear_taguri();
  static const int kTagUriFieldNumber = 19;
  const ::std::string& taguri() const;
  void set_taguri(const ::std::string& value);
  #if LANG_CXX11
  void set_taguri(::std::string&& value);
  #endif
  void set_taguri(const char* value);
  void set_taguri(const char* value, size_t size);
  ::std::string* mutable_taguri();
  ::std::string* release_taguri();
  void set_allocated_taguri(::std::string* taguri);

  // required uint32 PackType = 7;
  bool has_packtype() const;
  void clear_packtype();
  static const int kPackTypeFieldNumber = 7;
  ::google::protobuf::uint32 packtype() const;
  void set_packtype(::google::protobuf::uint32 value);

  // required uint32 PackFlag = 8;
  bool has_packflag() const;
  void clear_packflag();
  static const int kPackFlagFieldNumber = 8;
  ::google::protobuf::uint32 packflag() const;
  void set_packflag(::google::protobuf::uint32 value);

  // required uint32 PackExpire = 10;
  bool has_packexpire() const;
  void clear_packexpire();
  static const int kPackExpireFieldNumber = 10;
  ::google::protobuf::uint32 packexpire() const;
  void set_packexpire(::google::protobuf::uint32 value);

  // optional uint32 Timestamp = 12;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 12;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionSummary)
 private:
  void set_has_productid();
  void clear_has_productid();
  void set_has_iconurl();
  void clear_has_iconurl();
  void set_has_packname();
  void clear_has_packname();
  void set_has_packdesc();
  void clear_has_packdesc();
  void set_has_packauthinfo();
  void clear_has_packauthinfo();
  void set_has_packprice();
  void clear_has_packprice();
  void set_has_packtype();
  void clear_has_packtype();
  void set_has_packflag();
  void clear_has_packflag();
  void set_has_coverurl();
  void clear_has_coverurl();
  void set_has_packexpire();
  void clear_has_packexpire();
  void set_has_packcopyright();
  void clear_has_packcopyright();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_panelurl();
  void clear_has_panelurl();
  void set_has_pricenum();
  void clear_has_pricenum();
  void set_has_pricetype();
  void clear_has_pricetype();
  void set_has_sendinfo();
  void clear_has_sendinfo();
  void set_has_timelimitstr();
  void clear_has_timelimitstr();
  void set_has_introduce();
  void clear_has_introduce();
  void set_has_taguri();
  void clear_has_taguri();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr iconurl_;
  ::google::protobuf::internal::ArenaStringPtr packname_;
  ::google::protobuf::internal::ArenaStringPtr packdesc_;
  ::google::protobuf::internal::ArenaStringPtr packauthinfo_;
  ::google::protobuf::internal::ArenaStringPtr packprice_;
  ::google::protobuf::internal::ArenaStringPtr coverurl_;
  ::google::protobuf::internal::ArenaStringPtr packcopyright_;
  ::google::protobuf::internal::ArenaStringPtr panelurl_;
  ::google::protobuf::internal::ArenaStringPtr pricenum_;
  ::google::protobuf::internal::ArenaStringPtr pricetype_;
  ::google::protobuf::internal::ArenaStringPtr sendinfo_;
  ::google::protobuf::internal::ArenaStringPtr timelimitstr_;
  ::google::protobuf::internal::ArenaStringPtr introduce_;
  ::google::protobuf::internal::ArenaStringPtr taguri_;
  ::google::protobuf::uint32 packtype_;
  ::google::protobuf::uint32 packflag_;
  ::google::protobuf::uint32 packexpire_;
  ::google::protobuf::uint32 timestamp_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PackThumbExt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.PackThumbExt) */ {
 public:
  PackThumbExt();
  virtual ~PackThumbExt();

  PackThumbExt(const PackThumbExt& from);

  inline PackThumbExt& operator=(const PackThumbExt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PackThumbExt& default_instance();

  static inline const PackThumbExt* internal_default_instance() {
    return reinterpret_cast<const PackThumbExt*>(
               &_PackThumbExt_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(PackThumbExt* other);

  // implements Message ----------------------------------------------

  inline PackThumbExt* New() const PROTOBUF_FINAL { return New(NULL); }

  PackThumbExt* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PackThumbExt& from);
  void MergeFrom(const PackThumbExt& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PackThumbExt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string PreviewUrl = 1;
  bool has_previewurl() const;
  void clear_previewurl();
  static const int kPreviewUrlFieldNumber = 1;
  const ::std::string& previewurl() const;
  void set_previewurl(const ::std::string& value);
  #if LANG_CXX11
  void set_previewurl(::std::string&& value);
  #endif
  void set_previewurl(const char* value);
  void set_previewurl(const char* value, size_t size);
  ::std::string* mutable_previewurl();
  ::std::string* release_previewurl();
  void set_allocated_previewurl(::std::string* previewurl);

  // optional string Desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:micromsg.PackThumbExt)
 private:
  void set_has_previewurl();
  void clear_has_previewurl();
  void set_has_desc();
  void clear_has_desc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr previewurl_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionDetail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionDetail) */ {
 public:
  EmotionDetail();
  virtual ~EmotionDetail();

  EmotionDetail(const EmotionDetail& from);

  inline EmotionDetail& operator=(const EmotionDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionDetail& default_instance();

  static inline const EmotionDetail* internal_default_instance() {
    return reinterpret_cast<const EmotionDetail*>(
               &_EmotionDetail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(EmotionDetail* other);

  // implements Message ----------------------------------------------

  inline EmotionDetail* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionDetail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionDetail& from);
  void MergeFrom(const EmotionDetail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionDetail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.SKBuiltinString_t PackThumbList = 10;
  int packthumblist_size() const;
  void clear_packthumblist();
  static const int kPackThumbListFieldNumber = 10;
  const ::micromsg::SKBuiltinString_t& packthumblist(int index) const;
  ::micromsg::SKBuiltinString_t* mutable_packthumblist(int index);
  ::micromsg::SKBuiltinString_t* add_packthumblist();
  ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t >*
      mutable_packthumblist();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t >&
      packthumblist() const;

  // repeated .micromsg.PackThumbExt ThumbExtList = 19;
  int thumbextlist_size() const;
  void clear_thumbextlist();
  static const int kThumbExtListFieldNumber = 19;
  const ::micromsg::PackThumbExt& thumbextlist(int index) const;
  ::micromsg::PackThumbExt* mutable_thumbextlist(int index);
  ::micromsg::PackThumbExt* add_thumbextlist();
  ::google::protobuf::RepeatedPtrField< ::micromsg::PackThumbExt >*
      mutable_thumbextlist();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::PackThumbExt >&
      thumbextlist() const;

  // optional string ProductID = 1;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 1;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // optional string IconUrl = 2;
  bool has_iconurl() const;
  void clear_iconurl();
  static const int kIconUrlFieldNumber = 2;
  const ::std::string& iconurl() const;
  void set_iconurl(const ::std::string& value);
  #if LANG_CXX11
  void set_iconurl(::std::string&& value);
  #endif
  void set_iconurl(const char* value);
  void set_iconurl(const char* value, size_t size);
  ::std::string* mutable_iconurl();
  ::std::string* release_iconurl();
  void set_allocated_iconurl(::std::string* iconurl);

  // optional string PackName = 3;
  bool has_packname() const;
  void clear_packname();
  static const int kPackNameFieldNumber = 3;
  const ::std::string& packname() const;
  void set_packname(const ::std::string& value);
  #if LANG_CXX11
  void set_packname(::std::string&& value);
  #endif
  void set_packname(const char* value);
  void set_packname(const char* value, size_t size);
  ::std::string* mutable_packname();
  ::std::string* release_packname();
  void set_allocated_packname(::std::string* packname);

  // optional string PackDesc = 4;
  bool has_packdesc() const;
  void clear_packdesc();
  static const int kPackDescFieldNumber = 4;
  const ::std::string& packdesc() const;
  void set_packdesc(const ::std::string& value);
  #if LANG_CXX11
  void set_packdesc(::std::string&& value);
  #endif
  void set_packdesc(const char* value);
  void set_packdesc(const char* value, size_t size);
  ::std::string* mutable_packdesc();
  ::std::string* release_packdesc();
  void set_allocated_packdesc(::std::string* packdesc);

  // optional string PackAuthInfo = 5;
  bool has_packauthinfo() const;
  void clear_packauthinfo();
  static const int kPackAuthInfoFieldNumber = 5;
  const ::std::string& packauthinfo() const;
  void set_packauthinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_packauthinfo(::std::string&& value);
  #endif
  void set_packauthinfo(const char* value);
  void set_packauthinfo(const char* value, size_t size);
  ::std::string* mutable_packauthinfo();
  ::std::string* release_packauthinfo();
  void set_allocated_packauthinfo(::std::string* packauthinfo);

  // optional string PackPrice = 6;
  bool has_packprice() const;
  void clear_packprice();
  static const int kPackPriceFieldNumber = 6;
  const ::std::string& packprice() const;
  void set_packprice(const ::std::string& value);
  #if LANG_CXX11
  void set_packprice(::std::string&& value);
  #endif
  void set_packprice(const char* value);
  void set_packprice(const char* value, size_t size);
  ::std::string* mutable_packprice();
  ::std::string* release_packprice();
  void set_allocated_packprice(::std::string* packprice);

  // optional string CoverUrl = 11;
  bool has_coverurl() const;
  void clear_coverurl();
  static const int kCoverUrlFieldNumber = 11;
  const ::std::string& coverurl() const;
  void set_coverurl(const ::std::string& value);
  #if LANG_CXX11
  void set_coverurl(::std::string&& value);
  #endif
  void set_coverurl(const char* value);
  void set_coverurl(const char* value, size_t size);
  ::std::string* mutable_coverurl();
  ::std::string* release_coverurl();
  void set_allocated_coverurl(::std::string* coverurl);

  // optional string PackCopyright = 13;
  bool has_packcopyright() const;
  void clear_packcopyright();
  static const int kPackCopyrightFieldNumber = 13;
  const ::std::string& packcopyright() const;
  void set_packcopyright(const ::std::string& value);
  #if LANG_CXX11
  void set_packcopyright(::std::string&& value);
  #endif
  void set_packcopyright(const char* value);
  void set_packcopyright(const char* value, size_t size);
  ::std::string* mutable_packcopyright();
  ::std::string* release_packcopyright();
  void set_allocated_packcopyright(::std::string* packcopyright);

  // optional string PriceNum = 14;
  bool has_pricenum() const;
  void clear_pricenum();
  static const int kPriceNumFieldNumber = 14;
  const ::std::string& pricenum() const;
  void set_pricenum(const ::std::string& value);
  #if LANG_CXX11
  void set_pricenum(::std::string&& value);
  #endif
  void set_pricenum(const char* value);
  void set_pricenum(const char* value, size_t size);
  ::std::string* mutable_pricenum();
  ::std::string* release_pricenum();
  void set_allocated_pricenum(::std::string* pricenum);

  // optional string PriceType = 15;
  bool has_pricetype() const;
  void clear_pricetype();
  static const int kPriceTypeFieldNumber = 15;
  const ::std::string& pricetype() const;
  void set_pricetype(const ::std::string& value);
  #if LANG_CXX11
  void set_pricetype(::std::string&& value);
  #endif
  void set_pricetype(const char* value);
  void set_pricetype(const char* value, size_t size);
  ::std::string* mutable_pricetype();
  ::std::string* release_pricetype();
  void set_allocated_pricetype(::std::string* pricetype);

  // optional string PanelUrl = 16;
  bool has_panelurl() const;
  void clear_panelurl();
  static const int kPanelUrlFieldNumber = 16;
  const ::std::string& panelurl() const;
  void set_panelurl(const ::std::string& value);
  #if LANG_CXX11
  void set_panelurl(::std::string&& value);
  #endif
  void set_panelurl(const char* value);
  void set_panelurl(const char* value, size_t size);
  ::std::string* mutable_panelurl();
  ::std::string* release_panelurl();
  void set_allocated_panelurl(::std::string* panelurl);

  // optional string ConsumeProductID = 17;
  bool has_consumeproductid() const;
  void clear_consumeproductid();
  static const int kConsumeProductIDFieldNumber = 17;
  const ::std::string& consumeproductid() const;
  void set_consumeproductid(const ::std::string& value);
  #if LANG_CXX11
  void set_consumeproductid(::std::string&& value);
  #endif
  void set_consumeproductid(const char* value);
  void set_consumeproductid(const char* value, size_t size);
  ::std::string* mutable_consumeproductid();
  ::std::string* release_consumeproductid();
  void set_allocated_consumeproductid(::std::string* consumeproductid);

  // optional string TimeLimitStr = 21;
  bool has_timelimitstr() const;
  void clear_timelimitstr();
  static const int kTimeLimitStrFieldNumber = 21;
  const ::std::string& timelimitstr() const;
  void set_timelimitstr(const ::std::string& value);
  #if LANG_CXX11
  void set_timelimitstr(::std::string&& value);
  #endif
  void set_timelimitstr(const char* value);
  void set_timelimitstr(const char* value, size_t size);
  ::std::string* mutable_timelimitstr();
  ::std::string* release_timelimitstr();
  void set_allocated_timelimitstr(::std::string* timelimitstr);

  // optional string ShareDesc = 22;
  bool has_sharedesc() const;
  void clear_sharedesc();
  static const int kShareDescFieldNumber = 22;
  const ::std::string& sharedesc() const;
  void set_sharedesc(const ::std::string& value);
  #if LANG_CXX11
  void set_sharedesc(::std::string&& value);
  #endif
  void set_sharedesc(const char* value);
  void set_sharedesc(const char* value, size_t size);
  ::std::string* mutable_sharedesc();
  ::std::string* release_sharedesc();
  void set_allocated_sharedesc(::std::string* sharedesc);

  // optional string OldRedirectUrl = 23;
  bool has_oldredirecturl() const;
  void clear_oldredirecturl();
  static const int kOldRedirectUrlFieldNumber = 23;
  const ::std::string& oldredirecturl() const;
  void set_oldredirecturl(const ::std::string& value);
  #if LANG_CXX11
  void set_oldredirecturl(::std::string&& value);
  #endif
  void set_oldredirecturl(const char* value);
  void set_oldredirecturl(const char* value, size_t size);
  ::std::string* mutable_oldredirecturl();
  ::std::string* release_oldredirecturl();
  void set_allocated_oldredirecturl(::std::string* oldredirecturl);

  // required uint32 PackType = 7;
  bool has_packtype() const;
  void clear_packtype();
  static const int kPackTypeFieldNumber = 7;
  ::google::protobuf::uint32 packtype() const;
  void set_packtype(::google::protobuf::uint32 value);

  // required uint32 PackFlag = 8;
  bool has_packflag() const;
  void clear_packflag();
  static const int kPackFlagFieldNumber = 8;
  ::google::protobuf::uint32 packflag() const;
  void set_packflag(::google::protobuf::uint32 value);

  // required uint32 PackThumbCnt = 9;
  bool has_packthumbcnt() const;
  void clear_packthumbcnt();
  static const int kPackThumbCntFieldNumber = 9;
  ::google::protobuf::uint32 packthumbcnt() const;
  void set_packthumbcnt(::google::protobuf::uint32 value);

  // required uint32 PackExpire = 12;
  bool has_packexpire() const;
  void clear_packexpire();
  static const int kPackExpireFieldNumber = 12;
  ::google::protobuf::uint32 packexpire() const;
  void set_packexpire(::google::protobuf::uint32 value);

  // optional uint32 ThumbExtCount = 18;
  bool has_thumbextcount() const;
  void clear_thumbextcount();
  static const int kThumbExtCountFieldNumber = 18;
  ::google::protobuf::uint32 thumbextcount() const;
  void set_thumbextcount(::google::protobuf::uint32 value);

  // optional int32 Version = 20;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 20;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionDetail)
 private:
  void set_has_productid();
  void clear_has_productid();
  void set_has_iconurl();
  void clear_has_iconurl();
  void set_has_packname();
  void clear_has_packname();
  void set_has_packdesc();
  void clear_has_packdesc();
  void set_has_packauthinfo();
  void clear_has_packauthinfo();
  void set_has_packprice();
  void clear_has_packprice();
  void set_has_packtype();
  void clear_has_packtype();
  void set_has_packflag();
  void clear_has_packflag();
  void set_has_packthumbcnt();
  void clear_has_packthumbcnt();
  void set_has_coverurl();
  void clear_has_coverurl();
  void set_has_packexpire();
  void clear_has_packexpire();
  void set_has_packcopyright();
  void clear_has_packcopyright();
  void set_has_pricenum();
  void clear_has_pricenum();
  void set_has_pricetype();
  void clear_has_pricetype();
  void set_has_panelurl();
  void clear_has_panelurl();
  void set_has_consumeproductid();
  void clear_has_consumeproductid();
  void set_has_thumbextcount();
  void clear_has_thumbextcount();
  void set_has_version();
  void clear_has_version();
  void set_has_timelimitstr();
  void clear_has_timelimitstr();
  void set_has_sharedesc();
  void clear_has_sharedesc();
  void set_has_oldredirecturl();
  void clear_has_oldredirecturl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t > packthumblist_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::PackThumbExt > thumbextlist_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr iconurl_;
  ::google::protobuf::internal::ArenaStringPtr packname_;
  ::google::protobuf::internal::ArenaStringPtr packdesc_;
  ::google::protobuf::internal::ArenaStringPtr packauthinfo_;
  ::google::protobuf::internal::ArenaStringPtr packprice_;
  ::google::protobuf::internal::ArenaStringPtr coverurl_;
  ::google::protobuf::internal::ArenaStringPtr packcopyright_;
  ::google::protobuf::internal::ArenaStringPtr pricenum_;
  ::google::protobuf::internal::ArenaStringPtr pricetype_;
  ::google::protobuf::internal::ArenaStringPtr panelurl_;
  ::google::protobuf::internal::ArenaStringPtr consumeproductid_;
  ::google::protobuf::internal::ArenaStringPtr timelimitstr_;
  ::google::protobuf::internal::ArenaStringPtr sharedesc_;
  ::google::protobuf::internal::ArenaStringPtr oldredirecturl_;
  ::google::protobuf::uint32 packtype_;
  ::google::protobuf::uint32 packflag_;
  ::google::protobuf::uint32 packthumbcnt_;
  ::google::protobuf::uint32 packexpire_;
  ::google::protobuf::uint32 thumbextcount_;
  ::google::protobuf::int32 version_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionBannerImg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionBannerImg) */ {
 public:
  EmotionBannerImg();
  virtual ~EmotionBannerImg();

  EmotionBannerImg(const EmotionBannerImg& from);

  inline EmotionBannerImg& operator=(const EmotionBannerImg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionBannerImg& default_instance();

  static inline const EmotionBannerImg* internal_default_instance() {
    return reinterpret_cast<const EmotionBannerImg*>(
               &_EmotionBannerImg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(EmotionBannerImg* other);

  // implements Message ----------------------------------------------

  inline EmotionBannerImg* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionBannerImg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionBannerImg& from);
  void MergeFrom(const EmotionBannerImg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionBannerImg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ImgUrl = 1;
  bool has_imgurl() const;
  void clear_imgurl();
  static const int kImgUrlFieldNumber = 1;
  const ::std::string& imgurl() const;
  void set_imgurl(const ::std::string& value);
  #if LANG_CXX11
  void set_imgurl(::std::string&& value);
  #endif
  void set_imgurl(const char* value);
  void set_imgurl(const char* value, size_t size);
  ::std::string* mutable_imgurl();
  ::std::string* release_imgurl();
  void set_allocated_imgurl(::std::string* imgurl);

  // optional string StripUrl = 4;
  bool has_stripurl() const;
  void clear_stripurl();
  static const int kStripUrlFieldNumber = 4;
  const ::std::string& stripurl() const;
  void set_stripurl(const ::std::string& value);
  #if LANG_CXX11
  void set_stripurl(::std::string&& value);
  #endif
  void set_stripurl(const char* value);
  void set_stripurl(const char* value, size_t size);
  ::std::string* mutable_stripurl();
  ::std::string* release_stripurl();
  void set_allocated_stripurl(::std::string* stripurl);

  // required uint32 Width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 Height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionBannerImg)
 private:
  void set_has_imgurl();
  void clear_has_imgurl();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_stripurl();
  void clear_has_stripurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr imgurl_;
  ::google::protobuf::internal::ArenaStringPtr stripurl_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionBanner : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionBanner) */ {
 public:
  EmotionBanner();
  virtual ~EmotionBanner();

  EmotionBanner(const EmotionBanner& from);

  inline EmotionBanner& operator=(const EmotionBanner& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionBanner& default_instance();

  static inline const EmotionBanner* internal_default_instance() {
    return reinterpret_cast<const EmotionBanner*>(
               &_EmotionBanner_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(EmotionBanner* other);

  // implements Message ----------------------------------------------

  inline EmotionBanner* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionBanner* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionBanner& from);
  void MergeFrom(const EmotionBanner& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionBanner* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.EmotionSummary BannerSummary = 1;
  bool has_bannersummary() const;
  void clear_bannersummary();
  static const int kBannerSummaryFieldNumber = 1;
  const ::micromsg::EmotionSummary& bannersummary() const;
  ::micromsg::EmotionSummary* mutable_bannersummary();
  ::micromsg::EmotionSummary* release_bannersummary();
  void set_allocated_bannersummary(::micromsg::EmotionSummary* bannersummary);

  // required .micromsg.EmotionBannerImg BannerImg = 2;
  bool has_bannerimg() const;
  void clear_bannerimg();
  static const int kBannerImgFieldNumber = 2;
  const ::micromsg::EmotionBannerImg& bannerimg() const;
  ::micromsg::EmotionBannerImg* mutable_bannerimg();
  ::micromsg::EmotionBannerImg* release_bannerimg();
  void set_allocated_bannerimg(::micromsg::EmotionBannerImg* bannerimg);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionBanner)
 private:
  void set_has_bannersummary();
  void clear_has_bannersummary();
  void set_has_bannerimg();
  void clear_has_bannerimg();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::EmotionSummary* bannersummary_;
  ::micromsg::EmotionBannerImg* bannerimg_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionCell : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionCell) */ {
 public:
  EmotionCell();
  virtual ~EmotionCell();

  EmotionCell(const EmotionCell& from);

  inline EmotionCell& operator=(const EmotionCell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionCell& default_instance();

  static inline const EmotionCell* internal_default_instance() {
    return reinterpret_cast<const EmotionCell*>(
               &_EmotionCell_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(EmotionCell* other);

  // implements Message ----------------------------------------------

  inline EmotionCell* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionCell* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionCell& from);
  void MergeFrom(const EmotionCell& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionCell* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string CellTitle = 1;
  bool has_celltitle() const;
  void clear_celltitle();
  static const int kCellTitleFieldNumber = 1;
  const ::std::string& celltitle() const;
  void set_celltitle(const ::std::string& value);
  #if LANG_CXX11
  void set_celltitle(::std::string&& value);
  #endif
  void set_celltitle(const char* value);
  void set_celltitle(const char* value, size_t size);
  ::std::string* mutable_celltitle();
  ::std::string* release_celltitle();
  void set_allocated_celltitle(::std::string* celltitle);

  // optional string IconUrl = 4;
  bool has_iconurl() const;
  void clear_iconurl();
  static const int kIconUrlFieldNumber = 4;
  const ::std::string& iconurl() const;
  void set_iconurl(const ::std::string& value);
  #if LANG_CXX11
  void set_iconurl(::std::string&& value);
  #endif
  void set_iconurl(const char* value);
  void set_iconurl(const char* value, size_t size);
  ::std::string* mutable_iconurl();
  ::std::string* release_iconurl();
  void set_allocated_iconurl(::std::string* iconurl);

  // optional string TagUrl = 5;
  bool has_tagurl() const;
  void clear_tagurl();
  static const int kTagUrlFieldNumber = 5;
  const ::std::string& tagurl() const;
  void set_tagurl(const ::std::string& value);
  #if LANG_CXX11
  void set_tagurl(::std::string&& value);
  #endif
  void set_tagurl(const char* value);
  void set_tagurl(const char* value, size_t size);
  ::std::string* mutable_tagurl();
  ::std::string* release_tagurl();
  void set_allocated_tagurl(::std::string* tagurl);

  // required uint32 ReqType = 2;
  bool has_reqtype() const;
  void clear_reqtype();
  static const int kReqTypeFieldNumber = 2;
  ::google::protobuf::uint32 reqtype() const;
  void set_reqtype(::google::protobuf::uint32 value);

  // required uint32 Position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  ::google::protobuf::uint32 position() const;
  void set_position(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionCell)
 private:
  void set_has_celltitle();
  void clear_has_celltitle();
  void set_has_reqtype();
  void clear_has_reqtype();
  void set_has_position();
  void clear_has_position();
  void set_has_iconurl();
  void clear_has_iconurl();
  void set_has_tagurl();
  void clear_has_tagurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr celltitle_;
  ::google::protobuf::internal::ArenaStringPtr iconurl_;
  ::google::protobuf::internal::ArenaStringPtr tagurl_;
  ::google::protobuf::uint32 reqtype_;
  ::google::protobuf::uint32 position_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionListRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionListRequest) */ {
 public:
  GetEmotionListRequest();
  virtual ~GetEmotionListRequest();

  GetEmotionListRequest(const GetEmotionListRequest& from);

  inline GetEmotionListRequest& operator=(const GetEmotionListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionListRequest& default_instance();

  static inline const GetEmotionListRequest* internal_default_instance() {
    return reinterpret_cast<const GetEmotionListRequest*>(
               &_GetEmotionListRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(GetEmotionListRequest* other);

  // implements Message ----------------------------------------------

  inline GetEmotionListRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionListRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionListRequest& from);
  void MergeFrom(const GetEmotionListRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t ReqBuf = 2;
  bool has_reqbuf() const;
  void clear_reqbuf();
  static const int kReqBufFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& reqbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* release_reqbuf();
  void set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf);

  // required uint32 ReqType = 3;
  bool has_reqtype() const;
  void clear_reqtype();
  static const int kReqTypeFieldNumber = 3;
  ::google::protobuf::uint32 reqtype() const;
  void set_reqtype(::google::protobuf::uint32 value);

  // optional uint32 Scene = 4;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 4;
  ::google::protobuf::uint32 scene() const;
  void set_scene(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionListRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_reqbuf();
  void clear_has_reqbuf();
  void set_has_reqtype();
  void clear_has_reqtype();
  void set_has_scene();
  void clear_has_scene();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* reqbuf_;
  ::google::protobuf::uint32 reqtype_;
  ::google::protobuf::uint32 scene_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionListResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionListResponse) */ {
 public:
  GetEmotionListResponse();
  virtual ~GetEmotionListResponse();

  GetEmotionListResponse(const GetEmotionListResponse& from);

  inline GetEmotionListResponse& operator=(const GetEmotionListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionListResponse& default_instance();

  static inline const GetEmotionListResponse* internal_default_instance() {
    return reinterpret_cast<const GetEmotionListResponse*>(
               &_GetEmotionListResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(GetEmotionListResponse* other);

  // implements Message ----------------------------------------------

  inline GetEmotionListResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionListResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionListResponse& from);
  void MergeFrom(const GetEmotionListResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.EmotionSummary EmotionList = 4;
  int emotionlist_size() const;
  void clear_emotionlist();
  static const int kEmotionListFieldNumber = 4;
  const ::micromsg::EmotionSummary& emotionlist(int index) const;
  ::micromsg::EmotionSummary* mutable_emotionlist(int index);
  ::micromsg::EmotionSummary* add_emotionlist();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary >*
      mutable_emotionlist();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary >&
      emotionlist() const;

  // repeated .micromsg.EmotionBanner NewBannerList = 7;
  int newbannerlist_size() const;
  void clear_newbannerlist();
  static const int kNewBannerListFieldNumber = 7;
  const ::micromsg::EmotionBanner& newbannerlist(int index) const;
  ::micromsg::EmotionBanner* mutable_newbannerlist(int index);
  ::micromsg::EmotionBanner* add_newbannerlist();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionBanner >*
      mutable_newbannerlist();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionBanner >&
      newbannerlist() const;

  // repeated .micromsg.EmotionCell CellList = 9;
  int celllist_size() const;
  void clear_celllist();
  static const int kCellListFieldNumber = 9;
  const ::micromsg::EmotionCell& celllist(int index) const;
  ::micromsg::EmotionCell* mutable_celllist(int index);
  ::micromsg::EmotionCell* add_celllist();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionCell >*
      mutable_celllist();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionCell >&
      celllist() const;

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.SKBuiltinBuffer_t ReqBuf = 2;
  bool has_reqbuf() const;
  void clear_reqbuf();
  static const int kReqBufFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& reqbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* release_reqbuf();
  void set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf);

  // optional .micromsg.EmotionBanner Banner = 5;
  bool has_banner() const;
  void clear_banner();
  static const int kBannerFieldNumber = 5;
  const ::micromsg::EmotionBanner& banner() const;
  ::micromsg::EmotionBanner* mutable_banner();
  ::micromsg::EmotionBanner* release_banner();
  void set_allocated_banner(::micromsg::EmotionBanner* banner);

  // required uint32 EmotionCount = 3;
  bool has_emotioncount() const;
  void clear_emotioncount();
  static const int kEmotionCountFieldNumber = 3;
  ::google::protobuf::uint32 emotioncount() const;
  void set_emotioncount(::google::protobuf::uint32 value);

  // optional uint32 NewBannerCount = 6;
  bool has_newbannercount() const;
  void clear_newbannercount();
  static const int kNewBannerCountFieldNumber = 6;
  ::google::protobuf::uint32 newbannercount() const;
  void set_newbannercount(::google::protobuf::uint32 value);

  // optional uint32 CellCount = 8;
  bool has_cellcount() const;
  void clear_cellcount();
  static const int kCellCountFieldNumber = 8;
  ::google::protobuf::uint32 cellcount() const;
  void set_cellcount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionListResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_reqbuf();
  void clear_has_reqbuf();
  void set_has_emotioncount();
  void clear_has_emotioncount();
  void set_has_banner();
  void clear_has_banner();
  void set_has_newbannercount();
  void clear_has_newbannercount();
  void set_has_cellcount();
  void clear_has_cellcount();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary > emotionlist_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionBanner > newbannerlist_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionCell > celllist_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinBuffer_t* reqbuf_;
  ::micromsg::EmotionBanner* banner_;
  ::google::protobuf::uint32 emotioncount_;
  ::google::protobuf::uint32 newbannercount_;
  ::google::protobuf::uint32 cellcount_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionDetailRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionDetailRequest) */ {
 public:
  GetEmotionDetailRequest();
  virtual ~GetEmotionDetailRequest();

  GetEmotionDetailRequest(const GetEmotionDetailRequest& from);

  inline GetEmotionDetailRequest& operator=(const GetEmotionDetailRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionDetailRequest& default_instance();

  static inline const GetEmotionDetailRequest* internal_default_instance() {
    return reinterpret_cast<const GetEmotionDetailRequest*>(
               &_GetEmotionDetailRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(GetEmotionDetailRequest* other);

  // implements Message ----------------------------------------------

  inline GetEmotionDetailRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionDetailRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionDetailRequest& from);
  void MergeFrom(const GetEmotionDetailRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionDetailRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductID = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional uint32 Scene = 3;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 3;
  ::google::protobuf::uint32 scene() const;
  void set_scene(::google::protobuf::uint32 value);

  // optional int32 Version = 4;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionDetailRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_productid();
  void clear_has_productid();
  void set_has_scene();
  void clear_has_scene();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 scene_;
  ::google::protobuf::int32 version_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionDetailResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionDetailResponse) */ {
 public:
  GetEmotionDetailResponse();
  virtual ~GetEmotionDetailResponse();

  GetEmotionDetailResponse(const GetEmotionDetailResponse& from);

  inline GetEmotionDetailResponse& operator=(const GetEmotionDetailResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionDetailResponse& default_instance();

  static inline const GetEmotionDetailResponse* internal_default_instance() {
    return reinterpret_cast<const GetEmotionDetailResponse*>(
               &_GetEmotionDetailResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(GetEmotionDetailResponse* other);

  // implements Message ----------------------------------------------

  inline GetEmotionDetailResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionDetailResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionDetailResponse& from);
  void MergeFrom(const GetEmotionDetailResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionDetailResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.EmotionDetail EmotionDetail = 2;
  bool has_emotiondetail() const;
  void clear_emotiondetail();
  static const int kEmotionDetailFieldNumber = 2;
  const ::micromsg::EmotionDetail& emotiondetail() const;
  ::micromsg::EmotionDetail* mutable_emotiondetail();
  ::micromsg::EmotionDetail* release_emotiondetail();
  void set_allocated_emotiondetail(::micromsg::EmotionDetail* emotiondetail);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionDetailResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_emotiondetail();
  void clear_has_emotiondetail();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::EmotionDetail* emotiondetail_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VerifyPurchaseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.VerifyPurchaseRequest) */ {
 public:
  VerifyPurchaseRequest();
  virtual ~VerifyPurchaseRequest();

  VerifyPurchaseRequest(const VerifyPurchaseRequest& from);

  inline VerifyPurchaseRequest& operator=(const VerifyPurchaseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyPurchaseRequest& default_instance();

  static inline const VerifyPurchaseRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyPurchaseRequest*>(
               &_VerifyPurchaseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(VerifyPurchaseRequest* other);

  // implements Message ----------------------------------------------

  inline VerifyPurchaseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  VerifyPurchaseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VerifyPurchaseRequest& from);
  void MergeFrom(const VerifyPurchaseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VerifyPurchaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductID = 3;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 3;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // optional string Price = 6;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 6;
  const ::std::string& price() const;
  void set_price(const ::std::string& value);
  #if LANG_CXX11
  void set_price(::std::string&& value);
  #endif
  void set_price(const char* value);
  void set_price(const char* value, size_t size);
  ::std::string* mutable_price();
  ::std::string* release_price();
  void set_allocated_price(::std::string* price);

  // optional string CurrencyType = 7;
  bool has_currencytype() const;
  void clear_currencytype();
  static const int kCurrencyTypeFieldNumber = 7;
  const ::std::string& currencytype() const;
  void set_currencytype(const ::std::string& value);
  #if LANG_CXX11
  void set_currencytype(::std::string&& value);
  #endif
  void set_currencytype(const char* value);
  void set_currencytype(const char* value, size_t size);
  ::std::string* mutable_currencytype();
  ::std::string* release_currencytype();
  void set_allocated_currencytype(::std::string* currencytype);

  // optional string BillNo = 8;
  bool has_billno() const;
  void clear_billno();
  static const int kBillNoFieldNumber = 8;
  const ::std::string& billno() const;
  void set_billno(const ::std::string& value);
  #if LANG_CXX11
  void set_billno(::std::string&& value);
  #endif
  void set_billno(const char* value);
  void set_billno(const char* value, size_t size);
  ::std::string* mutable_billno();
  ::std::string* release_billno();
  void set_allocated_billno(::std::string* billno);

  // optional string ReceiptSig = 10;
  bool has_receiptsig() const;
  void clear_receiptsig();
  static const int kReceiptSigFieldNumber = 10;
  const ::std::string& receiptsig() const;
  void set_receiptsig(const ::std::string& value);
  #if LANG_CXX11
  void set_receiptsig(::std::string&& value);
  #endif
  void set_receiptsig(const char* value);
  void set_receiptsig(const char* value, size_t size);
  ::std::string* mutable_receiptsig();
  ::std::string* release_receiptsig();
  void set_allocated_receiptsig(::std::string* receiptsig);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t Receipt = 2;
  bool has_receipt() const;
  void clear_receipt();
  static const int kReceiptFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& receipt() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_receipt();
  ::micromsg::SKBuiltinBuffer_t* release_receipt();
  void set_allocated_receipt(::micromsg::SKBuiltinBuffer_t* receipt);

  // required uint32 VerifyType = 4;
  bool has_verifytype() const;
  void clear_verifytype();
  static const int kVerifyTypeFieldNumber = 4;
  ::google::protobuf::uint32 verifytype() const;
  void set_verifytype(::google::protobuf::uint32 value);

  // required uint32 PayType = 5;
  bool has_paytype() const;
  void clear_paytype();
  static const int kPayTypeFieldNumber = 5;
  ::google::protobuf::uint32 paytype() const;
  void set_paytype(::google::protobuf::uint32 value);

  // required uint32 PayTime = 9;
  bool has_paytime() const;
  void clear_paytime();
  static const int kPayTimeFieldNumber = 9;
  ::google::protobuf::uint32 paytime() const;
  void set_paytime(::google::protobuf::uint32 value);

  // optional uint32 Quantity = 11;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 11;
  ::google::protobuf::uint32 quantity() const;
  void set_quantity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.VerifyPurchaseRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_receipt();
  void clear_has_receipt();
  void set_has_productid();
  void clear_has_productid();
  void set_has_verifytype();
  void clear_has_verifytype();
  void set_has_paytype();
  void clear_has_paytype();
  void set_has_price();
  void clear_has_price();
  void set_has_currencytype();
  void clear_has_currencytype();
  void set_has_billno();
  void clear_has_billno();
  void set_has_paytime();
  void clear_has_paytime();
  void set_has_receiptsig();
  void clear_has_receiptsig();
  void set_has_quantity();
  void clear_has_quantity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr price_;
  ::google::protobuf::internal::ArenaStringPtr currencytype_;
  ::google::protobuf::internal::ArenaStringPtr billno_;
  ::google::protobuf::internal::ArenaStringPtr receiptsig_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* receipt_;
  ::google::protobuf::uint32 verifytype_;
  ::google::protobuf::uint32 paytype_;
  ::google::protobuf::uint32 paytime_;
  ::google::protobuf::uint32 quantity_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VerifyPurchaseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.VerifyPurchaseResponse) */ {
 public:
  VerifyPurchaseResponse();
  virtual ~VerifyPurchaseResponse();

  VerifyPurchaseResponse(const VerifyPurchaseResponse& from);

  inline VerifyPurchaseResponse& operator=(const VerifyPurchaseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyPurchaseResponse& default_instance();

  static inline const VerifyPurchaseResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyPurchaseResponse*>(
               &_VerifyPurchaseResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(VerifyPurchaseResponse* other);

  // implements Message ----------------------------------------------

  inline VerifyPurchaseResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  VerifyPurchaseResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VerifyPurchaseResponse& from);
  void MergeFrom(const VerifyPurchaseResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VerifyPurchaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string SeriesID = 2;
  bool has_seriesid() const;
  void clear_seriesid();
  static const int kSeriesIDFieldNumber = 2;
  const ::std::string& seriesid() const;
  void set_seriesid(const ::std::string& value);
  #if LANG_CXX11
  void set_seriesid(::std::string&& value);
  #endif
  void set_seriesid(const char* value);
  void set_seriesid(const char* value, size_t size);
  ::std::string* mutable_seriesid();
  ::std::string* release_seriesid();
  void set_allocated_seriesid(::std::string* seriesid);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required uint32 BizType = 3;
  bool has_biztype() const;
  void clear_biztype();
  static const int kBizTypeFieldNumber = 3;
  ::google::protobuf::uint32 biztype() const;
  void set_biztype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.VerifyPurchaseResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_seriesid();
  void clear_has_seriesid();
  void set_has_biztype();
  void clear_has_biztype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr seriesid_;
  ::micromsg::BaseResponse* baseresponse_;
  ::google::protobuf::uint32 biztype_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModEmotionPackRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ModEmotionPackRequest) */ {
 public:
  ModEmotionPackRequest();
  virtual ~ModEmotionPackRequest();

  ModEmotionPackRequest(const ModEmotionPackRequest& from);

  inline ModEmotionPackRequest& operator=(const ModEmotionPackRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModEmotionPackRequest& default_instance();

  static inline const ModEmotionPackRequest* internal_default_instance() {
    return reinterpret_cast<const ModEmotionPackRequest*>(
               &_ModEmotionPackRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ModEmotionPackRequest* other);

  // implements Message ----------------------------------------------

  inline ModEmotionPackRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ModEmotionPackRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModEmotionPackRequest& from);
  void MergeFrom(const ModEmotionPackRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModEmotionPackRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductID = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 OpCode = 3;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpCodeFieldNumber = 3;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.ModEmotionPackRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_productid();
  void clear_has_productid();
  void set_has_opcode();
  void clear_has_opcode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModEmotionPackResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ModEmotionPackResponse) */ {
 public:
  ModEmotionPackResponse();
  virtual ~ModEmotionPackResponse();

  ModEmotionPackResponse(const ModEmotionPackResponse& from);

  inline ModEmotionPackResponse& operator=(const ModEmotionPackResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModEmotionPackResponse& default_instance();

  static inline const ModEmotionPackResponse* internal_default_instance() {
    return reinterpret_cast<const ModEmotionPackResponse*>(
               &_ModEmotionPackResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ModEmotionPackResponse* other);

  // implements Message ----------------------------------------------

  inline ModEmotionPackResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ModEmotionPackResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ModEmotionPackResponse& from);
  void MergeFrom(const ModEmotionPackResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ModEmotionPackResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.ModEmotionPackResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PreparePurchaseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.PreparePurchaseRequest) */ {
 public:
  PreparePurchaseRequest();
  virtual ~PreparePurchaseRequest();

  PreparePurchaseRequest(const PreparePurchaseRequest& from);

  inline PreparePurchaseRequest& operator=(const PreparePurchaseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreparePurchaseRequest& default_instance();

  static inline const PreparePurchaseRequest* internal_default_instance() {
    return reinterpret_cast<const PreparePurchaseRequest*>(
               &_PreparePurchaseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(PreparePurchaseRequest* other);

  // implements Message ----------------------------------------------

  inline PreparePurchaseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PreparePurchaseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PreparePurchaseRequest& from);
  void MergeFrom(const PreparePurchaseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PreparePurchaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductID = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // optional string Price = 3;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 3;
  const ::std::string& price() const;
  void set_price(const ::std::string& value);
  #if LANG_CXX11
  void set_price(::std::string&& value);
  #endif
  void set_price(const char* value);
  void set_price(const char* value, size_t size);
  ::std::string* mutable_price();
  ::std::string* release_price();
  void set_allocated_price(::std::string* price);

  // optional string CurrencyType = 4;
  bool has_currencytype() const;
  void clear_currencytype();
  static const int kCurrencyTypeFieldNumber = 4;
  const ::std::string& currencytype() const;
  void set_currencytype(const ::std::string& value);
  #if LANG_CXX11
  void set_currencytype(::std::string&& value);
  #endif
  void set_currencytype(const char* value);
  void set_currencytype(const char* value, size_t size);
  ::std::string* mutable_currencytype();
  ::std::string* release_currencytype();
  void set_allocated_currencytype(::std::string* currencytype);

  // optional string ExtInfo = 7;
  bool has_extinfo() const;
  void clear_extinfo();
  static const int kExtInfoFieldNumber = 7;
  const ::std::string& extinfo() const;
  void set_extinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_extinfo(::std::string&& value);
  #endif
  void set_extinfo(const char* value);
  void set_extinfo(const char* value, size_t size);
  ::std::string* mutable_extinfo();
  ::std::string* release_extinfo();
  void set_allocated_extinfo(::std::string* extinfo);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 PayType = 5;
  bool has_paytype() const;
  void clear_paytype();
  static const int kPayTypeFieldNumber = 5;
  ::google::protobuf::uint32 paytype() const;
  void set_paytype(::google::protobuf::uint32 value);

  // optional uint32 Quantity = 8;
  bool has_quantity() const;
  void clear_quantity();
  static const int kQuantityFieldNumber = 8;
  ::google::protobuf::uint32 quantity() const;
  void set_quantity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.PreparePurchaseRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_productid();
  void clear_has_productid();
  void set_has_price();
  void clear_has_price();
  void set_has_currencytype();
  void clear_has_currencytype();
  void set_has_paytype();
  void clear_has_paytype();
  void set_has_extinfo();
  void clear_has_extinfo();
  void set_has_quantity();
  void clear_has_quantity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr price_;
  ::google::protobuf::internal::ArenaStringPtr currencytype_;
  ::google::protobuf::internal::ArenaStringPtr extinfo_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 paytype_;
  ::google::protobuf::uint32 quantity_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PreparePurchaseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.PreparePurchaseResponse) */ {
 public:
  PreparePurchaseResponse();
  virtual ~PreparePurchaseResponse();

  PreparePurchaseResponse(const PreparePurchaseResponse& from);

  inline PreparePurchaseResponse& operator=(const PreparePurchaseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreparePurchaseResponse& default_instance();

  static inline const PreparePurchaseResponse* internal_default_instance() {
    return reinterpret_cast<const PreparePurchaseResponse*>(
               &_PreparePurchaseResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(PreparePurchaseResponse* other);

  // implements Message ----------------------------------------------

  inline PreparePurchaseResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PreparePurchaseResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PreparePurchaseResponse& from);
  void MergeFrom(const PreparePurchaseResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PreparePurchaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string BillNo = 2;
  bool has_billno() const;
  void clear_billno();
  static const int kBillNoFieldNumber = 2;
  const ::std::string& billno() const;
  void set_billno(const ::std::string& value);
  #if LANG_CXX11
  void set_billno(::std::string&& value);
  #endif
  void set_billno(const char* value);
  void set_billno(const char* value, size_t size);
  ::std::string* mutable_billno();
  ::std::string* release_billno();
  void set_allocated_billno(::std::string* billno);

  // optional string TradeToken4TenPay = 3;
  bool has_tradetoken4tenpay() const;
  void clear_tradetoken4tenpay();
  static const int kTradeToken4TenPayFieldNumber = 3;
  const ::std::string& tradetoken4tenpay() const;
  void set_tradetoken4tenpay(const ::std::string& value);
  #if LANG_CXX11
  void set_tradetoken4tenpay(::std::string&& value);
  #endif
  void set_tradetoken4tenpay(const char* value);
  void set_tradetoken4tenpay(const char* value, size_t size);
  ::std::string* mutable_tradetoken4tenpay();
  ::std::string* release_tradetoken4tenpay();
  void set_allocated_tradetoken4tenpay(::std::string* tradetoken4tenpay);

  // optional string Partner4TenPay = 4;
  bool has_partner4tenpay() const;
  void clear_partner4tenpay();
  static const int kPartner4TenPayFieldNumber = 4;
  const ::std::string& partner4tenpay() const;
  void set_partner4tenpay(const ::std::string& value);
  #if LANG_CXX11
  void set_partner4tenpay(::std::string&& value);
  #endif
  void set_partner4tenpay(const char* value);
  void set_partner4tenpay(const char* value, size_t size);
  ::std::string* mutable_partner4tenpay();
  ::std::string* release_partner4tenpay();
  void set_allocated_partner4tenpay(::std::string* partner4tenpay);

  // optional string Sign4TenPay = 5;
  bool has_sign4tenpay() const;
  void clear_sign4tenpay();
  static const int kSign4TenPayFieldNumber = 5;
  const ::std::string& sign4tenpay() const;
  void set_sign4tenpay(const ::std::string& value);
  #if LANG_CXX11
  void set_sign4tenpay(::std::string&& value);
  #endif
  void set_sign4tenpay(const char* value);
  void set_sign4tenpay(const char* value, size_t size);
  ::std::string* mutable_sign4tenpay();
  ::std::string* release_sign4tenpay();
  void set_allocated_sign4tenpay(::std::string* sign4tenpay);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.PreparePurchaseResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_billno();
  void clear_has_billno();
  void set_has_tradetoken4tenpay();
  void clear_has_tradetoken4tenpay();
  void set_has_partner4tenpay();
  void clear_has_partner4tenpay();
  void set_has_sign4tenpay();
  void clear_has_sign4tenpay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr billno_;
  ::google::protobuf::internal::ArenaStringPtr tradetoken4tenpay_;
  ::google::protobuf::internal::ArenaStringPtr partner4tenpay_;
  ::google::protobuf::internal::ArenaStringPtr sign4tenpay_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeEmotionPackRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ExchangeEmotionPackRequest) */ {
 public:
  ExchangeEmotionPackRequest();
  virtual ~ExchangeEmotionPackRequest();

  ExchangeEmotionPackRequest(const ExchangeEmotionPackRequest& from);

  inline ExchangeEmotionPackRequest& operator=(const ExchangeEmotionPackRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeEmotionPackRequest& default_instance();

  static inline const ExchangeEmotionPackRequest* internal_default_instance() {
    return reinterpret_cast<const ExchangeEmotionPackRequest*>(
               &_ExchangeEmotionPackRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ExchangeEmotionPackRequest* other);

  // implements Message ----------------------------------------------

  inline ExchangeEmotionPackRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ExchangeEmotionPackRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExchangeEmotionPackRequest& from);
  void MergeFrom(const ExchangeEmotionPackRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExchangeEmotionPackRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductID = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // optional string SeriesID = 3;
  bool has_seriesid() const;
  void clear_seriesid();
  static const int kSeriesIDFieldNumber = 3;
  const ::std::string& seriesid() const;
  void set_seriesid(const ::std::string& value);
  #if LANG_CXX11
  void set_seriesid(::std::string&& value);
  #endif
  void set_seriesid(const char* value);
  void set_seriesid(const char* value, size_t size);
  ::std::string* mutable_seriesid();
  ::std::string* release_seriesid();
  void set_allocated_seriesid(::std::string* seriesid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.ExchangeEmotionPackRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_productid();
  void clear_has_productid();
  void set_has_seriesid();
  void clear_has_seriesid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr seriesid_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeEmotionPackResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ExchangeEmotionPackResponse) */ {
 public:
  ExchangeEmotionPackResponse();
  virtual ~ExchangeEmotionPackResponse();

  ExchangeEmotionPackResponse(const ExchangeEmotionPackResponse& from);

  inline ExchangeEmotionPackResponse& operator=(const ExchangeEmotionPackResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeEmotionPackResponse& default_instance();

  static inline const ExchangeEmotionPackResponse* internal_default_instance() {
    return reinterpret_cast<const ExchangeEmotionPackResponse*>(
               &_ExchangeEmotionPackResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(ExchangeEmotionPackResponse* other);

  // implements Message ----------------------------------------------

  inline ExchangeEmotionPackResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ExchangeEmotionPackResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExchangeEmotionPackResponse& from);
  void MergeFrom(const ExchangeEmotionPackResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExchangeEmotionPackResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.EmotionCDNUrl DownloadInfo = 2;
  bool has_downloadinfo() const;
  void clear_downloadinfo();
  static const int kDownloadInfoFieldNumber = 2;
  const ::micromsg::EmotionCDNUrl& downloadinfo() const;
  ::micromsg::EmotionCDNUrl* mutable_downloadinfo();
  ::micromsg::EmotionCDNUrl* release_downloadinfo();
  void set_allocated_downloadinfo(::micromsg::EmotionCDNUrl* downloadinfo);

  // @@protoc_insertion_point(class_scope:micromsg.ExchangeEmotionPackResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_downloadinfo();
  void clear_has_downloadinfo();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::EmotionCDNUrl* downloadinfo_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CancelPurchaseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.CancelPurchaseRequest) */ {
 public:
  CancelPurchaseRequest();
  virtual ~CancelPurchaseRequest();

  CancelPurchaseRequest(const CancelPurchaseRequest& from);

  inline CancelPurchaseRequest& operator=(const CancelPurchaseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelPurchaseRequest& default_instance();

  static inline const CancelPurchaseRequest* internal_default_instance() {
    return reinterpret_cast<const CancelPurchaseRequest*>(
               &_CancelPurchaseRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(CancelPurchaseRequest* other);

  // implements Message ----------------------------------------------

  inline CancelPurchaseRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CancelPurchaseRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CancelPurchaseRequest& from);
  void MergeFrom(const CancelPurchaseRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CancelPurchaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductID = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // optional string Price = 5;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 5;
  const ::std::string& price() const;
  void set_price(const ::std::string& value);
  #if LANG_CXX11
  void set_price(::std::string&& value);
  #endif
  void set_price(const char* value);
  void set_price(const char* value, size_t size);
  ::std::string* mutable_price();
  ::std::string* release_price();
  void set_allocated_price(::std::string* price);

  // optional string CurrencyType = 6;
  bool has_currencytype() const;
  void clear_currencytype();
  static const int kCurrencyTypeFieldNumber = 6;
  const ::std::string& currencytype() const;
  void set_currencytype(const ::std::string& value);
  #if LANG_CXX11
  void set_currencytype(::std::string&& value);
  #endif
  void set_currencytype(const char* value);
  void set_currencytype(const char* value, size_t size);
  ::std::string* mutable_currencytype();
  ::std::string* release_currencytype();
  void set_allocated_currencytype(::std::string* currencytype);

  // optional string BillNo = 7;
  bool has_billno() const;
  void clear_billno();
  static const int kBillNoFieldNumber = 7;
  const ::std::string& billno() const;
  void set_billno(const ::std::string& value);
  #if LANG_CXX11
  void set_billno(::std::string&& value);
  #endif
  void set_billno(const char* value);
  void set_billno(const char* value, size_t size);
  ::std::string* mutable_billno();
  ::std::string* release_billno();
  void set_allocated_billno(::std::string* billno);

  // optional string ErrorDescription = 10;
  bool has_errordescription() const;
  void clear_errordescription();
  static const int kErrorDescriptionFieldNumber = 10;
  const ::std::string& errordescription() const;
  void set_errordescription(const ::std::string& value);
  #if LANG_CXX11
  void set_errordescription(::std::string&& value);
  #endif
  void set_errordescription(const char* value);
  void set_errordescription(const char* value, size_t size);
  ::std::string* mutable_errordescription();
  ::std::string* release_errordescription();
  void set_allocated_errordescription(::std::string* errordescription);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 VerifyType = 3;
  bool has_verifytype() const;
  void clear_verifytype();
  static const int kVerifyTypeFieldNumber = 3;
  ::google::protobuf::uint32 verifytype() const;
  void set_verifytype(::google::protobuf::uint32 value);

  // required uint32 PayType = 4;
  bool has_paytype() const;
  void clear_paytype();
  static const int kPayTypeFieldNumber = 4;
  ::google::protobuf::uint32 paytype() const;
  void set_paytype(::google::protobuf::uint32 value);

  // required uint32 PayTime = 8;
  bool has_paytime() const;
  void clear_paytime();
  static const int kPayTimeFieldNumber = 8;
  ::google::protobuf::uint32 paytime() const;
  void set_paytime(::google::protobuf::uint32 value);

  // required int32 ErrorCode = 9;
  bool has_errorcode() const;
  void clear_errorcode();
  static const int kErrorCodeFieldNumber = 9;
  ::google::protobuf::int32 errorcode() const;
  void set_errorcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.CancelPurchaseRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_productid();
  void clear_has_productid();
  void set_has_verifytype();
  void clear_has_verifytype();
  void set_has_paytype();
  void clear_has_paytype();
  void set_has_price();
  void clear_has_price();
  void set_has_currencytype();
  void clear_has_currencytype();
  void set_has_billno();
  void clear_has_billno();
  void set_has_paytime();
  void clear_has_paytime();
  void set_has_errorcode();
  void clear_has_errorcode();
  void set_has_errordescription();
  void clear_has_errordescription();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr price_;
  ::google::protobuf::internal::ArenaStringPtr currencytype_;
  ::google::protobuf::internal::ArenaStringPtr billno_;
  ::google::protobuf::internal::ArenaStringPtr errordescription_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 verifytype_;
  ::google::protobuf::uint32 paytype_;
  ::google::protobuf::uint32 paytime_;
  ::google::protobuf::int32 errorcode_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CancelPurchaseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.CancelPurchaseResponse) */ {
 public:
  CancelPurchaseResponse();
  virtual ~CancelPurchaseResponse();

  CancelPurchaseResponse(const CancelPurchaseResponse& from);

  inline CancelPurchaseResponse& operator=(const CancelPurchaseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelPurchaseResponse& default_instance();

  static inline const CancelPurchaseResponse* internal_default_instance() {
    return reinterpret_cast<const CancelPurchaseResponse*>(
               &_CancelPurchaseResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(CancelPurchaseResponse* other);

  // implements Message ----------------------------------------------

  inline CancelPurchaseResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CancelPurchaseResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CancelPurchaseResponse& from);
  void MergeFrom(const CancelPurchaseResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CancelPurchaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.CancelPurchaseResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionMember : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionMember) */ {
 public:
  EmotionMember();
  virtual ~EmotionMember();

  EmotionMember(const EmotionMember& from);

  inline EmotionMember& operator=(const EmotionMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionMember& default_instance();

  static inline const EmotionMember* internal_default_instance() {
    return reinterpret_cast<const EmotionMember*>(
               &_EmotionMember_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(EmotionMember* other);

  // implements Message ----------------------------------------------

  inline EmotionMember* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionMember* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionMember& from);
  void MergeFrom(const EmotionMember& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionMember* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionMember)
 private:
  void set_has_username();
  void clear_has_username();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemberStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.MemberStatus) */ {
 public:
  MemberStatus();
  virtual ~MemberStatus();

  MemberStatus(const MemberStatus& from);

  inline MemberStatus& operator=(const MemberStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MemberStatus& default_instance();

  static inline const MemberStatus* internal_default_instance() {
    return reinterpret_cast<const MemberStatus*>(
               &_MemberStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(MemberStatus* other);

  // implements Message ----------------------------------------------

  inline MemberStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  MemberStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MemberStatus& from);
  void MergeFrom(const MemberStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MemberStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required int32 Status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::google::protobuf::int32 status() const;
  void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.MemberStatus)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::int32 status_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VerifyEmotionPresentationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.VerifyEmotionPresentationRequest) */ {
 public:
  VerifyEmotionPresentationRequest();
  virtual ~VerifyEmotionPresentationRequest();

  VerifyEmotionPresentationRequest(const VerifyEmotionPresentationRequest& from);

  inline VerifyEmotionPresentationRequest& operator=(const VerifyEmotionPresentationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyEmotionPresentationRequest& default_instance();

  static inline const VerifyEmotionPresentationRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyEmotionPresentationRequest*>(
               &_VerifyEmotionPresentationRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(VerifyEmotionPresentationRequest* other);

  // implements Message ----------------------------------------------

  inline VerifyEmotionPresentationRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  VerifyEmotionPresentationRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VerifyEmotionPresentationRequest& from);
  void MergeFrom(const VerifyEmotionPresentationRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VerifyEmotionPresentationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.EmotionMember MemberList = 4;
  int memberlist_size() const;
  void clear_memberlist();
  static const int kMemberListFieldNumber = 4;
  const ::micromsg::EmotionMember& memberlist(int index) const;
  ::micromsg::EmotionMember* mutable_memberlist(int index);
  ::micromsg::EmotionMember* add_memberlist();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionMember >*
      mutable_memberlist();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionMember >&
      memberlist() const;

  // optional string ProductID = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 MemberCount = 3;
  bool has_membercount() const;
  void clear_membercount();
  static const int kMemberCountFieldNumber = 3;
  ::google::protobuf::uint32 membercount() const;
  void set_membercount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.VerifyEmotionPresentationRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_productid();
  void clear_has_productid();
  void set_has_membercount();
  void clear_has_membercount();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionMember > memberlist_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 membercount_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VerifyEmotionPresentationResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.VerifyEmotionPresentationResponse) */ {
 public:
  VerifyEmotionPresentationResponse();
  virtual ~VerifyEmotionPresentationResponse();

  VerifyEmotionPresentationResponse(const VerifyEmotionPresentationResponse& from);

  inline VerifyEmotionPresentationResponse& operator=(const VerifyEmotionPresentationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyEmotionPresentationResponse& default_instance();

  static inline const VerifyEmotionPresentationResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyEmotionPresentationResponse*>(
               &_VerifyEmotionPresentationResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(VerifyEmotionPresentationResponse* other);

  // implements Message ----------------------------------------------

  inline VerifyEmotionPresentationResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  VerifyEmotionPresentationResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VerifyEmotionPresentationResponse& from);
  void MergeFrom(const VerifyEmotionPresentationResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VerifyEmotionPresentationResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.MemberStatus StatusList = 3;
  int statuslist_size() const;
  void clear_statuslist();
  static const int kStatusListFieldNumber = 3;
  const ::micromsg::MemberStatus& statuslist(int index) const;
  ::micromsg::MemberStatus* mutable_statuslist(int index);
  ::micromsg::MemberStatus* add_statuslist();
  ::google::protobuf::RepeatedPtrField< ::micromsg::MemberStatus >*
      mutable_statuslist();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::MemberStatus >&
      statuslist() const;

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required uint32 MemberCount = 2;
  bool has_membercount() const;
  void clear_membercount();
  static const int kMemberCountFieldNumber = 2;
  ::google::protobuf::uint32 membercount() const;
  void set_membercount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.VerifyEmotionPresentationResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_membercount();
  void clear_has_membercount();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::MemberStatus > statuslist_;
  ::micromsg::BaseResponse* baseresponse_;
  ::google::protobuf::uint32 membercount_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LangDesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.LangDesc) */ {
 public:
  LangDesc();
  virtual ~LangDesc();

  LangDesc(const LangDesc& from);

  inline LangDesc& operator=(const LangDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LangDesc& default_instance();

  static inline const LangDesc* internal_default_instance() {
    return reinterpret_cast<const LangDesc*>(
               &_LangDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(LangDesc* other);

  // implements Message ----------------------------------------------

  inline LangDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  LangDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LangDesc& from);
  void MergeFrom(const LangDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LangDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Lang = 1;
  bool has_lang() const;
  void clear_lang();
  static const int kLangFieldNumber = 1;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  #if LANG_CXX11
  void set_lang(::std::string&& value);
  #endif
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional string Desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:micromsg.LangDesc)
 private:
  void set_has_lang();
  void clear_has_lang();
  void set_has_desc();
  void clear_has_desc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionDesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionDesc) */ {
 public:
  EmotionDesc();
  virtual ~EmotionDesc();

  EmotionDesc(const EmotionDesc& from);

  inline EmotionDesc& operator=(const EmotionDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionDesc& default_instance();

  static inline const EmotionDesc* internal_default_instance() {
    return reinterpret_cast<const EmotionDesc*>(
               &_EmotionDesc_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(EmotionDesc* other);

  // implements Message ----------------------------------------------

  inline EmotionDesc* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionDesc* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionDesc& from);
  void MergeFrom(const EmotionDesc& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.LangDesc List = 3;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 3;
  const ::micromsg::LangDesc& list(int index) const;
  ::micromsg::LangDesc* mutable_list(int index);
  ::micromsg::LangDesc* add_list();
  ::google::protobuf::RepeatedPtrField< ::micromsg::LangDesc >*
      mutable_list();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::LangDesc >&
      list() const;

  // optional string Md5 = 1;
  bool has_md5() const;
  void clear_md5();
  static const int kMd5FieldNumber = 1;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_md5(::std::string&& value);
  #endif
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // required uint32 Count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionDesc)
 private:
  void set_has_md5();
  void clear_has_md5();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::LangDesc > list_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  ::google::protobuf::uint32 count_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionDescRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionDescRequest) */ {
 public:
  GetEmotionDescRequest();
  virtual ~GetEmotionDescRequest();

  GetEmotionDescRequest(const GetEmotionDescRequest& from);

  inline GetEmotionDescRequest& operator=(const GetEmotionDescRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionDescRequest& default_instance();

  static inline const GetEmotionDescRequest* internal_default_instance() {
    return reinterpret_cast<const GetEmotionDescRequest*>(
               &_GetEmotionDescRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(GetEmotionDescRequest* other);

  // implements Message ----------------------------------------------

  inline GetEmotionDescRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionDescRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionDescRequest& from);
  void MergeFrom(const GetEmotionDescRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionDescRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductID = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionDescRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_productid();
  void clear_has_productid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionDescResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionDescResponse) */ {
 public:
  GetEmotionDescResponse();
  virtual ~GetEmotionDescResponse();

  GetEmotionDescResponse(const GetEmotionDescResponse& from);

  inline GetEmotionDescResponse& operator=(const GetEmotionDescResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionDescResponse& default_instance();

  static inline const GetEmotionDescResponse* internal_default_instance() {
    return reinterpret_cast<const GetEmotionDescResponse*>(
               &_GetEmotionDescResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(GetEmotionDescResponse* other);

  // implements Message ----------------------------------------------

  inline GetEmotionDescResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionDescResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionDescResponse& from);
  void MergeFrom(const GetEmotionDescResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionDescResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.EmotionDesc List = 3;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 3;
  const ::micromsg::EmotionDesc& list(int index) const;
  ::micromsg::EmotionDesc* mutable_list(int index);
  ::micromsg::EmotionDesc* add_list();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDesc >*
      mutable_list();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDesc >&
      list() const;

  // optional string ButtonDesc = 5;
  bool has_buttondesc() const;
  void clear_buttondesc();
  static const int kButtonDescFieldNumber = 5;
  const ::std::string& buttondesc() const;
  void set_buttondesc(const ::std::string& value);
  #if LANG_CXX11
  void set_buttondesc(::std::string&& value);
  #endif
  void set_buttondesc(const char* value);
  void set_buttondesc(const char* value, size_t size);
  ::std::string* mutable_buttondesc();
  ::std::string* release_buttondesc();
  void set_allocated_buttondesc(::std::string* buttondesc);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required uint32 Count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // required uint32 ClickFlag = 4;
  bool has_clickflag() const;
  void clear_clickflag();
  static const int kClickFlagFieldNumber = 4;
  ::google::protobuf::uint32 clickflag() const;
  void set_clickflag(::google::protobuf::uint32 value);

  // optional uint32 DownLoadFlag = 6;
  bool has_downloadflag() const;
  void clear_downloadflag();
  static const int kDownLoadFlagFieldNumber = 6;
  ::google::protobuf::uint32 downloadflag() const;
  void set_downloadflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionDescResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_count();
  void clear_has_count();
  void set_has_clickflag();
  void clear_has_clickflag();
  void set_has_buttondesc();
  void clear_has_buttondesc();
  void set_has_downloadflag();
  void clear_has_downloadflag();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDesc > list_;
  ::google::protobuf::internal::ArenaStringPtr buttondesc_;
  ::micromsg::BaseResponse* baseresponse_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 clickflag_;
  ::google::protobuf::uint32 downloadflag_;
  friend struct protobuf_mmemotion_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// EmotionCDNUrl

// optional string Url = 1;
inline bool EmotionCDNUrl::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionCDNUrl::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionCDNUrl::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionCDNUrl::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& EmotionCDNUrl::url() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionCDNUrl.Url)
  return url_.GetNoArena();
}
inline void EmotionCDNUrl::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionCDNUrl.Url)
}
#if LANG_CXX11
inline void EmotionCDNUrl::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionCDNUrl.Url)
}
#endif
inline void EmotionCDNUrl::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionCDNUrl.Url)
}
inline void EmotionCDNUrl::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionCDNUrl.Url)
}
inline ::std::string* EmotionCDNUrl::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionCDNUrl.Url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionCDNUrl::release_url() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionCDNUrl.Url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionCDNUrl::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionCDNUrl.Url)
}

// optional string AesKey = 2;
inline bool EmotionCDNUrl::has_aeskey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmotionCDNUrl::set_has_aeskey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmotionCDNUrl::clear_has_aeskey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmotionCDNUrl::clear_aeskey() {
  aeskey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_aeskey();
}
inline const ::std::string& EmotionCDNUrl::aeskey() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionCDNUrl.AesKey)
  return aeskey_.GetNoArena();
}
inline void EmotionCDNUrl::set_aeskey(const ::std::string& value) {
  set_has_aeskey();
  aeskey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionCDNUrl.AesKey)
}
#if LANG_CXX11
inline void EmotionCDNUrl::set_aeskey(::std::string&& value) {
  set_has_aeskey();
  aeskey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionCDNUrl.AesKey)
}
#endif
inline void EmotionCDNUrl::set_aeskey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_aeskey();
  aeskey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionCDNUrl.AesKey)
}
inline void EmotionCDNUrl::set_aeskey(const char* value, size_t size) {
  set_has_aeskey();
  aeskey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionCDNUrl.AesKey)
}
inline ::std::string* EmotionCDNUrl::mutable_aeskey() {
  set_has_aeskey();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionCDNUrl.AesKey)
  return aeskey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionCDNUrl::release_aeskey() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionCDNUrl.AesKey)
  clear_has_aeskey();
  return aeskey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionCDNUrl::set_allocated_aeskey(::std::string* aeskey) {
  if (aeskey != NULL) {
    set_has_aeskey();
  } else {
    clear_has_aeskey();
  }
  aeskey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), aeskey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionCDNUrl.AesKey)
}

// required uint32 FileSize = 3;
inline bool EmotionCDNUrl::has_filesize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmotionCDNUrl::set_has_filesize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmotionCDNUrl::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmotionCDNUrl::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 EmotionCDNUrl::filesize() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionCDNUrl.FileSize)
  return filesize_;
}
inline void EmotionCDNUrl::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionCDNUrl.FileSize)
}

// -------------------------------------------------------------------

// EmotionSummary

// optional string ProductID = 1;
inline bool EmotionSummary::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionSummary::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionSummary::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionSummary::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& EmotionSummary::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.ProductID)
  return productid_.GetNoArena();
}
inline void EmotionSummary::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.ProductID)
}
#if LANG_CXX11
inline void EmotionSummary::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.ProductID)
}
#endif
inline void EmotionSummary::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.ProductID)
}
inline void EmotionSummary::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.ProductID)
}
inline ::std::string* EmotionSummary::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.ProductID)
}

// optional string IconUrl = 2;
inline bool EmotionSummary::has_iconurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmotionSummary::set_has_iconurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmotionSummary::clear_has_iconurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmotionSummary::clear_iconurl() {
  iconurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iconurl();
}
inline const ::std::string& EmotionSummary::iconurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.IconUrl)
  return iconurl_.GetNoArena();
}
inline void EmotionSummary::set_iconurl(const ::std::string& value) {
  set_has_iconurl();
  iconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.IconUrl)
}
#if LANG_CXX11
inline void EmotionSummary::set_iconurl(::std::string&& value) {
  set_has_iconurl();
  iconurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.IconUrl)
}
#endif
inline void EmotionSummary::set_iconurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iconurl();
  iconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.IconUrl)
}
inline void EmotionSummary::set_iconurl(const char* value, size_t size) {
  set_has_iconurl();
  iconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.IconUrl)
}
inline ::std::string* EmotionSummary::mutable_iconurl() {
  set_has_iconurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.IconUrl)
  return iconurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_iconurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.IconUrl)
  clear_has_iconurl();
  return iconurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_iconurl(::std::string* iconurl) {
  if (iconurl != NULL) {
    set_has_iconurl();
  } else {
    clear_has_iconurl();
  }
  iconurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iconurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.IconUrl)
}

// optional string PackName = 3;
inline bool EmotionSummary::has_packname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmotionSummary::set_has_packname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmotionSummary::clear_has_packname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmotionSummary::clear_packname() {
  packname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packname();
}
inline const ::std::string& EmotionSummary::packname() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PackName)
  return packname_.GetNoArena();
}
inline void EmotionSummary::set_packname(const ::std::string& value) {
  set_has_packname();
  packname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PackName)
}
#if LANG_CXX11
inline void EmotionSummary::set_packname(::std::string&& value) {
  set_has_packname();
  packname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.PackName)
}
#endif
inline void EmotionSummary::set_packname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packname();
  packname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.PackName)
}
inline void EmotionSummary::set_packname(const char* value, size_t size) {
  set_has_packname();
  packname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.PackName)
}
inline ::std::string* EmotionSummary::mutable_packname() {
  set_has_packname();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.PackName)
  return packname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_packname() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.PackName)
  clear_has_packname();
  return packname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_packname(::std::string* packname) {
  if (packname != NULL) {
    set_has_packname();
  } else {
    clear_has_packname();
  }
  packname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.PackName)
}

// optional string PackDesc = 4;
inline bool EmotionSummary::has_packdesc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmotionSummary::set_has_packdesc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmotionSummary::clear_has_packdesc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmotionSummary::clear_packdesc() {
  packdesc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packdesc();
}
inline const ::std::string& EmotionSummary::packdesc() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PackDesc)
  return packdesc_.GetNoArena();
}
inline void EmotionSummary::set_packdesc(const ::std::string& value) {
  set_has_packdesc();
  packdesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PackDesc)
}
#if LANG_CXX11
inline void EmotionSummary::set_packdesc(::std::string&& value) {
  set_has_packdesc();
  packdesc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.PackDesc)
}
#endif
inline void EmotionSummary::set_packdesc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packdesc();
  packdesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.PackDesc)
}
inline void EmotionSummary::set_packdesc(const char* value, size_t size) {
  set_has_packdesc();
  packdesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.PackDesc)
}
inline ::std::string* EmotionSummary::mutable_packdesc() {
  set_has_packdesc();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.PackDesc)
  return packdesc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_packdesc() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.PackDesc)
  clear_has_packdesc();
  return packdesc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_packdesc(::std::string* packdesc) {
  if (packdesc != NULL) {
    set_has_packdesc();
  } else {
    clear_has_packdesc();
  }
  packdesc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packdesc);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.PackDesc)
}

// optional string PackAuthInfo = 5;
inline bool EmotionSummary::has_packauthinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmotionSummary::set_has_packauthinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmotionSummary::clear_has_packauthinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmotionSummary::clear_packauthinfo() {
  packauthinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packauthinfo();
}
inline const ::std::string& EmotionSummary::packauthinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PackAuthInfo)
  return packauthinfo_.GetNoArena();
}
inline void EmotionSummary::set_packauthinfo(const ::std::string& value) {
  set_has_packauthinfo();
  packauthinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PackAuthInfo)
}
#if LANG_CXX11
inline void EmotionSummary::set_packauthinfo(::std::string&& value) {
  set_has_packauthinfo();
  packauthinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.PackAuthInfo)
}
#endif
inline void EmotionSummary::set_packauthinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packauthinfo();
  packauthinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.PackAuthInfo)
}
inline void EmotionSummary::set_packauthinfo(const char* value, size_t size) {
  set_has_packauthinfo();
  packauthinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.PackAuthInfo)
}
inline ::std::string* EmotionSummary::mutable_packauthinfo() {
  set_has_packauthinfo();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.PackAuthInfo)
  return packauthinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_packauthinfo() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.PackAuthInfo)
  clear_has_packauthinfo();
  return packauthinfo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_packauthinfo(::std::string* packauthinfo) {
  if (packauthinfo != NULL) {
    set_has_packauthinfo();
  } else {
    clear_has_packauthinfo();
  }
  packauthinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packauthinfo);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.PackAuthInfo)
}

// optional string PackPrice = 6;
inline bool EmotionSummary::has_packprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmotionSummary::set_has_packprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmotionSummary::clear_has_packprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmotionSummary::clear_packprice() {
  packprice_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packprice();
}
inline const ::std::string& EmotionSummary::packprice() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PackPrice)
  return packprice_.GetNoArena();
}
inline void EmotionSummary::set_packprice(const ::std::string& value) {
  set_has_packprice();
  packprice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PackPrice)
}
#if LANG_CXX11
inline void EmotionSummary::set_packprice(::std::string&& value) {
  set_has_packprice();
  packprice_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.PackPrice)
}
#endif
inline void EmotionSummary::set_packprice(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packprice();
  packprice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.PackPrice)
}
inline void EmotionSummary::set_packprice(const char* value, size_t size) {
  set_has_packprice();
  packprice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.PackPrice)
}
inline ::std::string* EmotionSummary::mutable_packprice() {
  set_has_packprice();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.PackPrice)
  return packprice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_packprice() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.PackPrice)
  clear_has_packprice();
  return packprice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_packprice(::std::string* packprice) {
  if (packprice != NULL) {
    set_has_packprice();
  } else {
    clear_has_packprice();
  }
  packprice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packprice);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.PackPrice)
}

// required uint32 PackType = 7;
inline bool EmotionSummary::has_packtype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EmotionSummary::set_has_packtype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EmotionSummary::clear_has_packtype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EmotionSummary::clear_packtype() {
  packtype_ = 0u;
  clear_has_packtype();
}
inline ::google::protobuf::uint32 EmotionSummary::packtype() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PackType)
  return packtype_;
}
inline void EmotionSummary::set_packtype(::google::protobuf::uint32 value) {
  set_has_packtype();
  packtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PackType)
}

// required uint32 PackFlag = 8;
inline bool EmotionSummary::has_packflag() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void EmotionSummary::set_has_packflag() {
  _has_bits_[0] |= 0x00010000u;
}
inline void EmotionSummary::clear_has_packflag() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void EmotionSummary::clear_packflag() {
  packflag_ = 0u;
  clear_has_packflag();
}
inline ::google::protobuf::uint32 EmotionSummary::packflag() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PackFlag)
  return packflag_;
}
inline void EmotionSummary::set_packflag(::google::protobuf::uint32 value) {
  set_has_packflag();
  packflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PackFlag)
}

// optional string CoverUrl = 9;
inline bool EmotionSummary::has_coverurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmotionSummary::set_has_coverurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmotionSummary::clear_has_coverurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmotionSummary::clear_coverurl() {
  coverurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_coverurl();
}
inline const ::std::string& EmotionSummary::coverurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.CoverUrl)
  return coverurl_.GetNoArena();
}
inline void EmotionSummary::set_coverurl(const ::std::string& value) {
  set_has_coverurl();
  coverurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.CoverUrl)
}
#if LANG_CXX11
inline void EmotionSummary::set_coverurl(::std::string&& value) {
  set_has_coverurl();
  coverurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.CoverUrl)
}
#endif
inline void EmotionSummary::set_coverurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coverurl();
  coverurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.CoverUrl)
}
inline void EmotionSummary::set_coverurl(const char* value, size_t size) {
  set_has_coverurl();
  coverurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.CoverUrl)
}
inline ::std::string* EmotionSummary::mutable_coverurl() {
  set_has_coverurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.CoverUrl)
  return coverurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_coverurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.CoverUrl)
  clear_has_coverurl();
  return coverurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_coverurl(::std::string* coverurl) {
  if (coverurl != NULL) {
    set_has_coverurl();
  } else {
    clear_has_coverurl();
  }
  coverurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coverurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.CoverUrl)
}

// required uint32 PackExpire = 10;
inline bool EmotionSummary::has_packexpire() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void EmotionSummary::set_has_packexpire() {
  _has_bits_[0] |= 0x00020000u;
}
inline void EmotionSummary::clear_has_packexpire() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void EmotionSummary::clear_packexpire() {
  packexpire_ = 0u;
  clear_has_packexpire();
}
inline ::google::protobuf::uint32 EmotionSummary::packexpire() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PackExpire)
  return packexpire_;
}
inline void EmotionSummary::set_packexpire(::google::protobuf::uint32 value) {
  set_has_packexpire();
  packexpire_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PackExpire)
}

// optional string PackCopyright = 11;
inline bool EmotionSummary::has_packcopyright() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmotionSummary::set_has_packcopyright() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmotionSummary::clear_has_packcopyright() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmotionSummary::clear_packcopyright() {
  packcopyright_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packcopyright();
}
inline const ::std::string& EmotionSummary::packcopyright() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PackCopyright)
  return packcopyright_.GetNoArena();
}
inline void EmotionSummary::set_packcopyright(const ::std::string& value) {
  set_has_packcopyright();
  packcopyright_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PackCopyright)
}
#if LANG_CXX11
inline void EmotionSummary::set_packcopyright(::std::string&& value) {
  set_has_packcopyright();
  packcopyright_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.PackCopyright)
}
#endif
inline void EmotionSummary::set_packcopyright(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packcopyright();
  packcopyright_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.PackCopyright)
}
inline void EmotionSummary::set_packcopyright(const char* value, size_t size) {
  set_has_packcopyright();
  packcopyright_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.PackCopyright)
}
inline ::std::string* EmotionSummary::mutable_packcopyright() {
  set_has_packcopyright();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.PackCopyright)
  return packcopyright_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_packcopyright() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.PackCopyright)
  clear_has_packcopyright();
  return packcopyright_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_packcopyright(::std::string* packcopyright) {
  if (packcopyright != NULL) {
    set_has_packcopyright();
  } else {
    clear_has_packcopyright();
  }
  packcopyright_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packcopyright);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.PackCopyright)
}

// optional uint32 Timestamp = 12;
inline bool EmotionSummary::has_timestamp() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void EmotionSummary::set_has_timestamp() {
  _has_bits_[0] |= 0x00040000u;
}
inline void EmotionSummary::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void EmotionSummary::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 EmotionSummary::timestamp() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.Timestamp)
  return timestamp_;
}
inline void EmotionSummary::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.Timestamp)
}

// optional string PanelUrl = 13;
inline bool EmotionSummary::has_panelurl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmotionSummary::set_has_panelurl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmotionSummary::clear_has_panelurl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmotionSummary::clear_panelurl() {
  panelurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_panelurl();
}
inline const ::std::string& EmotionSummary::panelurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PanelUrl)
  return panelurl_.GetNoArena();
}
inline void EmotionSummary::set_panelurl(const ::std::string& value) {
  set_has_panelurl();
  panelurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PanelUrl)
}
#if LANG_CXX11
inline void EmotionSummary::set_panelurl(::std::string&& value) {
  set_has_panelurl();
  panelurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.PanelUrl)
}
#endif
inline void EmotionSummary::set_panelurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_panelurl();
  panelurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.PanelUrl)
}
inline void EmotionSummary::set_panelurl(const char* value, size_t size) {
  set_has_panelurl();
  panelurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.PanelUrl)
}
inline ::std::string* EmotionSummary::mutable_panelurl() {
  set_has_panelurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.PanelUrl)
  return panelurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_panelurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.PanelUrl)
  clear_has_panelurl();
  return panelurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_panelurl(::std::string* panelurl) {
  if (panelurl != NULL) {
    set_has_panelurl();
  } else {
    clear_has_panelurl();
  }
  panelurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), panelurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.PanelUrl)
}

// optional string PriceNum = 14;
inline bool EmotionSummary::has_pricenum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmotionSummary::set_has_pricenum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmotionSummary::clear_has_pricenum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmotionSummary::clear_pricenum() {
  pricenum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pricenum();
}
inline const ::std::string& EmotionSummary::pricenum() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PriceNum)
  return pricenum_.GetNoArena();
}
inline void EmotionSummary::set_pricenum(const ::std::string& value) {
  set_has_pricenum();
  pricenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PriceNum)
}
#if LANG_CXX11
inline void EmotionSummary::set_pricenum(::std::string&& value) {
  set_has_pricenum();
  pricenum_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.PriceNum)
}
#endif
inline void EmotionSummary::set_pricenum(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pricenum();
  pricenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.PriceNum)
}
inline void EmotionSummary::set_pricenum(const char* value, size_t size) {
  set_has_pricenum();
  pricenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.PriceNum)
}
inline ::std::string* EmotionSummary::mutable_pricenum() {
  set_has_pricenum();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.PriceNum)
  return pricenum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_pricenum() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.PriceNum)
  clear_has_pricenum();
  return pricenum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_pricenum(::std::string* pricenum) {
  if (pricenum != NULL) {
    set_has_pricenum();
  } else {
    clear_has_pricenum();
  }
  pricenum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pricenum);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.PriceNum)
}

// optional string PriceType = 15;
inline bool EmotionSummary::has_pricetype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EmotionSummary::set_has_pricetype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EmotionSummary::clear_has_pricetype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EmotionSummary::clear_pricetype() {
  pricetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pricetype();
}
inline const ::std::string& EmotionSummary::pricetype() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.PriceType)
  return pricetype_.GetNoArena();
}
inline void EmotionSummary::set_pricetype(const ::std::string& value) {
  set_has_pricetype();
  pricetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.PriceType)
}
#if LANG_CXX11
inline void EmotionSummary::set_pricetype(::std::string&& value) {
  set_has_pricetype();
  pricetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.PriceType)
}
#endif
inline void EmotionSummary::set_pricetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pricetype();
  pricetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.PriceType)
}
inline void EmotionSummary::set_pricetype(const char* value, size_t size) {
  set_has_pricetype();
  pricetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.PriceType)
}
inline ::std::string* EmotionSummary::mutable_pricetype() {
  set_has_pricetype();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.PriceType)
  return pricetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_pricetype() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.PriceType)
  clear_has_pricetype();
  return pricetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_pricetype(::std::string* pricetype) {
  if (pricetype != NULL) {
    set_has_pricetype();
  } else {
    clear_has_pricetype();
  }
  pricetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pricetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.PriceType)
}

// optional string SendInfo = 16;
inline bool EmotionSummary::has_sendinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EmotionSummary::set_has_sendinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EmotionSummary::clear_has_sendinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EmotionSummary::clear_sendinfo() {
  sendinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sendinfo();
}
inline const ::std::string& EmotionSummary::sendinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.SendInfo)
  return sendinfo_.GetNoArena();
}
inline void EmotionSummary::set_sendinfo(const ::std::string& value) {
  set_has_sendinfo();
  sendinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.SendInfo)
}
#if LANG_CXX11
inline void EmotionSummary::set_sendinfo(::std::string&& value) {
  set_has_sendinfo();
  sendinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.SendInfo)
}
#endif
inline void EmotionSummary::set_sendinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sendinfo();
  sendinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.SendInfo)
}
inline void EmotionSummary::set_sendinfo(const char* value, size_t size) {
  set_has_sendinfo();
  sendinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.SendInfo)
}
inline ::std::string* EmotionSummary::mutable_sendinfo() {
  set_has_sendinfo();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.SendInfo)
  return sendinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_sendinfo() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.SendInfo)
  clear_has_sendinfo();
  return sendinfo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_sendinfo(::std::string* sendinfo) {
  if (sendinfo != NULL) {
    set_has_sendinfo();
  } else {
    clear_has_sendinfo();
  }
  sendinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sendinfo);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.SendInfo)
}

// optional string TimeLimitStr = 17;
inline bool EmotionSummary::has_timelimitstr() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EmotionSummary::set_has_timelimitstr() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EmotionSummary::clear_has_timelimitstr() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EmotionSummary::clear_timelimitstr() {
  timelimitstr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timelimitstr();
}
inline const ::std::string& EmotionSummary::timelimitstr() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.TimeLimitStr)
  return timelimitstr_.GetNoArena();
}
inline void EmotionSummary::set_timelimitstr(const ::std::string& value) {
  set_has_timelimitstr();
  timelimitstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.TimeLimitStr)
}
#if LANG_CXX11
inline void EmotionSummary::set_timelimitstr(::std::string&& value) {
  set_has_timelimitstr();
  timelimitstr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.TimeLimitStr)
}
#endif
inline void EmotionSummary::set_timelimitstr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timelimitstr();
  timelimitstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.TimeLimitStr)
}
inline void EmotionSummary::set_timelimitstr(const char* value, size_t size) {
  set_has_timelimitstr();
  timelimitstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.TimeLimitStr)
}
inline ::std::string* EmotionSummary::mutable_timelimitstr() {
  set_has_timelimitstr();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.TimeLimitStr)
  return timelimitstr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_timelimitstr() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.TimeLimitStr)
  clear_has_timelimitstr();
  return timelimitstr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_timelimitstr(::std::string* timelimitstr) {
  if (timelimitstr != NULL) {
    set_has_timelimitstr();
  } else {
    clear_has_timelimitstr();
  }
  timelimitstr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timelimitstr);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.TimeLimitStr)
}

// optional string Introduce = 18;
inline bool EmotionSummary::has_introduce() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EmotionSummary::set_has_introduce() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EmotionSummary::clear_has_introduce() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EmotionSummary::clear_introduce() {
  introduce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_introduce();
}
inline const ::std::string& EmotionSummary::introduce() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.Introduce)
  return introduce_.GetNoArena();
}
inline void EmotionSummary::set_introduce(const ::std::string& value) {
  set_has_introduce();
  introduce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.Introduce)
}
#if LANG_CXX11
inline void EmotionSummary::set_introduce(::std::string&& value) {
  set_has_introduce();
  introduce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.Introduce)
}
#endif
inline void EmotionSummary::set_introduce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_introduce();
  introduce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.Introduce)
}
inline void EmotionSummary::set_introduce(const char* value, size_t size) {
  set_has_introduce();
  introduce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.Introduce)
}
inline ::std::string* EmotionSummary::mutable_introduce() {
  set_has_introduce();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.Introduce)
  return introduce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_introduce() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.Introduce)
  clear_has_introduce();
  return introduce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_introduce(::std::string* introduce) {
  if (introduce != NULL) {
    set_has_introduce();
  } else {
    clear_has_introduce();
  }
  introduce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), introduce);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.Introduce)
}

// optional string TagUri = 19;
inline bool EmotionSummary::has_taguri() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EmotionSummary::set_has_taguri() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EmotionSummary::clear_has_taguri() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EmotionSummary::clear_taguri() {
  taguri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_taguri();
}
inline const ::std::string& EmotionSummary::taguri() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionSummary.TagUri)
  return taguri_.GetNoArena();
}
inline void EmotionSummary::set_taguri(const ::std::string& value) {
  set_has_taguri();
  taguri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionSummary.TagUri)
}
#if LANG_CXX11
inline void EmotionSummary::set_taguri(::std::string&& value) {
  set_has_taguri();
  taguri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionSummary.TagUri)
}
#endif
inline void EmotionSummary::set_taguri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_taguri();
  taguri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionSummary.TagUri)
}
inline void EmotionSummary::set_taguri(const char* value, size_t size) {
  set_has_taguri();
  taguri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionSummary.TagUri)
}
inline ::std::string* EmotionSummary::mutable_taguri() {
  set_has_taguri();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionSummary.TagUri)
  return taguri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionSummary::release_taguri() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionSummary.TagUri)
  clear_has_taguri();
  return taguri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionSummary::set_allocated_taguri(::std::string* taguri) {
  if (taguri != NULL) {
    set_has_taguri();
  } else {
    clear_has_taguri();
  }
  taguri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), taguri);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionSummary.TagUri)
}

// -------------------------------------------------------------------

// PackThumbExt

// optional string PreviewUrl = 1;
inline bool PackThumbExt::has_previewurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PackThumbExt::set_has_previewurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PackThumbExt::clear_has_previewurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PackThumbExt::clear_previewurl() {
  previewurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_previewurl();
}
inline const ::std::string& PackThumbExt::previewurl() const {
  // @@protoc_insertion_point(field_get:micromsg.PackThumbExt.PreviewUrl)
  return previewurl_.GetNoArena();
}
inline void PackThumbExt::set_previewurl(const ::std::string& value) {
  set_has_previewurl();
  previewurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PackThumbExt.PreviewUrl)
}
#if LANG_CXX11
inline void PackThumbExt::set_previewurl(::std::string&& value) {
  set_has_previewurl();
  previewurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PackThumbExt.PreviewUrl)
}
#endif
inline void PackThumbExt::set_previewurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_previewurl();
  previewurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PackThumbExt.PreviewUrl)
}
inline void PackThumbExt::set_previewurl(const char* value, size_t size) {
  set_has_previewurl();
  previewurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PackThumbExt.PreviewUrl)
}
inline ::std::string* PackThumbExt::mutable_previewurl() {
  set_has_previewurl();
  // @@protoc_insertion_point(field_mutable:micromsg.PackThumbExt.PreviewUrl)
  return previewurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackThumbExt::release_previewurl() {
  // @@protoc_insertion_point(field_release:micromsg.PackThumbExt.PreviewUrl)
  clear_has_previewurl();
  return previewurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackThumbExt::set_allocated_previewurl(::std::string* previewurl) {
  if (previewurl != NULL) {
    set_has_previewurl();
  } else {
    clear_has_previewurl();
  }
  previewurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previewurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PackThumbExt.PreviewUrl)
}

// optional string Desc = 2;
inline bool PackThumbExt::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PackThumbExt::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PackThumbExt::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PackThumbExt::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& PackThumbExt::desc() const {
  // @@protoc_insertion_point(field_get:micromsg.PackThumbExt.Desc)
  return desc_.GetNoArena();
}
inline void PackThumbExt::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PackThumbExt.Desc)
}
#if LANG_CXX11
inline void PackThumbExt::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PackThumbExt.Desc)
}
#endif
inline void PackThumbExt::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PackThumbExt.Desc)
}
inline void PackThumbExt::set_desc(const char* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PackThumbExt.Desc)
}
inline ::std::string* PackThumbExt::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:micromsg.PackThumbExt.Desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PackThumbExt::release_desc() {
  // @@protoc_insertion_point(field_release:micromsg.PackThumbExt.Desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PackThumbExt::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PackThumbExt.Desc)
}

// -------------------------------------------------------------------

// EmotionDetail

// optional string ProductID = 1;
inline bool EmotionDetail::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionDetail::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionDetail::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionDetail::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& EmotionDetail::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.ProductID)
  return productid_.GetNoArena();
}
inline void EmotionDetail::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.ProductID)
}
#if LANG_CXX11
inline void EmotionDetail::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.ProductID)
}
#endif
inline void EmotionDetail::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.ProductID)
}
inline void EmotionDetail::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.ProductID)
}
inline ::std::string* EmotionDetail::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.ProductID)
}

// optional string IconUrl = 2;
inline bool EmotionDetail::has_iconurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmotionDetail::set_has_iconurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmotionDetail::clear_has_iconurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmotionDetail::clear_iconurl() {
  iconurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iconurl();
}
inline const ::std::string& EmotionDetail::iconurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.IconUrl)
  return iconurl_.GetNoArena();
}
inline void EmotionDetail::set_iconurl(const ::std::string& value) {
  set_has_iconurl();
  iconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.IconUrl)
}
#if LANG_CXX11
inline void EmotionDetail::set_iconurl(::std::string&& value) {
  set_has_iconurl();
  iconurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.IconUrl)
}
#endif
inline void EmotionDetail::set_iconurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iconurl();
  iconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.IconUrl)
}
inline void EmotionDetail::set_iconurl(const char* value, size_t size) {
  set_has_iconurl();
  iconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.IconUrl)
}
inline ::std::string* EmotionDetail::mutable_iconurl() {
  set_has_iconurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.IconUrl)
  return iconurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_iconurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.IconUrl)
  clear_has_iconurl();
  return iconurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_iconurl(::std::string* iconurl) {
  if (iconurl != NULL) {
    set_has_iconurl();
  } else {
    clear_has_iconurl();
  }
  iconurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iconurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.IconUrl)
}

// optional string PackName = 3;
inline bool EmotionDetail::has_packname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmotionDetail::set_has_packname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmotionDetail::clear_has_packname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmotionDetail::clear_packname() {
  packname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packname();
}
inline const ::std::string& EmotionDetail::packname() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackName)
  return packname_.GetNoArena();
}
inline void EmotionDetail::set_packname(const ::std::string& value) {
  set_has_packname();
  packname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PackName)
}
#if LANG_CXX11
inline void EmotionDetail::set_packname(::std::string&& value) {
  set_has_packname();
  packname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.PackName)
}
#endif
inline void EmotionDetail::set_packname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packname();
  packname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.PackName)
}
inline void EmotionDetail::set_packname(const char* value, size_t size) {
  set_has_packname();
  packname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.PackName)
}
inline ::std::string* EmotionDetail::mutable_packname() {
  set_has_packname();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.PackName)
  return packname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_packname() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.PackName)
  clear_has_packname();
  return packname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_packname(::std::string* packname) {
  if (packname != NULL) {
    set_has_packname();
  } else {
    clear_has_packname();
  }
  packname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.PackName)
}

// optional string PackDesc = 4;
inline bool EmotionDetail::has_packdesc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmotionDetail::set_has_packdesc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmotionDetail::clear_has_packdesc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmotionDetail::clear_packdesc() {
  packdesc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packdesc();
}
inline const ::std::string& EmotionDetail::packdesc() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackDesc)
  return packdesc_.GetNoArena();
}
inline void EmotionDetail::set_packdesc(const ::std::string& value) {
  set_has_packdesc();
  packdesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PackDesc)
}
#if LANG_CXX11
inline void EmotionDetail::set_packdesc(::std::string&& value) {
  set_has_packdesc();
  packdesc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.PackDesc)
}
#endif
inline void EmotionDetail::set_packdesc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packdesc();
  packdesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.PackDesc)
}
inline void EmotionDetail::set_packdesc(const char* value, size_t size) {
  set_has_packdesc();
  packdesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.PackDesc)
}
inline ::std::string* EmotionDetail::mutable_packdesc() {
  set_has_packdesc();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.PackDesc)
  return packdesc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_packdesc() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.PackDesc)
  clear_has_packdesc();
  return packdesc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_packdesc(::std::string* packdesc) {
  if (packdesc != NULL) {
    set_has_packdesc();
  } else {
    clear_has_packdesc();
  }
  packdesc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packdesc);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.PackDesc)
}

// optional string PackAuthInfo = 5;
inline bool EmotionDetail::has_packauthinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmotionDetail::set_has_packauthinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmotionDetail::clear_has_packauthinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmotionDetail::clear_packauthinfo() {
  packauthinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packauthinfo();
}
inline const ::std::string& EmotionDetail::packauthinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackAuthInfo)
  return packauthinfo_.GetNoArena();
}
inline void EmotionDetail::set_packauthinfo(const ::std::string& value) {
  set_has_packauthinfo();
  packauthinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PackAuthInfo)
}
#if LANG_CXX11
inline void EmotionDetail::set_packauthinfo(::std::string&& value) {
  set_has_packauthinfo();
  packauthinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.PackAuthInfo)
}
#endif
inline void EmotionDetail::set_packauthinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packauthinfo();
  packauthinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.PackAuthInfo)
}
inline void EmotionDetail::set_packauthinfo(const char* value, size_t size) {
  set_has_packauthinfo();
  packauthinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.PackAuthInfo)
}
inline ::std::string* EmotionDetail::mutable_packauthinfo() {
  set_has_packauthinfo();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.PackAuthInfo)
  return packauthinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_packauthinfo() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.PackAuthInfo)
  clear_has_packauthinfo();
  return packauthinfo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_packauthinfo(::std::string* packauthinfo) {
  if (packauthinfo != NULL) {
    set_has_packauthinfo();
  } else {
    clear_has_packauthinfo();
  }
  packauthinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packauthinfo);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.PackAuthInfo)
}

// optional string PackPrice = 6;
inline bool EmotionDetail::has_packprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmotionDetail::set_has_packprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmotionDetail::clear_has_packprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmotionDetail::clear_packprice() {
  packprice_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packprice();
}
inline const ::std::string& EmotionDetail::packprice() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackPrice)
  return packprice_.GetNoArena();
}
inline void EmotionDetail::set_packprice(const ::std::string& value) {
  set_has_packprice();
  packprice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PackPrice)
}
#if LANG_CXX11
inline void EmotionDetail::set_packprice(::std::string&& value) {
  set_has_packprice();
  packprice_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.PackPrice)
}
#endif
inline void EmotionDetail::set_packprice(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packprice();
  packprice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.PackPrice)
}
inline void EmotionDetail::set_packprice(const char* value, size_t size) {
  set_has_packprice();
  packprice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.PackPrice)
}
inline ::std::string* EmotionDetail::mutable_packprice() {
  set_has_packprice();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.PackPrice)
  return packprice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_packprice() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.PackPrice)
  clear_has_packprice();
  return packprice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_packprice(::std::string* packprice) {
  if (packprice != NULL) {
    set_has_packprice();
  } else {
    clear_has_packprice();
  }
  packprice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packprice);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.PackPrice)
}

// required uint32 PackType = 7;
inline bool EmotionDetail::has_packtype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EmotionDetail::set_has_packtype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EmotionDetail::clear_has_packtype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EmotionDetail::clear_packtype() {
  packtype_ = 0u;
  clear_has_packtype();
}
inline ::google::protobuf::uint32 EmotionDetail::packtype() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackType)
  return packtype_;
}
inline void EmotionDetail::set_packtype(::google::protobuf::uint32 value) {
  set_has_packtype();
  packtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PackType)
}

// required uint32 PackFlag = 8;
inline bool EmotionDetail::has_packflag() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void EmotionDetail::set_has_packflag() {
  _has_bits_[0] |= 0x00010000u;
}
inline void EmotionDetail::clear_has_packflag() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void EmotionDetail::clear_packflag() {
  packflag_ = 0u;
  clear_has_packflag();
}
inline ::google::protobuf::uint32 EmotionDetail::packflag() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackFlag)
  return packflag_;
}
inline void EmotionDetail::set_packflag(::google::protobuf::uint32 value) {
  set_has_packflag();
  packflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PackFlag)
}

// required uint32 PackThumbCnt = 9;
inline bool EmotionDetail::has_packthumbcnt() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void EmotionDetail::set_has_packthumbcnt() {
  _has_bits_[0] |= 0x00020000u;
}
inline void EmotionDetail::clear_has_packthumbcnt() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void EmotionDetail::clear_packthumbcnt() {
  packthumbcnt_ = 0u;
  clear_has_packthumbcnt();
}
inline ::google::protobuf::uint32 EmotionDetail::packthumbcnt() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackThumbCnt)
  return packthumbcnt_;
}
inline void EmotionDetail::set_packthumbcnt(::google::protobuf::uint32 value) {
  set_has_packthumbcnt();
  packthumbcnt_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PackThumbCnt)
}

// repeated .micromsg.SKBuiltinString_t PackThumbList = 10;
inline int EmotionDetail::packthumblist_size() const {
  return packthumblist_.size();
}
inline void EmotionDetail::clear_packthumblist() {
  packthumblist_.Clear();
}
inline const ::micromsg::SKBuiltinString_t& EmotionDetail::packthumblist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackThumbList)
  return packthumblist_.Get(index);
}
inline ::micromsg::SKBuiltinString_t* EmotionDetail::mutable_packthumblist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.PackThumbList)
  return packthumblist_.Mutable(index);
}
inline ::micromsg::SKBuiltinString_t* EmotionDetail::add_packthumblist() {
  // @@protoc_insertion_point(field_add:micromsg.EmotionDetail.PackThumbList)
  return packthumblist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t >*
EmotionDetail::mutable_packthumblist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.EmotionDetail.PackThumbList)
  return &packthumblist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t >&
EmotionDetail::packthumblist() const {
  // @@protoc_insertion_point(field_list:micromsg.EmotionDetail.PackThumbList)
  return packthumblist_;
}

// optional string CoverUrl = 11;
inline bool EmotionDetail::has_coverurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmotionDetail::set_has_coverurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmotionDetail::clear_has_coverurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmotionDetail::clear_coverurl() {
  coverurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_coverurl();
}
inline const ::std::string& EmotionDetail::coverurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.CoverUrl)
  return coverurl_.GetNoArena();
}
inline void EmotionDetail::set_coverurl(const ::std::string& value) {
  set_has_coverurl();
  coverurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.CoverUrl)
}
#if LANG_CXX11
inline void EmotionDetail::set_coverurl(::std::string&& value) {
  set_has_coverurl();
  coverurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.CoverUrl)
}
#endif
inline void EmotionDetail::set_coverurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coverurl();
  coverurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.CoverUrl)
}
inline void EmotionDetail::set_coverurl(const char* value, size_t size) {
  set_has_coverurl();
  coverurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.CoverUrl)
}
inline ::std::string* EmotionDetail::mutable_coverurl() {
  set_has_coverurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.CoverUrl)
  return coverurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_coverurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.CoverUrl)
  clear_has_coverurl();
  return coverurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_coverurl(::std::string* coverurl) {
  if (coverurl != NULL) {
    set_has_coverurl();
  } else {
    clear_has_coverurl();
  }
  coverurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coverurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.CoverUrl)
}

// required uint32 PackExpire = 12;
inline bool EmotionDetail::has_packexpire() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void EmotionDetail::set_has_packexpire() {
  _has_bits_[0] |= 0x00040000u;
}
inline void EmotionDetail::clear_has_packexpire() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void EmotionDetail::clear_packexpire() {
  packexpire_ = 0u;
  clear_has_packexpire();
}
inline ::google::protobuf::uint32 EmotionDetail::packexpire() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackExpire)
  return packexpire_;
}
inline void EmotionDetail::set_packexpire(::google::protobuf::uint32 value) {
  set_has_packexpire();
  packexpire_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PackExpire)
}

// optional string PackCopyright = 13;
inline bool EmotionDetail::has_packcopyright() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmotionDetail::set_has_packcopyright() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmotionDetail::clear_has_packcopyright() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmotionDetail::clear_packcopyright() {
  packcopyright_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_packcopyright();
}
inline const ::std::string& EmotionDetail::packcopyright() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PackCopyright)
  return packcopyright_.GetNoArena();
}
inline void EmotionDetail::set_packcopyright(const ::std::string& value) {
  set_has_packcopyright();
  packcopyright_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PackCopyright)
}
#if LANG_CXX11
inline void EmotionDetail::set_packcopyright(::std::string&& value) {
  set_has_packcopyright();
  packcopyright_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.PackCopyright)
}
#endif
inline void EmotionDetail::set_packcopyright(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_packcopyright();
  packcopyright_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.PackCopyright)
}
inline void EmotionDetail::set_packcopyright(const char* value, size_t size) {
  set_has_packcopyright();
  packcopyright_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.PackCopyright)
}
inline ::std::string* EmotionDetail::mutable_packcopyright() {
  set_has_packcopyright();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.PackCopyright)
  return packcopyright_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_packcopyright() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.PackCopyright)
  clear_has_packcopyright();
  return packcopyright_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_packcopyright(::std::string* packcopyright) {
  if (packcopyright != NULL) {
    set_has_packcopyright();
  } else {
    clear_has_packcopyright();
  }
  packcopyright_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packcopyright);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.PackCopyright)
}

// optional string PriceNum = 14;
inline bool EmotionDetail::has_pricenum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmotionDetail::set_has_pricenum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmotionDetail::clear_has_pricenum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmotionDetail::clear_pricenum() {
  pricenum_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pricenum();
}
inline const ::std::string& EmotionDetail::pricenum() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PriceNum)
  return pricenum_.GetNoArena();
}
inline void EmotionDetail::set_pricenum(const ::std::string& value) {
  set_has_pricenum();
  pricenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PriceNum)
}
#if LANG_CXX11
inline void EmotionDetail::set_pricenum(::std::string&& value) {
  set_has_pricenum();
  pricenum_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.PriceNum)
}
#endif
inline void EmotionDetail::set_pricenum(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pricenum();
  pricenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.PriceNum)
}
inline void EmotionDetail::set_pricenum(const char* value, size_t size) {
  set_has_pricenum();
  pricenum_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.PriceNum)
}
inline ::std::string* EmotionDetail::mutable_pricenum() {
  set_has_pricenum();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.PriceNum)
  return pricenum_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_pricenum() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.PriceNum)
  clear_has_pricenum();
  return pricenum_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_pricenum(::std::string* pricenum) {
  if (pricenum != NULL) {
    set_has_pricenum();
  } else {
    clear_has_pricenum();
  }
  pricenum_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pricenum);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.PriceNum)
}

// optional string PriceType = 15;
inline bool EmotionDetail::has_pricetype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmotionDetail::set_has_pricetype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmotionDetail::clear_has_pricetype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmotionDetail::clear_pricetype() {
  pricetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pricetype();
}
inline const ::std::string& EmotionDetail::pricetype() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PriceType)
  return pricetype_.GetNoArena();
}
inline void EmotionDetail::set_pricetype(const ::std::string& value) {
  set_has_pricetype();
  pricetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PriceType)
}
#if LANG_CXX11
inline void EmotionDetail::set_pricetype(::std::string&& value) {
  set_has_pricetype();
  pricetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.PriceType)
}
#endif
inline void EmotionDetail::set_pricetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pricetype();
  pricetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.PriceType)
}
inline void EmotionDetail::set_pricetype(const char* value, size_t size) {
  set_has_pricetype();
  pricetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.PriceType)
}
inline ::std::string* EmotionDetail::mutable_pricetype() {
  set_has_pricetype();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.PriceType)
  return pricetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_pricetype() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.PriceType)
  clear_has_pricetype();
  return pricetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_pricetype(::std::string* pricetype) {
  if (pricetype != NULL) {
    set_has_pricetype();
  } else {
    clear_has_pricetype();
  }
  pricetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pricetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.PriceType)
}

// optional string PanelUrl = 16;
inline bool EmotionDetail::has_panelurl() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EmotionDetail::set_has_panelurl() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EmotionDetail::clear_has_panelurl() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EmotionDetail::clear_panelurl() {
  panelurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_panelurl();
}
inline const ::std::string& EmotionDetail::panelurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.PanelUrl)
  return panelurl_.GetNoArena();
}
inline void EmotionDetail::set_panelurl(const ::std::string& value) {
  set_has_panelurl();
  panelurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.PanelUrl)
}
#if LANG_CXX11
inline void EmotionDetail::set_panelurl(::std::string&& value) {
  set_has_panelurl();
  panelurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.PanelUrl)
}
#endif
inline void EmotionDetail::set_panelurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_panelurl();
  panelurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.PanelUrl)
}
inline void EmotionDetail::set_panelurl(const char* value, size_t size) {
  set_has_panelurl();
  panelurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.PanelUrl)
}
inline ::std::string* EmotionDetail::mutable_panelurl() {
  set_has_panelurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.PanelUrl)
  return panelurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_panelurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.PanelUrl)
  clear_has_panelurl();
  return panelurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_panelurl(::std::string* panelurl) {
  if (panelurl != NULL) {
    set_has_panelurl();
  } else {
    clear_has_panelurl();
  }
  panelurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), panelurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.PanelUrl)
}

// optional string ConsumeProductID = 17;
inline bool EmotionDetail::has_consumeproductid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EmotionDetail::set_has_consumeproductid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EmotionDetail::clear_has_consumeproductid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EmotionDetail::clear_consumeproductid() {
  consumeproductid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_consumeproductid();
}
inline const ::std::string& EmotionDetail::consumeproductid() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.ConsumeProductID)
  return consumeproductid_.GetNoArena();
}
inline void EmotionDetail::set_consumeproductid(const ::std::string& value) {
  set_has_consumeproductid();
  consumeproductid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.ConsumeProductID)
}
#if LANG_CXX11
inline void EmotionDetail::set_consumeproductid(::std::string&& value) {
  set_has_consumeproductid();
  consumeproductid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.ConsumeProductID)
}
#endif
inline void EmotionDetail::set_consumeproductid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_consumeproductid();
  consumeproductid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.ConsumeProductID)
}
inline void EmotionDetail::set_consumeproductid(const char* value, size_t size) {
  set_has_consumeproductid();
  consumeproductid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.ConsumeProductID)
}
inline ::std::string* EmotionDetail::mutable_consumeproductid() {
  set_has_consumeproductid();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.ConsumeProductID)
  return consumeproductid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_consumeproductid() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.ConsumeProductID)
  clear_has_consumeproductid();
  return consumeproductid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_consumeproductid(::std::string* consumeproductid) {
  if (consumeproductid != NULL) {
    set_has_consumeproductid();
  } else {
    clear_has_consumeproductid();
  }
  consumeproductid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), consumeproductid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.ConsumeProductID)
}

// optional uint32 ThumbExtCount = 18;
inline bool EmotionDetail::has_thumbextcount() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void EmotionDetail::set_has_thumbextcount() {
  _has_bits_[0] |= 0x00080000u;
}
inline void EmotionDetail::clear_has_thumbextcount() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void EmotionDetail::clear_thumbextcount() {
  thumbextcount_ = 0u;
  clear_has_thumbextcount();
}
inline ::google::protobuf::uint32 EmotionDetail::thumbextcount() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.ThumbExtCount)
  return thumbextcount_;
}
inline void EmotionDetail::set_thumbextcount(::google::protobuf::uint32 value) {
  set_has_thumbextcount();
  thumbextcount_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.ThumbExtCount)
}

// repeated .micromsg.PackThumbExt ThumbExtList = 19;
inline int EmotionDetail::thumbextlist_size() const {
  return thumbextlist_.size();
}
inline void EmotionDetail::clear_thumbextlist() {
  thumbextlist_.Clear();
}
inline const ::micromsg::PackThumbExt& EmotionDetail::thumbextlist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.ThumbExtList)
  return thumbextlist_.Get(index);
}
inline ::micromsg::PackThumbExt* EmotionDetail::mutable_thumbextlist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.ThumbExtList)
  return thumbextlist_.Mutable(index);
}
inline ::micromsg::PackThumbExt* EmotionDetail::add_thumbextlist() {
  // @@protoc_insertion_point(field_add:micromsg.EmotionDetail.ThumbExtList)
  return thumbextlist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::PackThumbExt >*
EmotionDetail::mutable_thumbextlist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.EmotionDetail.ThumbExtList)
  return &thumbextlist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::PackThumbExt >&
EmotionDetail::thumbextlist() const {
  // @@protoc_insertion_point(field_list:micromsg.EmotionDetail.ThumbExtList)
  return thumbextlist_;
}

// optional int32 Version = 20;
inline bool EmotionDetail::has_version() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void EmotionDetail::set_has_version() {
  _has_bits_[0] |= 0x00100000u;
}
inline void EmotionDetail::clear_has_version() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void EmotionDetail::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 EmotionDetail::version() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.Version)
  return version_;
}
inline void EmotionDetail::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.Version)
}

// optional string TimeLimitStr = 21;
inline bool EmotionDetail::has_timelimitstr() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EmotionDetail::set_has_timelimitstr() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EmotionDetail::clear_has_timelimitstr() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EmotionDetail::clear_timelimitstr() {
  timelimitstr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timelimitstr();
}
inline const ::std::string& EmotionDetail::timelimitstr() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.TimeLimitStr)
  return timelimitstr_.GetNoArena();
}
inline void EmotionDetail::set_timelimitstr(const ::std::string& value) {
  set_has_timelimitstr();
  timelimitstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.TimeLimitStr)
}
#if LANG_CXX11
inline void EmotionDetail::set_timelimitstr(::std::string&& value) {
  set_has_timelimitstr();
  timelimitstr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.TimeLimitStr)
}
#endif
inline void EmotionDetail::set_timelimitstr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timelimitstr();
  timelimitstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.TimeLimitStr)
}
inline void EmotionDetail::set_timelimitstr(const char* value, size_t size) {
  set_has_timelimitstr();
  timelimitstr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.TimeLimitStr)
}
inline ::std::string* EmotionDetail::mutable_timelimitstr() {
  set_has_timelimitstr();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.TimeLimitStr)
  return timelimitstr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_timelimitstr() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.TimeLimitStr)
  clear_has_timelimitstr();
  return timelimitstr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_timelimitstr(::std::string* timelimitstr) {
  if (timelimitstr != NULL) {
    set_has_timelimitstr();
  } else {
    clear_has_timelimitstr();
  }
  timelimitstr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timelimitstr);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.TimeLimitStr)
}

// optional string ShareDesc = 22;
inline bool EmotionDetail::has_sharedesc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EmotionDetail::set_has_sharedesc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EmotionDetail::clear_has_sharedesc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EmotionDetail::clear_sharedesc() {
  sharedesc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sharedesc();
}
inline const ::std::string& EmotionDetail::sharedesc() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.ShareDesc)
  return sharedesc_.GetNoArena();
}
inline void EmotionDetail::set_sharedesc(const ::std::string& value) {
  set_has_sharedesc();
  sharedesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.ShareDesc)
}
#if LANG_CXX11
inline void EmotionDetail::set_sharedesc(::std::string&& value) {
  set_has_sharedesc();
  sharedesc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.ShareDesc)
}
#endif
inline void EmotionDetail::set_sharedesc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sharedesc();
  sharedesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.ShareDesc)
}
inline void EmotionDetail::set_sharedesc(const char* value, size_t size) {
  set_has_sharedesc();
  sharedesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.ShareDesc)
}
inline ::std::string* EmotionDetail::mutable_sharedesc() {
  set_has_sharedesc();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.ShareDesc)
  return sharedesc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_sharedesc() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.ShareDesc)
  clear_has_sharedesc();
  return sharedesc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_sharedesc(::std::string* sharedesc) {
  if (sharedesc != NULL) {
    set_has_sharedesc();
  } else {
    clear_has_sharedesc();
  }
  sharedesc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sharedesc);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.ShareDesc)
}

// optional string OldRedirectUrl = 23;
inline bool EmotionDetail::has_oldredirecturl() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EmotionDetail::set_has_oldredirecturl() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EmotionDetail::clear_has_oldredirecturl() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EmotionDetail::clear_oldredirecturl() {
  oldredirecturl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oldredirecturl();
}
inline const ::std::string& EmotionDetail::oldredirecturl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDetail.OldRedirectUrl)
  return oldredirecturl_.GetNoArena();
}
inline void EmotionDetail::set_oldredirecturl(const ::std::string& value) {
  set_has_oldredirecturl();
  oldredirecturl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDetail.OldRedirectUrl)
}
#if LANG_CXX11
inline void EmotionDetail::set_oldredirecturl(::std::string&& value) {
  set_has_oldredirecturl();
  oldredirecturl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDetail.OldRedirectUrl)
}
#endif
inline void EmotionDetail::set_oldredirecturl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_oldredirecturl();
  oldredirecturl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDetail.OldRedirectUrl)
}
inline void EmotionDetail::set_oldredirecturl(const char* value, size_t size) {
  set_has_oldredirecturl();
  oldredirecturl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDetail.OldRedirectUrl)
}
inline ::std::string* EmotionDetail::mutable_oldredirecturl() {
  set_has_oldredirecturl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDetail.OldRedirectUrl)
  return oldredirecturl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDetail::release_oldredirecturl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDetail.OldRedirectUrl)
  clear_has_oldredirecturl();
  return oldredirecturl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDetail::set_allocated_oldredirecturl(::std::string* oldredirecturl) {
  if (oldredirecturl != NULL) {
    set_has_oldredirecturl();
  } else {
    clear_has_oldredirecturl();
  }
  oldredirecturl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oldredirecturl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDetail.OldRedirectUrl)
}

// -------------------------------------------------------------------

// EmotionBannerImg

// optional string ImgUrl = 1;
inline bool EmotionBannerImg::has_imgurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionBannerImg::set_has_imgurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionBannerImg::clear_has_imgurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionBannerImg::clear_imgurl() {
  imgurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgurl();
}
inline const ::std::string& EmotionBannerImg::imgurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionBannerImg.ImgUrl)
  return imgurl_.GetNoArena();
}
inline void EmotionBannerImg::set_imgurl(const ::std::string& value) {
  set_has_imgurl();
  imgurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionBannerImg.ImgUrl)
}
#if LANG_CXX11
inline void EmotionBannerImg::set_imgurl(::std::string&& value) {
  set_has_imgurl();
  imgurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionBannerImg.ImgUrl)
}
#endif
inline void EmotionBannerImg::set_imgurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgurl();
  imgurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionBannerImg.ImgUrl)
}
inline void EmotionBannerImg::set_imgurl(const char* value, size_t size) {
  set_has_imgurl();
  imgurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionBannerImg.ImgUrl)
}
inline ::std::string* EmotionBannerImg::mutable_imgurl() {
  set_has_imgurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionBannerImg.ImgUrl)
  return imgurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionBannerImg::release_imgurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionBannerImg.ImgUrl)
  clear_has_imgurl();
  return imgurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionBannerImg::set_allocated_imgurl(::std::string* imgurl) {
  if (imgurl != NULL) {
    set_has_imgurl();
  } else {
    clear_has_imgurl();
  }
  imgurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionBannerImg.ImgUrl)
}

// required uint32 Width = 2;
inline bool EmotionBannerImg::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmotionBannerImg::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmotionBannerImg::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmotionBannerImg::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 EmotionBannerImg::width() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionBannerImg.Width)
  return width_;
}
inline void EmotionBannerImg::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionBannerImg.Width)
}

// required uint32 Height = 3;
inline bool EmotionBannerImg::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmotionBannerImg::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmotionBannerImg::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmotionBannerImg::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 EmotionBannerImg::height() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionBannerImg.Height)
  return height_;
}
inline void EmotionBannerImg::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionBannerImg.Height)
}

// optional string StripUrl = 4;
inline bool EmotionBannerImg::has_stripurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmotionBannerImg::set_has_stripurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmotionBannerImg::clear_has_stripurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmotionBannerImg::clear_stripurl() {
  stripurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stripurl();
}
inline const ::std::string& EmotionBannerImg::stripurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionBannerImg.StripUrl)
  return stripurl_.GetNoArena();
}
inline void EmotionBannerImg::set_stripurl(const ::std::string& value) {
  set_has_stripurl();
  stripurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionBannerImg.StripUrl)
}
#if LANG_CXX11
inline void EmotionBannerImg::set_stripurl(::std::string&& value) {
  set_has_stripurl();
  stripurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionBannerImg.StripUrl)
}
#endif
inline void EmotionBannerImg::set_stripurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_stripurl();
  stripurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionBannerImg.StripUrl)
}
inline void EmotionBannerImg::set_stripurl(const char* value, size_t size) {
  set_has_stripurl();
  stripurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionBannerImg.StripUrl)
}
inline ::std::string* EmotionBannerImg::mutable_stripurl() {
  set_has_stripurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionBannerImg.StripUrl)
  return stripurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionBannerImg::release_stripurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionBannerImg.StripUrl)
  clear_has_stripurl();
  return stripurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionBannerImg::set_allocated_stripurl(::std::string* stripurl) {
  if (stripurl != NULL) {
    set_has_stripurl();
  } else {
    clear_has_stripurl();
  }
  stripurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stripurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionBannerImg.StripUrl)
}

// -------------------------------------------------------------------

// EmotionBanner

// required .micromsg.EmotionSummary BannerSummary = 1;
inline bool EmotionBanner::has_bannersummary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionBanner::set_has_bannersummary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionBanner::clear_has_bannersummary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionBanner::clear_bannersummary() {
  if (bannersummary_ != NULL) bannersummary_->::micromsg::EmotionSummary::Clear();
  clear_has_bannersummary();
}
inline const ::micromsg::EmotionSummary& EmotionBanner::bannersummary() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionBanner.BannerSummary)
  return bannersummary_ != NULL ? *bannersummary_
                         : *::micromsg::EmotionSummary::internal_default_instance();
}
inline ::micromsg::EmotionSummary* EmotionBanner::mutable_bannersummary() {
  set_has_bannersummary();
  if (bannersummary_ == NULL) {
    bannersummary_ = new ::micromsg::EmotionSummary;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionBanner.BannerSummary)
  return bannersummary_;
}
inline ::micromsg::EmotionSummary* EmotionBanner::release_bannersummary() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionBanner.BannerSummary)
  clear_has_bannersummary();
  ::micromsg::EmotionSummary* temp = bannersummary_;
  bannersummary_ = NULL;
  return temp;
}
inline void EmotionBanner::set_allocated_bannersummary(::micromsg::EmotionSummary* bannersummary) {
  delete bannersummary_;
  bannersummary_ = bannersummary;
  if (bannersummary) {
    set_has_bannersummary();
  } else {
    clear_has_bannersummary();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionBanner.BannerSummary)
}

// required .micromsg.EmotionBannerImg BannerImg = 2;
inline bool EmotionBanner::has_bannerimg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmotionBanner::set_has_bannerimg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmotionBanner::clear_has_bannerimg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmotionBanner::clear_bannerimg() {
  if (bannerimg_ != NULL) bannerimg_->::micromsg::EmotionBannerImg::Clear();
  clear_has_bannerimg();
}
inline const ::micromsg::EmotionBannerImg& EmotionBanner::bannerimg() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionBanner.BannerImg)
  return bannerimg_ != NULL ? *bannerimg_
                         : *::micromsg::EmotionBannerImg::internal_default_instance();
}
inline ::micromsg::EmotionBannerImg* EmotionBanner::mutable_bannerimg() {
  set_has_bannerimg();
  if (bannerimg_ == NULL) {
    bannerimg_ = new ::micromsg::EmotionBannerImg;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionBanner.BannerImg)
  return bannerimg_;
}
inline ::micromsg::EmotionBannerImg* EmotionBanner::release_bannerimg() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionBanner.BannerImg)
  clear_has_bannerimg();
  ::micromsg::EmotionBannerImg* temp = bannerimg_;
  bannerimg_ = NULL;
  return temp;
}
inline void EmotionBanner::set_allocated_bannerimg(::micromsg::EmotionBannerImg* bannerimg) {
  delete bannerimg_;
  bannerimg_ = bannerimg;
  if (bannerimg) {
    set_has_bannerimg();
  } else {
    clear_has_bannerimg();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionBanner.BannerImg)
}

// -------------------------------------------------------------------

// EmotionCell

// optional string CellTitle = 1;
inline bool EmotionCell::has_celltitle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionCell::set_has_celltitle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionCell::clear_has_celltitle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionCell::clear_celltitle() {
  celltitle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_celltitle();
}
inline const ::std::string& EmotionCell::celltitle() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionCell.CellTitle)
  return celltitle_.GetNoArena();
}
inline void EmotionCell::set_celltitle(const ::std::string& value) {
  set_has_celltitle();
  celltitle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionCell.CellTitle)
}
#if LANG_CXX11
inline void EmotionCell::set_celltitle(::std::string&& value) {
  set_has_celltitle();
  celltitle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionCell.CellTitle)
}
#endif
inline void EmotionCell::set_celltitle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_celltitle();
  celltitle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionCell.CellTitle)
}
inline void EmotionCell::set_celltitle(const char* value, size_t size) {
  set_has_celltitle();
  celltitle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionCell.CellTitle)
}
inline ::std::string* EmotionCell::mutable_celltitle() {
  set_has_celltitle();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionCell.CellTitle)
  return celltitle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionCell::release_celltitle() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionCell.CellTitle)
  clear_has_celltitle();
  return celltitle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionCell::set_allocated_celltitle(::std::string* celltitle) {
  if (celltitle != NULL) {
    set_has_celltitle();
  } else {
    clear_has_celltitle();
  }
  celltitle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), celltitle);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionCell.CellTitle)
}

// required uint32 ReqType = 2;
inline bool EmotionCell::has_reqtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmotionCell::set_has_reqtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmotionCell::clear_has_reqtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmotionCell::clear_reqtype() {
  reqtype_ = 0u;
  clear_has_reqtype();
}
inline ::google::protobuf::uint32 EmotionCell::reqtype() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionCell.ReqType)
  return reqtype_;
}
inline void EmotionCell::set_reqtype(::google::protobuf::uint32 value) {
  set_has_reqtype();
  reqtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionCell.ReqType)
}

// required uint32 Position = 3;
inline bool EmotionCell::has_position() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmotionCell::set_has_position() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmotionCell::clear_has_position() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmotionCell::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 EmotionCell::position() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionCell.Position)
  return position_;
}
inline void EmotionCell::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionCell.Position)
}

// optional string IconUrl = 4;
inline bool EmotionCell::has_iconurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmotionCell::set_has_iconurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmotionCell::clear_has_iconurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmotionCell::clear_iconurl() {
  iconurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iconurl();
}
inline const ::std::string& EmotionCell::iconurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionCell.IconUrl)
  return iconurl_.GetNoArena();
}
inline void EmotionCell::set_iconurl(const ::std::string& value) {
  set_has_iconurl();
  iconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionCell.IconUrl)
}
#if LANG_CXX11
inline void EmotionCell::set_iconurl(::std::string&& value) {
  set_has_iconurl();
  iconurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionCell.IconUrl)
}
#endif
inline void EmotionCell::set_iconurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iconurl();
  iconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionCell.IconUrl)
}
inline void EmotionCell::set_iconurl(const char* value, size_t size) {
  set_has_iconurl();
  iconurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionCell.IconUrl)
}
inline ::std::string* EmotionCell::mutable_iconurl() {
  set_has_iconurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionCell.IconUrl)
  return iconurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionCell::release_iconurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionCell.IconUrl)
  clear_has_iconurl();
  return iconurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionCell::set_allocated_iconurl(::std::string* iconurl) {
  if (iconurl != NULL) {
    set_has_iconurl();
  } else {
    clear_has_iconurl();
  }
  iconurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iconurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionCell.IconUrl)
}

// optional string TagUrl = 5;
inline bool EmotionCell::has_tagurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmotionCell::set_has_tagurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmotionCell::clear_has_tagurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmotionCell::clear_tagurl() {
  tagurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tagurl();
}
inline const ::std::string& EmotionCell::tagurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionCell.TagUrl)
  return tagurl_.GetNoArena();
}
inline void EmotionCell::set_tagurl(const ::std::string& value) {
  set_has_tagurl();
  tagurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionCell.TagUrl)
}
#if LANG_CXX11
inline void EmotionCell::set_tagurl(::std::string&& value) {
  set_has_tagurl();
  tagurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionCell.TagUrl)
}
#endif
inline void EmotionCell::set_tagurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tagurl();
  tagurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionCell.TagUrl)
}
inline void EmotionCell::set_tagurl(const char* value, size_t size) {
  set_has_tagurl();
  tagurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionCell.TagUrl)
}
inline ::std::string* EmotionCell::mutable_tagurl() {
  set_has_tagurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionCell.TagUrl)
  return tagurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionCell::release_tagurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionCell.TagUrl)
  clear_has_tagurl();
  return tagurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionCell::set_allocated_tagurl(::std::string* tagurl) {
  if (tagurl != NULL) {
    set_has_tagurl();
  } else {
    clear_has_tagurl();
  }
  tagurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tagurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionCell.TagUrl)
}

// -------------------------------------------------------------------

// GetEmotionListRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetEmotionListRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionListRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionListRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionListRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetEmotionListRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetEmotionListRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionListRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetEmotionListRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionListRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetEmotionListRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionListRequest.BaseRequest)
}

// required .micromsg.SKBuiltinBuffer_t ReqBuf = 2;
inline bool GetEmotionListRequest::has_reqbuf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionListRequest::set_has_reqbuf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionListRequest::clear_has_reqbuf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionListRequest::clear_reqbuf() {
  if (reqbuf_ != NULL) reqbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_reqbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetEmotionListRequest::reqbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListRequest.ReqBuf)
  return reqbuf_ != NULL ? *reqbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetEmotionListRequest::mutable_reqbuf() {
  set_has_reqbuf();
  if (reqbuf_ == NULL) {
    reqbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionListRequest.ReqBuf)
  return reqbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetEmotionListRequest::release_reqbuf() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionListRequest.ReqBuf)
  clear_has_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = reqbuf_;
  reqbuf_ = NULL;
  return temp;
}
inline void GetEmotionListRequest::set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf) {
  delete reqbuf_;
  reqbuf_ = reqbuf;
  if (reqbuf) {
    set_has_reqbuf();
  } else {
    clear_has_reqbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionListRequest.ReqBuf)
}

// required uint32 ReqType = 3;
inline bool GetEmotionListRequest::has_reqtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetEmotionListRequest::set_has_reqtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetEmotionListRequest::clear_has_reqtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetEmotionListRequest::clear_reqtype() {
  reqtype_ = 0u;
  clear_has_reqtype();
}
inline ::google::protobuf::uint32 GetEmotionListRequest::reqtype() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListRequest.ReqType)
  return reqtype_;
}
inline void GetEmotionListRequest::set_reqtype(::google::protobuf::uint32 value) {
  set_has_reqtype();
  reqtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionListRequest.ReqType)
}

// optional uint32 Scene = 4;
inline bool GetEmotionListRequest::has_scene() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetEmotionListRequest::set_has_scene() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetEmotionListRequest::clear_has_scene() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetEmotionListRequest::clear_scene() {
  scene_ = 0u;
  clear_has_scene();
}
inline ::google::protobuf::uint32 GetEmotionListRequest::scene() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListRequest.Scene)
  return scene_;
}
inline void GetEmotionListRequest::set_scene(::google::protobuf::uint32 value) {
  set_has_scene();
  scene_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionListRequest.Scene)
}

// -------------------------------------------------------------------

// GetEmotionListResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetEmotionListResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionListResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionListResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionListResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetEmotionListResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetEmotionListResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionListResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetEmotionListResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionListResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetEmotionListResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionListResponse.BaseResponse)
}

// required .micromsg.SKBuiltinBuffer_t ReqBuf = 2;
inline bool GetEmotionListResponse::has_reqbuf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionListResponse::set_has_reqbuf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionListResponse::clear_has_reqbuf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionListResponse::clear_reqbuf() {
  if (reqbuf_ != NULL) reqbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_reqbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetEmotionListResponse::reqbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListResponse.ReqBuf)
  return reqbuf_ != NULL ? *reqbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetEmotionListResponse::mutable_reqbuf() {
  set_has_reqbuf();
  if (reqbuf_ == NULL) {
    reqbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionListResponse.ReqBuf)
  return reqbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetEmotionListResponse::release_reqbuf() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionListResponse.ReqBuf)
  clear_has_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = reqbuf_;
  reqbuf_ = NULL;
  return temp;
}
inline void GetEmotionListResponse::set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf) {
  delete reqbuf_;
  reqbuf_ = reqbuf;
  if (reqbuf) {
    set_has_reqbuf();
  } else {
    clear_has_reqbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionListResponse.ReqBuf)
}

// required uint32 EmotionCount = 3;
inline bool GetEmotionListResponse::has_emotioncount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetEmotionListResponse::set_has_emotioncount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetEmotionListResponse::clear_has_emotioncount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetEmotionListResponse::clear_emotioncount() {
  emotioncount_ = 0u;
  clear_has_emotioncount();
}
inline ::google::protobuf::uint32 GetEmotionListResponse::emotioncount() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListResponse.EmotionCount)
  return emotioncount_;
}
inline void GetEmotionListResponse::set_emotioncount(::google::protobuf::uint32 value) {
  set_has_emotioncount();
  emotioncount_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionListResponse.EmotionCount)
}

// repeated .micromsg.EmotionSummary EmotionList = 4;
inline int GetEmotionListResponse::emotionlist_size() const {
  return emotionlist_.size();
}
inline void GetEmotionListResponse::clear_emotionlist() {
  emotionlist_.Clear();
}
inline const ::micromsg::EmotionSummary& GetEmotionListResponse::emotionlist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListResponse.EmotionList)
  return emotionlist_.Get(index);
}
inline ::micromsg::EmotionSummary* GetEmotionListResponse::mutable_emotionlist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionListResponse.EmotionList)
  return emotionlist_.Mutable(index);
}
inline ::micromsg::EmotionSummary* GetEmotionListResponse::add_emotionlist() {
  // @@protoc_insertion_point(field_add:micromsg.GetEmotionListResponse.EmotionList)
  return emotionlist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary >*
GetEmotionListResponse::mutable_emotionlist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetEmotionListResponse.EmotionList)
  return &emotionlist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary >&
GetEmotionListResponse::emotionlist() const {
  // @@protoc_insertion_point(field_list:micromsg.GetEmotionListResponse.EmotionList)
  return emotionlist_;
}

// optional .micromsg.EmotionBanner Banner = 5;
inline bool GetEmotionListResponse::has_banner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetEmotionListResponse::set_has_banner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetEmotionListResponse::clear_has_banner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetEmotionListResponse::clear_banner() {
  if (banner_ != NULL) banner_->::micromsg::EmotionBanner::Clear();
  clear_has_banner();
}
inline const ::micromsg::EmotionBanner& GetEmotionListResponse::banner() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListResponse.Banner)
  return banner_ != NULL ? *banner_
                         : *::micromsg::EmotionBanner::internal_default_instance();
}
inline ::micromsg::EmotionBanner* GetEmotionListResponse::mutable_banner() {
  set_has_banner();
  if (banner_ == NULL) {
    banner_ = new ::micromsg::EmotionBanner;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionListResponse.Banner)
  return banner_;
}
inline ::micromsg::EmotionBanner* GetEmotionListResponse::release_banner() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionListResponse.Banner)
  clear_has_banner();
  ::micromsg::EmotionBanner* temp = banner_;
  banner_ = NULL;
  return temp;
}
inline void GetEmotionListResponse::set_allocated_banner(::micromsg::EmotionBanner* banner) {
  delete banner_;
  banner_ = banner;
  if (banner) {
    set_has_banner();
  } else {
    clear_has_banner();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionListResponse.Banner)
}

// optional uint32 NewBannerCount = 6;
inline bool GetEmotionListResponse::has_newbannercount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetEmotionListResponse::set_has_newbannercount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetEmotionListResponse::clear_has_newbannercount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetEmotionListResponse::clear_newbannercount() {
  newbannercount_ = 0u;
  clear_has_newbannercount();
}
inline ::google::protobuf::uint32 GetEmotionListResponse::newbannercount() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListResponse.NewBannerCount)
  return newbannercount_;
}
inline void GetEmotionListResponse::set_newbannercount(::google::protobuf::uint32 value) {
  set_has_newbannercount();
  newbannercount_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionListResponse.NewBannerCount)
}

// repeated .micromsg.EmotionBanner NewBannerList = 7;
inline int GetEmotionListResponse::newbannerlist_size() const {
  return newbannerlist_.size();
}
inline void GetEmotionListResponse::clear_newbannerlist() {
  newbannerlist_.Clear();
}
inline const ::micromsg::EmotionBanner& GetEmotionListResponse::newbannerlist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListResponse.NewBannerList)
  return newbannerlist_.Get(index);
}
inline ::micromsg::EmotionBanner* GetEmotionListResponse::mutable_newbannerlist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionListResponse.NewBannerList)
  return newbannerlist_.Mutable(index);
}
inline ::micromsg::EmotionBanner* GetEmotionListResponse::add_newbannerlist() {
  // @@protoc_insertion_point(field_add:micromsg.GetEmotionListResponse.NewBannerList)
  return newbannerlist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionBanner >*
GetEmotionListResponse::mutable_newbannerlist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetEmotionListResponse.NewBannerList)
  return &newbannerlist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionBanner >&
GetEmotionListResponse::newbannerlist() const {
  // @@protoc_insertion_point(field_list:micromsg.GetEmotionListResponse.NewBannerList)
  return newbannerlist_;
}

// optional uint32 CellCount = 8;
inline bool GetEmotionListResponse::has_cellcount() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetEmotionListResponse::set_has_cellcount() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetEmotionListResponse::clear_has_cellcount() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetEmotionListResponse::clear_cellcount() {
  cellcount_ = 0u;
  clear_has_cellcount();
}
inline ::google::protobuf::uint32 GetEmotionListResponse::cellcount() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListResponse.CellCount)
  return cellcount_;
}
inline void GetEmotionListResponse::set_cellcount(::google::protobuf::uint32 value) {
  set_has_cellcount();
  cellcount_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionListResponse.CellCount)
}

// repeated .micromsg.EmotionCell CellList = 9;
inline int GetEmotionListResponse::celllist_size() const {
  return celllist_.size();
}
inline void GetEmotionListResponse::clear_celllist() {
  celllist_.Clear();
}
inline const ::micromsg::EmotionCell& GetEmotionListResponse::celllist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionListResponse.CellList)
  return celllist_.Get(index);
}
inline ::micromsg::EmotionCell* GetEmotionListResponse::mutable_celllist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionListResponse.CellList)
  return celllist_.Mutable(index);
}
inline ::micromsg::EmotionCell* GetEmotionListResponse::add_celllist() {
  // @@protoc_insertion_point(field_add:micromsg.GetEmotionListResponse.CellList)
  return celllist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionCell >*
GetEmotionListResponse::mutable_celllist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetEmotionListResponse.CellList)
  return &celllist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionCell >&
GetEmotionListResponse::celllist() const {
  // @@protoc_insertion_point(field_list:micromsg.GetEmotionListResponse.CellList)
  return celllist_;
}

// -------------------------------------------------------------------

// GetEmotionDetailRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetEmotionDetailRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionDetailRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionDetailRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionDetailRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetEmotionDetailRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDetailRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetEmotionDetailRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDetailRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetEmotionDetailRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDetailRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetEmotionDetailRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDetailRequest.BaseRequest)
}

// optional string ProductID = 2;
inline bool GetEmotionDetailRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionDetailRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionDetailRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionDetailRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& GetEmotionDetailRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDetailRequest.ProductID)
  return productid_.GetNoArena();
}
inline void GetEmotionDetailRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDetailRequest.ProductID)
}
#if LANG_CXX11
inline void GetEmotionDetailRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetEmotionDetailRequest.ProductID)
}
#endif
inline void GetEmotionDetailRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetEmotionDetailRequest.ProductID)
}
inline void GetEmotionDetailRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetEmotionDetailRequest.ProductID)
}
inline ::std::string* GetEmotionDetailRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDetailRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetEmotionDetailRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDetailRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetEmotionDetailRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDetailRequest.ProductID)
}

// optional uint32 Scene = 3;
inline bool GetEmotionDetailRequest::has_scene() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetEmotionDetailRequest::set_has_scene() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetEmotionDetailRequest::clear_has_scene() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetEmotionDetailRequest::clear_scene() {
  scene_ = 0u;
  clear_has_scene();
}
inline ::google::protobuf::uint32 GetEmotionDetailRequest::scene() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDetailRequest.Scene)
  return scene_;
}
inline void GetEmotionDetailRequest::set_scene(::google::protobuf::uint32 value) {
  set_has_scene();
  scene_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDetailRequest.Scene)
}

// optional int32 Version = 4;
inline bool GetEmotionDetailRequest::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetEmotionDetailRequest::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetEmotionDetailRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetEmotionDetailRequest::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 GetEmotionDetailRequest::version() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDetailRequest.Version)
  return version_;
}
inline void GetEmotionDetailRequest::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDetailRequest.Version)
}

// -------------------------------------------------------------------

// GetEmotionDetailResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetEmotionDetailResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionDetailResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionDetailResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionDetailResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetEmotionDetailResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDetailResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetEmotionDetailResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDetailResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetEmotionDetailResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDetailResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetEmotionDetailResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDetailResponse.BaseResponse)
}

// required .micromsg.EmotionDetail EmotionDetail = 2;
inline bool GetEmotionDetailResponse::has_emotiondetail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionDetailResponse::set_has_emotiondetail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionDetailResponse::clear_has_emotiondetail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionDetailResponse::clear_emotiondetail() {
  if (emotiondetail_ != NULL) emotiondetail_->::micromsg::EmotionDetail::Clear();
  clear_has_emotiondetail();
}
inline const ::micromsg::EmotionDetail& GetEmotionDetailResponse::emotiondetail() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDetailResponse.EmotionDetail)
  return emotiondetail_ != NULL ? *emotiondetail_
                         : *::micromsg::EmotionDetail::internal_default_instance();
}
inline ::micromsg::EmotionDetail* GetEmotionDetailResponse::mutable_emotiondetail() {
  set_has_emotiondetail();
  if (emotiondetail_ == NULL) {
    emotiondetail_ = new ::micromsg::EmotionDetail;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDetailResponse.EmotionDetail)
  return emotiondetail_;
}
inline ::micromsg::EmotionDetail* GetEmotionDetailResponse::release_emotiondetail() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDetailResponse.EmotionDetail)
  clear_has_emotiondetail();
  ::micromsg::EmotionDetail* temp = emotiondetail_;
  emotiondetail_ = NULL;
  return temp;
}
inline void GetEmotionDetailResponse::set_allocated_emotiondetail(::micromsg::EmotionDetail* emotiondetail) {
  delete emotiondetail_;
  emotiondetail_ = emotiondetail;
  if (emotiondetail) {
    set_has_emotiondetail();
  } else {
    clear_has_emotiondetail();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDetailResponse.EmotionDetail)
}

// -------------------------------------------------------------------

// VerifyPurchaseRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool VerifyPurchaseRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VerifyPurchaseRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VerifyPurchaseRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VerifyPurchaseRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& VerifyPurchaseRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* VerifyPurchaseRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPurchaseRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* VerifyPurchaseRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPurchaseRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void VerifyPurchaseRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPurchaseRequest.BaseRequest)
}

// required .micromsg.SKBuiltinBuffer_t Receipt = 2;
inline bool VerifyPurchaseRequest::has_receipt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VerifyPurchaseRequest::set_has_receipt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VerifyPurchaseRequest::clear_has_receipt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VerifyPurchaseRequest::clear_receipt() {
  if (receipt_ != NULL) receipt_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_receipt();
}
inline const ::micromsg::SKBuiltinBuffer_t& VerifyPurchaseRequest::receipt() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.Receipt)
  return receipt_ != NULL ? *receipt_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPurchaseRequest::mutable_receipt() {
  set_has_receipt();
  if (receipt_ == NULL) {
    receipt_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPurchaseRequest.Receipt)
  return receipt_;
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPurchaseRequest::release_receipt() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPurchaseRequest.Receipt)
  clear_has_receipt();
  ::micromsg::SKBuiltinBuffer_t* temp = receipt_;
  receipt_ = NULL;
  return temp;
}
inline void VerifyPurchaseRequest::set_allocated_receipt(::micromsg::SKBuiltinBuffer_t* receipt) {
  delete receipt_;
  receipt_ = receipt;
  if (receipt) {
    set_has_receipt();
  } else {
    clear_has_receipt();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPurchaseRequest.Receipt)
}

// optional string ProductID = 3;
inline bool VerifyPurchaseRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyPurchaseRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyPurchaseRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyPurchaseRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& VerifyPurchaseRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.ProductID)
  return productid_.GetNoArena();
}
inline void VerifyPurchaseRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseRequest.ProductID)
}
#if LANG_CXX11
inline void VerifyPurchaseRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPurchaseRequest.ProductID)
}
#endif
inline void VerifyPurchaseRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPurchaseRequest.ProductID)
}
inline void VerifyPurchaseRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPurchaseRequest.ProductID)
}
inline ::std::string* VerifyPurchaseRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPurchaseRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPurchaseRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPurchaseRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPurchaseRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPurchaseRequest.ProductID)
}

// required uint32 VerifyType = 4;
inline bool VerifyPurchaseRequest::has_verifytype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VerifyPurchaseRequest::set_has_verifytype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VerifyPurchaseRequest::clear_has_verifytype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VerifyPurchaseRequest::clear_verifytype() {
  verifytype_ = 0u;
  clear_has_verifytype();
}
inline ::google::protobuf::uint32 VerifyPurchaseRequest::verifytype() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.VerifyType)
  return verifytype_;
}
inline void VerifyPurchaseRequest::set_verifytype(::google::protobuf::uint32 value) {
  set_has_verifytype();
  verifytype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseRequest.VerifyType)
}

// required uint32 PayType = 5;
inline bool VerifyPurchaseRequest::has_paytype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VerifyPurchaseRequest::set_has_paytype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VerifyPurchaseRequest::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VerifyPurchaseRequest::clear_paytype() {
  paytype_ = 0u;
  clear_has_paytype();
}
inline ::google::protobuf::uint32 VerifyPurchaseRequest::paytype() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.PayType)
  return paytype_;
}
inline void VerifyPurchaseRequest::set_paytype(::google::protobuf::uint32 value) {
  set_has_paytype();
  paytype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseRequest.PayType)
}

// optional string Price = 6;
inline bool VerifyPurchaseRequest::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyPurchaseRequest::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyPurchaseRequest::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyPurchaseRequest::clear_price() {
  price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_price();
}
inline const ::std::string& VerifyPurchaseRequest::price() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.Price)
  return price_.GetNoArena();
}
inline void VerifyPurchaseRequest::set_price(const ::std::string& value) {
  set_has_price();
  price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseRequest.Price)
}
#if LANG_CXX11
inline void VerifyPurchaseRequest::set_price(::std::string&& value) {
  set_has_price();
  price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPurchaseRequest.Price)
}
#endif
inline void VerifyPurchaseRequest::set_price(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_price();
  price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPurchaseRequest.Price)
}
inline void VerifyPurchaseRequest::set_price(const char* value, size_t size) {
  set_has_price();
  price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPurchaseRequest.Price)
}
inline ::std::string* VerifyPurchaseRequest::mutable_price() {
  set_has_price();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPurchaseRequest.Price)
  return price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPurchaseRequest::release_price() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPurchaseRequest.Price)
  clear_has_price();
  return price_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPurchaseRequest::set_allocated_price(::std::string* price) {
  if (price != NULL) {
    set_has_price();
  } else {
    clear_has_price();
  }
  price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), price);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPurchaseRequest.Price)
}

// optional string CurrencyType = 7;
inline bool VerifyPurchaseRequest::has_currencytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyPurchaseRequest::set_has_currencytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyPurchaseRequest::clear_has_currencytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyPurchaseRequest::clear_currencytype() {
  currencytype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_currencytype();
}
inline const ::std::string& VerifyPurchaseRequest::currencytype() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.CurrencyType)
  return currencytype_.GetNoArena();
}
inline void VerifyPurchaseRequest::set_currencytype(const ::std::string& value) {
  set_has_currencytype();
  currencytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseRequest.CurrencyType)
}
#if LANG_CXX11
inline void VerifyPurchaseRequest::set_currencytype(::std::string&& value) {
  set_has_currencytype();
  currencytype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPurchaseRequest.CurrencyType)
}
#endif
inline void VerifyPurchaseRequest::set_currencytype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_currencytype();
  currencytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPurchaseRequest.CurrencyType)
}
inline void VerifyPurchaseRequest::set_currencytype(const char* value, size_t size) {
  set_has_currencytype();
  currencytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPurchaseRequest.CurrencyType)
}
inline ::std::string* VerifyPurchaseRequest::mutable_currencytype() {
  set_has_currencytype();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPurchaseRequest.CurrencyType)
  return currencytype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPurchaseRequest::release_currencytype() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPurchaseRequest.CurrencyType)
  clear_has_currencytype();
  return currencytype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPurchaseRequest::set_allocated_currencytype(::std::string* currencytype) {
  if (currencytype != NULL) {
    set_has_currencytype();
  } else {
    clear_has_currencytype();
  }
  currencytype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), currencytype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPurchaseRequest.CurrencyType)
}

// optional string BillNo = 8;
inline bool VerifyPurchaseRequest::has_billno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyPurchaseRequest::set_has_billno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VerifyPurchaseRequest::clear_has_billno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VerifyPurchaseRequest::clear_billno() {
  billno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_billno();
}
inline const ::std::string& VerifyPurchaseRequest::billno() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.BillNo)
  return billno_.GetNoArena();
}
inline void VerifyPurchaseRequest::set_billno(const ::std::string& value) {
  set_has_billno();
  billno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseRequest.BillNo)
}
#if LANG_CXX11
inline void VerifyPurchaseRequest::set_billno(::std::string&& value) {
  set_has_billno();
  billno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPurchaseRequest.BillNo)
}
#endif
inline void VerifyPurchaseRequest::set_billno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_billno();
  billno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPurchaseRequest.BillNo)
}
inline void VerifyPurchaseRequest::set_billno(const char* value, size_t size) {
  set_has_billno();
  billno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPurchaseRequest.BillNo)
}
inline ::std::string* VerifyPurchaseRequest::mutable_billno() {
  set_has_billno();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPurchaseRequest.BillNo)
  return billno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPurchaseRequest::release_billno() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPurchaseRequest.BillNo)
  clear_has_billno();
  return billno_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPurchaseRequest::set_allocated_billno(::std::string* billno) {
  if (billno != NULL) {
    set_has_billno();
  } else {
    clear_has_billno();
  }
  billno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), billno);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPurchaseRequest.BillNo)
}

// required uint32 PayTime = 9;
inline bool VerifyPurchaseRequest::has_paytime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VerifyPurchaseRequest::set_has_paytime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VerifyPurchaseRequest::clear_has_paytime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VerifyPurchaseRequest::clear_paytime() {
  paytime_ = 0u;
  clear_has_paytime();
}
inline ::google::protobuf::uint32 VerifyPurchaseRequest::paytime() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.PayTime)
  return paytime_;
}
inline void VerifyPurchaseRequest::set_paytime(::google::protobuf::uint32 value) {
  set_has_paytime();
  paytime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseRequest.PayTime)
}

// optional string ReceiptSig = 10;
inline bool VerifyPurchaseRequest::has_receiptsig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VerifyPurchaseRequest::set_has_receiptsig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VerifyPurchaseRequest::clear_has_receiptsig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VerifyPurchaseRequest::clear_receiptsig() {
  receiptsig_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_receiptsig();
}
inline const ::std::string& VerifyPurchaseRequest::receiptsig() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.ReceiptSig)
  return receiptsig_.GetNoArena();
}
inline void VerifyPurchaseRequest::set_receiptsig(const ::std::string& value) {
  set_has_receiptsig();
  receiptsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseRequest.ReceiptSig)
}
#if LANG_CXX11
inline void VerifyPurchaseRequest::set_receiptsig(::std::string&& value) {
  set_has_receiptsig();
  receiptsig_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPurchaseRequest.ReceiptSig)
}
#endif
inline void VerifyPurchaseRequest::set_receiptsig(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_receiptsig();
  receiptsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPurchaseRequest.ReceiptSig)
}
inline void VerifyPurchaseRequest::set_receiptsig(const char* value, size_t size) {
  set_has_receiptsig();
  receiptsig_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPurchaseRequest.ReceiptSig)
}
inline ::std::string* VerifyPurchaseRequest::mutable_receiptsig() {
  set_has_receiptsig();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPurchaseRequest.ReceiptSig)
  return receiptsig_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPurchaseRequest::release_receiptsig() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPurchaseRequest.ReceiptSig)
  clear_has_receiptsig();
  return receiptsig_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPurchaseRequest::set_allocated_receiptsig(::std::string* receiptsig) {
  if (receiptsig != NULL) {
    set_has_receiptsig();
  } else {
    clear_has_receiptsig();
  }
  receiptsig_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receiptsig);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPurchaseRequest.ReceiptSig)
}

// optional uint32 Quantity = 11;
inline bool VerifyPurchaseRequest::has_quantity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VerifyPurchaseRequest::set_has_quantity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VerifyPurchaseRequest::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VerifyPurchaseRequest::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 VerifyPurchaseRequest::quantity() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseRequest.Quantity)
  return quantity_;
}
inline void VerifyPurchaseRequest::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseRequest.Quantity)
}

// -------------------------------------------------------------------

// VerifyPurchaseResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool VerifyPurchaseResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyPurchaseResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyPurchaseResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyPurchaseResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& VerifyPurchaseResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* VerifyPurchaseResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPurchaseResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* VerifyPurchaseResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPurchaseResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void VerifyPurchaseResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPurchaseResponse.BaseResponse)
}

// optional string SeriesID = 2;
inline bool VerifyPurchaseResponse::has_seriesid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyPurchaseResponse::set_has_seriesid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyPurchaseResponse::clear_has_seriesid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyPurchaseResponse::clear_seriesid() {
  seriesid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seriesid();
}
inline const ::std::string& VerifyPurchaseResponse::seriesid() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseResponse.SeriesID)
  return seriesid_.GetNoArena();
}
inline void VerifyPurchaseResponse::set_seriesid(const ::std::string& value) {
  set_has_seriesid();
  seriesid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseResponse.SeriesID)
}
#if LANG_CXX11
inline void VerifyPurchaseResponse::set_seriesid(::std::string&& value) {
  set_has_seriesid();
  seriesid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPurchaseResponse.SeriesID)
}
#endif
inline void VerifyPurchaseResponse::set_seriesid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seriesid();
  seriesid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPurchaseResponse.SeriesID)
}
inline void VerifyPurchaseResponse::set_seriesid(const char* value, size_t size) {
  set_has_seriesid();
  seriesid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPurchaseResponse.SeriesID)
}
inline ::std::string* VerifyPurchaseResponse::mutable_seriesid() {
  set_has_seriesid();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPurchaseResponse.SeriesID)
  return seriesid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPurchaseResponse::release_seriesid() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPurchaseResponse.SeriesID)
  clear_has_seriesid();
  return seriesid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPurchaseResponse::set_allocated_seriesid(::std::string* seriesid) {
  if (seriesid != NULL) {
    set_has_seriesid();
  } else {
    clear_has_seriesid();
  }
  seriesid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seriesid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPurchaseResponse.SeriesID)
}

// required uint32 BizType = 3;
inline bool VerifyPurchaseResponse::has_biztype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyPurchaseResponse::set_has_biztype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyPurchaseResponse::clear_has_biztype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyPurchaseResponse::clear_biztype() {
  biztype_ = 0u;
  clear_has_biztype();
}
inline ::google::protobuf::uint32 VerifyPurchaseResponse::biztype() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPurchaseResponse.BizType)
  return biztype_;
}
inline void VerifyPurchaseResponse::set_biztype(::google::protobuf::uint32 value) {
  set_has_biztype();
  biztype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.VerifyPurchaseResponse.BizType)
}

// -------------------------------------------------------------------

// ModEmotionPackRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool ModEmotionPackRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModEmotionPackRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModEmotionPackRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModEmotionPackRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& ModEmotionPackRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.ModEmotionPackRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* ModEmotionPackRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ModEmotionPackRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* ModEmotionPackRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.ModEmotionPackRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void ModEmotionPackRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ModEmotionPackRequest.BaseRequest)
}

// optional string ProductID = 2;
inline bool ModEmotionPackRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModEmotionPackRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModEmotionPackRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModEmotionPackRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& ModEmotionPackRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.ModEmotionPackRequest.ProductID)
  return productid_.GetNoArena();
}
inline void ModEmotionPackRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ModEmotionPackRequest.ProductID)
}
#if LANG_CXX11
inline void ModEmotionPackRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ModEmotionPackRequest.ProductID)
}
#endif
inline void ModEmotionPackRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ModEmotionPackRequest.ProductID)
}
inline void ModEmotionPackRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ModEmotionPackRequest.ProductID)
}
inline ::std::string* ModEmotionPackRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.ModEmotionPackRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModEmotionPackRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.ModEmotionPackRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModEmotionPackRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ModEmotionPackRequest.ProductID)
}

// required uint32 OpCode = 3;
inline bool ModEmotionPackRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModEmotionPackRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModEmotionPackRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModEmotionPackRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 ModEmotionPackRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.ModEmotionPackRequest.OpCode)
  return opcode_;
}
inline void ModEmotionPackRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ModEmotionPackRequest.OpCode)
}

// -------------------------------------------------------------------

// ModEmotionPackResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool ModEmotionPackResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModEmotionPackResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModEmotionPackResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModEmotionPackResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& ModEmotionPackResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.ModEmotionPackResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* ModEmotionPackResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ModEmotionPackResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* ModEmotionPackResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.ModEmotionPackResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void ModEmotionPackResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ModEmotionPackResponse.BaseResponse)
}

// -------------------------------------------------------------------

// PreparePurchaseRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool PreparePurchaseRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PreparePurchaseRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PreparePurchaseRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PreparePurchaseRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& PreparePurchaseRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* PreparePurchaseRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* PreparePurchaseRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void PreparePurchaseRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseRequest.BaseRequest)
}

// optional string ProductID = 2;
inline bool PreparePurchaseRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreparePurchaseRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreparePurchaseRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreparePurchaseRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& PreparePurchaseRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseRequest.ProductID)
  return productid_.GetNoArena();
}
inline void PreparePurchaseRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseRequest.ProductID)
}
#if LANG_CXX11
inline void PreparePurchaseRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PreparePurchaseRequest.ProductID)
}
#endif
inline void PreparePurchaseRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PreparePurchaseRequest.ProductID)
}
inline void PreparePurchaseRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PreparePurchaseRequest.ProductID)
}
inline ::std::string* PreparePurchaseRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreparePurchaseRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreparePurchaseRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseRequest.ProductID)
}

// optional string Price = 3;
inline bool PreparePurchaseRequest::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreparePurchaseRequest::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreparePurchaseRequest::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreparePurchaseRequest::clear_price() {
  price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_price();
}
inline const ::std::string& PreparePurchaseRequest::price() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseRequest.Price)
  return price_.GetNoArena();
}
inline void PreparePurchaseRequest::set_price(const ::std::string& value) {
  set_has_price();
  price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseRequest.Price)
}
#if LANG_CXX11
inline void PreparePurchaseRequest::set_price(::std::string&& value) {
  set_has_price();
  price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PreparePurchaseRequest.Price)
}
#endif
inline void PreparePurchaseRequest::set_price(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_price();
  price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PreparePurchaseRequest.Price)
}
inline void PreparePurchaseRequest::set_price(const char* value, size_t size) {
  set_has_price();
  price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PreparePurchaseRequest.Price)
}
inline ::std::string* PreparePurchaseRequest::mutable_price() {
  set_has_price();
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseRequest.Price)
  return price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreparePurchaseRequest::release_price() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseRequest.Price)
  clear_has_price();
  return price_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreparePurchaseRequest::set_allocated_price(::std::string* price) {
  if (price != NULL) {
    set_has_price();
  } else {
    clear_has_price();
  }
  price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), price);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseRequest.Price)
}

// optional string CurrencyType = 4;
inline bool PreparePurchaseRequest::has_currencytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PreparePurchaseRequest::set_has_currencytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PreparePurchaseRequest::clear_has_currencytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PreparePurchaseRequest::clear_currencytype() {
  currencytype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_currencytype();
}
inline const ::std::string& PreparePurchaseRequest::currencytype() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseRequest.CurrencyType)
  return currencytype_.GetNoArena();
}
inline void PreparePurchaseRequest::set_currencytype(const ::std::string& value) {
  set_has_currencytype();
  currencytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseRequest.CurrencyType)
}
#if LANG_CXX11
inline void PreparePurchaseRequest::set_currencytype(::std::string&& value) {
  set_has_currencytype();
  currencytype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PreparePurchaseRequest.CurrencyType)
}
#endif
inline void PreparePurchaseRequest::set_currencytype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_currencytype();
  currencytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PreparePurchaseRequest.CurrencyType)
}
inline void PreparePurchaseRequest::set_currencytype(const char* value, size_t size) {
  set_has_currencytype();
  currencytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PreparePurchaseRequest.CurrencyType)
}
inline ::std::string* PreparePurchaseRequest::mutable_currencytype() {
  set_has_currencytype();
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseRequest.CurrencyType)
  return currencytype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreparePurchaseRequest::release_currencytype() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseRequest.CurrencyType)
  clear_has_currencytype();
  return currencytype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreparePurchaseRequest::set_allocated_currencytype(::std::string* currencytype) {
  if (currencytype != NULL) {
    set_has_currencytype();
  } else {
    clear_has_currencytype();
  }
  currencytype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), currencytype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseRequest.CurrencyType)
}

// required uint32 PayType = 5;
inline bool PreparePurchaseRequest::has_paytype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PreparePurchaseRequest::set_has_paytype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PreparePurchaseRequest::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PreparePurchaseRequest::clear_paytype() {
  paytype_ = 0u;
  clear_has_paytype();
}
inline ::google::protobuf::uint32 PreparePurchaseRequest::paytype() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseRequest.PayType)
  return paytype_;
}
inline void PreparePurchaseRequest::set_paytype(::google::protobuf::uint32 value) {
  set_has_paytype();
  paytype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseRequest.PayType)
}

// optional string ExtInfo = 7;
inline bool PreparePurchaseRequest::has_extinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PreparePurchaseRequest::set_has_extinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PreparePurchaseRequest::clear_has_extinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PreparePurchaseRequest::clear_extinfo() {
  extinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extinfo();
}
inline const ::std::string& PreparePurchaseRequest::extinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseRequest.ExtInfo)
  return extinfo_.GetNoArena();
}
inline void PreparePurchaseRequest::set_extinfo(const ::std::string& value) {
  set_has_extinfo();
  extinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseRequest.ExtInfo)
}
#if LANG_CXX11
inline void PreparePurchaseRequest::set_extinfo(::std::string&& value) {
  set_has_extinfo();
  extinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PreparePurchaseRequest.ExtInfo)
}
#endif
inline void PreparePurchaseRequest::set_extinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extinfo();
  extinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PreparePurchaseRequest.ExtInfo)
}
inline void PreparePurchaseRequest::set_extinfo(const char* value, size_t size) {
  set_has_extinfo();
  extinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PreparePurchaseRequest.ExtInfo)
}
inline ::std::string* PreparePurchaseRequest::mutable_extinfo() {
  set_has_extinfo();
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseRequest.ExtInfo)
  return extinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreparePurchaseRequest::release_extinfo() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseRequest.ExtInfo)
  clear_has_extinfo();
  return extinfo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreparePurchaseRequest::set_allocated_extinfo(::std::string* extinfo) {
  if (extinfo != NULL) {
    set_has_extinfo();
  } else {
    clear_has_extinfo();
  }
  extinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extinfo);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseRequest.ExtInfo)
}

// optional uint32 Quantity = 8;
inline bool PreparePurchaseRequest::has_quantity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PreparePurchaseRequest::set_has_quantity() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PreparePurchaseRequest::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PreparePurchaseRequest::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 PreparePurchaseRequest::quantity() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseRequest.Quantity)
  return quantity_;
}
inline void PreparePurchaseRequest::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseRequest.Quantity)
}

// -------------------------------------------------------------------

// PreparePurchaseResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool PreparePurchaseResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PreparePurchaseResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PreparePurchaseResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PreparePurchaseResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& PreparePurchaseResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* PreparePurchaseResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* PreparePurchaseResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void PreparePurchaseResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseResponse.BaseResponse)
}

// optional string BillNo = 2;
inline bool PreparePurchaseResponse::has_billno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreparePurchaseResponse::set_has_billno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreparePurchaseResponse::clear_has_billno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreparePurchaseResponse::clear_billno() {
  billno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_billno();
}
inline const ::std::string& PreparePurchaseResponse::billno() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseResponse.BillNo)
  return billno_.GetNoArena();
}
inline void PreparePurchaseResponse::set_billno(const ::std::string& value) {
  set_has_billno();
  billno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseResponse.BillNo)
}
#if LANG_CXX11
inline void PreparePurchaseResponse::set_billno(::std::string&& value) {
  set_has_billno();
  billno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PreparePurchaseResponse.BillNo)
}
#endif
inline void PreparePurchaseResponse::set_billno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_billno();
  billno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PreparePurchaseResponse.BillNo)
}
inline void PreparePurchaseResponse::set_billno(const char* value, size_t size) {
  set_has_billno();
  billno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PreparePurchaseResponse.BillNo)
}
inline ::std::string* PreparePurchaseResponse::mutable_billno() {
  set_has_billno();
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseResponse.BillNo)
  return billno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreparePurchaseResponse::release_billno() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseResponse.BillNo)
  clear_has_billno();
  return billno_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreparePurchaseResponse::set_allocated_billno(::std::string* billno) {
  if (billno != NULL) {
    set_has_billno();
  } else {
    clear_has_billno();
  }
  billno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), billno);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseResponse.BillNo)
}

// optional string TradeToken4TenPay = 3;
inline bool PreparePurchaseResponse::has_tradetoken4tenpay() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreparePurchaseResponse::set_has_tradetoken4tenpay() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreparePurchaseResponse::clear_has_tradetoken4tenpay() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreparePurchaseResponse::clear_tradetoken4tenpay() {
  tradetoken4tenpay_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tradetoken4tenpay();
}
inline const ::std::string& PreparePurchaseResponse::tradetoken4tenpay() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseResponse.TradeToken4TenPay)
  return tradetoken4tenpay_.GetNoArena();
}
inline void PreparePurchaseResponse::set_tradetoken4tenpay(const ::std::string& value) {
  set_has_tradetoken4tenpay();
  tradetoken4tenpay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseResponse.TradeToken4TenPay)
}
#if LANG_CXX11
inline void PreparePurchaseResponse::set_tradetoken4tenpay(::std::string&& value) {
  set_has_tradetoken4tenpay();
  tradetoken4tenpay_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PreparePurchaseResponse.TradeToken4TenPay)
}
#endif
inline void PreparePurchaseResponse::set_tradetoken4tenpay(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tradetoken4tenpay();
  tradetoken4tenpay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PreparePurchaseResponse.TradeToken4TenPay)
}
inline void PreparePurchaseResponse::set_tradetoken4tenpay(const char* value, size_t size) {
  set_has_tradetoken4tenpay();
  tradetoken4tenpay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PreparePurchaseResponse.TradeToken4TenPay)
}
inline ::std::string* PreparePurchaseResponse::mutable_tradetoken4tenpay() {
  set_has_tradetoken4tenpay();
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseResponse.TradeToken4TenPay)
  return tradetoken4tenpay_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreparePurchaseResponse::release_tradetoken4tenpay() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseResponse.TradeToken4TenPay)
  clear_has_tradetoken4tenpay();
  return tradetoken4tenpay_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreparePurchaseResponse::set_allocated_tradetoken4tenpay(::std::string* tradetoken4tenpay) {
  if (tradetoken4tenpay != NULL) {
    set_has_tradetoken4tenpay();
  } else {
    clear_has_tradetoken4tenpay();
  }
  tradetoken4tenpay_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tradetoken4tenpay);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseResponse.TradeToken4TenPay)
}

// optional string Partner4TenPay = 4;
inline bool PreparePurchaseResponse::has_partner4tenpay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PreparePurchaseResponse::set_has_partner4tenpay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PreparePurchaseResponse::clear_has_partner4tenpay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PreparePurchaseResponse::clear_partner4tenpay() {
  partner4tenpay_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_partner4tenpay();
}
inline const ::std::string& PreparePurchaseResponse::partner4tenpay() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseResponse.Partner4TenPay)
  return partner4tenpay_.GetNoArena();
}
inline void PreparePurchaseResponse::set_partner4tenpay(const ::std::string& value) {
  set_has_partner4tenpay();
  partner4tenpay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseResponse.Partner4TenPay)
}
#if LANG_CXX11
inline void PreparePurchaseResponse::set_partner4tenpay(::std::string&& value) {
  set_has_partner4tenpay();
  partner4tenpay_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PreparePurchaseResponse.Partner4TenPay)
}
#endif
inline void PreparePurchaseResponse::set_partner4tenpay(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_partner4tenpay();
  partner4tenpay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PreparePurchaseResponse.Partner4TenPay)
}
inline void PreparePurchaseResponse::set_partner4tenpay(const char* value, size_t size) {
  set_has_partner4tenpay();
  partner4tenpay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PreparePurchaseResponse.Partner4TenPay)
}
inline ::std::string* PreparePurchaseResponse::mutable_partner4tenpay() {
  set_has_partner4tenpay();
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseResponse.Partner4TenPay)
  return partner4tenpay_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreparePurchaseResponse::release_partner4tenpay() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseResponse.Partner4TenPay)
  clear_has_partner4tenpay();
  return partner4tenpay_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreparePurchaseResponse::set_allocated_partner4tenpay(::std::string* partner4tenpay) {
  if (partner4tenpay != NULL) {
    set_has_partner4tenpay();
  } else {
    clear_has_partner4tenpay();
  }
  partner4tenpay_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partner4tenpay);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseResponse.Partner4TenPay)
}

// optional string Sign4TenPay = 5;
inline bool PreparePurchaseResponse::has_sign4tenpay() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PreparePurchaseResponse::set_has_sign4tenpay() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PreparePurchaseResponse::clear_has_sign4tenpay() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PreparePurchaseResponse::clear_sign4tenpay() {
  sign4tenpay_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sign4tenpay();
}
inline const ::std::string& PreparePurchaseResponse::sign4tenpay() const {
  // @@protoc_insertion_point(field_get:micromsg.PreparePurchaseResponse.Sign4TenPay)
  return sign4tenpay_.GetNoArena();
}
inline void PreparePurchaseResponse::set_sign4tenpay(const ::std::string& value) {
  set_has_sign4tenpay();
  sign4tenpay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PreparePurchaseResponse.Sign4TenPay)
}
#if LANG_CXX11
inline void PreparePurchaseResponse::set_sign4tenpay(::std::string&& value) {
  set_has_sign4tenpay();
  sign4tenpay_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PreparePurchaseResponse.Sign4TenPay)
}
#endif
inline void PreparePurchaseResponse::set_sign4tenpay(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sign4tenpay();
  sign4tenpay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PreparePurchaseResponse.Sign4TenPay)
}
inline void PreparePurchaseResponse::set_sign4tenpay(const char* value, size_t size) {
  set_has_sign4tenpay();
  sign4tenpay_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PreparePurchaseResponse.Sign4TenPay)
}
inline ::std::string* PreparePurchaseResponse::mutable_sign4tenpay() {
  set_has_sign4tenpay();
  // @@protoc_insertion_point(field_mutable:micromsg.PreparePurchaseResponse.Sign4TenPay)
  return sign4tenpay_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreparePurchaseResponse::release_sign4tenpay() {
  // @@protoc_insertion_point(field_release:micromsg.PreparePurchaseResponse.Sign4TenPay)
  clear_has_sign4tenpay();
  return sign4tenpay_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreparePurchaseResponse::set_allocated_sign4tenpay(::std::string* sign4tenpay) {
  if (sign4tenpay != NULL) {
    set_has_sign4tenpay();
  } else {
    clear_has_sign4tenpay();
  }
  sign4tenpay_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign4tenpay);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PreparePurchaseResponse.Sign4TenPay)
}

// -------------------------------------------------------------------

// ExchangeEmotionPackRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool ExchangeEmotionPackRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExchangeEmotionPackRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExchangeEmotionPackRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExchangeEmotionPackRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& ExchangeEmotionPackRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.ExchangeEmotionPackRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* ExchangeEmotionPackRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ExchangeEmotionPackRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* ExchangeEmotionPackRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.ExchangeEmotionPackRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void ExchangeEmotionPackRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ExchangeEmotionPackRequest.BaseRequest)
}

// optional string ProductID = 2;
inline bool ExchangeEmotionPackRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeEmotionPackRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeEmotionPackRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeEmotionPackRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& ExchangeEmotionPackRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.ExchangeEmotionPackRequest.ProductID)
  return productid_.GetNoArena();
}
inline void ExchangeEmotionPackRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ExchangeEmotionPackRequest.ProductID)
}
#if LANG_CXX11
inline void ExchangeEmotionPackRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ExchangeEmotionPackRequest.ProductID)
}
#endif
inline void ExchangeEmotionPackRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ExchangeEmotionPackRequest.ProductID)
}
inline void ExchangeEmotionPackRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ExchangeEmotionPackRequest.ProductID)
}
inline ::std::string* ExchangeEmotionPackRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.ExchangeEmotionPackRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExchangeEmotionPackRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.ExchangeEmotionPackRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExchangeEmotionPackRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ExchangeEmotionPackRequest.ProductID)
}

// optional string SeriesID = 3;
inline bool ExchangeEmotionPackRequest::has_seriesid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeEmotionPackRequest::set_has_seriesid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeEmotionPackRequest::clear_has_seriesid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeEmotionPackRequest::clear_seriesid() {
  seriesid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_seriesid();
}
inline const ::std::string& ExchangeEmotionPackRequest::seriesid() const {
  // @@protoc_insertion_point(field_get:micromsg.ExchangeEmotionPackRequest.SeriesID)
  return seriesid_.GetNoArena();
}
inline void ExchangeEmotionPackRequest::set_seriesid(const ::std::string& value) {
  set_has_seriesid();
  seriesid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ExchangeEmotionPackRequest.SeriesID)
}
#if LANG_CXX11
inline void ExchangeEmotionPackRequest::set_seriesid(::std::string&& value) {
  set_has_seriesid();
  seriesid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ExchangeEmotionPackRequest.SeriesID)
}
#endif
inline void ExchangeEmotionPackRequest::set_seriesid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_seriesid();
  seriesid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ExchangeEmotionPackRequest.SeriesID)
}
inline void ExchangeEmotionPackRequest::set_seriesid(const char* value, size_t size) {
  set_has_seriesid();
  seriesid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ExchangeEmotionPackRequest.SeriesID)
}
inline ::std::string* ExchangeEmotionPackRequest::mutable_seriesid() {
  set_has_seriesid();
  // @@protoc_insertion_point(field_mutable:micromsg.ExchangeEmotionPackRequest.SeriesID)
  return seriesid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExchangeEmotionPackRequest::release_seriesid() {
  // @@protoc_insertion_point(field_release:micromsg.ExchangeEmotionPackRequest.SeriesID)
  clear_has_seriesid();
  return seriesid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExchangeEmotionPackRequest::set_allocated_seriesid(::std::string* seriesid) {
  if (seriesid != NULL) {
    set_has_seriesid();
  } else {
    clear_has_seriesid();
  }
  seriesid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), seriesid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ExchangeEmotionPackRequest.SeriesID)
}

// -------------------------------------------------------------------

// ExchangeEmotionPackResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool ExchangeEmotionPackResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExchangeEmotionPackResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExchangeEmotionPackResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExchangeEmotionPackResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& ExchangeEmotionPackResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.ExchangeEmotionPackResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* ExchangeEmotionPackResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ExchangeEmotionPackResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* ExchangeEmotionPackResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.ExchangeEmotionPackResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void ExchangeEmotionPackResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ExchangeEmotionPackResponse.BaseResponse)
}

// required .micromsg.EmotionCDNUrl DownloadInfo = 2;
inline bool ExchangeEmotionPackResponse::has_downloadinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExchangeEmotionPackResponse::set_has_downloadinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExchangeEmotionPackResponse::clear_has_downloadinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExchangeEmotionPackResponse::clear_downloadinfo() {
  if (downloadinfo_ != NULL) downloadinfo_->::micromsg::EmotionCDNUrl::Clear();
  clear_has_downloadinfo();
}
inline const ::micromsg::EmotionCDNUrl& ExchangeEmotionPackResponse::downloadinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.ExchangeEmotionPackResponse.DownloadInfo)
  return downloadinfo_ != NULL ? *downloadinfo_
                         : *::micromsg::EmotionCDNUrl::internal_default_instance();
}
inline ::micromsg::EmotionCDNUrl* ExchangeEmotionPackResponse::mutable_downloadinfo() {
  set_has_downloadinfo();
  if (downloadinfo_ == NULL) {
    downloadinfo_ = new ::micromsg::EmotionCDNUrl;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ExchangeEmotionPackResponse.DownloadInfo)
  return downloadinfo_;
}
inline ::micromsg::EmotionCDNUrl* ExchangeEmotionPackResponse::release_downloadinfo() {
  // @@protoc_insertion_point(field_release:micromsg.ExchangeEmotionPackResponse.DownloadInfo)
  clear_has_downloadinfo();
  ::micromsg::EmotionCDNUrl* temp = downloadinfo_;
  downloadinfo_ = NULL;
  return temp;
}
inline void ExchangeEmotionPackResponse::set_allocated_downloadinfo(::micromsg::EmotionCDNUrl* downloadinfo) {
  delete downloadinfo_;
  downloadinfo_ = downloadinfo;
  if (downloadinfo) {
    set_has_downloadinfo();
  } else {
    clear_has_downloadinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ExchangeEmotionPackResponse.DownloadInfo)
}

// -------------------------------------------------------------------

// CancelPurchaseRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool CancelPurchaseRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CancelPurchaseRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CancelPurchaseRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CancelPurchaseRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& CancelPurchaseRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* CancelPurchaseRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.CancelPurchaseRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* CancelPurchaseRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.CancelPurchaseRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void CancelPurchaseRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.CancelPurchaseRequest.BaseRequest)
}

// optional string ProductID = 2;
inline bool CancelPurchaseRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelPurchaseRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelPurchaseRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelPurchaseRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& CancelPurchaseRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.ProductID)
  return productid_.GetNoArena();
}
inline void CancelPurchaseRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.CancelPurchaseRequest.ProductID)
}
#if LANG_CXX11
inline void CancelPurchaseRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.CancelPurchaseRequest.ProductID)
}
#endif
inline void CancelPurchaseRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.CancelPurchaseRequest.ProductID)
}
inline void CancelPurchaseRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.CancelPurchaseRequest.ProductID)
}
inline ::std::string* CancelPurchaseRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.CancelPurchaseRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelPurchaseRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.CancelPurchaseRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelPurchaseRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.CancelPurchaseRequest.ProductID)
}

// required uint32 VerifyType = 3;
inline bool CancelPurchaseRequest::has_verifytype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CancelPurchaseRequest::set_has_verifytype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CancelPurchaseRequest::clear_has_verifytype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CancelPurchaseRequest::clear_verifytype() {
  verifytype_ = 0u;
  clear_has_verifytype();
}
inline ::google::protobuf::uint32 CancelPurchaseRequest::verifytype() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.VerifyType)
  return verifytype_;
}
inline void CancelPurchaseRequest::set_verifytype(::google::protobuf::uint32 value) {
  set_has_verifytype();
  verifytype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.CancelPurchaseRequest.VerifyType)
}

// required uint32 PayType = 4;
inline bool CancelPurchaseRequest::has_paytype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CancelPurchaseRequest::set_has_paytype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CancelPurchaseRequest::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CancelPurchaseRequest::clear_paytype() {
  paytype_ = 0u;
  clear_has_paytype();
}
inline ::google::protobuf::uint32 CancelPurchaseRequest::paytype() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.PayType)
  return paytype_;
}
inline void CancelPurchaseRequest::set_paytype(::google::protobuf::uint32 value) {
  set_has_paytype();
  paytype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.CancelPurchaseRequest.PayType)
}

// optional string Price = 5;
inline bool CancelPurchaseRequest::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CancelPurchaseRequest::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CancelPurchaseRequest::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CancelPurchaseRequest::clear_price() {
  price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_price();
}
inline const ::std::string& CancelPurchaseRequest::price() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.Price)
  return price_.GetNoArena();
}
inline void CancelPurchaseRequest::set_price(const ::std::string& value) {
  set_has_price();
  price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.CancelPurchaseRequest.Price)
}
#if LANG_CXX11
inline void CancelPurchaseRequest::set_price(::std::string&& value) {
  set_has_price();
  price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.CancelPurchaseRequest.Price)
}
#endif
inline void CancelPurchaseRequest::set_price(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_price();
  price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.CancelPurchaseRequest.Price)
}
inline void CancelPurchaseRequest::set_price(const char* value, size_t size) {
  set_has_price();
  price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.CancelPurchaseRequest.Price)
}
inline ::std::string* CancelPurchaseRequest::mutable_price() {
  set_has_price();
  // @@protoc_insertion_point(field_mutable:micromsg.CancelPurchaseRequest.Price)
  return price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelPurchaseRequest::release_price() {
  // @@protoc_insertion_point(field_release:micromsg.CancelPurchaseRequest.Price)
  clear_has_price();
  return price_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelPurchaseRequest::set_allocated_price(::std::string* price) {
  if (price != NULL) {
    set_has_price();
  } else {
    clear_has_price();
  }
  price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), price);
  // @@protoc_insertion_point(field_set_allocated:micromsg.CancelPurchaseRequest.Price)
}

// optional string CurrencyType = 6;
inline bool CancelPurchaseRequest::has_currencytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CancelPurchaseRequest::set_has_currencytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CancelPurchaseRequest::clear_has_currencytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CancelPurchaseRequest::clear_currencytype() {
  currencytype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_currencytype();
}
inline const ::std::string& CancelPurchaseRequest::currencytype() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.CurrencyType)
  return currencytype_.GetNoArena();
}
inline void CancelPurchaseRequest::set_currencytype(const ::std::string& value) {
  set_has_currencytype();
  currencytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.CancelPurchaseRequest.CurrencyType)
}
#if LANG_CXX11
inline void CancelPurchaseRequest::set_currencytype(::std::string&& value) {
  set_has_currencytype();
  currencytype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.CancelPurchaseRequest.CurrencyType)
}
#endif
inline void CancelPurchaseRequest::set_currencytype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_currencytype();
  currencytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.CancelPurchaseRequest.CurrencyType)
}
inline void CancelPurchaseRequest::set_currencytype(const char* value, size_t size) {
  set_has_currencytype();
  currencytype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.CancelPurchaseRequest.CurrencyType)
}
inline ::std::string* CancelPurchaseRequest::mutable_currencytype() {
  set_has_currencytype();
  // @@protoc_insertion_point(field_mutable:micromsg.CancelPurchaseRequest.CurrencyType)
  return currencytype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelPurchaseRequest::release_currencytype() {
  // @@protoc_insertion_point(field_release:micromsg.CancelPurchaseRequest.CurrencyType)
  clear_has_currencytype();
  return currencytype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelPurchaseRequest::set_allocated_currencytype(::std::string* currencytype) {
  if (currencytype != NULL) {
    set_has_currencytype();
  } else {
    clear_has_currencytype();
  }
  currencytype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), currencytype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.CancelPurchaseRequest.CurrencyType)
}

// optional string BillNo = 7;
inline bool CancelPurchaseRequest::has_billno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CancelPurchaseRequest::set_has_billno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CancelPurchaseRequest::clear_has_billno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CancelPurchaseRequest::clear_billno() {
  billno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_billno();
}
inline const ::std::string& CancelPurchaseRequest::billno() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.BillNo)
  return billno_.GetNoArena();
}
inline void CancelPurchaseRequest::set_billno(const ::std::string& value) {
  set_has_billno();
  billno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.CancelPurchaseRequest.BillNo)
}
#if LANG_CXX11
inline void CancelPurchaseRequest::set_billno(::std::string&& value) {
  set_has_billno();
  billno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.CancelPurchaseRequest.BillNo)
}
#endif
inline void CancelPurchaseRequest::set_billno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_billno();
  billno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.CancelPurchaseRequest.BillNo)
}
inline void CancelPurchaseRequest::set_billno(const char* value, size_t size) {
  set_has_billno();
  billno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.CancelPurchaseRequest.BillNo)
}
inline ::std::string* CancelPurchaseRequest::mutable_billno() {
  set_has_billno();
  // @@protoc_insertion_point(field_mutable:micromsg.CancelPurchaseRequest.BillNo)
  return billno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelPurchaseRequest::release_billno() {
  // @@protoc_insertion_point(field_release:micromsg.CancelPurchaseRequest.BillNo)
  clear_has_billno();
  return billno_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelPurchaseRequest::set_allocated_billno(::std::string* billno) {
  if (billno != NULL) {
    set_has_billno();
  } else {
    clear_has_billno();
  }
  billno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), billno);
  // @@protoc_insertion_point(field_set_allocated:micromsg.CancelPurchaseRequest.BillNo)
}

// required uint32 PayTime = 8;
inline bool CancelPurchaseRequest::has_paytime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CancelPurchaseRequest::set_has_paytime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CancelPurchaseRequest::clear_has_paytime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CancelPurchaseRequest::clear_paytime() {
  paytime_ = 0u;
  clear_has_paytime();
}
inline ::google::protobuf::uint32 CancelPurchaseRequest::paytime() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.PayTime)
  return paytime_;
}
inline void CancelPurchaseRequest::set_paytime(::google::protobuf::uint32 value) {
  set_has_paytime();
  paytime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.CancelPurchaseRequest.PayTime)
}

// required int32 ErrorCode = 9;
inline bool CancelPurchaseRequest::has_errorcode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CancelPurchaseRequest::set_has_errorcode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CancelPurchaseRequest::clear_has_errorcode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CancelPurchaseRequest::clear_errorcode() {
  errorcode_ = 0;
  clear_has_errorcode();
}
inline ::google::protobuf::int32 CancelPurchaseRequest::errorcode() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.ErrorCode)
  return errorcode_;
}
inline void CancelPurchaseRequest::set_errorcode(::google::protobuf::int32 value) {
  set_has_errorcode();
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.CancelPurchaseRequest.ErrorCode)
}

// optional string ErrorDescription = 10;
inline bool CancelPurchaseRequest::has_errordescription() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CancelPurchaseRequest::set_has_errordescription() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CancelPurchaseRequest::clear_has_errordescription() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CancelPurchaseRequest::clear_errordescription() {
  errordescription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errordescription();
}
inline const ::std::string& CancelPurchaseRequest::errordescription() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseRequest.ErrorDescription)
  return errordescription_.GetNoArena();
}
inline void CancelPurchaseRequest::set_errordescription(const ::std::string& value) {
  set_has_errordescription();
  errordescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.CancelPurchaseRequest.ErrorDescription)
}
#if LANG_CXX11
inline void CancelPurchaseRequest::set_errordescription(::std::string&& value) {
  set_has_errordescription();
  errordescription_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.CancelPurchaseRequest.ErrorDescription)
}
#endif
inline void CancelPurchaseRequest::set_errordescription(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errordescription();
  errordescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.CancelPurchaseRequest.ErrorDescription)
}
inline void CancelPurchaseRequest::set_errordescription(const char* value, size_t size) {
  set_has_errordescription();
  errordescription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.CancelPurchaseRequest.ErrorDescription)
}
inline ::std::string* CancelPurchaseRequest::mutable_errordescription() {
  set_has_errordescription();
  // @@protoc_insertion_point(field_mutable:micromsg.CancelPurchaseRequest.ErrorDescription)
  return errordescription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelPurchaseRequest::release_errordescription() {
  // @@protoc_insertion_point(field_release:micromsg.CancelPurchaseRequest.ErrorDescription)
  clear_has_errordescription();
  return errordescription_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelPurchaseRequest::set_allocated_errordescription(::std::string* errordescription) {
  if (errordescription != NULL) {
    set_has_errordescription();
  } else {
    clear_has_errordescription();
  }
  errordescription_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errordescription);
  // @@protoc_insertion_point(field_set_allocated:micromsg.CancelPurchaseRequest.ErrorDescription)
}

// -------------------------------------------------------------------

// CancelPurchaseResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool CancelPurchaseResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelPurchaseResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelPurchaseResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelPurchaseResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& CancelPurchaseResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.CancelPurchaseResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* CancelPurchaseResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.CancelPurchaseResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* CancelPurchaseResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.CancelPurchaseResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void CancelPurchaseResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.CancelPurchaseResponse.BaseResponse)
}

// -------------------------------------------------------------------

// EmotionMember

// optional string UserName = 1;
inline bool EmotionMember::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionMember::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionMember::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionMember::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& EmotionMember::username() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionMember.UserName)
  return username_.GetNoArena();
}
inline void EmotionMember::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionMember.UserName)
}
#if LANG_CXX11
inline void EmotionMember::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionMember.UserName)
}
#endif
inline void EmotionMember::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionMember.UserName)
}
inline void EmotionMember::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionMember.UserName)
}
inline ::std::string* EmotionMember::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionMember.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionMember::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionMember.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionMember::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionMember.UserName)
}

// -------------------------------------------------------------------

// MemberStatus

// optional string UserName = 1;
inline bool MemberStatus::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemberStatus::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemberStatus::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemberStatus::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& MemberStatus::username() const {
  // @@protoc_insertion_point(field_get:micromsg.MemberStatus.UserName)
  return username_.GetNoArena();
}
inline void MemberStatus::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.MemberStatus.UserName)
}
#if LANG_CXX11
inline void MemberStatus::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.MemberStatus.UserName)
}
#endif
inline void MemberStatus::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.MemberStatus.UserName)
}
inline void MemberStatus::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.MemberStatus.UserName)
}
inline ::std::string* MemberStatus::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.MemberStatus.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MemberStatus::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.MemberStatus.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MemberStatus::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.MemberStatus.UserName)
}

// required int32 Status = 2;
inline bool MemberStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemberStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemberStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemberStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 MemberStatus::status() const {
  // @@protoc_insertion_point(field_get:micromsg.MemberStatus.Status)
  return status_;
}
inline void MemberStatus::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:micromsg.MemberStatus.Status)
}

// -------------------------------------------------------------------

// VerifyEmotionPresentationRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool VerifyEmotionPresentationRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyEmotionPresentationRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyEmotionPresentationRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyEmotionPresentationRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& VerifyEmotionPresentationRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyEmotionPresentationRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* VerifyEmotionPresentationRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyEmotionPresentationRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* VerifyEmotionPresentationRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyEmotionPresentationRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void VerifyEmotionPresentationRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyEmotionPresentationRequest.BaseRequest)
}

// optional string ProductID = 2;
inline bool VerifyEmotionPresentationRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyEmotionPresentationRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyEmotionPresentationRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyEmotionPresentationRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& VerifyEmotionPresentationRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyEmotionPresentationRequest.ProductID)
  return productid_.GetNoArena();
}
inline void VerifyEmotionPresentationRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyEmotionPresentationRequest.ProductID)
}
#if LANG_CXX11
inline void VerifyEmotionPresentationRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyEmotionPresentationRequest.ProductID)
}
#endif
inline void VerifyEmotionPresentationRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyEmotionPresentationRequest.ProductID)
}
inline void VerifyEmotionPresentationRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyEmotionPresentationRequest.ProductID)
}
inline ::std::string* VerifyEmotionPresentationRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyEmotionPresentationRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyEmotionPresentationRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyEmotionPresentationRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyEmotionPresentationRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyEmotionPresentationRequest.ProductID)
}

// required uint32 MemberCount = 3;
inline bool VerifyEmotionPresentationRequest::has_membercount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyEmotionPresentationRequest::set_has_membercount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyEmotionPresentationRequest::clear_has_membercount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyEmotionPresentationRequest::clear_membercount() {
  membercount_ = 0u;
  clear_has_membercount();
}
inline ::google::protobuf::uint32 VerifyEmotionPresentationRequest::membercount() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyEmotionPresentationRequest.MemberCount)
  return membercount_;
}
inline void VerifyEmotionPresentationRequest::set_membercount(::google::protobuf::uint32 value) {
  set_has_membercount();
  membercount_ = value;
  // @@protoc_insertion_point(field_set:micromsg.VerifyEmotionPresentationRequest.MemberCount)
}

// repeated .micromsg.EmotionMember MemberList = 4;
inline int VerifyEmotionPresentationRequest::memberlist_size() const {
  return memberlist_.size();
}
inline void VerifyEmotionPresentationRequest::clear_memberlist() {
  memberlist_.Clear();
}
inline const ::micromsg::EmotionMember& VerifyEmotionPresentationRequest::memberlist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyEmotionPresentationRequest.MemberList)
  return memberlist_.Get(index);
}
inline ::micromsg::EmotionMember* VerifyEmotionPresentationRequest::mutable_memberlist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyEmotionPresentationRequest.MemberList)
  return memberlist_.Mutable(index);
}
inline ::micromsg::EmotionMember* VerifyEmotionPresentationRequest::add_memberlist() {
  // @@protoc_insertion_point(field_add:micromsg.VerifyEmotionPresentationRequest.MemberList)
  return memberlist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionMember >*
VerifyEmotionPresentationRequest::mutable_memberlist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.VerifyEmotionPresentationRequest.MemberList)
  return &memberlist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionMember >&
VerifyEmotionPresentationRequest::memberlist() const {
  // @@protoc_insertion_point(field_list:micromsg.VerifyEmotionPresentationRequest.MemberList)
  return memberlist_;
}

// -------------------------------------------------------------------

// VerifyEmotionPresentationResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool VerifyEmotionPresentationResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyEmotionPresentationResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyEmotionPresentationResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyEmotionPresentationResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& VerifyEmotionPresentationResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyEmotionPresentationResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* VerifyEmotionPresentationResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyEmotionPresentationResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* VerifyEmotionPresentationResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyEmotionPresentationResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void VerifyEmotionPresentationResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyEmotionPresentationResponse.BaseResponse)
}

// required uint32 MemberCount = 2;
inline bool VerifyEmotionPresentationResponse::has_membercount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyEmotionPresentationResponse::set_has_membercount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyEmotionPresentationResponse::clear_has_membercount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyEmotionPresentationResponse::clear_membercount() {
  membercount_ = 0u;
  clear_has_membercount();
}
inline ::google::protobuf::uint32 VerifyEmotionPresentationResponse::membercount() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyEmotionPresentationResponse.MemberCount)
  return membercount_;
}
inline void VerifyEmotionPresentationResponse::set_membercount(::google::protobuf::uint32 value) {
  set_has_membercount();
  membercount_ = value;
  // @@protoc_insertion_point(field_set:micromsg.VerifyEmotionPresentationResponse.MemberCount)
}

// repeated .micromsg.MemberStatus StatusList = 3;
inline int VerifyEmotionPresentationResponse::statuslist_size() const {
  return statuslist_.size();
}
inline void VerifyEmotionPresentationResponse::clear_statuslist() {
  statuslist_.Clear();
}
inline const ::micromsg::MemberStatus& VerifyEmotionPresentationResponse::statuslist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyEmotionPresentationResponse.StatusList)
  return statuslist_.Get(index);
}
inline ::micromsg::MemberStatus* VerifyEmotionPresentationResponse::mutable_statuslist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyEmotionPresentationResponse.StatusList)
  return statuslist_.Mutable(index);
}
inline ::micromsg::MemberStatus* VerifyEmotionPresentationResponse::add_statuslist() {
  // @@protoc_insertion_point(field_add:micromsg.VerifyEmotionPresentationResponse.StatusList)
  return statuslist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::MemberStatus >*
VerifyEmotionPresentationResponse::mutable_statuslist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.VerifyEmotionPresentationResponse.StatusList)
  return &statuslist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::MemberStatus >&
VerifyEmotionPresentationResponse::statuslist() const {
  // @@protoc_insertion_point(field_list:micromsg.VerifyEmotionPresentationResponse.StatusList)
  return statuslist_;
}

// -------------------------------------------------------------------

// LangDesc

// optional string Lang = 1;
inline bool LangDesc::has_lang() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LangDesc::set_has_lang() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LangDesc::clear_has_lang() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LangDesc::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lang();
}
inline const ::std::string& LangDesc::lang() const {
  // @@protoc_insertion_point(field_get:micromsg.LangDesc.Lang)
  return lang_.GetNoArena();
}
inline void LangDesc::set_lang(const ::std::string& value) {
  set_has_lang();
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LangDesc.Lang)
}
#if LANG_CXX11
inline void LangDesc::set_lang(::std::string&& value) {
  set_has_lang();
  lang_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LangDesc.Lang)
}
#endif
inline void LangDesc::set_lang(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lang();
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LangDesc.Lang)
}
inline void LangDesc::set_lang(const char* value, size_t size) {
  set_has_lang();
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LangDesc.Lang)
}
inline ::std::string* LangDesc::mutable_lang() {
  set_has_lang();
  // @@protoc_insertion_point(field_mutable:micromsg.LangDesc.Lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LangDesc::release_lang() {
  // @@protoc_insertion_point(field_release:micromsg.LangDesc.Lang)
  clear_has_lang();
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LangDesc::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    set_has_lang();
  } else {
    clear_has_lang();
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LangDesc.Lang)
}

// optional string Desc = 2;
inline bool LangDesc::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LangDesc::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LangDesc::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LangDesc::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& LangDesc::desc() const {
  // @@protoc_insertion_point(field_get:micromsg.LangDesc.Desc)
  return desc_.GetNoArena();
}
inline void LangDesc::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LangDesc.Desc)
}
#if LANG_CXX11
inline void LangDesc::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LangDesc.Desc)
}
#endif
inline void LangDesc::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LangDesc.Desc)
}
inline void LangDesc::set_desc(const char* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LangDesc.Desc)
}
inline ::std::string* LangDesc::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:micromsg.LangDesc.Desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LangDesc::release_desc() {
  // @@protoc_insertion_point(field_release:micromsg.LangDesc.Desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LangDesc::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LangDesc.Desc)
}

// -------------------------------------------------------------------

// EmotionDesc

// optional string Md5 = 1;
inline bool EmotionDesc::has_md5() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionDesc::set_has_md5() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionDesc::clear_has_md5() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionDesc::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_md5();
}
inline const ::std::string& EmotionDesc::md5() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDesc.Md5)
  return md5_.GetNoArena();
}
inline void EmotionDesc::set_md5(const ::std::string& value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDesc.Md5)
}
#if LANG_CXX11
inline void EmotionDesc::set_md5(::std::string&& value) {
  set_has_md5();
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDesc.Md5)
}
#endif
inline void EmotionDesc::set_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDesc.Md5)
}
inline void EmotionDesc::set_md5(const char* value, size_t size) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDesc.Md5)
}
inline ::std::string* EmotionDesc::mutable_md5() {
  set_has_md5();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDesc.Md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDesc::release_md5() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDesc.Md5)
  clear_has_md5();
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDesc::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    set_has_md5();
  } else {
    clear_has_md5();
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDesc.Md5)
}

// required uint32 Count = 2;
inline bool EmotionDesc::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmotionDesc::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmotionDesc::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmotionDesc::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 EmotionDesc::count() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDesc.Count)
  return count_;
}
inline void EmotionDesc::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionDesc.Count)
}

// repeated .micromsg.LangDesc List = 3;
inline int EmotionDesc::list_size() const {
  return list_.size();
}
inline void EmotionDesc::clear_list() {
  list_.Clear();
}
inline const ::micromsg::LangDesc& EmotionDesc::list(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDesc.List)
  return list_.Get(index);
}
inline ::micromsg::LangDesc* EmotionDesc::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDesc.List)
  return list_.Mutable(index);
}
inline ::micromsg::LangDesc* EmotionDesc::add_list() {
  // @@protoc_insertion_point(field_add:micromsg.EmotionDesc.List)
  return list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::LangDesc >*
EmotionDesc::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.EmotionDesc.List)
  return &list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::LangDesc >&
EmotionDesc::list() const {
  // @@protoc_insertion_point(field_list:micromsg.EmotionDesc.List)
  return list_;
}

// -------------------------------------------------------------------

// GetEmotionDescRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetEmotionDescRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionDescRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionDescRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionDescRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetEmotionDescRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDescRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetEmotionDescRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDescRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetEmotionDescRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDescRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetEmotionDescRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDescRequest.BaseRequest)
}

// optional string ProductID = 2;
inline bool GetEmotionDescRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionDescRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionDescRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionDescRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& GetEmotionDescRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDescRequest.ProductID)
  return productid_.GetNoArena();
}
inline void GetEmotionDescRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDescRequest.ProductID)
}
#if LANG_CXX11
inline void GetEmotionDescRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetEmotionDescRequest.ProductID)
}
#endif
inline void GetEmotionDescRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetEmotionDescRequest.ProductID)
}
inline void GetEmotionDescRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetEmotionDescRequest.ProductID)
}
inline ::std::string* GetEmotionDescRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDescRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetEmotionDescRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDescRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetEmotionDescRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDescRequest.ProductID)
}

// -------------------------------------------------------------------

// GetEmotionDescResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetEmotionDescResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionDescResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionDescResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionDescResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetEmotionDescResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDescResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetEmotionDescResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDescResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetEmotionDescResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDescResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetEmotionDescResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDescResponse.BaseResponse)
}

// required uint32 Count = 2;
inline bool GetEmotionDescResponse::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetEmotionDescResponse::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetEmotionDescResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetEmotionDescResponse::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetEmotionDescResponse::count() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDescResponse.Count)
  return count_;
}
inline void GetEmotionDescResponse::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDescResponse.Count)
}

// repeated .micromsg.EmotionDesc List = 3;
inline int GetEmotionDescResponse::list_size() const {
  return list_.size();
}
inline void GetEmotionDescResponse::clear_list() {
  list_.Clear();
}
inline const ::micromsg::EmotionDesc& GetEmotionDescResponse::list(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDescResponse.List)
  return list_.Get(index);
}
inline ::micromsg::EmotionDesc* GetEmotionDescResponse::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDescResponse.List)
  return list_.Mutable(index);
}
inline ::micromsg::EmotionDesc* GetEmotionDescResponse::add_list() {
  // @@protoc_insertion_point(field_add:micromsg.GetEmotionDescResponse.List)
  return list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDesc >*
GetEmotionDescResponse::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetEmotionDescResponse.List)
  return &list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDesc >&
GetEmotionDescResponse::list() const {
  // @@protoc_insertion_point(field_list:micromsg.GetEmotionDescResponse.List)
  return list_;
}

// required uint32 ClickFlag = 4;
inline bool GetEmotionDescResponse::has_clickflag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetEmotionDescResponse::set_has_clickflag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetEmotionDescResponse::clear_has_clickflag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetEmotionDescResponse::clear_clickflag() {
  clickflag_ = 0u;
  clear_has_clickflag();
}
inline ::google::protobuf::uint32 GetEmotionDescResponse::clickflag() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDescResponse.ClickFlag)
  return clickflag_;
}
inline void GetEmotionDescResponse::set_clickflag(::google::protobuf::uint32 value) {
  set_has_clickflag();
  clickflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDescResponse.ClickFlag)
}

// optional string ButtonDesc = 5;
inline bool GetEmotionDescResponse::has_buttondesc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionDescResponse::set_has_buttondesc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionDescResponse::clear_has_buttondesc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionDescResponse::clear_buttondesc() {
  buttondesc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_buttondesc();
}
inline const ::std::string& GetEmotionDescResponse::buttondesc() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDescResponse.ButtonDesc)
  return buttondesc_.GetNoArena();
}
inline void GetEmotionDescResponse::set_buttondesc(const ::std::string& value) {
  set_has_buttondesc();
  buttondesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDescResponse.ButtonDesc)
}
#if LANG_CXX11
inline void GetEmotionDescResponse::set_buttondesc(::std::string&& value) {
  set_has_buttondesc();
  buttondesc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetEmotionDescResponse.ButtonDesc)
}
#endif
inline void GetEmotionDescResponse::set_buttondesc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_buttondesc();
  buttondesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetEmotionDescResponse.ButtonDesc)
}
inline void GetEmotionDescResponse::set_buttondesc(const char* value, size_t size) {
  set_has_buttondesc();
  buttondesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetEmotionDescResponse.ButtonDesc)
}
inline ::std::string* GetEmotionDescResponse::mutable_buttondesc() {
  set_has_buttondesc();
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDescResponse.ButtonDesc)
  return buttondesc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetEmotionDescResponse::release_buttondesc() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDescResponse.ButtonDesc)
  clear_has_buttondesc();
  return buttondesc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetEmotionDescResponse::set_allocated_buttondesc(::std::string* buttondesc) {
  if (buttondesc != NULL) {
    set_has_buttondesc();
  } else {
    clear_has_buttondesc();
  }
  buttondesc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buttondesc);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDescResponse.ButtonDesc)
}

// optional uint32 DownLoadFlag = 6;
inline bool GetEmotionDescResponse::has_downloadflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetEmotionDescResponse::set_has_downloadflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetEmotionDescResponse::clear_has_downloadflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetEmotionDescResponse::clear_downloadflag() {
  downloadflag_ = 0u;
  clear_has_downloadflag();
}
inline ::google::protobuf::uint32 GetEmotionDescResponse::downloadflag() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDescResponse.DownLoadFlag)
  return downloadflag_;
}
inline void GetEmotionDescResponse::set_downloadflag(::google::protobuf::uint32 value) {
  set_has_downloadflag();
  downloadflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDescResponse.DownLoadFlag)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace micromsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mmemotion_2eproto__INCLUDED
