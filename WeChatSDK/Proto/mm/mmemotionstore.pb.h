// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmemotionstore.proto

#ifndef PROTOBUF_mmemotionstore_2eproto__INCLUDED
#define PROTOBUF_mmemotionstore_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "mmbuiltintype.pb.h"
#include "mmbase.pb.h"
#include "mmemotion.pb.h"
// @@protoc_insertion_point(includes)
namespace micromsg {
class AdditionalContactList;
class AdditionalContactListDefaultTypeInternal;
extern AdditionalContactListDefaultTypeInternal _AdditionalContactList_default_instance_;
class AskForRewardRequest;
class AskForRewardRequestDefaultTypeInternal;
extern AskForRewardRequestDefaultTypeInternal _AskForRewardRequest_default_instance_;
class AskForRewardResponse;
class AskForRewardResponseDefaultTypeInternal;
extern AskForRewardResponseDefaultTypeInternal _AskForRewardResponse_default_instance_;
class BackupEmojiOperateRequest;
class BackupEmojiOperateRequestDefaultTypeInternal;
extern BackupEmojiOperateRequestDefaultTypeInternal _BackupEmojiOperateRequest_default_instance_;
class BackupEmojiOperateResponse;
class BackupEmojiOperateResponseDefaultTypeInternal;
extern BackupEmojiOperateResponseDefaultTypeInternal _BackupEmojiOperateResponse_default_instance_;
class BaseRequest;
class BaseRequestDefaultTypeInternal;
extern BaseRequestDefaultTypeInternal _BaseRequest_default_instance_;
class BaseResponse;
class BaseResponseDefaultTypeInternal;
extern BaseResponseDefaultTypeInternal _BaseResponse_default_instance_;
class BatchEmojiBackupRequest;
class BatchEmojiBackupRequestDefaultTypeInternal;
extern BatchEmojiBackupRequestDefaultTypeInternal _BatchEmojiBackupRequest_default_instance_;
class BatchEmojiBackupResponse;
class BatchEmojiBackupResponseDefaultTypeInternal;
extern BatchEmojiBackupResponseDefaultTypeInternal _BatchEmojiBackupResponse_default_instance_;
class BatchEmojiDownLoadRequest;
class BatchEmojiDownLoadRequestDefaultTypeInternal;
extern BatchEmojiDownLoadRequestDefaultTypeInternal _BatchEmojiDownLoadRequest_default_instance_;
class BatchEmojiDownLoadResponse;
class BatchEmojiDownLoadResponseDefaultTypeInternal;
extern BatchEmojiDownLoadResponseDefaultTypeInternal _BatchEmojiDownLoadResponse_default_instance_;
class BindEmailRequest;
class BindEmailRequestDefaultTypeInternal;
extern BindEmailRequestDefaultTypeInternal _BindEmailRequest_default_instance_;
class BindEmailResponse;
class BindEmailResponseDefaultTypeInternal;
extern BindEmailResponseDefaultTypeInternal _BindEmailResponse_default_instance_;
class BuiltinIP;
class BuiltinIPDefaultTypeInternal;
extern BuiltinIPDefaultTypeInternal _BuiltinIP_default_instance_;
class BuiltinIPList;
class BuiltinIPListDefaultTypeInternal;
extern BuiltinIPListDefaultTypeInternal _BuiltinIPList_default_instance_;
class CDNDnsInfo;
class CDNDnsInfoDefaultTypeInternal;
extern CDNDnsInfoDefaultTypeInternal _CDNDnsInfo_default_instance_;
class CancelPurchaseRequest;
class CancelPurchaseRequestDefaultTypeInternal;
extern CancelPurchaseRequestDefaultTypeInternal _CancelPurchaseRequest_default_instance_;
class CancelPurchaseResponse;
class CancelPurchaseResponseDefaultTypeInternal;
extern CancelPurchaseResponseDefaultTypeInternal _CancelPurchaseResponse_default_instance_;
class ChatRoomMemberData;
class ChatRoomMemberDataDefaultTypeInternal;
extern ChatRoomMemberDataDefaultTypeInternal _ChatRoomMemberData_default_instance_;
class ChatRoomMemberInfo;
class ChatRoomMemberInfoDefaultTypeInternal;
extern ChatRoomMemberInfoDefaultTypeInternal _ChatRoomMemberInfo_default_instance_;
class CmdItem;
class CmdItemDefaultTypeInternal;
extern CmdItemDefaultTypeInternal _CmdItem_default_instance_;
class CmdList;
class CmdListDefaultTypeInternal;
extern CmdListDefaultTypeInternal _CmdList_default_instance_;
class CustomizedInfo;
class CustomizedInfoDefaultTypeInternal;
extern CustomizedInfoDefaultTypeInternal _CustomizedInfo_default_instance_;
class DelMemberReq;
class DelMemberReqDefaultTypeInternal;
extern DelMemberReqDefaultTypeInternal _DelMemberReq_default_instance_;
class DelMemberResp;
class DelMemberRespDefaultTypeInternal;
extern DelMemberRespDefaultTypeInternal _DelMemberResp_default_instance_;
class DisturbSetting;
class DisturbSettingDefaultTypeInternal;
extern DisturbSettingDefaultTypeInternal _DisturbSetting_default_instance_;
class DisturbTimeSpan;
class DisturbTimeSpanDefaultTypeInternal;
extern DisturbTimeSpanDefaultTypeInternal _DisturbTimeSpan_default_instance_;
class EmojiInfo;
class EmojiInfoDefaultTypeInternal;
extern EmojiInfoDefaultTypeInternal _EmojiInfo_default_instance_;
class EmojiUploadRequest;
class EmojiUploadRequestDefaultTypeInternal;
extern EmojiUploadRequestDefaultTypeInternal _EmojiUploadRequest_default_instance_;
class EmojiUploadResponse;
class EmojiUploadResponseDefaultTypeInternal;
extern EmojiUploadResponseDefaultTypeInternal _EmojiUploadResponse_default_instance_;
class EmotionBanner;
class EmotionBannerDefaultTypeInternal;
extern EmotionBannerDefaultTypeInternal _EmotionBanner_default_instance_;
class EmotionBannerImg;
class EmotionBannerImgDefaultTypeInternal;
extern EmotionBannerImgDefaultTypeInternal _EmotionBannerImg_default_instance_;
class EmotionCDNUrl;
class EmotionCDNUrlDefaultTypeInternal;
extern EmotionCDNUrlDefaultTypeInternal _EmotionCDNUrl_default_instance_;
class EmotionCell;
class EmotionCellDefaultTypeInternal;
extern EmotionCellDefaultTypeInternal _EmotionCell_default_instance_;
class EmotionDesc;
class EmotionDescDefaultTypeInternal;
extern EmotionDescDefaultTypeInternal _EmotionDesc_default_instance_;
class EmotionDetail;
class EmotionDetailDefaultTypeInternal;
extern EmotionDetailDefaultTypeInternal _EmotionDetail_default_instance_;
class EmotionDonor;
class EmotionDonorDefaultTypeInternal;
extern EmotionDonorDefaultTypeInternal _EmotionDonor_default_instance_;
class EmotionMember;
class EmotionMemberDefaultTypeInternal;
extern EmotionMemberDefaultTypeInternal _EmotionMember_default_instance_;
class EmotionPrice;
class EmotionPriceDefaultTypeInternal;
extern EmotionPriceDefaultTypeInternal _EmotionPrice_default_instance_;
class EmotionReward;
class EmotionRewardDefaultTypeInternal;
extern EmotionRewardDefaultTypeInternal _EmotionReward_default_instance_;
class EmotionSummary;
class EmotionSummaryDefaultTypeInternal;
extern EmotionSummaryDefaultTypeInternal _EmotionSummary_default_instance_;
class ExchangeEmotionPackRequest;
class ExchangeEmotionPackRequestDefaultTypeInternal;
extern ExchangeEmotionPackRequestDefaultTypeInternal _ExchangeEmotionPackRequest_default_instance_;
class ExchangeEmotionPackResponse;
class ExchangeEmotionPackResponseDefaultTypeInternal;
extern ExchangeEmotionPackResponseDefaultTypeInternal _ExchangeEmotionPackResponse_default_instance_;
class GetEmotionDescRequest;
class GetEmotionDescRequestDefaultTypeInternal;
extern GetEmotionDescRequestDefaultTypeInternal _GetEmotionDescRequest_default_instance_;
class GetEmotionDescResponse;
class GetEmotionDescResponseDefaultTypeInternal;
extern GetEmotionDescResponseDefaultTypeInternal _GetEmotionDescResponse_default_instance_;
class GetEmotionDetailRequest;
class GetEmotionDetailRequestDefaultTypeInternal;
extern GetEmotionDetailRequestDefaultTypeInternal _GetEmotionDetailRequest_default_instance_;
class GetEmotionDetailResponse;
class GetEmotionDetailResponseDefaultTypeInternal;
extern GetEmotionDetailResponseDefaultTypeInternal _GetEmotionDetailResponse_default_instance_;
class GetEmotionDonorListRequest;
class GetEmotionDonorListRequestDefaultTypeInternal;
extern GetEmotionDonorListRequestDefaultTypeInternal _GetEmotionDonorListRequest_default_instance_;
class GetEmotionDonorListResponse;
class GetEmotionDonorListResponseDefaultTypeInternal;
extern GetEmotionDonorListResponseDefaultTypeInternal _GetEmotionDonorListResponse_default_instance_;
class GetEmotionListRequest;
class GetEmotionListRequestDefaultTypeInternal;
extern GetEmotionListRequestDefaultTypeInternal _GetEmotionListRequest_default_instance_;
class GetEmotionListResponse;
class GetEmotionListResponseDefaultTypeInternal;
extern GetEmotionListResponseDefaultTypeInternal _GetEmotionListResponse_default_instance_;
class GetEmotionRewardRequest;
class GetEmotionRewardRequestDefaultTypeInternal;
extern GetEmotionRewardRequestDefaultTypeInternal _GetEmotionRewardRequest_default_instance_;
class GetEmotionRewardResponse;
class GetEmotionRewardResponseDefaultTypeInternal;
extern GetEmotionRewardResponseDefaultTypeInternal _GetEmotionRewardResponse_default_instance_;
class GetLocationRequest;
class GetLocationRequestDefaultTypeInternal;
extern GetLocationRequestDefaultTypeInternal _GetLocationRequest_default_instance_;
class GetLocationResponse;
class GetLocationResponseDefaultTypeInternal;
extern GetLocationResponseDefaultTypeInternal _GetLocationResponse_default_instance_;
class GetPersonalDesignerRequest;
class GetPersonalDesignerRequestDefaultTypeInternal;
extern GetPersonalDesignerRequestDefaultTypeInternal _GetPersonalDesignerRequest_default_instance_;
class GetPersonalDesignerResponse;
class GetPersonalDesignerResponseDefaultTypeInternal;
extern GetPersonalDesignerResponseDefaultTypeInternal _GetPersonalDesignerResponse_default_instance_;
class GetRewardMagicListRequest;
class GetRewardMagicListRequestDefaultTypeInternal;
extern GetRewardMagicListRequestDefaultTypeInternal _GetRewardMagicListRequest_default_instance_;
class GetRewardMagicListResponse;
class GetRewardMagicListResponseDefaultTypeInternal;
extern GetRewardMagicListResponseDefaultTypeInternal _GetRewardMagicListResponse_default_instance_;
class GmailInfo;
class GmailInfoDefaultTypeInternal;
extern GmailInfoDefaultTypeInternal _GmailInfo_default_instance_;
class GmailList;
class GmailListDefaultTypeInternal;
extern GmailListDefaultTypeInternal _GmailList_default_instance_;
class HardDevice;
class HardDeviceDefaultTypeInternal;
extern HardDeviceDefaultTypeInternal _HardDevice_default_instance_;
class Host;
class HostDefaultTypeInternal;
extern HostDefaultTypeInternal _Host_default_instance_;
class HostList;
class HostListDefaultTypeInternal;
extern HostListDefaultTypeInternal _HostList_default_instance_;
class JumpEmotionDetailRequest;
class JumpEmotionDetailRequestDefaultTypeInternal;
extern JumpEmotionDetailRequestDefaultTypeInternal _JumpEmotionDetailRequest_default_instance_;
class JumpEmotionDetailResponse;
class JumpEmotionDetailResponseDefaultTypeInternal;
extern JumpEmotionDetailResponseDefaultTypeInternal _JumpEmotionDetailResponse_default_instance_;
class LangDesc;
class LangDescDefaultTypeInternal;
extern LangDescDefaultTypeInternal _LangDesc_default_instance_;
class LinkedinContactItem;
class LinkedinContactItemDefaultTypeInternal;
extern LinkedinContactItemDefaultTypeInternal _LinkedinContactItem_default_instance_;
class MemberReq;
class MemberReqDefaultTypeInternal;
extern MemberReqDefaultTypeInternal _MemberReq_default_instance_;
class MemberResp;
class MemberRespDefaultTypeInternal;
extern MemberRespDefaultTypeInternal _MemberResp_default_instance_;
class MemberStatus;
class MemberStatusDefaultTypeInternal;
extern MemberStatusDefaultTypeInternal _MemberStatus_default_instance_;
class ModContact;
class ModContactDefaultTypeInternal;
extern ModContactDefaultTypeInternal _ModContact_default_instance_;
class ModEmotionPackRequest;
class ModEmotionPackRequestDefaultTypeInternal;
extern ModEmotionPackRequestDefaultTypeInternal _ModEmotionPackRequest_default_instance_;
class ModEmotionPackResponse;
class ModEmotionPackResponseDefaultTypeInternal;
extern ModEmotionPackResponseDefaultTypeInternal _ModEmotionPackResponse_default_instance_;
class ModUserInfo;
class ModUserInfoDefaultTypeInternal;
extern ModUserInfoDefaultTypeInternal _ModUserInfo_default_instance_;
class NetworkControl;
class NetworkControlDefaultTypeInternal;
extern NetworkControlDefaultTypeInternal _NetworkControl_default_instance_;
class PackThumbExt;
class PackThumbExtDefaultTypeInternal;
extern PackThumbExtDefaultTypeInternal _PackThumbExt_default_instance_;
class PatternLockInfo;
class PatternLockInfoDefaultTypeInternal;
extern PatternLockInfoDefaultTypeInternal _PatternLockInfo_default_instance_;
class PluginKey;
class PluginKeyDefaultTypeInternal;
extern PluginKeyDefaultTypeInternal _PluginKey_default_instance_;
class PluginKeyList;
class PluginKeyListDefaultTypeInternal;
extern PluginKeyListDefaultTypeInternal _PluginKeyList_default_instance_;
class PositionInfo;
class PositionInfoDefaultTypeInternal;
extern PositionInfoDefaultTypeInternal _PositionInfo_default_instance_;
class PreparePurchaseRequest;
class PreparePurchaseRequestDefaultTypeInternal;
extern PreparePurchaseRequestDefaultTypeInternal _PreparePurchaseRequest_default_instance_;
class PreparePurchaseResponse;
class PreparePurchaseResponseDefaultTypeInternal;
extern PreparePurchaseResponseDefaultTypeInternal _PreparePurchaseResponse_default_instance_;
class RewardMagic;
class RewardMagicDefaultTypeInternal;
extern RewardMagicDefaultTypeInternal _RewardMagic_default_instance_;
class RoomInfo;
class RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class SKBuiltinBuffer_t;
class SKBuiltinBuffer_tDefaultTypeInternal;
extern SKBuiltinBuffer_tDefaultTypeInternal _SKBuiltinBuffer_t_default_instance_;
class SKBuiltinChar_t;
class SKBuiltinChar_tDefaultTypeInternal;
extern SKBuiltinChar_tDefaultTypeInternal _SKBuiltinChar_t_default_instance_;
class SKBuiltinDouble64_t;
class SKBuiltinDouble64_tDefaultTypeInternal;
extern SKBuiltinDouble64_tDefaultTypeInternal _SKBuiltinDouble64_t_default_instance_;
class SKBuiltinFloat32_t;
class SKBuiltinFloat32_tDefaultTypeInternal;
extern SKBuiltinFloat32_tDefaultTypeInternal _SKBuiltinFloat32_t_default_instance_;
class SKBuiltinInt16_t;
class SKBuiltinInt16_tDefaultTypeInternal;
extern SKBuiltinInt16_tDefaultTypeInternal _SKBuiltinInt16_t_default_instance_;
class SKBuiltinInt32_t;
class SKBuiltinInt32_tDefaultTypeInternal;
extern SKBuiltinInt32_tDefaultTypeInternal _SKBuiltinInt32_t_default_instance_;
class SKBuiltinInt64_t;
class SKBuiltinInt64_tDefaultTypeInternal;
extern SKBuiltinInt64_tDefaultTypeInternal _SKBuiltinInt64_t_default_instance_;
class SKBuiltinInt8_t;
class SKBuiltinInt8_tDefaultTypeInternal;
extern SKBuiltinInt8_tDefaultTypeInternal _SKBuiltinInt8_t_default_instance_;
class SKBuiltinString_t;
class SKBuiltinString_tDefaultTypeInternal;
extern SKBuiltinString_tDefaultTypeInternal _SKBuiltinString_t_default_instance_;
class SKBuiltinUchar_t;
class SKBuiltinUchar_tDefaultTypeInternal;
extern SKBuiltinUchar_tDefaultTypeInternal _SKBuiltinUchar_t_default_instance_;
class SKBuiltinUint16_t;
class SKBuiltinUint16_tDefaultTypeInternal;
extern SKBuiltinUint16_tDefaultTypeInternal _SKBuiltinUint16_t_default_instance_;
class SKBuiltinUint32_t;
class SKBuiltinUint32_tDefaultTypeInternal;
extern SKBuiltinUint32_tDefaultTypeInternal _SKBuiltinUint32_t_default_instance_;
class SKBuiltinUint64_t;
class SKBuiltinUint64_tDefaultTypeInternal;
extern SKBuiltinUint64_tDefaultTypeInternal _SKBuiltinUint64_t_default_instance_;
class SKBuiltinUint8_t;
class SKBuiltinUint8_tDefaultTypeInternal;
extern SKBuiltinUint8_tDefaultTypeInternal _SKBuiltinUint8_t_default_instance_;
class SafeDevice;
class SafeDeviceDefaultTypeInternal;
extern SafeDeviceDefaultTypeInternal _SafeDevice_default_instance_;
class SafeDeviceList;
class SafeDeviceListDefaultTypeInternal;
extern SafeDeviceListDefaultTypeInternal _SafeDeviceList_default_instance_;
class ShakeSyncRequest;
class ShakeSyncRequestDefaultTypeInternal;
extern ShakeSyncRequestDefaultTypeInternal _ShakeSyncRequest_default_instance_;
class ShakeSyncResponse;
class ShakeSyncResponseDefaultTypeInternal;
extern ShakeSyncResponseDefaultTypeInternal _ShakeSyncResponse_default_instance_;
class ShowStyleKey;
class ShowStyleKeyDefaultTypeInternal;
extern ShowStyleKeyDefaultTypeInternal _ShowStyleKey_default_instance_;
class SnsUserInfo;
class SnsUserInfoDefaultTypeInternal;
extern SnsUserInfoDefaultTypeInternal _SnsUserInfo_default_instance_;
class StyleKeyVal;
class StyleKeyValDefaultTypeInternal;
extern StyleKeyValDefaultTypeInternal _StyleKeyVal_default_instance_;
class UploadEmojiInfoReq;
class UploadEmojiInfoReqDefaultTypeInternal;
extern UploadEmojiInfoReqDefaultTypeInternal _UploadEmojiInfoReq_default_instance_;
class UploadEmojiInfoResp;
class UploadEmojiInfoRespDefaultTypeInternal;
extern UploadEmojiInfoRespDefaultTypeInternal _UploadEmojiInfoResp_default_instance_;
class UploadMyPanelListRequest;
class UploadMyPanelListRequestDefaultTypeInternal;
extern UploadMyPanelListRequestDefaultTypeInternal _UploadMyPanelListRequest_default_instance_;
class UploadMyPanelListResponse;
class UploadMyPanelListResponseDefaultTypeInternal;
extern UploadMyPanelListResponseDefaultTypeInternal _UploadMyPanelListResponse_default_instance_;
class UserInfoExt;
class UserInfoExtDefaultTypeInternal;
extern UserInfoExtDefaultTypeInternal _UserInfoExt_default_instance_;
class VerifyEmotionPresentationRequest;
class VerifyEmotionPresentationRequestDefaultTypeInternal;
extern VerifyEmotionPresentationRequestDefaultTypeInternal _VerifyEmotionPresentationRequest_default_instance_;
class VerifyEmotionPresentationResponse;
class VerifyEmotionPresentationResponseDefaultTypeInternal;
extern VerifyEmotionPresentationResponseDefaultTypeInternal _VerifyEmotionPresentationResponse_default_instance_;
class VerifyPurchaseRequest;
class VerifyPurchaseRequestDefaultTypeInternal;
extern VerifyPurchaseRequestDefaultTypeInternal _VerifyPurchaseRequest_default_instance_;
class VerifyPurchaseResponse;
class VerifyPurchaseResponseDefaultTypeInternal;
extern VerifyPurchaseResponseDefaultTypeInternal _VerifyPurchaseResponse_default_instance_;
}  // namespace micromsg

namespace micromsg {

namespace protobuf_mmemotionstore_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mmemotionstore_2eproto

// ===================================================================

class JumpEmotionDetailRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.JumpEmotionDetailRequest) */ {
 public:
  JumpEmotionDetailRequest();
  virtual ~JumpEmotionDetailRequest();

  JumpEmotionDetailRequest(const JumpEmotionDetailRequest& from);

  inline JumpEmotionDetailRequest& operator=(const JumpEmotionDetailRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JumpEmotionDetailRequest& default_instance();

  static inline const JumpEmotionDetailRequest* internal_default_instance() {
    return reinterpret_cast<const JumpEmotionDetailRequest*>(
               &_JumpEmotionDetailRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(JumpEmotionDetailRequest* other);

  // implements Message ----------------------------------------------

  inline JumpEmotionDetailRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  JumpEmotionDetailRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JumpEmotionDetailRequest& from);
  void MergeFrom(const JumpEmotionDetailRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JumpEmotionDetailRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.JumpEmotionDetailRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_url();
  void clear_has_url();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JumpEmotionDetailResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.JumpEmotionDetailResponse) */ {
 public:
  JumpEmotionDetailResponse();
  virtual ~JumpEmotionDetailResponse();

  JumpEmotionDetailResponse(const JumpEmotionDetailResponse& from);

  inline JumpEmotionDetailResponse& operator=(const JumpEmotionDetailResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JumpEmotionDetailResponse& default_instance();

  static inline const JumpEmotionDetailResponse* internal_default_instance() {
    return reinterpret_cast<const JumpEmotionDetailResponse*>(
               &_JumpEmotionDetailResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(JumpEmotionDetailResponse* other);

  // implements Message ----------------------------------------------

  inline JumpEmotionDetailResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  JumpEmotionDetailResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JumpEmotionDetailResponse& from);
  void MergeFrom(const JumpEmotionDetailResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JumpEmotionDetailResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ProductID = 2;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 2;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.JumpEmotionDetailResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_productid();
  void clear_has_productid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchEmojiBackupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BatchEmojiBackupRequest) */ {
 public:
  BatchEmojiBackupRequest();
  virtual ~BatchEmojiBackupRequest();

  BatchEmojiBackupRequest(const BatchEmojiBackupRequest& from);

  inline BatchEmojiBackupRequest& operator=(const BatchEmojiBackupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchEmojiBackupRequest& default_instance();

  static inline const BatchEmojiBackupRequest* internal_default_instance() {
    return reinterpret_cast<const BatchEmojiBackupRequest*>(
               &_BatchEmojiBackupRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(BatchEmojiBackupRequest* other);

  // implements Message ----------------------------------------------

  inline BatchEmojiBackupRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchEmojiBackupRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatchEmojiBackupRequest& from);
  void MergeFrom(const BatchEmojiBackupRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatchEmojiBackupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string Md5List = 1;
  int md5list_size() const;
  void clear_md5list();
  static const int kMd5ListFieldNumber = 1;
  const ::std::string& md5list(int index) const;
  ::std::string* mutable_md5list(int index);
  void set_md5list(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_md5list(int index, ::std::string&& value);
  #endif
  void set_md5list(int index, const char* value);
  void set_md5list(int index, const char* value, size_t size);
  ::std::string* add_md5list();
  void add_md5list(const ::std::string& value);
  #if LANG_CXX11
  void add_md5list(::std::string&& value);
  #endif
  void add_md5list(const char* value);
  void add_md5list(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& md5list() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_md5list();

  // @@protoc_insertion_point(class_scope:micromsg.BatchEmojiBackupRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> md5list_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchEmojiBackupResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BatchEmojiBackupResponse) */ {
 public:
  BatchEmojiBackupResponse();
  virtual ~BatchEmojiBackupResponse();

  BatchEmojiBackupResponse(const BatchEmojiBackupResponse& from);

  inline BatchEmojiBackupResponse& operator=(const BatchEmojiBackupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchEmojiBackupResponse& default_instance();

  static inline const BatchEmojiBackupResponse* internal_default_instance() {
    return reinterpret_cast<const BatchEmojiBackupResponse*>(
               &_BatchEmojiBackupResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(BatchEmojiBackupResponse* other);

  // implements Message ----------------------------------------------

  inline BatchEmojiBackupResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchEmojiBackupResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatchEmojiBackupResponse& from);
  void MergeFrom(const BatchEmojiBackupResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatchEmojiBackupResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string NeedUploadMd5List = 2;
  int needuploadmd5list_size() const;
  void clear_needuploadmd5list();
  static const int kNeedUploadMd5ListFieldNumber = 2;
  const ::std::string& needuploadmd5list(int index) const;
  ::std::string* mutable_needuploadmd5list(int index);
  void set_needuploadmd5list(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_needuploadmd5list(int index, ::std::string&& value);
  #endif
  void set_needuploadmd5list(int index, const char* value);
  void set_needuploadmd5list(int index, const char* value, size_t size);
  ::std::string* add_needuploadmd5list();
  void add_needuploadmd5list(const ::std::string& value);
  #if LANG_CXX11
  void add_needuploadmd5list(::std::string&& value);
  #endif
  void add_needuploadmd5list(const char* value);
  void add_needuploadmd5list(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& needuploadmd5list() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_needuploadmd5list();

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.BatchEmojiBackupResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> needuploadmd5list_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchEmojiDownLoadRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BatchEmojiDownLoadRequest) */ {
 public:
  BatchEmojiDownLoadRequest();
  virtual ~BatchEmojiDownLoadRequest();

  BatchEmojiDownLoadRequest(const BatchEmojiDownLoadRequest& from);

  inline BatchEmojiDownLoadRequest& operator=(const BatchEmojiDownLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchEmojiDownLoadRequest& default_instance();

  static inline const BatchEmojiDownLoadRequest* internal_default_instance() {
    return reinterpret_cast<const BatchEmojiDownLoadRequest*>(
               &_BatchEmojiDownLoadRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(BatchEmojiDownLoadRequest* other);

  // implements Message ----------------------------------------------

  inline BatchEmojiDownLoadRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchEmojiDownLoadRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatchEmojiDownLoadRequest& from);
  void MergeFrom(const BatchEmojiDownLoadRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatchEmojiDownLoadRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BatchEmojiDownLoadRequest)
 private:
  void set_has_index();
  void clear_has_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 index_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmojiInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmojiInfo) */ {
 public:
  EmojiInfo();
  virtual ~EmojiInfo();

  EmojiInfo(const EmojiInfo& from);

  inline EmojiInfo& operator=(const EmojiInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmojiInfo& default_instance();

  static inline const EmojiInfo* internal_default_instance() {
    return reinterpret_cast<const EmojiInfo*>(
               &_EmojiInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(EmojiInfo* other);

  // implements Message ----------------------------------------------

  inline EmojiInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EmojiInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmojiInfo& from);
  void MergeFrom(const EmojiInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmojiInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Md5 = 1;
  bool has_md5() const;
  void clear_md5();
  static const int kMd5FieldNumber = 1;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_md5(::std::string&& value);
  #endif
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // optional string Url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:micromsg.EmojiInfo)
 private:
  void set_has_md5();
  void clear_has_md5();
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchEmojiDownLoadResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BatchEmojiDownLoadResponse) */ {
 public:
  BatchEmojiDownLoadResponse();
  virtual ~BatchEmojiDownLoadResponse();

  BatchEmojiDownLoadResponse(const BatchEmojiDownLoadResponse& from);

  inline BatchEmojiDownLoadResponse& operator=(const BatchEmojiDownLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchEmojiDownLoadResponse& default_instance();

  static inline const BatchEmojiDownLoadResponse* internal_default_instance() {
    return reinterpret_cast<const BatchEmojiDownLoadResponse*>(
               &_BatchEmojiDownLoadResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(BatchEmojiDownLoadResponse* other);

  // implements Message ----------------------------------------------

  inline BatchEmojiDownLoadResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BatchEmojiDownLoadResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BatchEmojiDownLoadResponse& from);
  void MergeFrom(const BatchEmojiDownLoadResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BatchEmojiDownLoadResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string Md5List = 3;
  int md5list_size() const;
  void clear_md5list();
  static const int kMd5ListFieldNumber = 3;
  const ::std::string& md5list(int index) const;
  ::std::string* mutable_md5list(int index);
  void set_md5list(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_md5list(int index, ::std::string&& value);
  #endif
  void set_md5list(int index, const char* value);
  void set_md5list(int index, const char* value, size_t size);
  ::std::string* add_md5list();
  void add_md5list(const ::std::string& value);
  #if LANG_CXX11
  void add_md5list(::std::string&& value);
  #endif
  void add_md5list(const char* value);
  void add_md5list(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& md5list() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_md5list();

  // repeated .micromsg.EmojiInfo EmojiList = 5;
  int emojilist_size() const;
  void clear_emojilist();
  static const int kEmojiListFieldNumber = 5;
  const ::micromsg::EmojiInfo& emojilist(int index) const;
  ::micromsg::EmojiInfo* mutable_emojilist(int index);
  ::micromsg::EmojiInfo* add_emojilist();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmojiInfo >*
      mutable_emojilist();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmojiInfo >&
      emojilist() const;

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required uint32 Index = 2;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // required uint32 EndFlag = 4;
  bool has_endflag() const;
  void clear_endflag();
  static const int kEndFlagFieldNumber = 4;
  ::google::protobuf::uint32 endflag() const;
  void set_endflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BatchEmojiDownLoadResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_index();
  void clear_has_index();
  void set_has_endflag();
  void clear_has_endflag();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> md5list_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmojiInfo > emojilist_;
  ::micromsg::BaseResponse* baseresponse_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 endflag_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BackupEmojiOperateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BackupEmojiOperateRequest) */ {
 public:
  BackupEmojiOperateRequest();
  virtual ~BackupEmojiOperateRequest();

  BackupEmojiOperateRequest(const BackupEmojiOperateRequest& from);

  inline BackupEmojiOperateRequest& operator=(const BackupEmojiOperateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BackupEmojiOperateRequest& default_instance();

  static inline const BackupEmojiOperateRequest* internal_default_instance() {
    return reinterpret_cast<const BackupEmojiOperateRequest*>(
               &_BackupEmojiOperateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(BackupEmojiOperateRequest* other);

  // implements Message ----------------------------------------------

  inline BackupEmojiOperateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BackupEmojiOperateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BackupEmojiOperateRequest& from);
  void MergeFrom(const BackupEmojiOperateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BackupEmojiOperateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string Md5List = 1;
  int md5list_size() const;
  void clear_md5list();
  static const int kMd5ListFieldNumber = 1;
  const ::std::string& md5list(int index) const;
  ::std::string* mutable_md5list(int index);
  void set_md5list(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_md5list(int index, ::std::string&& value);
  #endif
  void set_md5list(int index, const char* value);
  void set_md5list(int index, const char* value, size_t size);
  ::std::string* add_md5list();
  void add_md5list(const ::std::string& value);
  #if LANG_CXX11
  void add_md5list(::std::string&& value);
  #endif
  void add_md5list(const char* value);
  void add_md5list(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& md5list() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_md5list();

  // required uint32 Opcode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BackupEmojiOperateRequest)
 private:
  void set_has_opcode();
  void clear_has_opcode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> md5list_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BackupEmojiOperateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BackupEmojiOperateResponse) */ {
 public:
  BackupEmojiOperateResponse();
  virtual ~BackupEmojiOperateResponse();

  BackupEmojiOperateResponse(const BackupEmojiOperateResponse& from);

  inline BackupEmojiOperateResponse& operator=(const BackupEmojiOperateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BackupEmojiOperateResponse& default_instance();

  static inline const BackupEmojiOperateResponse* internal_default_instance() {
    return reinterpret_cast<const BackupEmojiOperateResponse*>(
               &_BackupEmojiOperateResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(BackupEmojiOperateResponse* other);

  // implements Message ----------------------------------------------

  inline BackupEmojiOperateResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BackupEmojiOperateResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BackupEmojiOperateResponse& from);
  void MergeFrom(const BackupEmojiOperateResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BackupEmojiOperateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string NeedUploadMd5List = 2;
  int needuploadmd5list_size() const;
  void clear_needuploadmd5list();
  static const int kNeedUploadMd5ListFieldNumber = 2;
  const ::std::string& needuploadmd5list(int index) const;
  ::std::string* mutable_needuploadmd5list(int index);
  void set_needuploadmd5list(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_needuploadmd5list(int index, ::std::string&& value);
  #endif
  void set_needuploadmd5list(int index, const char* value);
  void set_needuploadmd5list(int index, const char* value, size_t size);
  ::std::string* add_needuploadmd5list();
  void add_needuploadmd5list(const ::std::string& value);
  #if LANG_CXX11
  void add_needuploadmd5list(::std::string&& value);
  #endif
  void add_needuploadmd5list(const char* value);
  void add_needuploadmd5list(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& needuploadmd5list() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_needuploadmd5list();

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.BackupEmojiOperateResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> needuploadmd5list_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UploadEmojiInfoReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UploadEmojiInfoReq) */ {
 public:
  UploadEmojiInfoReq();
  virtual ~UploadEmojiInfoReq();

  UploadEmojiInfoReq(const UploadEmojiInfoReq& from);

  inline UploadEmojiInfoReq& operator=(const UploadEmojiInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadEmojiInfoReq& default_instance();

  static inline const UploadEmojiInfoReq* internal_default_instance() {
    return reinterpret_cast<const UploadEmojiInfoReq*>(
               &_UploadEmojiInfoReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(UploadEmojiInfoReq* other);

  // implements Message ----------------------------------------------

  inline UploadEmojiInfoReq* New() const PROTOBUF_FINAL { return New(NULL); }

  UploadEmojiInfoReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UploadEmojiInfoReq& from);
  void MergeFrom(const UploadEmojiInfoReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UploadEmojiInfoReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string MD5 = 1;
  bool has_md5() const;
  void clear_md5();
  static const int kMD5FieldNumber = 1;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_md5(::std::string&& value);
  #endif
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // required bytes EmojiBuffer = 4;
  bool has_emojibuffer() const;
  void clear_emojibuffer();
  static const int kEmojiBufferFieldNumber = 4;
  const ::std::string& emojibuffer() const;
  void set_emojibuffer(const ::std::string& value);
  #if LANG_CXX11
  void set_emojibuffer(::std::string&& value);
  #endif
  void set_emojibuffer(const char* value);
  void set_emojibuffer(const void* value, size_t size);
  ::std::string* mutable_emojibuffer();
  ::std::string* release_emojibuffer();
  void set_allocated_emojibuffer(::std::string* emojibuffer);

  // required int32 StartPos = 2;
  bool has_startpos() const;
  void clear_startpos();
  static const int kStartPosFieldNumber = 2;
  ::google::protobuf::int32 startpos() const;
  void set_startpos(::google::protobuf::int32 value);

  // required int32 TotalLen = 3;
  bool has_totallen() const;
  void clear_totallen();
  static const int kTotalLenFieldNumber = 3;
  ::google::protobuf::int32 totallen() const;
  void set_totallen(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.UploadEmojiInfoReq)
 private:
  void set_has_md5();
  void clear_has_md5();
  void set_has_startpos();
  void clear_has_startpos();
  void set_has_totallen();
  void clear_has_totallen();
  void set_has_emojibuffer();
  void clear_has_emojibuffer();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  ::google::protobuf::internal::ArenaStringPtr emojibuffer_;
  ::google::protobuf::int32 startpos_;
  ::google::protobuf::int32 totallen_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmojiUploadRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmojiUploadRequest) */ {
 public:
  EmojiUploadRequest();
  virtual ~EmojiUploadRequest();

  EmojiUploadRequest(const EmojiUploadRequest& from);

  inline EmojiUploadRequest& operator=(const EmojiUploadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmojiUploadRequest& default_instance();

  static inline const EmojiUploadRequest* internal_default_instance() {
    return reinterpret_cast<const EmojiUploadRequest*>(
               &_EmojiUploadRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(EmojiUploadRequest* other);

  // implements Message ----------------------------------------------

  inline EmojiUploadRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EmojiUploadRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmojiUploadRequest& from);
  void MergeFrom(const EmojiUploadRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmojiUploadRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.UploadEmojiInfoReq EmojiItem = 1;
  int emojiitem_size() const;
  void clear_emojiitem();
  static const int kEmojiItemFieldNumber = 1;
  const ::micromsg::UploadEmojiInfoReq& emojiitem(int index) const;
  ::micromsg::UploadEmojiInfoReq* mutable_emojiitem(int index);
  ::micromsg::UploadEmojiInfoReq* add_emojiitem();
  ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoReq >*
      mutable_emojiitem();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoReq >&
      emojiitem() const;

  // optional uint32 ReqTime = 2;
  bool has_reqtime() const;
  void clear_reqtime();
  static const int kReqTimeFieldNumber = 2;
  ::google::protobuf::uint32 reqtime() const;
  void set_reqtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.EmojiUploadRequest)
 private:
  void set_has_reqtime();
  void clear_has_reqtime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoReq > emojiitem_;
  ::google::protobuf::uint32 reqtime_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UploadEmojiInfoResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UploadEmojiInfoResp) */ {
 public:
  UploadEmojiInfoResp();
  virtual ~UploadEmojiInfoResp();

  UploadEmojiInfoResp(const UploadEmojiInfoResp& from);

  inline UploadEmojiInfoResp& operator=(const UploadEmojiInfoResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadEmojiInfoResp& default_instance();

  static inline const UploadEmojiInfoResp* internal_default_instance() {
    return reinterpret_cast<const UploadEmojiInfoResp*>(
               &_UploadEmojiInfoResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(UploadEmojiInfoResp* other);

  // implements Message ----------------------------------------------

  inline UploadEmojiInfoResp* New() const PROTOBUF_FINAL { return New(NULL); }

  UploadEmojiInfoResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UploadEmojiInfoResp& from);
  void MergeFrom(const UploadEmojiInfoResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UploadEmojiInfoResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string MD5 = 4;
  bool has_md5() const;
  void clear_md5();
  static const int kMD5FieldNumber = 4;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_md5(::std::string&& value);
  #endif
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // required int32 Ret = 1;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 1;
  ::google::protobuf::int32 ret() const;
  void set_ret(::google::protobuf::int32 value);

  // required int32 StartPos = 2;
  bool has_startpos() const;
  void clear_startpos();
  static const int kStartPosFieldNumber = 2;
  ::google::protobuf::int32 startpos() const;
  void set_startpos(::google::protobuf::int32 value);

  // required int32 TotalLen = 3;
  bool has_totallen() const;
  void clear_totallen();
  static const int kTotalLenFieldNumber = 3;
  ::google::protobuf::int32 totallen() const;
  void set_totallen(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.UploadEmojiInfoResp)
 private:
  void set_has_ret();
  void clear_has_ret();
  void set_has_startpos();
  void clear_has_startpos();
  void set_has_totallen();
  void clear_has_totallen();
  void set_has_md5();
  void clear_has_md5();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 startpos_;
  ::google::protobuf::int32 totallen_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmojiUploadResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmojiUploadResponse) */ {
 public:
  EmojiUploadResponse();
  virtual ~EmojiUploadResponse();

  EmojiUploadResponse(const EmojiUploadResponse& from);

  inline EmojiUploadResponse& operator=(const EmojiUploadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmojiUploadResponse& default_instance();

  static inline const EmojiUploadResponse* internal_default_instance() {
    return reinterpret_cast<const EmojiUploadResponse*>(
               &_EmojiUploadResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(EmojiUploadResponse* other);

  // implements Message ----------------------------------------------

  inline EmojiUploadResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  EmojiUploadResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmojiUploadResponse& from);
  void MergeFrom(const EmojiUploadResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmojiUploadResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.UploadEmojiInfoResp EmojiItem = 2;
  int emojiitem_size() const;
  void clear_emojiitem();
  static const int kEmojiItemFieldNumber = 2;
  const ::micromsg::UploadEmojiInfoResp& emojiitem(int index) const;
  ::micromsg::UploadEmojiInfoResp* mutable_emojiitem(int index);
  ::micromsg::UploadEmojiInfoResp* add_emojiitem();
  ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoResp >*
      mutable_emojiitem();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoResp >&
      emojiitem() const;

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.EmojiUploadResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoResp > emojiitem_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UploadMyPanelListRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UploadMyPanelListRequest) */ {
 public:
  UploadMyPanelListRequest();
  virtual ~UploadMyPanelListRequest();

  UploadMyPanelListRequest(const UploadMyPanelListRequest& from);

  inline UploadMyPanelListRequest& operator=(const UploadMyPanelListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadMyPanelListRequest& default_instance();

  static inline const UploadMyPanelListRequest* internal_default_instance() {
    return reinterpret_cast<const UploadMyPanelListRequest*>(
               &_UploadMyPanelListRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(UploadMyPanelListRequest* other);

  // implements Message ----------------------------------------------

  inline UploadMyPanelListRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UploadMyPanelListRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UploadMyPanelListRequest& from);
  void MergeFrom(const UploadMyPanelListRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UploadMyPanelListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ProductIDList = 2;
  int productidlist_size() const;
  void clear_productidlist();
  static const int kProductIDListFieldNumber = 2;
  const ::std::string& productidlist(int index) const;
  ::std::string* mutable_productidlist(int index);
  void set_productidlist(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_productidlist(int index, ::std::string&& value);
  #endif
  void set_productidlist(int index, const char* value);
  void set_productidlist(int index, const char* value, size_t size);
  ::std::string* add_productidlist();
  void add_productidlist(const ::std::string& value);
  #if LANG_CXX11
  void add_productidlist(::std::string&& value);
  #endif
  void add_productidlist(const char* value);
  void add_productidlist(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& productidlist() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productidlist();

  // required uint32 OpCode = 1;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpCodeFieldNumber = 1;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.UploadMyPanelListRequest)
 private:
  void set_has_opcode();
  void clear_has_opcode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> productidlist_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UploadMyPanelListResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UploadMyPanelListResponse) */ {
 public:
  UploadMyPanelListResponse();
  virtual ~UploadMyPanelListResponse();

  UploadMyPanelListResponse(const UploadMyPanelListResponse& from);

  inline UploadMyPanelListResponse& operator=(const UploadMyPanelListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UploadMyPanelListResponse& default_instance();

  static inline const UploadMyPanelListResponse* internal_default_instance() {
    return reinterpret_cast<const UploadMyPanelListResponse*>(
               &_UploadMyPanelListResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(UploadMyPanelListResponse* other);

  // implements Message ----------------------------------------------

  inline UploadMyPanelListResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UploadMyPanelListResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UploadMyPanelListResponse& from);
  void MergeFrom(const UploadMyPanelListResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UploadMyPanelListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.UploadMyPanelListResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPersonalDesignerRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetPersonalDesignerRequest) */ {
 public:
  GetPersonalDesignerRequest();
  virtual ~GetPersonalDesignerRequest();

  GetPersonalDesignerRequest(const GetPersonalDesignerRequest& from);

  inline GetPersonalDesignerRequest& operator=(const GetPersonalDesignerRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPersonalDesignerRequest& default_instance();

  static inline const GetPersonalDesignerRequest* internal_default_instance() {
    return reinterpret_cast<const GetPersonalDesignerRequest*>(
               &_GetPersonalDesignerRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(GetPersonalDesignerRequest* other);

  // implements Message ----------------------------------------------

  inline GetPersonalDesignerRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetPersonalDesignerRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetPersonalDesignerRequest& from);
  void MergeFrom(const GetPersonalDesignerRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetPersonalDesignerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.SKBuiltinBuffer_t ReqBuf = 2;
  bool has_reqbuf() const;
  void clear_reqbuf();
  static const int kReqBufFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& reqbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* release_reqbuf();
  void set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf);

  // required uint32 DesignerUin = 1;
  bool has_designeruin() const;
  void clear_designeruin();
  static const int kDesignerUinFieldNumber = 1;
  ::google::protobuf::uint32 designeruin() const;
  void set_designeruin(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetPersonalDesignerRequest)
 private:
  void set_has_designeruin();
  void clear_has_designeruin();
  void set_has_reqbuf();
  void clear_has_reqbuf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* reqbuf_;
  ::google::protobuf::uint32 designeruin_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPersonalDesignerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetPersonalDesignerResponse) */ {
 public:
  GetPersonalDesignerResponse();
  virtual ~GetPersonalDesignerResponse();

  GetPersonalDesignerResponse(const GetPersonalDesignerResponse& from);

  inline GetPersonalDesignerResponse& operator=(const GetPersonalDesignerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPersonalDesignerResponse& default_instance();

  static inline const GetPersonalDesignerResponse* internal_default_instance() {
    return reinterpret_cast<const GetPersonalDesignerResponse*>(
               &_GetPersonalDesignerResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(GetPersonalDesignerResponse* other);

  // implements Message ----------------------------------------------

  inline GetPersonalDesignerResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetPersonalDesignerResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetPersonalDesignerResponse& from);
  void MergeFrom(const GetPersonalDesignerResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetPersonalDesignerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.EmotionSummary EmotionList = 7;
  int emotionlist_size() const;
  void clear_emotionlist();
  static const int kEmotionListFieldNumber = 7;
  const ::micromsg::EmotionSummary& emotionlist(int index) const;
  ::micromsg::EmotionSummary* mutable_emotionlist(int index);
  ::micromsg::EmotionSummary* add_emotionlist();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary >*
      mutable_emotionlist();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary >&
      emotionlist() const;

  // required string BannerUrl = 2;
  bool has_bannerurl() const;
  void clear_bannerurl();
  static const int kBannerUrlFieldNumber = 2;
  const ::std::string& bannerurl() const;
  void set_bannerurl(const ::std::string& value);
  #if LANG_CXX11
  void set_bannerurl(::std::string&& value);
  #endif
  void set_bannerurl(const char* value);
  void set_bannerurl(const char* value, size_t size);
  ::std::string* mutable_bannerurl();
  ::std::string* release_bannerurl();
  void set_allocated_bannerurl(::std::string* bannerurl);

  // required string Name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string Desc = 4;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 4;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // required string HeadUrl = 5;
  bool has_headurl() const;
  void clear_headurl();
  static const int kHeadUrlFieldNumber = 5;
  const ::std::string& headurl() const;
  void set_headurl(const ::std::string& value);
  #if LANG_CXX11
  void set_headurl(::std::string&& value);
  #endif
  void set_headurl(const char* value);
  void set_headurl(const char* value, size_t size);
  ::std::string* mutable_headurl();
  ::std::string* release_headurl();
  void set_allocated_headurl(::std::string* headurl);

  // required string BizName = 6;
  bool has_bizname() const;
  void clear_bizname();
  static const int kBizNameFieldNumber = 6;
  const ::std::string& bizname() const;
  void set_bizname(const ::std::string& value);
  #if LANG_CXX11
  void set_bizname(::std::string&& value);
  #endif
  void set_bizname(const char* value);
  void set_bizname(const char* value, size_t size);
  ::std::string* mutable_bizname();
  ::std::string* release_bizname();
  void set_allocated_bizname(::std::string* bizname);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.SKBuiltinBuffer_t ReqBuf = 8;
  bool has_reqbuf() const;
  void clear_reqbuf();
  static const int kReqBufFieldNumber = 8;
  const ::micromsg::SKBuiltinBuffer_t& reqbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* release_reqbuf();
  void set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf);

  // @@protoc_insertion_point(class_scope:micromsg.GetPersonalDesignerResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_bannerurl();
  void clear_has_bannerurl();
  void set_has_name();
  void clear_has_name();
  void set_has_desc();
  void clear_has_desc();
  void set_has_headurl();
  void clear_has_headurl();
  void set_has_bizname();
  void clear_has_bizname();
  void set_has_reqbuf();
  void clear_has_reqbuf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary > emotionlist_;
  ::google::protobuf::internal::ArenaStringPtr bannerurl_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr headurl_;
  ::google::protobuf::internal::ArenaStringPtr bizname_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinBuffer_t* reqbuf_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionRewardRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionRewardRequest) */ {
 public:
  GetEmotionRewardRequest();
  virtual ~GetEmotionRewardRequest();

  GetEmotionRewardRequest(const GetEmotionRewardRequest& from);

  inline GetEmotionRewardRequest& operator=(const GetEmotionRewardRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionRewardRequest& default_instance();

  static inline const GetEmotionRewardRequest* internal_default_instance() {
    return reinterpret_cast<const GetEmotionRewardRequest*>(
               &_GetEmotionRewardRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(GetEmotionRewardRequest* other);

  // implements Message ----------------------------------------------

  inline GetEmotionRewardRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionRewardRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionRewardRequest& from);
  void MergeFrom(const GetEmotionRewardRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionRewardRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ProductID = 1;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 1;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required uint32 OpCode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpCodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionRewardRequest)
 private:
  void set_has_productid();
  void clear_has_productid();
  void set_has_opcode();
  void clear_has_opcode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionPrice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionPrice) */ {
 public:
  EmotionPrice();
  virtual ~EmotionPrice();

  EmotionPrice(const EmotionPrice& from);

  inline EmotionPrice& operator=(const EmotionPrice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionPrice& default_instance();

  static inline const EmotionPrice* internal_default_instance() {
    return reinterpret_cast<const EmotionPrice*>(
               &_EmotionPrice_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(EmotionPrice* other);

  // implements Message ----------------------------------------------

  inline EmotionPrice* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionPrice* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionPrice& from);
  void MergeFrom(const EmotionPrice& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionPrice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Label = 1;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 1;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // required string Number = 2;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  const ::std::string& number() const;
  void set_number(const ::std::string& value);
  #if LANG_CXX11
  void set_number(::std::string&& value);
  #endif
  void set_number(const char* value);
  void set_number(const char* value, size_t size);
  ::std::string* mutable_number();
  ::std::string* release_number();
  void set_allocated_number(::std::string* number);

  // required string Type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionPrice)
 private:
  void set_has_label();
  void clear_has_label();
  void set_has_number();
  void clear_has_number();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr number_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionDonor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionDonor) */ {
 public:
  EmotionDonor();
  virtual ~EmotionDonor();

  EmotionDonor(const EmotionDonor& from);

  inline EmotionDonor& operator=(const EmotionDonor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionDonor& default_instance();

  static inline const EmotionDonor* internal_default_instance() {
    return reinterpret_cast<const EmotionDonor*>(
               &_EmotionDonor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(EmotionDonor* other);

  // implements Message ----------------------------------------------

  inline EmotionDonor* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionDonor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionDonor& from);
  void MergeFrom(const EmotionDonor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionDonor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string HeadUrl = 1;
  bool has_headurl() const;
  void clear_headurl();
  static const int kHeadUrlFieldNumber = 1;
  const ::std::string& headurl() const;
  void set_headurl(const ::std::string& value);
  #if LANG_CXX11
  void set_headurl(::std::string&& value);
  #endif
  void set_headurl(const char* value);
  void set_headurl(const char* value, size_t size);
  ::std::string* mutable_headurl();
  ::std::string* release_headurl();
  void set_allocated_headurl(::std::string* headurl);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionDonor)
 private:
  void set_has_headurl();
  void clear_has_headurl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr headurl_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmotionReward : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmotionReward) */ {
 public:
  EmotionReward();
  virtual ~EmotionReward();

  EmotionReward(const EmotionReward& from);

  inline EmotionReward& operator=(const EmotionReward& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmotionReward& default_instance();

  static inline const EmotionReward* internal_default_instance() {
    return reinterpret_cast<const EmotionReward*>(
               &_EmotionReward_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(EmotionReward* other);

  // implements Message ----------------------------------------------

  inline EmotionReward* New() const PROTOBUF_FINAL { return New(NULL); }

  EmotionReward* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmotionReward& from);
  void MergeFrom(const EmotionReward& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmotionReward* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string BegWord = 1;
  bool has_begword() const;
  void clear_begword();
  static const int kBegWordFieldNumber = 1;
  const ::std::string& begword() const;
  void set_begword(const ::std::string& value);
  #if LANG_CXX11
  void set_begword(::std::string&& value);
  #endif
  void set_begword(const char* value);
  void set_begword(const char* value, size_t size);
  ::std::string* mutable_begword();
  ::std::string* release_begword();
  void set_allocated_begword(::std::string* begword);

  // required string BegPicUrl = 2;
  bool has_begpicurl() const;
  void clear_begpicurl();
  static const int kBegPicUrlFieldNumber = 2;
  const ::std::string& begpicurl() const;
  void set_begpicurl(const ::std::string& value);
  #if LANG_CXX11
  void set_begpicurl(::std::string&& value);
  #endif
  void set_begpicurl(const char* value);
  void set_begpicurl(const char* value, size_t size);
  ::std::string* mutable_begpicurl();
  ::std::string* release_begpicurl();
  void set_allocated_begpicurl(::std::string* begpicurl);

  // required string ThanksPicUrl = 3;
  bool has_thankspicurl() const;
  void clear_thankspicurl();
  static const int kThanksPicUrlFieldNumber = 3;
  const ::std::string& thankspicurl() const;
  void set_thankspicurl(const ::std::string& value);
  #if LANG_CXX11
  void set_thankspicurl(::std::string&& value);
  #endif
  void set_thankspicurl(const char* value);
  void set_thankspicurl(const char* value, size_t size);
  ::std::string* mutable_thankspicurl();
  ::std::string* release_thankspicurl();
  void set_allocated_thankspicurl(::std::string* thankspicurl);

  // optional string MagicUrl = 4;
  bool has_magicurl() const;
  void clear_magicurl();
  static const int kMagicUrlFieldNumber = 4;
  const ::std::string& magicurl() const;
  void set_magicurl(const ::std::string& value);
  #if LANG_CXX11
  void set_magicurl(::std::string&& value);
  #endif
  void set_magicurl(const char* value);
  void set_magicurl(const char* value, size_t size);
  ::std::string* mutable_magicurl();
  ::std::string* release_magicurl();
  void set_allocated_magicurl(::std::string* magicurl);

  // optional string MagicWord = 5;
  bool has_magicword() const;
  void clear_magicword();
  static const int kMagicWordFieldNumber = 5;
  const ::std::string& magicword() const;
  void set_magicword(const ::std::string& value);
  #if LANG_CXX11
  void set_magicword(::std::string&& value);
  #endif
  void set_magicword(const char* value);
  void set_magicword(const char* value, size_t size);
  ::std::string* mutable_magicword();
  ::std::string* release_magicword();
  void set_allocated_magicword(::std::string* magicword);

  // optional string MagicMd5 = 8;
  bool has_magicmd5() const;
  void clear_magicmd5();
  static const int kMagicMd5FieldNumber = 8;
  const ::std::string& magicmd5() const;
  void set_magicmd5(const ::std::string& value);
  #if LANG_CXX11
  void set_magicmd5(::std::string&& value);
  #endif
  void set_magicmd5(const char* value);
  void set_magicmd5(const char* value, size_t size);
  ::std::string* mutable_magicmd5();
  ::std::string* release_magicmd5();
  void set_allocated_magicmd5(::std::string* magicmd5);

  // optional uint32 MagicExpire = 6;
  bool has_magicexpire() const;
  void clear_magicexpire();
  static const int kMagicExpireFieldNumber = 6;
  ::google::protobuf::uint32 magicexpire() const;
  void set_magicexpire(::google::protobuf::uint32 value);

  // optional uint32 MagicLimit = 7;
  bool has_magiclimit() const;
  void clear_magiclimit();
  static const int kMagicLimitFieldNumber = 7;
  ::google::protobuf::uint32 magiclimit() const;
  void set_magiclimit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.EmotionReward)
 private:
  void set_has_begword();
  void clear_has_begword();
  void set_has_begpicurl();
  void clear_has_begpicurl();
  void set_has_thankspicurl();
  void clear_has_thankspicurl();
  void set_has_magicurl();
  void clear_has_magicurl();
  void set_has_magicword();
  void clear_has_magicword();
  void set_has_magicexpire();
  void clear_has_magicexpire();
  void set_has_magiclimit();
  void clear_has_magiclimit();
  void set_has_magicmd5();
  void clear_has_magicmd5();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr begword_;
  ::google::protobuf::internal::ArenaStringPtr begpicurl_;
  ::google::protobuf::internal::ArenaStringPtr thankspicurl_;
  ::google::protobuf::internal::ArenaStringPtr magicurl_;
  ::google::protobuf::internal::ArenaStringPtr magicword_;
  ::google::protobuf::internal::ArenaStringPtr magicmd5_;
  ::google::protobuf::uint32 magicexpire_;
  ::google::protobuf::uint32 magiclimit_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionRewardResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionRewardResponse) */ {
 public:
  GetEmotionRewardResponse();
  virtual ~GetEmotionRewardResponse();

  GetEmotionRewardResponse(const GetEmotionRewardResponse& from);

  inline GetEmotionRewardResponse& operator=(const GetEmotionRewardResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionRewardResponse& default_instance();

  static inline const GetEmotionRewardResponse* internal_default_instance() {
    return reinterpret_cast<const GetEmotionRewardResponse*>(
               &_GetEmotionRewardResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(GetEmotionRewardResponse* other);

  // implements Message ----------------------------------------------

  inline GetEmotionRewardResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionRewardResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionRewardResponse& from);
  void MergeFrom(const GetEmotionRewardResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionRewardResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.EmotionPrice Price = 2;
  int price_size() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  const ::micromsg::EmotionPrice& price(int index) const;
  ::micromsg::EmotionPrice* mutable_price(int index);
  ::micromsg::EmotionPrice* add_price();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionPrice >*
      mutable_price();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionPrice >&
      price() const;

  // repeated .micromsg.EmotionDonor Donors = 4;
  int donors_size() const;
  void clear_donors();
  static const int kDonorsFieldNumber = 4;
  const ::micromsg::EmotionDonor& donors(int index) const;
  ::micromsg::EmotionDonor* mutable_donors(int index);
  ::micromsg::EmotionDonor* add_donors();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor >*
      mutable_donors();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor >&
      donors() const;

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.EmotionReward Reward = 5;
  bool has_reward() const;
  void clear_reward();
  static const int kRewardFieldNumber = 5;
  const ::micromsg::EmotionReward& reward() const;
  ::micromsg::EmotionReward* mutable_reward();
  ::micromsg::EmotionReward* release_reward();
  void set_allocated_reward(::micromsg::EmotionReward* reward);

  // optional uint32 DonorNum = 3;
  bool has_donornum() const;
  void clear_donornum();
  static const int kDonorNumFieldNumber = 3;
  ::google::protobuf::uint32 donornum() const;
  void set_donornum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionRewardResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_donornum();
  void clear_has_donornum();
  void set_has_reward();
  void clear_has_reward();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionPrice > price_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor > donors_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::EmotionReward* reward_;
  ::google::protobuf::uint32 donornum_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionDonorListRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionDonorListRequest) */ {
 public:
  GetEmotionDonorListRequest();
  virtual ~GetEmotionDonorListRequest();

  GetEmotionDonorListRequest(const GetEmotionDonorListRequest& from);

  inline GetEmotionDonorListRequest& operator=(const GetEmotionDonorListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionDonorListRequest& default_instance();

  static inline const GetEmotionDonorListRequest* internal_default_instance() {
    return reinterpret_cast<const GetEmotionDonorListRequest*>(
               &_GetEmotionDonorListRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(GetEmotionDonorListRequest* other);

  // implements Message ----------------------------------------------

  inline GetEmotionDonorListRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionDonorListRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionDonorListRequest& from);
  void MergeFrom(const GetEmotionDonorListRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionDonorListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ProductID = 1;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 1;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required .micromsg.SKBuiltinBuffer_t ReqBuf = 2;
  bool has_reqbuf() const;
  void clear_reqbuf();
  static const int kReqBufFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& reqbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* release_reqbuf();
  void set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionDonorListRequest)
 private:
  void set_has_productid();
  void clear_has_productid();
  void set_has_reqbuf();
  void clear_has_reqbuf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::micromsg::SKBuiltinBuffer_t* reqbuf_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetEmotionDonorListResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetEmotionDonorListResponse) */ {
 public:
  GetEmotionDonorListResponse();
  virtual ~GetEmotionDonorListResponse();

  GetEmotionDonorListResponse(const GetEmotionDonorListResponse& from);

  inline GetEmotionDonorListResponse& operator=(const GetEmotionDonorListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEmotionDonorListResponse& default_instance();

  static inline const GetEmotionDonorListResponse* internal_default_instance() {
    return reinterpret_cast<const GetEmotionDonorListResponse*>(
               &_GetEmotionDonorListResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(GetEmotionDonorListResponse* other);

  // implements Message ----------------------------------------------

  inline GetEmotionDonorListResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetEmotionDonorListResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetEmotionDonorListResponse& from);
  void MergeFrom(const GetEmotionDonorListResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetEmotionDonorListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.EmotionDonor Donors = 3;
  int donors_size() const;
  void clear_donors();
  static const int kDonorsFieldNumber = 3;
  const ::micromsg::EmotionDonor& donors(int index) const;
  ::micromsg::EmotionDonor* mutable_donors(int index);
  ::micromsg::EmotionDonor* add_donors();
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor >*
      mutable_donors();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor >&
      donors() const;

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.SKBuiltinBuffer_t RespBuf = 4;
  bool has_respbuf() const;
  void clear_respbuf();
  static const int kRespBufFieldNumber = 4;
  const ::micromsg::SKBuiltinBuffer_t& respbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_respbuf();
  ::micromsg::SKBuiltinBuffer_t* release_respbuf();
  void set_allocated_respbuf(::micromsg::SKBuiltinBuffer_t* respbuf);

  // required uint32 DonorNum = 2;
  bool has_donornum() const;
  void clear_donornum();
  static const int kDonorNumFieldNumber = 2;
  ::google::protobuf::uint32 donornum() const;
  void set_donornum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetEmotionDonorListResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_donornum();
  void clear_has_donornum();
  void set_has_respbuf();
  void clear_has_respbuf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor > donors_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinBuffer_t* respbuf_;
  ::google::protobuf::uint32 donornum_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AskForRewardRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AskForRewardRequest) */ {
 public:
  AskForRewardRequest();
  virtual ~AskForRewardRequest();

  AskForRewardRequest(const AskForRewardRequest& from);

  inline AskForRewardRequest& operator=(const AskForRewardRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AskForRewardRequest& default_instance();

  static inline const AskForRewardRequest* internal_default_instance() {
    return reinterpret_cast<const AskForRewardRequest*>(
               &_AskForRewardRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(AskForRewardRequest* other);

  // implements Message ----------------------------------------------

  inline AskForRewardRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AskForRewardRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskForRewardRequest& from);
  void MergeFrom(const AskForRewardRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskForRewardRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ProductID = 1;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 1;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // required .micromsg.EmotionPrice Price = 2;
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 2;
  const ::micromsg::EmotionPrice& price() const;
  ::micromsg::EmotionPrice* mutable_price();
  ::micromsg::EmotionPrice* release_price();
  void set_allocated_price(::micromsg::EmotionPrice* price);

  // @@protoc_insertion_point(class_scope:micromsg.AskForRewardRequest)
 private:
  void set_has_productid();
  void clear_has_productid();
  void set_has_price();
  void clear_has_price();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::micromsg::EmotionPrice* price_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AskForRewardResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AskForRewardResponse) */ {
 public:
  AskForRewardResponse();
  virtual ~AskForRewardResponse();

  AskForRewardResponse(const AskForRewardResponse& from);

  inline AskForRewardResponse& operator=(const AskForRewardResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AskForRewardResponse& default_instance();

  static inline const AskForRewardResponse* internal_default_instance() {
    return reinterpret_cast<const AskForRewardResponse*>(
               &_AskForRewardResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(AskForRewardResponse* other);

  // implements Message ----------------------------------------------

  inline AskForRewardResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AskForRewardResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AskForRewardResponse& from);
  void MergeFrom(const AskForRewardResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AskForRewardResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ReqKey = 2;
  bool has_reqkey() const;
  void clear_reqkey();
  static const int kReqKeyFieldNumber = 2;
  const ::std::string& reqkey() const;
  void set_reqkey(const ::std::string& value);
  #if LANG_CXX11
  void set_reqkey(::std::string&& value);
  #endif
  void set_reqkey(const char* value);
  void set_reqkey(const char* value, size_t size);
  ::std::string* mutable_reqkey();
  ::std::string* release_reqkey();
  void set_allocated_reqkey(::std::string* reqkey);

  // required string AppID = 3;
  bool has_appid() const;
  void clear_appid();
  static const int kAppIDFieldNumber = 3;
  const ::std::string& appid() const;
  void set_appid(const ::std::string& value);
  #if LANG_CXX11
  void set_appid(::std::string&& value);
  #endif
  void set_appid(const char* value);
  void set_appid(const char* value, size_t size);
  ::std::string* mutable_appid();
  ::std::string* release_appid();
  void set_allocated_appid(::std::string* appid);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.AskForRewardResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_reqkey();
  void clear_has_reqkey();
  void set_has_appid();
  void clear_has_appid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reqkey_;
  ::google::protobuf::internal::ArenaStringPtr appid_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRewardMagicListRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetRewardMagicListRequest) */ {
 public:
  GetRewardMagicListRequest();
  virtual ~GetRewardMagicListRequest();

  GetRewardMagicListRequest(const GetRewardMagicListRequest& from);

  inline GetRewardMagicListRequest& operator=(const GetRewardMagicListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRewardMagicListRequest& default_instance();

  static inline const GetRewardMagicListRequest* internal_default_instance() {
    return reinterpret_cast<const GetRewardMagicListRequest*>(
               &_GetRewardMagicListRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(GetRewardMagicListRequest* other);

  // implements Message ----------------------------------------------

  inline GetRewardMagicListRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRewardMagicListRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRewardMagicListRequest& from);
  void MergeFrom(const GetRewardMagicListRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRewardMagicListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Scene = 1;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 1;
  ::google::protobuf::uint32 scene() const;
  void set_scene(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetRewardMagicListRequest)
 private:
  void set_has_scene();
  void clear_has_scene();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 scene_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RewardMagic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.RewardMagic) */ {
 public:
  RewardMagic();
  virtual ~RewardMagic();

  RewardMagic(const RewardMagic& from);

  inline RewardMagic& operator=(const RewardMagic& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardMagic& default_instance();

  static inline const RewardMagic* internal_default_instance() {
    return reinterpret_cast<const RewardMagic*>(
               &_RewardMagic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(RewardMagic* other);

  // implements Message ----------------------------------------------

  inline RewardMagic* New() const PROTOBUF_FINAL { return New(NULL); }

  RewardMagic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RewardMagic& from);
  void MergeFrom(const RewardMagic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RewardMagic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string MagicWord = 1;
  bool has_magicword() const;
  void clear_magicword();
  static const int kMagicWordFieldNumber = 1;
  const ::std::string& magicword() const;
  void set_magicword(const ::std::string& value);
  #if LANG_CXX11
  void set_magicword(::std::string&& value);
  #endif
  void set_magicword(const char* value);
  void set_magicword(const char* value, size_t size);
  ::std::string* mutable_magicword();
  ::std::string* release_magicword();
  void set_allocated_magicword(::std::string* magicword);

  // required string MagicUrl = 2;
  bool has_magicurl() const;
  void clear_magicurl();
  static const int kMagicUrlFieldNumber = 2;
  const ::std::string& magicurl() const;
  void set_magicurl(const ::std::string& value);
  #if LANG_CXX11
  void set_magicurl(::std::string&& value);
  #endif
  void set_magicurl(const char* value);
  void set_magicurl(const char* value, size_t size);
  ::std::string* mutable_magicurl();
  ::std::string* release_magicurl();
  void set_allocated_magicurl(::std::string* magicurl);

  // required string ProductID = 5;
  bool has_productid() const;
  void clear_productid();
  static const int kProductIDFieldNumber = 5;
  const ::std::string& productid() const;
  void set_productid(const ::std::string& value);
  #if LANG_CXX11
  void set_productid(::std::string&& value);
  #endif
  void set_productid(const char* value);
  void set_productid(const char* value, size_t size);
  ::std::string* mutable_productid();
  ::std::string* release_productid();
  void set_allocated_productid(::std::string* productid);

  // optional string Md5 = 6;
  bool has_md5() const;
  void clear_md5();
  static const int kMd5FieldNumber = 6;
  const ::std::string& md5() const;
  void set_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_md5(::std::string&& value);
  #endif
  void set_md5(const char* value);
  void set_md5(const char* value, size_t size);
  ::std::string* mutable_md5();
  ::std::string* release_md5();
  void set_allocated_md5(::std::string* md5);

  // optional uint32 MagicExpire = 3;
  bool has_magicexpire() const;
  void clear_magicexpire();
  static const int kMagicExpireFieldNumber = 3;
  ::google::protobuf::uint32 magicexpire() const;
  void set_magicexpire(::google::protobuf::uint32 value);

  // optional uint32 MagicLimit = 4;
  bool has_magiclimit() const;
  void clear_magiclimit();
  static const int kMagicLimitFieldNumber = 4;
  ::google::protobuf::uint32 magiclimit() const;
  void set_magiclimit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.RewardMagic)
 private:
  void set_has_magicword();
  void clear_has_magicword();
  void set_has_magicurl();
  void clear_has_magicurl();
  void set_has_magicexpire();
  void clear_has_magicexpire();
  void set_has_magiclimit();
  void clear_has_magiclimit();
  void set_has_productid();
  void clear_has_productid();
  void set_has_md5();
  void clear_has_md5();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr magicword_;
  ::google::protobuf::internal::ArenaStringPtr magicurl_;
  ::google::protobuf::internal::ArenaStringPtr productid_;
  ::google::protobuf::internal::ArenaStringPtr md5_;
  ::google::protobuf::uint32 magicexpire_;
  ::google::protobuf::uint32 magiclimit_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRewardMagicListResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetRewardMagicListResponse) */ {
 public:
  GetRewardMagicListResponse();
  virtual ~GetRewardMagicListResponse();

  GetRewardMagicListResponse(const GetRewardMagicListResponse& from);

  inline GetRewardMagicListResponse& operator=(const GetRewardMagicListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRewardMagicListResponse& default_instance();

  static inline const GetRewardMagicListResponse* internal_default_instance() {
    return reinterpret_cast<const GetRewardMagicListResponse*>(
               &_GetRewardMagicListResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(GetRewardMagicListResponse* other);

  // implements Message ----------------------------------------------

  inline GetRewardMagicListResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetRewardMagicListResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetRewardMagicListResponse& from);
  void MergeFrom(const GetRewardMagicListResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetRewardMagicListResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.RewardMagic Magic = 2;
  int magic_size() const;
  void clear_magic();
  static const int kMagicFieldNumber = 2;
  const ::micromsg::RewardMagic& magic(int index) const;
  ::micromsg::RewardMagic* mutable_magic(int index);
  ::micromsg::RewardMagic* add_magic();
  ::google::protobuf::RepeatedPtrField< ::micromsg::RewardMagic >*
      mutable_magic();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::RewardMagic >&
      magic() const;

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.GetRewardMagicListResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::RewardMagic > magic_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmemotionstore_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// JumpEmotionDetailRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool JumpEmotionDetailRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JumpEmotionDetailRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JumpEmotionDetailRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JumpEmotionDetailRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& JumpEmotionDetailRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.JumpEmotionDetailRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* JumpEmotionDetailRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.JumpEmotionDetailRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* JumpEmotionDetailRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.JumpEmotionDetailRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void JumpEmotionDetailRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.JumpEmotionDetailRequest.BaseRequest)
}

// required string Url = 2;
inline bool JumpEmotionDetailRequest::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JumpEmotionDetailRequest::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JumpEmotionDetailRequest::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JumpEmotionDetailRequest::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& JumpEmotionDetailRequest::url() const {
  // @@protoc_insertion_point(field_get:micromsg.JumpEmotionDetailRequest.Url)
  return url_.GetNoArena();
}
inline void JumpEmotionDetailRequest::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.JumpEmotionDetailRequest.Url)
}
#if LANG_CXX11
inline void JumpEmotionDetailRequest::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.JumpEmotionDetailRequest.Url)
}
#endif
inline void JumpEmotionDetailRequest::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.JumpEmotionDetailRequest.Url)
}
inline void JumpEmotionDetailRequest::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.JumpEmotionDetailRequest.Url)
}
inline ::std::string* JumpEmotionDetailRequest::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:micromsg.JumpEmotionDetailRequest.Url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JumpEmotionDetailRequest::release_url() {
  // @@protoc_insertion_point(field_release:micromsg.JumpEmotionDetailRequest.Url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JumpEmotionDetailRequest::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:micromsg.JumpEmotionDetailRequest.Url)
}

// -------------------------------------------------------------------

// JumpEmotionDetailResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool JumpEmotionDetailResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JumpEmotionDetailResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JumpEmotionDetailResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JumpEmotionDetailResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& JumpEmotionDetailResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.JumpEmotionDetailResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* JumpEmotionDetailResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.JumpEmotionDetailResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* JumpEmotionDetailResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.JumpEmotionDetailResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void JumpEmotionDetailResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.JumpEmotionDetailResponse.BaseResponse)
}

// optional string ProductID = 2;
inline bool JumpEmotionDetailResponse::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JumpEmotionDetailResponse::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JumpEmotionDetailResponse::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JumpEmotionDetailResponse::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& JumpEmotionDetailResponse::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.JumpEmotionDetailResponse.ProductID)
  return productid_.GetNoArena();
}
inline void JumpEmotionDetailResponse::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.JumpEmotionDetailResponse.ProductID)
}
#if LANG_CXX11
inline void JumpEmotionDetailResponse::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.JumpEmotionDetailResponse.ProductID)
}
#endif
inline void JumpEmotionDetailResponse::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.JumpEmotionDetailResponse.ProductID)
}
inline void JumpEmotionDetailResponse::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.JumpEmotionDetailResponse.ProductID)
}
inline ::std::string* JumpEmotionDetailResponse::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.JumpEmotionDetailResponse.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JumpEmotionDetailResponse::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.JumpEmotionDetailResponse.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JumpEmotionDetailResponse::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.JumpEmotionDetailResponse.ProductID)
}

// -------------------------------------------------------------------

// BatchEmojiBackupRequest

// repeated string Md5List = 1;
inline int BatchEmojiBackupRequest::md5list_size() const {
  return md5list_.size();
}
inline void BatchEmojiBackupRequest::clear_md5list() {
  md5list_.Clear();
}
inline const ::std::string& BatchEmojiBackupRequest::md5list(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.BatchEmojiBackupRequest.Md5List)
  return md5list_.Get(index);
}
inline ::std::string* BatchEmojiBackupRequest::mutable_md5list(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.BatchEmojiBackupRequest.Md5List)
  return md5list_.Mutable(index);
}
inline void BatchEmojiBackupRequest::set_md5list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:micromsg.BatchEmojiBackupRequest.Md5List)
  md5list_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BatchEmojiBackupRequest::set_md5list(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:micromsg.BatchEmojiBackupRequest.Md5List)
  md5list_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BatchEmojiBackupRequest::set_md5list(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  md5list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:micromsg.BatchEmojiBackupRequest.Md5List)
}
inline void BatchEmojiBackupRequest::set_md5list(int index, const char* value, size_t size) {
  md5list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:micromsg.BatchEmojiBackupRequest.Md5List)
}
inline ::std::string* BatchEmojiBackupRequest::add_md5list() {
  // @@protoc_insertion_point(field_add_mutable:micromsg.BatchEmojiBackupRequest.Md5List)
  return md5list_.Add();
}
inline void BatchEmojiBackupRequest::add_md5list(const ::std::string& value) {
  md5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:micromsg.BatchEmojiBackupRequest.Md5List)
}
#if LANG_CXX11
inline void BatchEmojiBackupRequest::add_md5list(::std::string&& value) {
  md5list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:micromsg.BatchEmojiBackupRequest.Md5List)
}
#endif
inline void BatchEmojiBackupRequest::add_md5list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  md5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:micromsg.BatchEmojiBackupRequest.Md5List)
}
inline void BatchEmojiBackupRequest::add_md5list(const char* value, size_t size) {
  md5list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:micromsg.BatchEmojiBackupRequest.Md5List)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchEmojiBackupRequest::md5list() const {
  // @@protoc_insertion_point(field_list:micromsg.BatchEmojiBackupRequest.Md5List)
  return md5list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchEmojiBackupRequest::mutable_md5list() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.BatchEmojiBackupRequest.Md5List)
  return &md5list_;
}

// -------------------------------------------------------------------

// BatchEmojiBackupResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BatchEmojiBackupResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchEmojiBackupResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchEmojiBackupResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchEmojiBackupResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BatchEmojiBackupResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BatchEmojiBackupResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BatchEmojiBackupResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BatchEmojiBackupResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BatchEmojiBackupResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BatchEmojiBackupResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BatchEmojiBackupResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BatchEmojiBackupResponse.BaseResponse)
}

// repeated string NeedUploadMd5List = 2;
inline int BatchEmojiBackupResponse::needuploadmd5list_size() const {
  return needuploadmd5list_.size();
}
inline void BatchEmojiBackupResponse::clear_needuploadmd5list() {
  needuploadmd5list_.Clear();
}
inline const ::std::string& BatchEmojiBackupResponse::needuploadmd5list(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
  return needuploadmd5list_.Get(index);
}
inline ::std::string* BatchEmojiBackupResponse::mutable_needuploadmd5list(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
  return needuploadmd5list_.Mutable(index);
}
inline void BatchEmojiBackupResponse::set_needuploadmd5list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
  needuploadmd5list_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BatchEmojiBackupResponse::set_needuploadmd5list(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
  needuploadmd5list_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BatchEmojiBackupResponse::set_needuploadmd5list(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  needuploadmd5list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
}
inline void BatchEmojiBackupResponse::set_needuploadmd5list(int index, const char* value, size_t size) {
  needuploadmd5list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
}
inline ::std::string* BatchEmojiBackupResponse::add_needuploadmd5list() {
  // @@protoc_insertion_point(field_add_mutable:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
  return needuploadmd5list_.Add();
}
inline void BatchEmojiBackupResponse::add_needuploadmd5list(const ::std::string& value) {
  needuploadmd5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
}
#if LANG_CXX11
inline void BatchEmojiBackupResponse::add_needuploadmd5list(::std::string&& value) {
  needuploadmd5list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
}
#endif
inline void BatchEmojiBackupResponse::add_needuploadmd5list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  needuploadmd5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
}
inline void BatchEmojiBackupResponse::add_needuploadmd5list(const char* value, size_t size) {
  needuploadmd5list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchEmojiBackupResponse::needuploadmd5list() const {
  // @@protoc_insertion_point(field_list:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
  return needuploadmd5list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchEmojiBackupResponse::mutable_needuploadmd5list() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.BatchEmojiBackupResponse.NeedUploadMd5List)
  return &needuploadmd5list_;
}

// -------------------------------------------------------------------

// BatchEmojiDownLoadRequest

// required uint32 Index = 1;
inline bool BatchEmojiDownLoadRequest::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchEmojiDownLoadRequest::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchEmojiDownLoadRequest::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchEmojiDownLoadRequest::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 BatchEmojiDownLoadRequest::index() const {
  // @@protoc_insertion_point(field_get:micromsg.BatchEmojiDownLoadRequest.Index)
  return index_;
}
inline void BatchEmojiDownLoadRequest::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BatchEmojiDownLoadRequest.Index)
}

// -------------------------------------------------------------------

// EmojiInfo

// required string Md5 = 1;
inline bool EmojiInfo::has_md5() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmojiInfo::set_has_md5() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmojiInfo::clear_has_md5() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmojiInfo::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_md5();
}
inline const ::std::string& EmojiInfo::md5() const {
  // @@protoc_insertion_point(field_get:micromsg.EmojiInfo.Md5)
  return md5_.GetNoArena();
}
inline void EmojiInfo::set_md5(const ::std::string& value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmojiInfo.Md5)
}
#if LANG_CXX11
inline void EmojiInfo::set_md5(::std::string&& value) {
  set_has_md5();
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmojiInfo.Md5)
}
#endif
inline void EmojiInfo::set_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmojiInfo.Md5)
}
inline void EmojiInfo::set_md5(const char* value, size_t size) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmojiInfo.Md5)
}
inline ::std::string* EmojiInfo::mutable_md5() {
  set_has_md5();
  // @@protoc_insertion_point(field_mutable:micromsg.EmojiInfo.Md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmojiInfo::release_md5() {
  // @@protoc_insertion_point(field_release:micromsg.EmojiInfo.Md5)
  clear_has_md5();
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmojiInfo::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    set_has_md5();
  } else {
    clear_has_md5();
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmojiInfo.Md5)
}

// optional string Url = 2;
inline bool EmojiInfo::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmojiInfo::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmojiInfo::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmojiInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& EmojiInfo::url() const {
  // @@protoc_insertion_point(field_get:micromsg.EmojiInfo.Url)
  return url_.GetNoArena();
}
inline void EmojiInfo::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmojiInfo.Url)
}
#if LANG_CXX11
inline void EmojiInfo::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmojiInfo.Url)
}
#endif
inline void EmojiInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmojiInfo.Url)
}
inline void EmojiInfo::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmojiInfo.Url)
}
inline ::std::string* EmojiInfo::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:micromsg.EmojiInfo.Url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmojiInfo::release_url() {
  // @@protoc_insertion_point(field_release:micromsg.EmojiInfo.Url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmojiInfo::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmojiInfo.Url)
}

// -------------------------------------------------------------------

// BatchEmojiDownLoadResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BatchEmojiDownLoadResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchEmojiDownLoadResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchEmojiDownLoadResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchEmojiDownLoadResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BatchEmojiDownLoadResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BatchEmojiDownLoadResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BatchEmojiDownLoadResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BatchEmojiDownLoadResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BatchEmojiDownLoadResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BatchEmojiDownLoadResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BatchEmojiDownLoadResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BatchEmojiDownLoadResponse.BaseResponse)
}

// required uint32 Index = 2;
inline bool BatchEmojiDownLoadResponse::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchEmojiDownLoadResponse::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchEmojiDownLoadResponse::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchEmojiDownLoadResponse::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 BatchEmojiDownLoadResponse::index() const {
  // @@protoc_insertion_point(field_get:micromsg.BatchEmojiDownLoadResponse.Index)
  return index_;
}
inline void BatchEmojiDownLoadResponse::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BatchEmojiDownLoadResponse.Index)
}

// repeated string Md5List = 3;
inline int BatchEmojiDownLoadResponse::md5list_size() const {
  return md5list_.size();
}
inline void BatchEmojiDownLoadResponse::clear_md5list() {
  md5list_.Clear();
}
inline const ::std::string& BatchEmojiDownLoadResponse::md5list(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.BatchEmojiDownLoadResponse.Md5List)
  return md5list_.Get(index);
}
inline ::std::string* BatchEmojiDownLoadResponse::mutable_md5list(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.BatchEmojiDownLoadResponse.Md5List)
  return md5list_.Mutable(index);
}
inline void BatchEmojiDownLoadResponse::set_md5list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:micromsg.BatchEmojiDownLoadResponse.Md5List)
  md5list_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BatchEmojiDownLoadResponse::set_md5list(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:micromsg.BatchEmojiDownLoadResponse.Md5List)
  md5list_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BatchEmojiDownLoadResponse::set_md5list(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  md5list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:micromsg.BatchEmojiDownLoadResponse.Md5List)
}
inline void BatchEmojiDownLoadResponse::set_md5list(int index, const char* value, size_t size) {
  md5list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:micromsg.BatchEmojiDownLoadResponse.Md5List)
}
inline ::std::string* BatchEmojiDownLoadResponse::add_md5list() {
  // @@protoc_insertion_point(field_add_mutable:micromsg.BatchEmojiDownLoadResponse.Md5List)
  return md5list_.Add();
}
inline void BatchEmojiDownLoadResponse::add_md5list(const ::std::string& value) {
  md5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:micromsg.BatchEmojiDownLoadResponse.Md5List)
}
#if LANG_CXX11
inline void BatchEmojiDownLoadResponse::add_md5list(::std::string&& value) {
  md5list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:micromsg.BatchEmojiDownLoadResponse.Md5List)
}
#endif
inline void BatchEmojiDownLoadResponse::add_md5list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  md5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:micromsg.BatchEmojiDownLoadResponse.Md5List)
}
inline void BatchEmojiDownLoadResponse::add_md5list(const char* value, size_t size) {
  md5list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:micromsg.BatchEmojiDownLoadResponse.Md5List)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchEmojiDownLoadResponse::md5list() const {
  // @@protoc_insertion_point(field_list:micromsg.BatchEmojiDownLoadResponse.Md5List)
  return md5list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchEmojiDownLoadResponse::mutable_md5list() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.BatchEmojiDownLoadResponse.Md5List)
  return &md5list_;
}

// required uint32 EndFlag = 4;
inline bool BatchEmojiDownLoadResponse::has_endflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatchEmojiDownLoadResponse::set_has_endflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatchEmojiDownLoadResponse::clear_has_endflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatchEmojiDownLoadResponse::clear_endflag() {
  endflag_ = 0u;
  clear_has_endflag();
}
inline ::google::protobuf::uint32 BatchEmojiDownLoadResponse::endflag() const {
  // @@protoc_insertion_point(field_get:micromsg.BatchEmojiDownLoadResponse.EndFlag)
  return endflag_;
}
inline void BatchEmojiDownLoadResponse::set_endflag(::google::protobuf::uint32 value) {
  set_has_endflag();
  endflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BatchEmojiDownLoadResponse.EndFlag)
}

// repeated .micromsg.EmojiInfo EmojiList = 5;
inline int BatchEmojiDownLoadResponse::emojilist_size() const {
  return emojilist_.size();
}
inline void BatchEmojiDownLoadResponse::clear_emojilist() {
  emojilist_.Clear();
}
inline const ::micromsg::EmojiInfo& BatchEmojiDownLoadResponse::emojilist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.BatchEmojiDownLoadResponse.EmojiList)
  return emojilist_.Get(index);
}
inline ::micromsg::EmojiInfo* BatchEmojiDownLoadResponse::mutable_emojilist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.BatchEmojiDownLoadResponse.EmojiList)
  return emojilist_.Mutable(index);
}
inline ::micromsg::EmojiInfo* BatchEmojiDownLoadResponse::add_emojilist() {
  // @@protoc_insertion_point(field_add:micromsg.BatchEmojiDownLoadResponse.EmojiList)
  return emojilist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmojiInfo >*
BatchEmojiDownLoadResponse::mutable_emojilist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.BatchEmojiDownLoadResponse.EmojiList)
  return &emojilist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmojiInfo >&
BatchEmojiDownLoadResponse::emojilist() const {
  // @@protoc_insertion_point(field_list:micromsg.BatchEmojiDownLoadResponse.EmojiList)
  return emojilist_;
}

// -------------------------------------------------------------------

// BackupEmojiOperateRequest

// repeated string Md5List = 1;
inline int BackupEmojiOperateRequest::md5list_size() const {
  return md5list_.size();
}
inline void BackupEmojiOperateRequest::clear_md5list() {
  md5list_.Clear();
}
inline const ::std::string& BackupEmojiOperateRequest::md5list(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.BackupEmojiOperateRequest.Md5List)
  return md5list_.Get(index);
}
inline ::std::string* BackupEmojiOperateRequest::mutable_md5list(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.BackupEmojiOperateRequest.Md5List)
  return md5list_.Mutable(index);
}
inline void BackupEmojiOperateRequest::set_md5list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:micromsg.BackupEmojiOperateRequest.Md5List)
  md5list_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BackupEmojiOperateRequest::set_md5list(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:micromsg.BackupEmojiOperateRequest.Md5List)
  md5list_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BackupEmojiOperateRequest::set_md5list(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  md5list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:micromsg.BackupEmojiOperateRequest.Md5List)
}
inline void BackupEmojiOperateRequest::set_md5list(int index, const char* value, size_t size) {
  md5list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:micromsg.BackupEmojiOperateRequest.Md5List)
}
inline ::std::string* BackupEmojiOperateRequest::add_md5list() {
  // @@protoc_insertion_point(field_add_mutable:micromsg.BackupEmojiOperateRequest.Md5List)
  return md5list_.Add();
}
inline void BackupEmojiOperateRequest::add_md5list(const ::std::string& value) {
  md5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:micromsg.BackupEmojiOperateRequest.Md5List)
}
#if LANG_CXX11
inline void BackupEmojiOperateRequest::add_md5list(::std::string&& value) {
  md5list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:micromsg.BackupEmojiOperateRequest.Md5List)
}
#endif
inline void BackupEmojiOperateRequest::add_md5list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  md5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:micromsg.BackupEmojiOperateRequest.Md5List)
}
inline void BackupEmojiOperateRequest::add_md5list(const char* value, size_t size) {
  md5list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:micromsg.BackupEmojiOperateRequest.Md5List)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BackupEmojiOperateRequest::md5list() const {
  // @@protoc_insertion_point(field_list:micromsg.BackupEmojiOperateRequest.Md5List)
  return md5list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BackupEmojiOperateRequest::mutable_md5list() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.BackupEmojiOperateRequest.Md5List)
  return &md5list_;
}

// required uint32 Opcode = 2;
inline bool BackupEmojiOperateRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BackupEmojiOperateRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BackupEmojiOperateRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BackupEmojiOperateRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 BackupEmojiOperateRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.BackupEmojiOperateRequest.Opcode)
  return opcode_;
}
inline void BackupEmojiOperateRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BackupEmojiOperateRequest.Opcode)
}

// -------------------------------------------------------------------

// BackupEmojiOperateResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BackupEmojiOperateResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BackupEmojiOperateResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BackupEmojiOperateResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BackupEmojiOperateResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BackupEmojiOperateResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BackupEmojiOperateResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BackupEmojiOperateResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BackupEmojiOperateResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BackupEmojiOperateResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BackupEmojiOperateResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BackupEmojiOperateResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BackupEmojiOperateResponse.BaseResponse)
}

// repeated string NeedUploadMd5List = 2;
inline int BackupEmojiOperateResponse::needuploadmd5list_size() const {
  return needuploadmd5list_.size();
}
inline void BackupEmojiOperateResponse::clear_needuploadmd5list() {
  needuploadmd5list_.Clear();
}
inline const ::std::string& BackupEmojiOperateResponse::needuploadmd5list(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
  return needuploadmd5list_.Get(index);
}
inline ::std::string* BackupEmojiOperateResponse::mutable_needuploadmd5list(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
  return needuploadmd5list_.Mutable(index);
}
inline void BackupEmojiOperateResponse::set_needuploadmd5list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
  needuploadmd5list_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BackupEmojiOperateResponse::set_needuploadmd5list(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
  needuploadmd5list_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BackupEmojiOperateResponse::set_needuploadmd5list(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  needuploadmd5list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
}
inline void BackupEmojiOperateResponse::set_needuploadmd5list(int index, const char* value, size_t size) {
  needuploadmd5list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
}
inline ::std::string* BackupEmojiOperateResponse::add_needuploadmd5list() {
  // @@protoc_insertion_point(field_add_mutable:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
  return needuploadmd5list_.Add();
}
inline void BackupEmojiOperateResponse::add_needuploadmd5list(const ::std::string& value) {
  needuploadmd5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
}
#if LANG_CXX11
inline void BackupEmojiOperateResponse::add_needuploadmd5list(::std::string&& value) {
  needuploadmd5list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
}
#endif
inline void BackupEmojiOperateResponse::add_needuploadmd5list(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  needuploadmd5list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
}
inline void BackupEmojiOperateResponse::add_needuploadmd5list(const char* value, size_t size) {
  needuploadmd5list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BackupEmojiOperateResponse::needuploadmd5list() const {
  // @@protoc_insertion_point(field_list:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
  return needuploadmd5list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BackupEmojiOperateResponse::mutable_needuploadmd5list() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.BackupEmojiOperateResponse.NeedUploadMd5List)
  return &needuploadmd5list_;
}

// -------------------------------------------------------------------

// UploadEmojiInfoReq

// optional string MD5 = 1;
inline bool UploadEmojiInfoReq::has_md5() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadEmojiInfoReq::set_has_md5() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadEmojiInfoReq::clear_has_md5() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadEmojiInfoReq::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_md5();
}
inline const ::std::string& UploadEmojiInfoReq::md5() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadEmojiInfoReq.MD5)
  return md5_.GetNoArena();
}
inline void UploadEmojiInfoReq::set_md5(const ::std::string& value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.UploadEmojiInfoReq.MD5)
}
#if LANG_CXX11
inline void UploadEmojiInfoReq::set_md5(::std::string&& value) {
  set_has_md5();
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.UploadEmojiInfoReq.MD5)
}
#endif
inline void UploadEmojiInfoReq::set_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.UploadEmojiInfoReq.MD5)
}
inline void UploadEmojiInfoReq::set_md5(const char* value, size_t size) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.UploadEmojiInfoReq.MD5)
}
inline ::std::string* UploadEmojiInfoReq::mutable_md5() {
  set_has_md5();
  // @@protoc_insertion_point(field_mutable:micromsg.UploadEmojiInfoReq.MD5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UploadEmojiInfoReq::release_md5() {
  // @@protoc_insertion_point(field_release:micromsg.UploadEmojiInfoReq.MD5)
  clear_has_md5();
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadEmojiInfoReq::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    set_has_md5();
  } else {
    clear_has_md5();
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:micromsg.UploadEmojiInfoReq.MD5)
}

// required int32 StartPos = 2;
inline bool UploadEmojiInfoReq::has_startpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UploadEmojiInfoReq::set_has_startpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UploadEmojiInfoReq::clear_has_startpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UploadEmojiInfoReq::clear_startpos() {
  startpos_ = 0;
  clear_has_startpos();
}
inline ::google::protobuf::int32 UploadEmojiInfoReq::startpos() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadEmojiInfoReq.StartPos)
  return startpos_;
}
inline void UploadEmojiInfoReq::set_startpos(::google::protobuf::int32 value) {
  set_has_startpos();
  startpos_ = value;
  // @@protoc_insertion_point(field_set:micromsg.UploadEmojiInfoReq.StartPos)
}

// required int32 TotalLen = 3;
inline bool UploadEmojiInfoReq::has_totallen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UploadEmojiInfoReq::set_has_totallen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UploadEmojiInfoReq::clear_has_totallen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UploadEmojiInfoReq::clear_totallen() {
  totallen_ = 0;
  clear_has_totallen();
}
inline ::google::protobuf::int32 UploadEmojiInfoReq::totallen() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadEmojiInfoReq.TotalLen)
  return totallen_;
}
inline void UploadEmojiInfoReq::set_totallen(::google::protobuf::int32 value) {
  set_has_totallen();
  totallen_ = value;
  // @@protoc_insertion_point(field_set:micromsg.UploadEmojiInfoReq.TotalLen)
}

// required bytes EmojiBuffer = 4;
inline bool UploadEmojiInfoReq::has_emojibuffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadEmojiInfoReq::set_has_emojibuffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadEmojiInfoReq::clear_has_emojibuffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadEmojiInfoReq::clear_emojibuffer() {
  emojibuffer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_emojibuffer();
}
inline const ::std::string& UploadEmojiInfoReq::emojibuffer() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadEmojiInfoReq.EmojiBuffer)
  return emojibuffer_.GetNoArena();
}
inline void UploadEmojiInfoReq::set_emojibuffer(const ::std::string& value) {
  set_has_emojibuffer();
  emojibuffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.UploadEmojiInfoReq.EmojiBuffer)
}
#if LANG_CXX11
inline void UploadEmojiInfoReq::set_emojibuffer(::std::string&& value) {
  set_has_emojibuffer();
  emojibuffer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.UploadEmojiInfoReq.EmojiBuffer)
}
#endif
inline void UploadEmojiInfoReq::set_emojibuffer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_emojibuffer();
  emojibuffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.UploadEmojiInfoReq.EmojiBuffer)
}
inline void UploadEmojiInfoReq::set_emojibuffer(const void* value, size_t size) {
  set_has_emojibuffer();
  emojibuffer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.UploadEmojiInfoReq.EmojiBuffer)
}
inline ::std::string* UploadEmojiInfoReq::mutable_emojibuffer() {
  set_has_emojibuffer();
  // @@protoc_insertion_point(field_mutable:micromsg.UploadEmojiInfoReq.EmojiBuffer)
  return emojibuffer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UploadEmojiInfoReq::release_emojibuffer() {
  // @@protoc_insertion_point(field_release:micromsg.UploadEmojiInfoReq.EmojiBuffer)
  clear_has_emojibuffer();
  return emojibuffer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadEmojiInfoReq::set_allocated_emojibuffer(::std::string* emojibuffer) {
  if (emojibuffer != NULL) {
    set_has_emojibuffer();
  } else {
    clear_has_emojibuffer();
  }
  emojibuffer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), emojibuffer);
  // @@protoc_insertion_point(field_set_allocated:micromsg.UploadEmojiInfoReq.EmojiBuffer)
}

// -------------------------------------------------------------------

// EmojiUploadRequest

// repeated .micromsg.UploadEmojiInfoReq EmojiItem = 1;
inline int EmojiUploadRequest::emojiitem_size() const {
  return emojiitem_.size();
}
inline void EmojiUploadRequest::clear_emojiitem() {
  emojiitem_.Clear();
}
inline const ::micromsg::UploadEmojiInfoReq& EmojiUploadRequest::emojiitem(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.EmojiUploadRequest.EmojiItem)
  return emojiitem_.Get(index);
}
inline ::micromsg::UploadEmojiInfoReq* EmojiUploadRequest::mutable_emojiitem(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.EmojiUploadRequest.EmojiItem)
  return emojiitem_.Mutable(index);
}
inline ::micromsg::UploadEmojiInfoReq* EmojiUploadRequest::add_emojiitem() {
  // @@protoc_insertion_point(field_add:micromsg.EmojiUploadRequest.EmojiItem)
  return emojiitem_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoReq >*
EmojiUploadRequest::mutable_emojiitem() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.EmojiUploadRequest.EmojiItem)
  return &emojiitem_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoReq >&
EmojiUploadRequest::emojiitem() const {
  // @@protoc_insertion_point(field_list:micromsg.EmojiUploadRequest.EmojiItem)
  return emojiitem_;
}

// optional uint32 ReqTime = 2;
inline bool EmojiUploadRequest::has_reqtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmojiUploadRequest::set_has_reqtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmojiUploadRequest::clear_has_reqtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmojiUploadRequest::clear_reqtime() {
  reqtime_ = 0u;
  clear_has_reqtime();
}
inline ::google::protobuf::uint32 EmojiUploadRequest::reqtime() const {
  // @@protoc_insertion_point(field_get:micromsg.EmojiUploadRequest.ReqTime)
  return reqtime_;
}
inline void EmojiUploadRequest::set_reqtime(::google::protobuf::uint32 value) {
  set_has_reqtime();
  reqtime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmojiUploadRequest.ReqTime)
}

// -------------------------------------------------------------------

// UploadEmojiInfoResp

// required int32 Ret = 1;
inline bool UploadEmojiInfoResp::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UploadEmojiInfoResp::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UploadEmojiInfoResp::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UploadEmojiInfoResp::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 UploadEmojiInfoResp::ret() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadEmojiInfoResp.Ret)
  return ret_;
}
inline void UploadEmojiInfoResp::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:micromsg.UploadEmojiInfoResp.Ret)
}

// required int32 StartPos = 2;
inline bool UploadEmojiInfoResp::has_startpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UploadEmojiInfoResp::set_has_startpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UploadEmojiInfoResp::clear_has_startpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UploadEmojiInfoResp::clear_startpos() {
  startpos_ = 0;
  clear_has_startpos();
}
inline ::google::protobuf::int32 UploadEmojiInfoResp::startpos() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadEmojiInfoResp.StartPos)
  return startpos_;
}
inline void UploadEmojiInfoResp::set_startpos(::google::protobuf::int32 value) {
  set_has_startpos();
  startpos_ = value;
  // @@protoc_insertion_point(field_set:micromsg.UploadEmojiInfoResp.StartPos)
}

// required int32 TotalLen = 3;
inline bool UploadEmojiInfoResp::has_totallen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UploadEmojiInfoResp::set_has_totallen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UploadEmojiInfoResp::clear_has_totallen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UploadEmojiInfoResp::clear_totallen() {
  totallen_ = 0;
  clear_has_totallen();
}
inline ::google::protobuf::int32 UploadEmojiInfoResp::totallen() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadEmojiInfoResp.TotalLen)
  return totallen_;
}
inline void UploadEmojiInfoResp::set_totallen(::google::protobuf::int32 value) {
  set_has_totallen();
  totallen_ = value;
  // @@protoc_insertion_point(field_set:micromsg.UploadEmojiInfoResp.TotalLen)
}

// optional string MD5 = 4;
inline bool UploadEmojiInfoResp::has_md5() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadEmojiInfoResp::set_has_md5() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadEmojiInfoResp::clear_has_md5() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadEmojiInfoResp::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_md5();
}
inline const ::std::string& UploadEmojiInfoResp::md5() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadEmojiInfoResp.MD5)
  return md5_.GetNoArena();
}
inline void UploadEmojiInfoResp::set_md5(const ::std::string& value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.UploadEmojiInfoResp.MD5)
}
#if LANG_CXX11
inline void UploadEmojiInfoResp::set_md5(::std::string&& value) {
  set_has_md5();
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.UploadEmojiInfoResp.MD5)
}
#endif
inline void UploadEmojiInfoResp::set_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.UploadEmojiInfoResp.MD5)
}
inline void UploadEmojiInfoResp::set_md5(const char* value, size_t size) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.UploadEmojiInfoResp.MD5)
}
inline ::std::string* UploadEmojiInfoResp::mutable_md5() {
  set_has_md5();
  // @@protoc_insertion_point(field_mutable:micromsg.UploadEmojiInfoResp.MD5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UploadEmojiInfoResp::release_md5() {
  // @@protoc_insertion_point(field_release:micromsg.UploadEmojiInfoResp.MD5)
  clear_has_md5();
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UploadEmojiInfoResp::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    set_has_md5();
  } else {
    clear_has_md5();
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:micromsg.UploadEmojiInfoResp.MD5)
}

// -------------------------------------------------------------------

// EmojiUploadResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool EmojiUploadResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmojiUploadResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmojiUploadResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmojiUploadResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& EmojiUploadResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.EmojiUploadResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* EmojiUploadResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmojiUploadResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* EmojiUploadResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.EmojiUploadResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void EmojiUploadResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmojiUploadResponse.BaseResponse)
}

// repeated .micromsg.UploadEmojiInfoResp EmojiItem = 2;
inline int EmojiUploadResponse::emojiitem_size() const {
  return emojiitem_.size();
}
inline void EmojiUploadResponse::clear_emojiitem() {
  emojiitem_.Clear();
}
inline const ::micromsg::UploadEmojiInfoResp& EmojiUploadResponse::emojiitem(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.EmojiUploadResponse.EmojiItem)
  return emojiitem_.Get(index);
}
inline ::micromsg::UploadEmojiInfoResp* EmojiUploadResponse::mutable_emojiitem(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.EmojiUploadResponse.EmojiItem)
  return emojiitem_.Mutable(index);
}
inline ::micromsg::UploadEmojiInfoResp* EmojiUploadResponse::add_emojiitem() {
  // @@protoc_insertion_point(field_add:micromsg.EmojiUploadResponse.EmojiItem)
  return emojiitem_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoResp >*
EmojiUploadResponse::mutable_emojiitem() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.EmojiUploadResponse.EmojiItem)
  return &emojiitem_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::UploadEmojiInfoResp >&
EmojiUploadResponse::emojiitem() const {
  // @@protoc_insertion_point(field_list:micromsg.EmojiUploadResponse.EmojiItem)
  return emojiitem_;
}

// -------------------------------------------------------------------

// UploadMyPanelListRequest

// required uint32 OpCode = 1;
inline bool UploadMyPanelListRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadMyPanelListRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadMyPanelListRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadMyPanelListRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 UploadMyPanelListRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadMyPanelListRequest.OpCode)
  return opcode_;
}
inline void UploadMyPanelListRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.UploadMyPanelListRequest.OpCode)
}

// repeated string ProductIDList = 2;
inline int UploadMyPanelListRequest::productidlist_size() const {
  return productidlist_.size();
}
inline void UploadMyPanelListRequest::clear_productidlist() {
  productidlist_.Clear();
}
inline const ::std::string& UploadMyPanelListRequest::productidlist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.UploadMyPanelListRequest.ProductIDList)
  return productidlist_.Get(index);
}
inline ::std::string* UploadMyPanelListRequest::mutable_productidlist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.UploadMyPanelListRequest.ProductIDList)
  return productidlist_.Mutable(index);
}
inline void UploadMyPanelListRequest::set_productidlist(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:micromsg.UploadMyPanelListRequest.ProductIDList)
  productidlist_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void UploadMyPanelListRequest::set_productidlist(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:micromsg.UploadMyPanelListRequest.ProductIDList)
  productidlist_.Mutable(index)->assign(std::move(value));
}
#endif
inline void UploadMyPanelListRequest::set_productidlist(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productidlist_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:micromsg.UploadMyPanelListRequest.ProductIDList)
}
inline void UploadMyPanelListRequest::set_productidlist(int index, const char* value, size_t size) {
  productidlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:micromsg.UploadMyPanelListRequest.ProductIDList)
}
inline ::std::string* UploadMyPanelListRequest::add_productidlist() {
  // @@protoc_insertion_point(field_add_mutable:micromsg.UploadMyPanelListRequest.ProductIDList)
  return productidlist_.Add();
}
inline void UploadMyPanelListRequest::add_productidlist(const ::std::string& value) {
  productidlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:micromsg.UploadMyPanelListRequest.ProductIDList)
}
#if LANG_CXX11
inline void UploadMyPanelListRequest::add_productidlist(::std::string&& value) {
  productidlist_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:micromsg.UploadMyPanelListRequest.ProductIDList)
}
#endif
inline void UploadMyPanelListRequest::add_productidlist(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  productidlist_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:micromsg.UploadMyPanelListRequest.ProductIDList)
}
inline void UploadMyPanelListRequest::add_productidlist(const char* value, size_t size) {
  productidlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:micromsg.UploadMyPanelListRequest.ProductIDList)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UploadMyPanelListRequest::productidlist() const {
  // @@protoc_insertion_point(field_list:micromsg.UploadMyPanelListRequest.ProductIDList)
  return productidlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UploadMyPanelListRequest::mutable_productidlist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.UploadMyPanelListRequest.ProductIDList)
  return &productidlist_;
}

// -------------------------------------------------------------------

// UploadMyPanelListResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool UploadMyPanelListResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UploadMyPanelListResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UploadMyPanelListResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UploadMyPanelListResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& UploadMyPanelListResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.UploadMyPanelListResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* UploadMyPanelListResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UploadMyPanelListResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* UploadMyPanelListResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.UploadMyPanelListResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void UploadMyPanelListResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UploadMyPanelListResponse.BaseResponse)
}

// -------------------------------------------------------------------

// GetPersonalDesignerRequest

// required uint32 DesignerUin = 1;
inline bool GetPersonalDesignerRequest::has_designeruin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPersonalDesignerRequest::set_has_designeruin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPersonalDesignerRequest::clear_has_designeruin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPersonalDesignerRequest::clear_designeruin() {
  designeruin_ = 0u;
  clear_has_designeruin();
}
inline ::google::protobuf::uint32 GetPersonalDesignerRequest::designeruin() const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerRequest.DesignerUin)
  return designeruin_;
}
inline void GetPersonalDesignerRequest::set_designeruin(::google::protobuf::uint32 value) {
  set_has_designeruin();
  designeruin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetPersonalDesignerRequest.DesignerUin)
}

// required .micromsg.SKBuiltinBuffer_t ReqBuf = 2;
inline bool GetPersonalDesignerRequest::has_reqbuf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPersonalDesignerRequest::set_has_reqbuf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPersonalDesignerRequest::clear_has_reqbuf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPersonalDesignerRequest::clear_reqbuf() {
  if (reqbuf_ != NULL) reqbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_reqbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetPersonalDesignerRequest::reqbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerRequest.ReqBuf)
  return reqbuf_ != NULL ? *reqbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetPersonalDesignerRequest::mutable_reqbuf() {
  set_has_reqbuf();
  if (reqbuf_ == NULL) {
    reqbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetPersonalDesignerRequest.ReqBuf)
  return reqbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetPersonalDesignerRequest::release_reqbuf() {
  // @@protoc_insertion_point(field_release:micromsg.GetPersonalDesignerRequest.ReqBuf)
  clear_has_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = reqbuf_;
  reqbuf_ = NULL;
  return temp;
}
inline void GetPersonalDesignerRequest::set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf) {
  delete reqbuf_;
  reqbuf_ = reqbuf;
  if (reqbuf) {
    set_has_reqbuf();
  } else {
    clear_has_reqbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetPersonalDesignerRequest.ReqBuf)
}

// -------------------------------------------------------------------

// GetPersonalDesignerResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetPersonalDesignerResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetPersonalDesignerResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetPersonalDesignerResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetPersonalDesignerResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetPersonalDesignerResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetPersonalDesignerResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetPersonalDesignerResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetPersonalDesignerResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetPersonalDesignerResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetPersonalDesignerResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetPersonalDesignerResponse.BaseResponse)
}

// required string BannerUrl = 2;
inline bool GetPersonalDesignerResponse::has_bannerurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPersonalDesignerResponse::set_has_bannerurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPersonalDesignerResponse::clear_has_bannerurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPersonalDesignerResponse::clear_bannerurl() {
  bannerurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bannerurl();
}
inline const ::std::string& GetPersonalDesignerResponse::bannerurl() const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerResponse.BannerUrl)
  return bannerurl_.GetNoArena();
}
inline void GetPersonalDesignerResponse::set_bannerurl(const ::std::string& value) {
  set_has_bannerurl();
  bannerurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetPersonalDesignerResponse.BannerUrl)
}
#if LANG_CXX11
inline void GetPersonalDesignerResponse::set_bannerurl(::std::string&& value) {
  set_has_bannerurl();
  bannerurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetPersonalDesignerResponse.BannerUrl)
}
#endif
inline void GetPersonalDesignerResponse::set_bannerurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bannerurl();
  bannerurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetPersonalDesignerResponse.BannerUrl)
}
inline void GetPersonalDesignerResponse::set_bannerurl(const char* value, size_t size) {
  set_has_bannerurl();
  bannerurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetPersonalDesignerResponse.BannerUrl)
}
inline ::std::string* GetPersonalDesignerResponse::mutable_bannerurl() {
  set_has_bannerurl();
  // @@protoc_insertion_point(field_mutable:micromsg.GetPersonalDesignerResponse.BannerUrl)
  return bannerurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPersonalDesignerResponse::release_bannerurl() {
  // @@protoc_insertion_point(field_release:micromsg.GetPersonalDesignerResponse.BannerUrl)
  clear_has_bannerurl();
  return bannerurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPersonalDesignerResponse::set_allocated_bannerurl(::std::string* bannerurl) {
  if (bannerurl != NULL) {
    set_has_bannerurl();
  } else {
    clear_has_bannerurl();
  }
  bannerurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bannerurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetPersonalDesignerResponse.BannerUrl)
}

// required string Name = 3;
inline bool GetPersonalDesignerResponse::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPersonalDesignerResponse::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPersonalDesignerResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPersonalDesignerResponse::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GetPersonalDesignerResponse::name() const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerResponse.Name)
  return name_.GetNoArena();
}
inline void GetPersonalDesignerResponse::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetPersonalDesignerResponse.Name)
}
#if LANG_CXX11
inline void GetPersonalDesignerResponse::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetPersonalDesignerResponse.Name)
}
#endif
inline void GetPersonalDesignerResponse::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetPersonalDesignerResponse.Name)
}
inline void GetPersonalDesignerResponse::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetPersonalDesignerResponse.Name)
}
inline ::std::string* GetPersonalDesignerResponse::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:micromsg.GetPersonalDesignerResponse.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPersonalDesignerResponse::release_name() {
  // @@protoc_insertion_point(field_release:micromsg.GetPersonalDesignerResponse.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPersonalDesignerResponse::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetPersonalDesignerResponse.Name)
}

// required string Desc = 4;
inline bool GetPersonalDesignerResponse::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPersonalDesignerResponse::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPersonalDesignerResponse::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPersonalDesignerResponse::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& GetPersonalDesignerResponse::desc() const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerResponse.Desc)
  return desc_.GetNoArena();
}
inline void GetPersonalDesignerResponse::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetPersonalDesignerResponse.Desc)
}
#if LANG_CXX11
inline void GetPersonalDesignerResponse::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetPersonalDesignerResponse.Desc)
}
#endif
inline void GetPersonalDesignerResponse::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetPersonalDesignerResponse.Desc)
}
inline void GetPersonalDesignerResponse::set_desc(const char* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetPersonalDesignerResponse.Desc)
}
inline ::std::string* GetPersonalDesignerResponse::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:micromsg.GetPersonalDesignerResponse.Desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPersonalDesignerResponse::release_desc() {
  // @@protoc_insertion_point(field_release:micromsg.GetPersonalDesignerResponse.Desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPersonalDesignerResponse::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetPersonalDesignerResponse.Desc)
}

// required string HeadUrl = 5;
inline bool GetPersonalDesignerResponse::has_headurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetPersonalDesignerResponse::set_has_headurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetPersonalDesignerResponse::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetPersonalDesignerResponse::clear_headurl() {
  headurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headurl();
}
inline const ::std::string& GetPersonalDesignerResponse::headurl() const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerResponse.HeadUrl)
  return headurl_.GetNoArena();
}
inline void GetPersonalDesignerResponse::set_headurl(const ::std::string& value) {
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetPersonalDesignerResponse.HeadUrl)
}
#if LANG_CXX11
inline void GetPersonalDesignerResponse::set_headurl(::std::string&& value) {
  set_has_headurl();
  headurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetPersonalDesignerResponse.HeadUrl)
}
#endif
inline void GetPersonalDesignerResponse::set_headurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetPersonalDesignerResponse.HeadUrl)
}
inline void GetPersonalDesignerResponse::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetPersonalDesignerResponse.HeadUrl)
}
inline ::std::string* GetPersonalDesignerResponse::mutable_headurl() {
  set_has_headurl();
  // @@protoc_insertion_point(field_mutable:micromsg.GetPersonalDesignerResponse.HeadUrl)
  return headurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPersonalDesignerResponse::release_headurl() {
  // @@protoc_insertion_point(field_release:micromsg.GetPersonalDesignerResponse.HeadUrl)
  clear_has_headurl();
  return headurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPersonalDesignerResponse::set_allocated_headurl(::std::string* headurl) {
  if (headurl != NULL) {
    set_has_headurl();
  } else {
    clear_has_headurl();
  }
  headurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetPersonalDesignerResponse.HeadUrl)
}

// required string BizName = 6;
inline bool GetPersonalDesignerResponse::has_bizname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetPersonalDesignerResponse::set_has_bizname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetPersonalDesignerResponse::clear_has_bizname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetPersonalDesignerResponse::clear_bizname() {
  bizname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bizname();
}
inline const ::std::string& GetPersonalDesignerResponse::bizname() const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerResponse.BizName)
  return bizname_.GetNoArena();
}
inline void GetPersonalDesignerResponse::set_bizname(const ::std::string& value) {
  set_has_bizname();
  bizname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetPersonalDesignerResponse.BizName)
}
#if LANG_CXX11
inline void GetPersonalDesignerResponse::set_bizname(::std::string&& value) {
  set_has_bizname();
  bizname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetPersonalDesignerResponse.BizName)
}
#endif
inline void GetPersonalDesignerResponse::set_bizname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bizname();
  bizname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetPersonalDesignerResponse.BizName)
}
inline void GetPersonalDesignerResponse::set_bizname(const char* value, size_t size) {
  set_has_bizname();
  bizname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetPersonalDesignerResponse.BizName)
}
inline ::std::string* GetPersonalDesignerResponse::mutable_bizname() {
  set_has_bizname();
  // @@protoc_insertion_point(field_mutable:micromsg.GetPersonalDesignerResponse.BizName)
  return bizname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPersonalDesignerResponse::release_bizname() {
  // @@protoc_insertion_point(field_release:micromsg.GetPersonalDesignerResponse.BizName)
  clear_has_bizname();
  return bizname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPersonalDesignerResponse::set_allocated_bizname(::std::string* bizname) {
  if (bizname != NULL) {
    set_has_bizname();
  } else {
    clear_has_bizname();
  }
  bizname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bizname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetPersonalDesignerResponse.BizName)
}

// repeated .micromsg.EmotionSummary EmotionList = 7;
inline int GetPersonalDesignerResponse::emotionlist_size() const {
  return emotionlist_.size();
}
inline void GetPersonalDesignerResponse::clear_emotionlist() {
  emotionlist_.Clear();
}
inline const ::micromsg::EmotionSummary& GetPersonalDesignerResponse::emotionlist(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerResponse.EmotionList)
  return emotionlist_.Get(index);
}
inline ::micromsg::EmotionSummary* GetPersonalDesignerResponse::mutable_emotionlist(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetPersonalDesignerResponse.EmotionList)
  return emotionlist_.Mutable(index);
}
inline ::micromsg::EmotionSummary* GetPersonalDesignerResponse::add_emotionlist() {
  // @@protoc_insertion_point(field_add:micromsg.GetPersonalDesignerResponse.EmotionList)
  return emotionlist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary >*
GetPersonalDesignerResponse::mutable_emotionlist() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetPersonalDesignerResponse.EmotionList)
  return &emotionlist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionSummary >&
GetPersonalDesignerResponse::emotionlist() const {
  // @@protoc_insertion_point(field_list:micromsg.GetPersonalDesignerResponse.EmotionList)
  return emotionlist_;
}

// required .micromsg.SKBuiltinBuffer_t ReqBuf = 8;
inline bool GetPersonalDesignerResponse::has_reqbuf() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetPersonalDesignerResponse::set_has_reqbuf() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetPersonalDesignerResponse::clear_has_reqbuf() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetPersonalDesignerResponse::clear_reqbuf() {
  if (reqbuf_ != NULL) reqbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_reqbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetPersonalDesignerResponse::reqbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.GetPersonalDesignerResponse.ReqBuf)
  return reqbuf_ != NULL ? *reqbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetPersonalDesignerResponse::mutable_reqbuf() {
  set_has_reqbuf();
  if (reqbuf_ == NULL) {
    reqbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetPersonalDesignerResponse.ReqBuf)
  return reqbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetPersonalDesignerResponse::release_reqbuf() {
  // @@protoc_insertion_point(field_release:micromsg.GetPersonalDesignerResponse.ReqBuf)
  clear_has_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = reqbuf_;
  reqbuf_ = NULL;
  return temp;
}
inline void GetPersonalDesignerResponse::set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf) {
  delete reqbuf_;
  reqbuf_ = reqbuf;
  if (reqbuf) {
    set_has_reqbuf();
  } else {
    clear_has_reqbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetPersonalDesignerResponse.ReqBuf)
}

// -------------------------------------------------------------------

// GetEmotionRewardRequest

// required string ProductID = 1;
inline bool GetEmotionRewardRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionRewardRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionRewardRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionRewardRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& GetEmotionRewardRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionRewardRequest.ProductID)
  return productid_.GetNoArena();
}
inline void GetEmotionRewardRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionRewardRequest.ProductID)
}
#if LANG_CXX11
inline void GetEmotionRewardRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetEmotionRewardRequest.ProductID)
}
#endif
inline void GetEmotionRewardRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetEmotionRewardRequest.ProductID)
}
inline void GetEmotionRewardRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetEmotionRewardRequest.ProductID)
}
inline ::std::string* GetEmotionRewardRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionRewardRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetEmotionRewardRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionRewardRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetEmotionRewardRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionRewardRequest.ProductID)
}

// required uint32 OpCode = 2;
inline bool GetEmotionRewardRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionRewardRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionRewardRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionRewardRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 GetEmotionRewardRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionRewardRequest.OpCode)
  return opcode_;
}
inline void GetEmotionRewardRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionRewardRequest.OpCode)
}

// -------------------------------------------------------------------

// EmotionPrice

// required string Label = 1;
inline bool EmotionPrice::has_label() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionPrice::set_has_label() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionPrice::clear_has_label() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionPrice::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& EmotionPrice::label() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionPrice.Label)
  return label_.GetNoArena();
}
inline void EmotionPrice::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionPrice.Label)
}
#if LANG_CXX11
inline void EmotionPrice::set_label(::std::string&& value) {
  set_has_label();
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionPrice.Label)
}
#endif
inline void EmotionPrice::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionPrice.Label)
}
inline void EmotionPrice::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionPrice.Label)
}
inline ::std::string* EmotionPrice::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionPrice.Label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionPrice::release_label() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionPrice.Label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionPrice::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionPrice.Label)
}

// required string Number = 2;
inline bool EmotionPrice::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmotionPrice::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmotionPrice::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmotionPrice::clear_number() {
  number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_number();
}
inline const ::std::string& EmotionPrice::number() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionPrice.Number)
  return number_.GetNoArena();
}
inline void EmotionPrice::set_number(const ::std::string& value) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionPrice.Number)
}
#if LANG_CXX11
inline void EmotionPrice::set_number(::std::string&& value) {
  set_has_number();
  number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionPrice.Number)
}
#endif
inline void EmotionPrice::set_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionPrice.Number)
}
inline void EmotionPrice::set_number(const char* value, size_t size) {
  set_has_number();
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionPrice.Number)
}
inline ::std::string* EmotionPrice::mutable_number() {
  set_has_number();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionPrice.Number)
  return number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionPrice::release_number() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionPrice.Number)
  clear_has_number();
  return number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionPrice::set_allocated_number(::std::string* number) {
  if (number != NULL) {
    set_has_number();
  } else {
    clear_has_number();
  }
  number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionPrice.Number)
}

// required string Type = 3;
inline bool EmotionPrice::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmotionPrice::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmotionPrice::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmotionPrice::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& EmotionPrice::type() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionPrice.Type)
  return type_.GetNoArena();
}
inline void EmotionPrice::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionPrice.Type)
}
#if LANG_CXX11
inline void EmotionPrice::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionPrice.Type)
}
#endif
inline void EmotionPrice::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionPrice.Type)
}
inline void EmotionPrice::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionPrice.Type)
}
inline ::std::string* EmotionPrice::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionPrice.Type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionPrice::release_type() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionPrice.Type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionPrice::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionPrice.Type)
}

// -------------------------------------------------------------------

// EmotionDonor

// required string HeadUrl = 1;
inline bool EmotionDonor::has_headurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionDonor::set_has_headurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionDonor::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionDonor::clear_headurl() {
  headurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headurl();
}
inline const ::std::string& EmotionDonor::headurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionDonor.HeadUrl)
  return headurl_.GetNoArena();
}
inline void EmotionDonor::set_headurl(const ::std::string& value) {
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionDonor.HeadUrl)
}
#if LANG_CXX11
inline void EmotionDonor::set_headurl(::std::string&& value) {
  set_has_headurl();
  headurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionDonor.HeadUrl)
}
#endif
inline void EmotionDonor::set_headurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionDonor.HeadUrl)
}
inline void EmotionDonor::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  headurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionDonor.HeadUrl)
}
inline ::std::string* EmotionDonor::mutable_headurl() {
  set_has_headurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionDonor.HeadUrl)
  return headurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionDonor::release_headurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionDonor.HeadUrl)
  clear_has_headurl();
  return headurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionDonor::set_allocated_headurl(::std::string* headurl) {
  if (headurl != NULL) {
    set_has_headurl();
  } else {
    clear_has_headurl();
  }
  headurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionDonor.HeadUrl)
}

// -------------------------------------------------------------------

// EmotionReward

// required string BegWord = 1;
inline bool EmotionReward::has_begword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmotionReward::set_has_begword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmotionReward::clear_has_begword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmotionReward::clear_begword() {
  begword_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_begword();
}
inline const ::std::string& EmotionReward::begword() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionReward.BegWord)
  return begword_.GetNoArena();
}
inline void EmotionReward::set_begword(const ::std::string& value) {
  set_has_begword();
  begword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionReward.BegWord)
}
#if LANG_CXX11
inline void EmotionReward::set_begword(::std::string&& value) {
  set_has_begword();
  begword_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionReward.BegWord)
}
#endif
inline void EmotionReward::set_begword(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_begword();
  begword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionReward.BegWord)
}
inline void EmotionReward::set_begword(const char* value, size_t size) {
  set_has_begword();
  begword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionReward.BegWord)
}
inline ::std::string* EmotionReward::mutable_begword() {
  set_has_begword();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionReward.BegWord)
  return begword_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionReward::release_begword() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionReward.BegWord)
  clear_has_begword();
  return begword_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionReward::set_allocated_begword(::std::string* begword) {
  if (begword != NULL) {
    set_has_begword();
  } else {
    clear_has_begword();
  }
  begword_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), begword);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionReward.BegWord)
}

// required string BegPicUrl = 2;
inline bool EmotionReward::has_begpicurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmotionReward::set_has_begpicurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmotionReward::clear_has_begpicurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmotionReward::clear_begpicurl() {
  begpicurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_begpicurl();
}
inline const ::std::string& EmotionReward::begpicurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionReward.BegPicUrl)
  return begpicurl_.GetNoArena();
}
inline void EmotionReward::set_begpicurl(const ::std::string& value) {
  set_has_begpicurl();
  begpicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionReward.BegPicUrl)
}
#if LANG_CXX11
inline void EmotionReward::set_begpicurl(::std::string&& value) {
  set_has_begpicurl();
  begpicurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionReward.BegPicUrl)
}
#endif
inline void EmotionReward::set_begpicurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_begpicurl();
  begpicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionReward.BegPicUrl)
}
inline void EmotionReward::set_begpicurl(const char* value, size_t size) {
  set_has_begpicurl();
  begpicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionReward.BegPicUrl)
}
inline ::std::string* EmotionReward::mutable_begpicurl() {
  set_has_begpicurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionReward.BegPicUrl)
  return begpicurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionReward::release_begpicurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionReward.BegPicUrl)
  clear_has_begpicurl();
  return begpicurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionReward::set_allocated_begpicurl(::std::string* begpicurl) {
  if (begpicurl != NULL) {
    set_has_begpicurl();
  } else {
    clear_has_begpicurl();
  }
  begpicurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), begpicurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionReward.BegPicUrl)
}

// required string ThanksPicUrl = 3;
inline bool EmotionReward::has_thankspicurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmotionReward::set_has_thankspicurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmotionReward::clear_has_thankspicurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmotionReward::clear_thankspicurl() {
  thankspicurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_thankspicurl();
}
inline const ::std::string& EmotionReward::thankspicurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionReward.ThanksPicUrl)
  return thankspicurl_.GetNoArena();
}
inline void EmotionReward::set_thankspicurl(const ::std::string& value) {
  set_has_thankspicurl();
  thankspicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionReward.ThanksPicUrl)
}
#if LANG_CXX11
inline void EmotionReward::set_thankspicurl(::std::string&& value) {
  set_has_thankspicurl();
  thankspicurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionReward.ThanksPicUrl)
}
#endif
inline void EmotionReward::set_thankspicurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_thankspicurl();
  thankspicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionReward.ThanksPicUrl)
}
inline void EmotionReward::set_thankspicurl(const char* value, size_t size) {
  set_has_thankspicurl();
  thankspicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionReward.ThanksPicUrl)
}
inline ::std::string* EmotionReward::mutable_thankspicurl() {
  set_has_thankspicurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionReward.ThanksPicUrl)
  return thankspicurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionReward::release_thankspicurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionReward.ThanksPicUrl)
  clear_has_thankspicurl();
  return thankspicurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionReward::set_allocated_thankspicurl(::std::string* thankspicurl) {
  if (thankspicurl != NULL) {
    set_has_thankspicurl();
  } else {
    clear_has_thankspicurl();
  }
  thankspicurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thankspicurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionReward.ThanksPicUrl)
}

// optional string MagicUrl = 4;
inline bool EmotionReward::has_magicurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmotionReward::set_has_magicurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmotionReward::clear_has_magicurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmotionReward::clear_magicurl() {
  magicurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_magicurl();
}
inline const ::std::string& EmotionReward::magicurl() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionReward.MagicUrl)
  return magicurl_.GetNoArena();
}
inline void EmotionReward::set_magicurl(const ::std::string& value) {
  set_has_magicurl();
  magicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionReward.MagicUrl)
}
#if LANG_CXX11
inline void EmotionReward::set_magicurl(::std::string&& value) {
  set_has_magicurl();
  magicurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionReward.MagicUrl)
}
#endif
inline void EmotionReward::set_magicurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_magicurl();
  magicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionReward.MagicUrl)
}
inline void EmotionReward::set_magicurl(const char* value, size_t size) {
  set_has_magicurl();
  magicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionReward.MagicUrl)
}
inline ::std::string* EmotionReward::mutable_magicurl() {
  set_has_magicurl();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionReward.MagicUrl)
  return magicurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionReward::release_magicurl() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionReward.MagicUrl)
  clear_has_magicurl();
  return magicurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionReward::set_allocated_magicurl(::std::string* magicurl) {
  if (magicurl != NULL) {
    set_has_magicurl();
  } else {
    clear_has_magicurl();
  }
  magicurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), magicurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionReward.MagicUrl)
}

// optional string MagicWord = 5;
inline bool EmotionReward::has_magicword() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmotionReward::set_has_magicword() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmotionReward::clear_has_magicword() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmotionReward::clear_magicword() {
  magicword_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_magicword();
}
inline const ::std::string& EmotionReward::magicword() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionReward.MagicWord)
  return magicword_.GetNoArena();
}
inline void EmotionReward::set_magicword(const ::std::string& value) {
  set_has_magicword();
  magicword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionReward.MagicWord)
}
#if LANG_CXX11
inline void EmotionReward::set_magicword(::std::string&& value) {
  set_has_magicword();
  magicword_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionReward.MagicWord)
}
#endif
inline void EmotionReward::set_magicword(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_magicword();
  magicword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionReward.MagicWord)
}
inline void EmotionReward::set_magicword(const char* value, size_t size) {
  set_has_magicword();
  magicword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionReward.MagicWord)
}
inline ::std::string* EmotionReward::mutable_magicword() {
  set_has_magicword();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionReward.MagicWord)
  return magicword_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionReward::release_magicword() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionReward.MagicWord)
  clear_has_magicword();
  return magicword_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionReward::set_allocated_magicword(::std::string* magicword) {
  if (magicword != NULL) {
    set_has_magicword();
  } else {
    clear_has_magicword();
  }
  magicword_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), magicword);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionReward.MagicWord)
}

// optional uint32 MagicExpire = 6;
inline bool EmotionReward::has_magicexpire() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmotionReward::set_has_magicexpire() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmotionReward::clear_has_magicexpire() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmotionReward::clear_magicexpire() {
  magicexpire_ = 0u;
  clear_has_magicexpire();
}
inline ::google::protobuf::uint32 EmotionReward::magicexpire() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionReward.MagicExpire)
  return magicexpire_;
}
inline void EmotionReward::set_magicexpire(::google::protobuf::uint32 value) {
  set_has_magicexpire();
  magicexpire_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionReward.MagicExpire)
}

// optional uint32 MagicLimit = 7;
inline bool EmotionReward::has_magiclimit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmotionReward::set_has_magiclimit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmotionReward::clear_has_magiclimit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmotionReward::clear_magiclimit() {
  magiclimit_ = 0u;
  clear_has_magiclimit();
}
inline ::google::protobuf::uint32 EmotionReward::magiclimit() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionReward.MagicLimit)
  return magiclimit_;
}
inline void EmotionReward::set_magiclimit(::google::protobuf::uint32 value) {
  set_has_magiclimit();
  magiclimit_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmotionReward.MagicLimit)
}

// optional string MagicMd5 = 8;
inline bool EmotionReward::has_magicmd5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmotionReward::set_has_magicmd5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmotionReward::clear_has_magicmd5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmotionReward::clear_magicmd5() {
  magicmd5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_magicmd5();
}
inline const ::std::string& EmotionReward::magicmd5() const {
  // @@protoc_insertion_point(field_get:micromsg.EmotionReward.MagicMd5)
  return magicmd5_.GetNoArena();
}
inline void EmotionReward::set_magicmd5(const ::std::string& value) {
  set_has_magicmd5();
  magicmd5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmotionReward.MagicMd5)
}
#if LANG_CXX11
inline void EmotionReward::set_magicmd5(::std::string&& value) {
  set_has_magicmd5();
  magicmd5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmotionReward.MagicMd5)
}
#endif
inline void EmotionReward::set_magicmd5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_magicmd5();
  magicmd5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmotionReward.MagicMd5)
}
inline void EmotionReward::set_magicmd5(const char* value, size_t size) {
  set_has_magicmd5();
  magicmd5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmotionReward.MagicMd5)
}
inline ::std::string* EmotionReward::mutable_magicmd5() {
  set_has_magicmd5();
  // @@protoc_insertion_point(field_mutable:micromsg.EmotionReward.MagicMd5)
  return magicmd5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmotionReward::release_magicmd5() {
  // @@protoc_insertion_point(field_release:micromsg.EmotionReward.MagicMd5)
  clear_has_magicmd5();
  return magicmd5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmotionReward::set_allocated_magicmd5(::std::string* magicmd5) {
  if (magicmd5 != NULL) {
    set_has_magicmd5();
  } else {
    clear_has_magicmd5();
  }
  magicmd5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), magicmd5);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmotionReward.MagicMd5)
}

// -------------------------------------------------------------------

// GetEmotionRewardResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetEmotionRewardResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionRewardResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionRewardResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionRewardResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetEmotionRewardResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionRewardResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetEmotionRewardResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionRewardResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetEmotionRewardResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionRewardResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetEmotionRewardResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionRewardResponse.BaseResponse)
}

// repeated .micromsg.EmotionPrice Price = 2;
inline int GetEmotionRewardResponse::price_size() const {
  return price_.size();
}
inline void GetEmotionRewardResponse::clear_price() {
  price_.Clear();
}
inline const ::micromsg::EmotionPrice& GetEmotionRewardResponse::price(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionRewardResponse.Price)
  return price_.Get(index);
}
inline ::micromsg::EmotionPrice* GetEmotionRewardResponse::mutable_price(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionRewardResponse.Price)
  return price_.Mutable(index);
}
inline ::micromsg::EmotionPrice* GetEmotionRewardResponse::add_price() {
  // @@protoc_insertion_point(field_add:micromsg.GetEmotionRewardResponse.Price)
  return price_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionPrice >*
GetEmotionRewardResponse::mutable_price() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetEmotionRewardResponse.Price)
  return &price_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionPrice >&
GetEmotionRewardResponse::price() const {
  // @@protoc_insertion_point(field_list:micromsg.GetEmotionRewardResponse.Price)
  return price_;
}

// optional uint32 DonorNum = 3;
inline bool GetEmotionRewardResponse::has_donornum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetEmotionRewardResponse::set_has_donornum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetEmotionRewardResponse::clear_has_donornum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetEmotionRewardResponse::clear_donornum() {
  donornum_ = 0u;
  clear_has_donornum();
}
inline ::google::protobuf::uint32 GetEmotionRewardResponse::donornum() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionRewardResponse.DonorNum)
  return donornum_;
}
inline void GetEmotionRewardResponse::set_donornum(::google::protobuf::uint32 value) {
  set_has_donornum();
  donornum_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionRewardResponse.DonorNum)
}

// repeated .micromsg.EmotionDonor Donors = 4;
inline int GetEmotionRewardResponse::donors_size() const {
  return donors_.size();
}
inline void GetEmotionRewardResponse::clear_donors() {
  donors_.Clear();
}
inline const ::micromsg::EmotionDonor& GetEmotionRewardResponse::donors(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionRewardResponse.Donors)
  return donors_.Get(index);
}
inline ::micromsg::EmotionDonor* GetEmotionRewardResponse::mutable_donors(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionRewardResponse.Donors)
  return donors_.Mutable(index);
}
inline ::micromsg::EmotionDonor* GetEmotionRewardResponse::add_donors() {
  // @@protoc_insertion_point(field_add:micromsg.GetEmotionRewardResponse.Donors)
  return donors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor >*
GetEmotionRewardResponse::mutable_donors() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetEmotionRewardResponse.Donors)
  return &donors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor >&
GetEmotionRewardResponse::donors() const {
  // @@protoc_insertion_point(field_list:micromsg.GetEmotionRewardResponse.Donors)
  return donors_;
}

// optional .micromsg.EmotionReward Reward = 5;
inline bool GetEmotionRewardResponse::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionRewardResponse::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionRewardResponse::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionRewardResponse::clear_reward() {
  if (reward_ != NULL) reward_->::micromsg::EmotionReward::Clear();
  clear_has_reward();
}
inline const ::micromsg::EmotionReward& GetEmotionRewardResponse::reward() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionRewardResponse.Reward)
  return reward_ != NULL ? *reward_
                         : *::micromsg::EmotionReward::internal_default_instance();
}
inline ::micromsg::EmotionReward* GetEmotionRewardResponse::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) {
    reward_ = new ::micromsg::EmotionReward;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionRewardResponse.Reward)
  return reward_;
}
inline ::micromsg::EmotionReward* GetEmotionRewardResponse::release_reward() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionRewardResponse.Reward)
  clear_has_reward();
  ::micromsg::EmotionReward* temp = reward_;
  reward_ = NULL;
  return temp;
}
inline void GetEmotionRewardResponse::set_allocated_reward(::micromsg::EmotionReward* reward) {
  delete reward_;
  reward_ = reward;
  if (reward) {
    set_has_reward();
  } else {
    clear_has_reward();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionRewardResponse.Reward)
}

// -------------------------------------------------------------------

// GetEmotionDonorListRequest

// required string ProductID = 1;
inline bool GetEmotionDonorListRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionDonorListRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionDonorListRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionDonorListRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& GetEmotionDonorListRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDonorListRequest.ProductID)
  return productid_.GetNoArena();
}
inline void GetEmotionDonorListRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDonorListRequest.ProductID)
}
#if LANG_CXX11
inline void GetEmotionDonorListRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetEmotionDonorListRequest.ProductID)
}
#endif
inline void GetEmotionDonorListRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetEmotionDonorListRequest.ProductID)
}
inline void GetEmotionDonorListRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetEmotionDonorListRequest.ProductID)
}
inline ::std::string* GetEmotionDonorListRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDonorListRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetEmotionDonorListRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDonorListRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetEmotionDonorListRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDonorListRequest.ProductID)
}

// required .micromsg.SKBuiltinBuffer_t ReqBuf = 2;
inline bool GetEmotionDonorListRequest::has_reqbuf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionDonorListRequest::set_has_reqbuf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionDonorListRequest::clear_has_reqbuf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionDonorListRequest::clear_reqbuf() {
  if (reqbuf_ != NULL) reqbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_reqbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetEmotionDonorListRequest::reqbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDonorListRequest.ReqBuf)
  return reqbuf_ != NULL ? *reqbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetEmotionDonorListRequest::mutable_reqbuf() {
  set_has_reqbuf();
  if (reqbuf_ == NULL) {
    reqbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDonorListRequest.ReqBuf)
  return reqbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetEmotionDonorListRequest::release_reqbuf() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDonorListRequest.ReqBuf)
  clear_has_reqbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = reqbuf_;
  reqbuf_ = NULL;
  return temp;
}
inline void GetEmotionDonorListRequest::set_allocated_reqbuf(::micromsg::SKBuiltinBuffer_t* reqbuf) {
  delete reqbuf_;
  reqbuf_ = reqbuf;
  if (reqbuf) {
    set_has_reqbuf();
  } else {
    clear_has_reqbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDonorListRequest.ReqBuf)
}

// -------------------------------------------------------------------

// GetEmotionDonorListResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetEmotionDonorListResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEmotionDonorListResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEmotionDonorListResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEmotionDonorListResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetEmotionDonorListResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDonorListResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetEmotionDonorListResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDonorListResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetEmotionDonorListResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDonorListResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetEmotionDonorListResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDonorListResponse.BaseResponse)
}

// required uint32 DonorNum = 2;
inline bool GetEmotionDonorListResponse::has_donornum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetEmotionDonorListResponse::set_has_donornum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetEmotionDonorListResponse::clear_has_donornum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetEmotionDonorListResponse::clear_donornum() {
  donornum_ = 0u;
  clear_has_donornum();
}
inline ::google::protobuf::uint32 GetEmotionDonorListResponse::donornum() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDonorListResponse.DonorNum)
  return donornum_;
}
inline void GetEmotionDonorListResponse::set_donornum(::google::protobuf::uint32 value) {
  set_has_donornum();
  donornum_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetEmotionDonorListResponse.DonorNum)
}

// repeated .micromsg.EmotionDonor Donors = 3;
inline int GetEmotionDonorListResponse::donors_size() const {
  return donors_.size();
}
inline void GetEmotionDonorListResponse::clear_donors() {
  donors_.Clear();
}
inline const ::micromsg::EmotionDonor& GetEmotionDonorListResponse::donors(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDonorListResponse.Donors)
  return donors_.Get(index);
}
inline ::micromsg::EmotionDonor* GetEmotionDonorListResponse::mutable_donors(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDonorListResponse.Donors)
  return donors_.Mutable(index);
}
inline ::micromsg::EmotionDonor* GetEmotionDonorListResponse::add_donors() {
  // @@protoc_insertion_point(field_add:micromsg.GetEmotionDonorListResponse.Donors)
  return donors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor >*
GetEmotionDonorListResponse::mutable_donors() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetEmotionDonorListResponse.Donors)
  return &donors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::EmotionDonor >&
GetEmotionDonorListResponse::donors() const {
  // @@protoc_insertion_point(field_list:micromsg.GetEmotionDonorListResponse.Donors)
  return donors_;
}

// optional .micromsg.SKBuiltinBuffer_t RespBuf = 4;
inline bool GetEmotionDonorListResponse::has_respbuf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEmotionDonorListResponse::set_has_respbuf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEmotionDonorListResponse::clear_has_respbuf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEmotionDonorListResponse::clear_respbuf() {
  if (respbuf_ != NULL) respbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_respbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetEmotionDonorListResponse::respbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.GetEmotionDonorListResponse.RespBuf)
  return respbuf_ != NULL ? *respbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetEmotionDonorListResponse::mutable_respbuf() {
  set_has_respbuf();
  if (respbuf_ == NULL) {
    respbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetEmotionDonorListResponse.RespBuf)
  return respbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetEmotionDonorListResponse::release_respbuf() {
  // @@protoc_insertion_point(field_release:micromsg.GetEmotionDonorListResponse.RespBuf)
  clear_has_respbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = respbuf_;
  respbuf_ = NULL;
  return temp;
}
inline void GetEmotionDonorListResponse::set_allocated_respbuf(::micromsg::SKBuiltinBuffer_t* respbuf) {
  delete respbuf_;
  respbuf_ = respbuf;
  if (respbuf) {
    set_has_respbuf();
  } else {
    clear_has_respbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetEmotionDonorListResponse.RespBuf)
}

// -------------------------------------------------------------------

// AskForRewardRequest

// required string ProductID = 1;
inline bool AskForRewardRequest::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskForRewardRequest::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskForRewardRequest::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskForRewardRequest::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& AskForRewardRequest::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.AskForRewardRequest.ProductID)
  return productid_.GetNoArena();
}
inline void AskForRewardRequest::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AskForRewardRequest.ProductID)
}
#if LANG_CXX11
inline void AskForRewardRequest::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AskForRewardRequest.ProductID)
}
#endif
inline void AskForRewardRequest::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AskForRewardRequest.ProductID)
}
inline void AskForRewardRequest::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AskForRewardRequest.ProductID)
}
inline ::std::string* AskForRewardRequest::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.AskForRewardRequest.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AskForRewardRequest::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.AskForRewardRequest.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AskForRewardRequest::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AskForRewardRequest.ProductID)
}

// required .micromsg.EmotionPrice Price = 2;
inline bool AskForRewardRequest::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskForRewardRequest::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AskForRewardRequest::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AskForRewardRequest::clear_price() {
  if (price_ != NULL) price_->::micromsg::EmotionPrice::Clear();
  clear_has_price();
}
inline const ::micromsg::EmotionPrice& AskForRewardRequest::price() const {
  // @@protoc_insertion_point(field_get:micromsg.AskForRewardRequest.Price)
  return price_ != NULL ? *price_
                         : *::micromsg::EmotionPrice::internal_default_instance();
}
inline ::micromsg::EmotionPrice* AskForRewardRequest::mutable_price() {
  set_has_price();
  if (price_ == NULL) {
    price_ = new ::micromsg::EmotionPrice;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AskForRewardRequest.Price)
  return price_;
}
inline ::micromsg::EmotionPrice* AskForRewardRequest::release_price() {
  // @@protoc_insertion_point(field_release:micromsg.AskForRewardRequest.Price)
  clear_has_price();
  ::micromsg::EmotionPrice* temp = price_;
  price_ = NULL;
  return temp;
}
inline void AskForRewardRequest::set_allocated_price(::micromsg::EmotionPrice* price) {
  delete price_;
  price_ = price;
  if (price) {
    set_has_price();
  } else {
    clear_has_price();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AskForRewardRequest.Price)
}

// -------------------------------------------------------------------

// AskForRewardResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool AskForRewardResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AskForRewardResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AskForRewardResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AskForRewardResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& AskForRewardResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.AskForRewardResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* AskForRewardResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AskForRewardResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* AskForRewardResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.AskForRewardResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void AskForRewardResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AskForRewardResponse.BaseResponse)
}

// required string ReqKey = 2;
inline bool AskForRewardResponse::has_reqkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AskForRewardResponse::set_has_reqkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AskForRewardResponse::clear_has_reqkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AskForRewardResponse::clear_reqkey() {
  reqkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reqkey();
}
inline const ::std::string& AskForRewardResponse::reqkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AskForRewardResponse.ReqKey)
  return reqkey_.GetNoArena();
}
inline void AskForRewardResponse::set_reqkey(const ::std::string& value) {
  set_has_reqkey();
  reqkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AskForRewardResponse.ReqKey)
}
#if LANG_CXX11
inline void AskForRewardResponse::set_reqkey(::std::string&& value) {
  set_has_reqkey();
  reqkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AskForRewardResponse.ReqKey)
}
#endif
inline void AskForRewardResponse::set_reqkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reqkey();
  reqkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AskForRewardResponse.ReqKey)
}
inline void AskForRewardResponse::set_reqkey(const char* value, size_t size) {
  set_has_reqkey();
  reqkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AskForRewardResponse.ReqKey)
}
inline ::std::string* AskForRewardResponse::mutable_reqkey() {
  set_has_reqkey();
  // @@protoc_insertion_point(field_mutable:micromsg.AskForRewardResponse.ReqKey)
  return reqkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AskForRewardResponse::release_reqkey() {
  // @@protoc_insertion_point(field_release:micromsg.AskForRewardResponse.ReqKey)
  clear_has_reqkey();
  return reqkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AskForRewardResponse::set_allocated_reqkey(::std::string* reqkey) {
  if (reqkey != NULL) {
    set_has_reqkey();
  } else {
    clear_has_reqkey();
  }
  reqkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reqkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AskForRewardResponse.ReqKey)
}

// required string AppID = 3;
inline bool AskForRewardResponse::has_appid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AskForRewardResponse::set_has_appid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AskForRewardResponse::clear_has_appid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AskForRewardResponse::clear_appid() {
  appid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_appid();
}
inline const ::std::string& AskForRewardResponse::appid() const {
  // @@protoc_insertion_point(field_get:micromsg.AskForRewardResponse.AppID)
  return appid_.GetNoArena();
}
inline void AskForRewardResponse::set_appid(const ::std::string& value) {
  set_has_appid();
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AskForRewardResponse.AppID)
}
#if LANG_CXX11
inline void AskForRewardResponse::set_appid(::std::string&& value) {
  set_has_appid();
  appid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AskForRewardResponse.AppID)
}
#endif
inline void AskForRewardResponse::set_appid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_appid();
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AskForRewardResponse.AppID)
}
inline void AskForRewardResponse::set_appid(const char* value, size_t size) {
  set_has_appid();
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AskForRewardResponse.AppID)
}
inline ::std::string* AskForRewardResponse::mutable_appid() {
  set_has_appid();
  // @@protoc_insertion_point(field_mutable:micromsg.AskForRewardResponse.AppID)
  return appid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AskForRewardResponse::release_appid() {
  // @@protoc_insertion_point(field_release:micromsg.AskForRewardResponse.AppID)
  clear_has_appid();
  return appid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AskForRewardResponse::set_allocated_appid(::std::string* appid) {
  if (appid != NULL) {
    set_has_appid();
  } else {
    clear_has_appid();
  }
  appid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), appid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AskForRewardResponse.AppID)
}

// -------------------------------------------------------------------

// GetRewardMagicListRequest

// required uint32 Scene = 1;
inline bool GetRewardMagicListRequest::has_scene() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRewardMagicListRequest::set_has_scene() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRewardMagicListRequest::clear_has_scene() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRewardMagicListRequest::clear_scene() {
  scene_ = 0u;
  clear_has_scene();
}
inline ::google::protobuf::uint32 GetRewardMagicListRequest::scene() const {
  // @@protoc_insertion_point(field_get:micromsg.GetRewardMagicListRequest.Scene)
  return scene_;
}
inline void GetRewardMagicListRequest::set_scene(::google::protobuf::uint32 value) {
  set_has_scene();
  scene_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetRewardMagicListRequest.Scene)
}

// -------------------------------------------------------------------

// RewardMagic

// required string MagicWord = 1;
inline bool RewardMagic::has_magicword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardMagic::set_has_magicword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardMagic::clear_has_magicword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardMagic::clear_magicword() {
  magicword_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_magicword();
}
inline const ::std::string& RewardMagic::magicword() const {
  // @@protoc_insertion_point(field_get:micromsg.RewardMagic.MagicWord)
  return magicword_.GetNoArena();
}
inline void RewardMagic::set_magicword(const ::std::string& value) {
  set_has_magicword();
  magicword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RewardMagic.MagicWord)
}
#if LANG_CXX11
inline void RewardMagic::set_magicword(::std::string&& value) {
  set_has_magicword();
  magicword_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RewardMagic.MagicWord)
}
#endif
inline void RewardMagic::set_magicword(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_magicword();
  magicword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RewardMagic.MagicWord)
}
inline void RewardMagic::set_magicword(const char* value, size_t size) {
  set_has_magicword();
  magicword_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RewardMagic.MagicWord)
}
inline ::std::string* RewardMagic::mutable_magicword() {
  set_has_magicword();
  // @@protoc_insertion_point(field_mutable:micromsg.RewardMagic.MagicWord)
  return magicword_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RewardMagic::release_magicword() {
  // @@protoc_insertion_point(field_release:micromsg.RewardMagic.MagicWord)
  clear_has_magicword();
  return magicword_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RewardMagic::set_allocated_magicword(::std::string* magicword) {
  if (magicword != NULL) {
    set_has_magicword();
  } else {
    clear_has_magicword();
  }
  magicword_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), magicword);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RewardMagic.MagicWord)
}

// required string MagicUrl = 2;
inline bool RewardMagic::has_magicurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardMagic::set_has_magicurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardMagic::clear_has_magicurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardMagic::clear_magicurl() {
  magicurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_magicurl();
}
inline const ::std::string& RewardMagic::magicurl() const {
  // @@protoc_insertion_point(field_get:micromsg.RewardMagic.MagicUrl)
  return magicurl_.GetNoArena();
}
inline void RewardMagic::set_magicurl(const ::std::string& value) {
  set_has_magicurl();
  magicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RewardMagic.MagicUrl)
}
#if LANG_CXX11
inline void RewardMagic::set_magicurl(::std::string&& value) {
  set_has_magicurl();
  magicurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RewardMagic.MagicUrl)
}
#endif
inline void RewardMagic::set_magicurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_magicurl();
  magicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RewardMagic.MagicUrl)
}
inline void RewardMagic::set_magicurl(const char* value, size_t size) {
  set_has_magicurl();
  magicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RewardMagic.MagicUrl)
}
inline ::std::string* RewardMagic::mutable_magicurl() {
  set_has_magicurl();
  // @@protoc_insertion_point(field_mutable:micromsg.RewardMagic.MagicUrl)
  return magicurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RewardMagic::release_magicurl() {
  // @@protoc_insertion_point(field_release:micromsg.RewardMagic.MagicUrl)
  clear_has_magicurl();
  return magicurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RewardMagic::set_allocated_magicurl(::std::string* magicurl) {
  if (magicurl != NULL) {
    set_has_magicurl();
  } else {
    clear_has_magicurl();
  }
  magicurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), magicurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RewardMagic.MagicUrl)
}

// optional uint32 MagicExpire = 3;
inline bool RewardMagic::has_magicexpire() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RewardMagic::set_has_magicexpire() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RewardMagic::clear_has_magicexpire() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RewardMagic::clear_magicexpire() {
  magicexpire_ = 0u;
  clear_has_magicexpire();
}
inline ::google::protobuf::uint32 RewardMagic::magicexpire() const {
  // @@protoc_insertion_point(field_get:micromsg.RewardMagic.MagicExpire)
  return magicexpire_;
}
inline void RewardMagic::set_magicexpire(::google::protobuf::uint32 value) {
  set_has_magicexpire();
  magicexpire_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RewardMagic.MagicExpire)
}

// optional uint32 MagicLimit = 4;
inline bool RewardMagic::has_magiclimit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RewardMagic::set_has_magiclimit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RewardMagic::clear_has_magiclimit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RewardMagic::clear_magiclimit() {
  magiclimit_ = 0u;
  clear_has_magiclimit();
}
inline ::google::protobuf::uint32 RewardMagic::magiclimit() const {
  // @@protoc_insertion_point(field_get:micromsg.RewardMagic.MagicLimit)
  return magiclimit_;
}
inline void RewardMagic::set_magiclimit(::google::protobuf::uint32 value) {
  set_has_magiclimit();
  magiclimit_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RewardMagic.MagicLimit)
}

// required string ProductID = 5;
inline bool RewardMagic::has_productid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RewardMagic::set_has_productid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RewardMagic::clear_has_productid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RewardMagic::clear_productid() {
  productid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_productid();
}
inline const ::std::string& RewardMagic::productid() const {
  // @@protoc_insertion_point(field_get:micromsg.RewardMagic.ProductID)
  return productid_.GetNoArena();
}
inline void RewardMagic::set_productid(const ::std::string& value) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RewardMagic.ProductID)
}
#if LANG_CXX11
inline void RewardMagic::set_productid(::std::string&& value) {
  set_has_productid();
  productid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RewardMagic.ProductID)
}
#endif
inline void RewardMagic::set_productid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RewardMagic.ProductID)
}
inline void RewardMagic::set_productid(const char* value, size_t size) {
  set_has_productid();
  productid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RewardMagic.ProductID)
}
inline ::std::string* RewardMagic::mutable_productid() {
  set_has_productid();
  // @@protoc_insertion_point(field_mutable:micromsg.RewardMagic.ProductID)
  return productid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RewardMagic::release_productid() {
  // @@protoc_insertion_point(field_release:micromsg.RewardMagic.ProductID)
  clear_has_productid();
  return productid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RewardMagic::set_allocated_productid(::std::string* productid) {
  if (productid != NULL) {
    set_has_productid();
  } else {
    clear_has_productid();
  }
  productid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), productid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RewardMagic.ProductID)
}

// optional string Md5 = 6;
inline bool RewardMagic::has_md5() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RewardMagic::set_has_md5() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RewardMagic::clear_has_md5() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RewardMagic::clear_md5() {
  md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_md5();
}
inline const ::std::string& RewardMagic::md5() const {
  // @@protoc_insertion_point(field_get:micromsg.RewardMagic.Md5)
  return md5_.GetNoArena();
}
inline void RewardMagic::set_md5(const ::std::string& value) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RewardMagic.Md5)
}
#if LANG_CXX11
inline void RewardMagic::set_md5(::std::string&& value) {
  set_has_md5();
  md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RewardMagic.Md5)
}
#endif
inline void RewardMagic::set_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RewardMagic.Md5)
}
inline void RewardMagic::set_md5(const char* value, size_t size) {
  set_has_md5();
  md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RewardMagic.Md5)
}
inline ::std::string* RewardMagic::mutable_md5() {
  set_has_md5();
  // @@protoc_insertion_point(field_mutable:micromsg.RewardMagic.Md5)
  return md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RewardMagic::release_md5() {
  // @@protoc_insertion_point(field_release:micromsg.RewardMagic.Md5)
  clear_has_md5();
  return md5_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RewardMagic::set_allocated_md5(::std::string* md5) {
  if (md5 != NULL) {
    set_has_md5();
  } else {
    clear_has_md5();
  }
  md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), md5);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RewardMagic.Md5)
}

// -------------------------------------------------------------------

// GetRewardMagicListResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetRewardMagicListResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRewardMagicListResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRewardMagicListResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRewardMagicListResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetRewardMagicListResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetRewardMagicListResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetRewardMagicListResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetRewardMagicListResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetRewardMagicListResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetRewardMagicListResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetRewardMagicListResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetRewardMagicListResponse.BaseResponse)
}

// repeated .micromsg.RewardMagic Magic = 2;
inline int GetRewardMagicListResponse::magic_size() const {
  return magic_.size();
}
inline void GetRewardMagicListResponse::clear_magic() {
  magic_.Clear();
}
inline const ::micromsg::RewardMagic& GetRewardMagicListResponse::magic(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetRewardMagicListResponse.Magic)
  return magic_.Get(index);
}
inline ::micromsg::RewardMagic* GetRewardMagicListResponse::mutable_magic(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetRewardMagicListResponse.Magic)
  return magic_.Mutable(index);
}
inline ::micromsg::RewardMagic* GetRewardMagicListResponse::add_magic() {
  // @@protoc_insertion_point(field_add:micromsg.GetRewardMagicListResponse.Magic)
  return magic_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::RewardMagic >*
GetRewardMagicListResponse::mutable_magic() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetRewardMagicListResponse.Magic)
  return &magic_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::RewardMagic >&
GetRewardMagicListResponse::magic() const {
  // @@protoc_insertion_point(field_list:micromsg.GetRewardMagicListResponse.Magic)
  return magic_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace micromsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mmemotionstore_2eproto__INCLUDED
