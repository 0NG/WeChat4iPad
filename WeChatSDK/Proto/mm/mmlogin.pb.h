// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmlogin.proto

#ifndef PROTOBUF_mmlogin_2eproto__INCLUDED
#define PROTOBUF_mmlogin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "mmbuiltintype.pb.h"
#include "mmbase.pb.h"
// @@protoc_insertion_point(includes)
namespace micromsg {
class AcctSectResp;
class AcctSectRespDefaultTypeInternal;
extern AcctSectRespDefaultTypeInternal _AcctSectResp_default_instance_;
class AdditionalContactList;
class AdditionalContactListDefaultTypeInternal;
extern AdditionalContactListDefaultTypeInternal _AdditionalContactList_default_instance_;
class AndroidGCMRegRequest;
class AndroidGCMRegRequestDefaultTypeInternal;
extern AndroidGCMRegRequestDefaultTypeInternal _AndroidGCMRegRequest_default_instance_;
class AndroidGCMRegResponse;
class AndroidGCMRegResponseDefaultTypeInternal;
extern AndroidGCMRegResponseDefaultTypeInternal _AndroidGCMRegResponse_default_instance_;
class AndroidGCMUnRegRequest;
class AndroidGCMUnRegRequestDefaultTypeInternal;
extern AndroidGCMUnRegRequestDefaultTypeInternal _AndroidGCMUnRegRequest_default_instance_;
class AndroidGCMUnRegResponse;
class AndroidGCMUnRegResponseDefaultTypeInternal;
extern AndroidGCMUnRegResponseDefaultTypeInternal _AndroidGCMUnRegResponse_default_instance_;
class ApplyResetPawRequest;
class ApplyResetPawRequestDefaultTypeInternal;
extern ApplyResetPawRequestDefaultTypeInternal _ApplyResetPawRequest_default_instance_;
class ApplyResetPawResponse;
class ApplyResetPawResponseDefaultTypeInternal;
extern ApplyResetPawResponseDefaultTypeInternal _ApplyResetPawResponse_default_instance_;
class AshaRegRequest;
class AshaRegRequestDefaultTypeInternal;
extern AshaRegRequestDefaultTypeInternal _AshaRegRequest_default_instance_;
class AshaRegResponse;
class AshaRegResponseDefaultTypeInternal;
extern AshaRegResponseDefaultTypeInternal _AshaRegResponse_default_instance_;
class AshaUnRegRequest;
class AshaUnRegRequestDefaultTypeInternal;
extern AshaUnRegRequestDefaultTypeInternal _AshaUnRegRequest_default_instance_;
class AshaUnRegResponse;
class AshaUnRegResponseDefaultTypeInternal;
extern AshaUnRegResponseDefaultTypeInternal _AshaUnRegResponse_default_instance_;
class AuthSectResp;
class AuthSectRespDefaultTypeInternal;
extern AuthSectRespDefaultTypeInternal _AuthSectResp_default_instance_;
class AutoAuthAesReqData;
class AutoAuthAesReqDataDefaultTypeInternal;
extern AutoAuthAesReqDataDefaultTypeInternal _AutoAuthAesReqData_default_instance_;
class AutoAuthKey;
class AutoAuthKeyDefaultTypeInternal;
extern AutoAuthKeyDefaultTypeInternal _AutoAuthKey_default_instance_;
class AutoAuthRequest;
class AutoAuthRequestDefaultTypeInternal;
extern AutoAuthRequestDefaultTypeInternal _AutoAuthRequest_default_instance_;
class AutoAuthRsaReqData;
class AutoAuthRsaReqDataDefaultTypeInternal;
extern AutoAuthRsaReqDataDefaultTypeInternal _AutoAuthRsaReqData_default_instance_;
class BaseAuthReqInfo;
class BaseAuthReqInfoDefaultTypeInternal;
extern BaseAuthReqInfoDefaultTypeInternal _BaseAuthReqInfo_default_instance_;
class BaseRequest;
class BaseRequestDefaultTypeInternal;
extern BaseRequestDefaultTypeInternal _BaseRequest_default_instance_;
class BaseResponse;
class BaseResponseDefaultTypeInternal;
extern BaseResponseDefaultTypeInternal _BaseResponse_default_instance_;
class BindBlackberryPPIDRequest;
class BindBlackberryPPIDRequestDefaultTypeInternal;
extern BindBlackberryPPIDRequestDefaultTypeInternal _BindBlackberryPPIDRequest_default_instance_;
class BindBlackberryPPIDResponse;
class BindBlackberryPPIDResponseDefaultTypeInternal;
extern BindBlackberryPPIDResponseDefaultTypeInternal _BindBlackberryPPIDResponse_default_instance_;
class BindEmailRequest;
class BindEmailRequestDefaultTypeInternal;
extern BindEmailRequestDefaultTypeInternal _BindEmailRequest_default_instance_;
class BindEmailResponse;
class BindEmailResponseDefaultTypeInternal;
extern BindEmailResponseDefaultTypeInternal _BindEmailResponse_default_instance_;
class BindGoogleContactRequest;
class BindGoogleContactRequestDefaultTypeInternal;
extern BindGoogleContactRequestDefaultTypeInternal _BindGoogleContactRequest_default_instance_;
class BindGoogleContactResponse;
class BindGoogleContactResponseDefaultTypeInternal;
extern BindGoogleContactResponseDefaultTypeInternal _BindGoogleContactResponse_default_instance_;
class BindLinkedinContactRequest;
class BindLinkedinContactRequestDefaultTypeInternal;
extern BindLinkedinContactRequestDefaultTypeInternal _BindLinkedinContactRequest_default_instance_;
class BindLinkedinContactResponse;
class BindLinkedinContactResponseDefaultTypeInternal;
extern BindLinkedinContactResponseDefaultTypeInternal _BindLinkedinContactResponse_default_instance_;
class BindOpMobileRequest;
class BindOpMobileRequestDefaultTypeInternal;
extern BindOpMobileRequestDefaultTypeInternal _BindOpMobileRequest_default_instance_;
class BindOpMobileResponse;
class BindOpMobileResponseDefaultTypeInternal;
extern BindOpMobileResponseDefaultTypeInternal _BindOpMobileResponse_default_instance_;
class BindQQRequest;
class BindQQRequestDefaultTypeInternal;
extern BindQQRequestDefaultTypeInternal _BindQQRequest_default_instance_;
class BindQQResponse;
class BindQQResponseDefaultTypeInternal;
extern BindQQResponseDefaultTypeInternal _BindQQResponse_default_instance_;
class BindSafeMobileRequest;
class BindSafeMobileRequestDefaultTypeInternal;
extern BindSafeMobileRequestDefaultTypeInternal _BindSafeMobileRequest_default_instance_;
class BindSafeMobileResponse;
class BindSafeMobileResponseDefaultTypeInternal;
extern BindSafeMobileResponseDefaultTypeInternal _BindSafeMobileResponse_default_instance_;
class BlackBerryRegRequest;
class BlackBerryRegRequestDefaultTypeInternal;
extern BlackBerryRegRequestDefaultTypeInternal _BlackBerryRegRequest_default_instance_;
class BlackBerryRegResponse;
class BlackBerryRegResponseDefaultTypeInternal;
extern BlackBerryRegResponseDefaultTypeInternal _BlackBerryRegResponse_default_instance_;
class BlackBerryUnRegRequest;
class BlackBerryUnRegRequestDefaultTypeInternal;
extern BlackBerryUnRegRequestDefaultTypeInternal _BlackBerryUnRegRequest_default_instance_;
class BlackBerryUnRegResponse;
class BlackBerryUnRegResponseDefaultTypeInternal;
extern BlackBerryUnRegResponseDefaultTypeInternal _BlackBerryUnRegResponse_default_instance_;
class BlueToothAutoLoginInfo;
class BlueToothAutoLoginInfoDefaultTypeInternal;
extern BlueToothAutoLoginInfoDefaultTypeInternal _BlueToothAutoLoginInfo_default_instance_;
class BlueToothAutoLoginInfoPkg;
class BlueToothAutoLoginInfoPkgDefaultTypeInternal;
extern BlueToothAutoLoginInfoPkgDefaultTypeInternal _BlueToothAutoLoginInfoPkg_default_instance_;
class BlueToothAutoLoginRequest;
class BlueToothAutoLoginRequestDefaultTypeInternal;
extern BlueToothAutoLoginRequestDefaultTypeInternal _BlueToothAutoLoginRequest_default_instance_;
class BlueToothAutoLoginResponse;
class BlueToothAutoLoginResponseDefaultTypeInternal;
extern BlueToothAutoLoginResponseDefaultTypeInternal _BlueToothAutoLoginResponse_default_instance_;
class BlueToothBindLoginRequest;
class BlueToothBindLoginRequestDefaultTypeInternal;
extern BlueToothBindLoginRequestDefaultTypeInternal _BlueToothBindLoginRequest_default_instance_;
class BlueToothBindLoginResponse;
class BlueToothBindLoginResponseDefaultTypeInternal;
extern BlueToothBindLoginResponseDefaultTypeInternal _BlueToothBindLoginResponse_default_instance_;
class BuiltinIP;
class BuiltinIPDefaultTypeInternal;
extern BuiltinIPDefaultTypeInternal _BuiltinIP_default_instance_;
class BuiltinIPList;
class BuiltinIPListDefaultTypeInternal;
extern BuiltinIPListDefaultTypeInternal _BuiltinIPList_default_instance_;
class CDNDnsInfo;
class CDNDnsInfoDefaultTypeInternal;
extern CDNDnsInfoDefaultTypeInternal _CDNDnsInfo_default_instance_;
class ChatRoomMemberData;
class ChatRoomMemberDataDefaultTypeInternal;
extern ChatRoomMemberDataDefaultTypeInternal _ChatRoomMemberData_default_instance_;
class ChatRoomMemberInfo;
class ChatRoomMemberInfoDefaultTypeInternal;
extern ChatRoomMemberInfoDefaultTypeInternal _ChatRoomMemberInfo_default_instance_;
class CheckLoginQRCodeRequest;
class CheckLoginQRCodeRequestDefaultTypeInternal;
extern CheckLoginQRCodeRequestDefaultTypeInternal _CheckLoginQRCodeRequest_default_instance_;
class CheckLoginQRCodeResponse;
class CheckLoginQRCodeResponseDefaultTypeInternal;
extern CheckLoginQRCodeResponseDefaultTypeInternal _CheckLoginQRCodeResponse_default_instance_;
class CheckUnBindRequest;
class CheckUnBindRequestDefaultTypeInternal;
extern CheckUnBindRequestDefaultTypeInternal _CheckUnBindRequest_default_instance_;
class CheckUnBindResponse;
class CheckUnBindResponseDefaultTypeInternal;
extern CheckUnBindResponseDefaultTypeInternal _CheckUnBindResponse_default_instance_;
class CmdItem;
class CmdItemDefaultTypeInternal;
extern CmdItemDefaultTypeInternal _CmdItem_default_instance_;
class CmdList;
class CmdListDefaultTypeInternal;
extern CmdListDefaultTypeInternal _CmdList_default_instance_;
class CustomizedInfo;
class CustomizedInfoDefaultTypeInternal;
extern CustomizedInfoDefaultTypeInternal _CustomizedInfo_default_instance_;
class DelMemberReq;
class DelMemberReqDefaultTypeInternal;
extern DelMemberReqDefaultTypeInternal _DelMemberReq_default_instance_;
class DelMemberResp;
class DelMemberRespDefaultTypeInternal;
extern DelMemberRespDefaultTypeInternal _DelMemberResp_default_instance_;
class DelSafeDeviceRequest;
class DelSafeDeviceRequestDefaultTypeInternal;
extern DelSafeDeviceRequestDefaultTypeInternal _DelSafeDeviceRequest_default_instance_;
class DelSafeDeviceResponse;
class DelSafeDeviceResponseDefaultTypeInternal;
extern DelSafeDeviceResponseDefaultTypeInternal _DelSafeDeviceResponse_default_instance_;
class DisturbSetting;
class DisturbSettingDefaultTypeInternal;
extern DisturbSettingDefaultTypeInternal _DisturbSetting_default_instance_;
class DisturbTimeSpan;
class DisturbTimeSpanDefaultTypeInternal;
extern DisturbTimeSpanDefaultTypeInternal _DisturbTimeSpan_default_instance_;
class ECDHKey;
class ECDHKeyDefaultTypeInternal;
extern ECDHKeyDefaultTypeInternal _ECDHKey_default_instance_;
class EmailRegRequest;
class EmailRegRequestDefaultTypeInternal;
extern EmailRegRequestDefaultTypeInternal _EmailRegRequest_default_instance_;
class EmailRegResponse;
class EmailRegResponseDefaultTypeInternal;
extern EmailRegResponseDefaultTypeInternal _EmailRegResponse_default_instance_;
class ExtSession;
class ExtSessionDefaultTypeInternal;
extern ExtSessionDefaultTypeInternal _ExtSession_default_instance_;
class FaceBookAuthRequest;
class FaceBookAuthRequestDefaultTypeInternal;
extern FaceBookAuthRequestDefaultTypeInternal _FaceBookAuthRequest_default_instance_;
class FaceBookAuthResponse;
class FaceBookAuthResponseDefaultTypeInternal;
extern FaceBookAuthResponseDefaultTypeInternal _FaceBookAuthResponse_default_instance_;
class GetCertRequest;
class GetCertRequestDefaultTypeInternal;
extern GetCertRequestDefaultTypeInternal _GetCertRequest_default_instance_;
class GetCertResponse;
class GetCertResponseDefaultTypeInternal;
extern GetCertResponseDefaultTypeInternal _GetCertResponse_default_instance_;
class GetIosExtensionKeyRequest;
class GetIosExtensionKeyRequestDefaultTypeInternal;
extern GetIosExtensionKeyRequestDefaultTypeInternal _GetIosExtensionKeyRequest_default_instance_;
class GetIosExtensionKeyResponse;
class GetIosExtensionKeyResponseDefaultTypeInternal;
extern GetIosExtensionKeyResponseDefaultTypeInternal _GetIosExtensionKeyResponse_default_instance_;
class GetLocationRequest;
class GetLocationRequestDefaultTypeInternal;
extern GetLocationRequestDefaultTypeInternal _GetLocationRequest_default_instance_;
class GetLocationResponse;
class GetLocationResponseDefaultTypeInternal;
extern GetLocationResponseDefaultTypeInternal _GetLocationResponse_default_instance_;
class GetLoginQRCodeRequest;
class GetLoginQRCodeRequestDefaultTypeInternal;
extern GetLoginQRCodeRequestDefaultTypeInternal _GetLoginQRCodeRequest_default_instance_;
class GetLoginQRCodeResponse;
class GetLoginQRCodeResponseDefaultTypeInternal;
extern GetLoginQRCodeResponseDefaultTypeInternal _GetLoginQRCodeResponse_default_instance_;
class GetLoginURLRequest;
class GetLoginURLRequestDefaultTypeInternal;
extern GetLoginURLRequestDefaultTypeInternal _GetLoginURLRequest_default_instance_;
class GetLoginURLResponse;
class GetLoginURLResponseDefaultTypeInternal;
extern GetLoginURLResponseDefaultTypeInternal _GetLoginURLResponse_default_instance_;
class GetSuggestAliasRequest;
class GetSuggestAliasRequestDefaultTypeInternal;
extern GetSuggestAliasRequestDefaultTypeInternal _GetSuggestAliasRequest_default_instance_;
class GetSuggestAliasResponse;
class GetSuggestAliasResponseDefaultTypeInternal;
extern GetSuggestAliasResponseDefaultTypeInternal _GetSuggestAliasResponse_default_instance_;
class GetUserNameRequest;
class GetUserNameRequestDefaultTypeInternal;
extern GetUserNameRequestDefaultTypeInternal _GetUserNameRequest_default_instance_;
class GetUserNameResponse;
class GetUserNameResponseDefaultTypeInternal;
extern GetUserNameResponseDefaultTypeInternal _GetUserNameResponse_default_instance_;
class GetWeiBoURLReq;
class GetWeiBoURLReqDefaultTypeInternal;
extern GetWeiBoURLReqDefaultTypeInternal _GetWeiBoURLReq_default_instance_;
class GetWeiBoURLResp;
class GetWeiBoURLRespDefaultTypeInternal;
extern GetWeiBoURLRespDefaultTypeInternal _GetWeiBoURLResp_default_instance_;
class GmailInfo;
class GmailInfoDefaultTypeInternal;
extern GmailInfoDefaultTypeInternal _GmailInfo_default_instance_;
class GmailList;
class GmailListDefaultTypeInternal;
extern GmailListDefaultTypeInternal _GmailList_default_instance_;
class HardDevice;
class HardDeviceDefaultTypeInternal;
extern HardDeviceDefaultTypeInternal _HardDevice_default_instance_;
class Host;
class HostDefaultTypeInternal;
extern HostDefaultTypeInternal _Host_default_instance_;
class HostList;
class HostListDefaultTypeInternal;
extern HostListDefaultTypeInternal _HostList_default_instance_;
class IphoneRegRequest;
class IphoneRegRequestDefaultTypeInternal;
extern IphoneRegRequestDefaultTypeInternal _IphoneRegRequest_default_instance_;
class IphoneRegResponse;
class IphoneRegResponseDefaultTypeInternal;
extern IphoneRegResponseDefaultTypeInternal _IphoneRegResponse_default_instance_;
class IphoneUnRegRequest;
class IphoneUnRegRequestDefaultTypeInternal;
extern IphoneUnRegRequestDefaultTypeInternal _IphoneUnRegRequest_default_instance_;
class IphoneUnRegResponse;
class IphoneUnRegResponseDefaultTypeInternal;
extern IphoneUnRegResponseDefaultTypeInternal _IphoneUnRegResponse_default_instance_;
class LinkedinContactItem;
class LinkedinContactItemDefaultTypeInternal;
extern LinkedinContactItemDefaultTypeInternal _LinkedinContactItem_default_instance_;
class LockWebDeviceRequest;
class LockWebDeviceRequestDefaultTypeInternal;
extern LockWebDeviceRequestDefaultTypeInternal _LockWebDeviceRequest_default_instance_;
class LockWebDeviceResponse;
class LockWebDeviceResponseDefaultTypeInternal;
extern LockWebDeviceResponseDefaultTypeInternal _LockWebDeviceResponse_default_instance_;
class LoginQRCodeNotify;
class LoginQRCodeNotifyDefaultTypeInternal;
extern LoginQRCodeNotifyDefaultTypeInternal _LoginQRCodeNotify_default_instance_;
class LoginQRCodeNotifyPkg;
class LoginQRCodeNotifyPkgDefaultTypeInternal;
extern LoginQRCodeNotifyPkgDefaultTypeInternal _LoginQRCodeNotifyPkg_default_instance_;
class ManualAuthAesReqData;
class ManualAuthAesReqDataDefaultTypeInternal;
extern ManualAuthAesReqDataDefaultTypeInternal _ManualAuthAesReqData_default_instance_;
class ManualAuthRequest;
class ManualAuthRequestDefaultTypeInternal;
extern ManualAuthRequestDefaultTypeInternal _ManualAuthRequest_default_instance_;
class ManualAuthRsaReqData;
class ManualAuthRsaReqDataDefaultTypeInternal;
extern ManualAuthRsaReqDataDefaultTypeInternal _ManualAuthRsaReqData_default_instance_;
class MemberReq;
class MemberReqDefaultTypeInternal;
extern MemberReqDefaultTypeInternal _MemberReq_default_instance_;
class MemberResp;
class MemberRespDefaultTypeInternal;
extern MemberRespDefaultTypeInternal _MemberResp_default_instance_;
class ModContact;
class ModContactDefaultTypeInternal;
extern ModContactDefaultTypeInternal _ModContact_default_instance_;
class ModUserInfo;
class ModUserInfoDefaultTypeInternal;
extern ModUserInfoDefaultTypeInternal _ModUserInfo_default_instance_;
class NetworkControl;
class NetworkControlDefaultTypeInternal;
extern NetworkControlDefaultTypeInternal _NetworkControl_default_instance_;
class NetworkSectResp;
class NetworkSectRespDefaultTypeInternal;
extern NetworkSectRespDefaultTypeInternal _NetworkSectResp_default_instance_;
class NewAuthRequest;
class NewAuthRequestDefaultTypeInternal;
extern NewAuthRequestDefaultTypeInternal _NewAuthRequest_default_instance_;
class NewAuthResponse;
class NewAuthResponseDefaultTypeInternal;
extern NewAuthResponseDefaultTypeInternal _NewAuthResponse_default_instance_;
class NewAuthRsaReqData;
class NewAuthRsaReqDataDefaultTypeInternal;
extern NewAuthRsaReqDataDefaultTypeInternal _NewAuthRsaReqData_default_instance_;
class NewRegRequest;
class NewRegRequestDefaultTypeInternal;
extern NewRegRequestDefaultTypeInternal _NewRegRequest_default_instance_;
class NewRegResponse;
class NewRegResponseDefaultTypeInternal;
extern NewRegResponseDefaultTypeInternal _NewRegResponse_default_instance_;
class OpPatternLockRequest;
class OpPatternLockRequestDefaultTypeInternal;
extern OpPatternLockRequestDefaultTypeInternal _OpPatternLockRequest_default_instance_;
class OpPatternLockResponse;
class OpPatternLockResponseDefaultTypeInternal;
extern OpPatternLockResponseDefaultTypeInternal _OpPatternLockResponse_default_instance_;
class PatternLockBuffer;
class PatternLockBufferDefaultTypeInternal;
extern PatternLockBufferDefaultTypeInternal _PatternLockBuffer_default_instance_;
class PatternLockInfo;
class PatternLockInfoDefaultTypeInternal;
extern PatternLockInfoDefaultTypeInternal _PatternLockInfo_default_instance_;
class PluginKey;
class PluginKeyDefaultTypeInternal;
extern PluginKeyDefaultTypeInternal _PluginKey_default_instance_;
class PluginKeyList;
class PluginKeyListDefaultTypeInternal;
extern PluginKeyListDefaultTypeInternal _PluginKeyList_default_instance_;
class PositionInfo;
class PositionInfoDefaultTypeInternal;
extern PositionInfoDefaultTypeInternal _PositionInfo_default_instance_;
class PushLoginURLRequest;
class PushLoginURLRequestDefaultTypeInternal;
extern PushLoginURLRequestDefaultTypeInternal _PushLoginURLRequest_default_instance_;
class PushLoginURLResponse;
class PushLoginURLResponseDefaultTypeInternal;
extern PushLoginURLResponseDefaultTypeInternal _PushLoginURLResponse_default_instance_;
class QueryHasPswdRequest;
class QueryHasPswdRequestDefaultTypeInternal;
extern QueryHasPswdRequestDefaultTypeInternal _QueryHasPswdRequest_default_instance_;
class QueryHasPswdResponse;
class QueryHasPswdResponseDefaultTypeInternal;
extern QueryHasPswdResponseDefaultTypeInternal _QueryHasPswdResponse_default_instance_;
class RSACert;
class RSACertDefaultTypeInternal;
extern RSACertDefaultTypeInternal _RSACert_default_instance_;
class RegEquipmentRequest;
class RegEquipmentRequestDefaultTypeInternal;
extern RegEquipmentRequestDefaultTypeInternal _RegEquipmentRequest_default_instance_;
class RegEquipmentResponse;
class RegEquipmentResponseDefaultTypeInternal;
extern RegEquipmentResponseDefaultTypeInternal _RegEquipmentResponse_default_instance_;
class RegisterNewPatternLockRequest;
class RegisterNewPatternLockRequestDefaultTypeInternal;
extern RegisterNewPatternLockRequestDefaultTypeInternal _RegisterNewPatternLockRequest_default_instance_;
class RegisterNewPatternLockResponse;
class RegisterNewPatternLockResponseDefaultTypeInternal;
extern RegisterNewPatternLockResponseDefaultTypeInternal _RegisterNewPatternLockResponse_default_instance_;
class ResetEquipmentRequest;
class ResetEquipmentRequestDefaultTypeInternal;
extern ResetEquipmentRequestDefaultTypeInternal _ResetEquipmentRequest_default_instance_;
class ResetEquipmentResponse;
class ResetEquipmentResponseDefaultTypeInternal;
extern ResetEquipmentResponseDefaultTypeInternal _ResetEquipmentResponse_default_instance_;
class ResetPawInfo;
class ResetPawInfoDefaultTypeInternal;
extern ResetPawInfoDefaultTypeInternal _ResetPawInfo_default_instance_;
class ResetPwdRequest;
class ResetPwdRequestDefaultTypeInternal;
extern ResetPwdRequestDefaultTypeInternal _ResetPwdRequest_default_instance_;
class ResetPwdResponse;
class ResetPwdResponseDefaultTypeInternal;
extern ResetPwdResponseDefaultTypeInternal _ResetPwdResponse_default_instance_;
class RoomInfo;
class RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class SKBuiltinBuffer_t;
class SKBuiltinBuffer_tDefaultTypeInternal;
extern SKBuiltinBuffer_tDefaultTypeInternal _SKBuiltinBuffer_t_default_instance_;
class SKBuiltinChar_t;
class SKBuiltinChar_tDefaultTypeInternal;
extern SKBuiltinChar_tDefaultTypeInternal _SKBuiltinChar_t_default_instance_;
class SKBuiltinDouble64_t;
class SKBuiltinDouble64_tDefaultTypeInternal;
extern SKBuiltinDouble64_tDefaultTypeInternal _SKBuiltinDouble64_t_default_instance_;
class SKBuiltinFloat32_t;
class SKBuiltinFloat32_tDefaultTypeInternal;
extern SKBuiltinFloat32_tDefaultTypeInternal _SKBuiltinFloat32_t_default_instance_;
class SKBuiltinInt16_t;
class SKBuiltinInt16_tDefaultTypeInternal;
extern SKBuiltinInt16_tDefaultTypeInternal _SKBuiltinInt16_t_default_instance_;
class SKBuiltinInt32_t;
class SKBuiltinInt32_tDefaultTypeInternal;
extern SKBuiltinInt32_tDefaultTypeInternal _SKBuiltinInt32_t_default_instance_;
class SKBuiltinInt64_t;
class SKBuiltinInt64_tDefaultTypeInternal;
extern SKBuiltinInt64_tDefaultTypeInternal _SKBuiltinInt64_t_default_instance_;
class SKBuiltinInt8_t;
class SKBuiltinInt8_tDefaultTypeInternal;
extern SKBuiltinInt8_tDefaultTypeInternal _SKBuiltinInt8_t_default_instance_;
class SKBuiltinString_t;
class SKBuiltinString_tDefaultTypeInternal;
extern SKBuiltinString_tDefaultTypeInternal _SKBuiltinString_t_default_instance_;
class SKBuiltinUchar_t;
class SKBuiltinUchar_tDefaultTypeInternal;
extern SKBuiltinUchar_tDefaultTypeInternal _SKBuiltinUchar_t_default_instance_;
class SKBuiltinUint16_t;
class SKBuiltinUint16_tDefaultTypeInternal;
extern SKBuiltinUint16_tDefaultTypeInternal _SKBuiltinUint16_t_default_instance_;
class SKBuiltinUint32_t;
class SKBuiltinUint32_tDefaultTypeInternal;
extern SKBuiltinUint32_tDefaultTypeInternal _SKBuiltinUint32_t_default_instance_;
class SKBuiltinUint64_t;
class SKBuiltinUint64_tDefaultTypeInternal;
extern SKBuiltinUint64_tDefaultTypeInternal _SKBuiltinUint64_t_default_instance_;
class SKBuiltinUint8_t;
class SKBuiltinUint8_tDefaultTypeInternal;
extern SKBuiltinUint8_tDefaultTypeInternal _SKBuiltinUint8_t_default_instance_;
class SafeDevice;
class SafeDeviceDefaultTypeInternal;
extern SafeDeviceDefaultTypeInternal _SafeDevice_default_instance_;
class SafeDeviceList;
class SafeDeviceListDefaultTypeInternal;
extern SafeDeviceListDefaultTypeInternal _SafeDeviceList_default_instance_;
class SecAuthRegKeySect;
class SecAuthRegKeySectDefaultTypeInternal;
extern SecAuthRegKeySectDefaultTypeInternal _SecAuthRegKeySect_default_instance_;
class SetEmailPwdRequest;
class SetEmailPwdRequestDefaultTypeInternal;
extern SetEmailPwdRequestDefaultTypeInternal _SetEmailPwdRequest_default_instance_;
class SetEmailPwdResponse;
class SetEmailPwdResponseDefaultTypeInternal;
extern SetEmailPwdResponseDefaultTypeInternal _SetEmailPwdResponse_default_instance_;
class SetPwdRequest;
class SetPwdRequestDefaultTypeInternal;
extern SetPwdRequestDefaultTypeInternal _SetPwdRequest_default_instance_;
class SetPwdResponse;
class SetPwdResponseDefaultTypeInternal;
extern SetPwdResponseDefaultTypeInternal _SetPwdResponse_default_instance_;
class ShakeSyncRequest;
class ShakeSyncRequestDefaultTypeInternal;
extern ShakeSyncRequestDefaultTypeInternal _ShakeSyncRequest_default_instance_;
class ShakeSyncResponse;
class ShakeSyncResponseDefaultTypeInternal;
extern ShakeSyncResponseDefaultTypeInternal _ShakeSyncResponse_default_instance_;
class ShowStyleKey;
class ShowStyleKeyDefaultTypeInternal;
extern ShowStyleKeyDefaultTypeInternal _ShowStyleKey_default_instance_;
class SnsUserInfo;
class SnsUserInfoDefaultTypeInternal;
extern SnsUserInfoDefaultTypeInternal _SnsUserInfo_default_instance_;
class StyleKeyVal;
class StyleKeyValDefaultTypeInternal;
extern StyleKeyValDefaultTypeInternal _StyleKeyVal_default_instance_;
class UnBindLinkedinContactRequest;
class UnBindLinkedinContactRequestDefaultTypeInternal;
extern UnBindLinkedinContactRequestDefaultTypeInternal _UnBindLinkedinContactRequest_default_instance_;
class UnBindLinkedinContactResponse;
class UnBindLinkedinContactResponseDefaultTypeInternal;
extern UnBindLinkedinContactResponseDefaultTypeInternal _UnBindLinkedinContactResponse_default_instance_;
class UnBindQQRequest;
class UnBindQQRequestDefaultTypeInternal;
extern UnBindQQRequestDefaultTypeInternal _UnBindQQRequest_default_instance_;
class UnBindQQResponse;
class UnBindQQResponseDefaultTypeInternal;
extern UnBindQQResponseDefaultTypeInternal _UnBindQQResponse_default_instance_;
class UnifyAuthResponse;
class UnifyAuthResponseDefaultTypeInternal;
extern UnifyAuthResponseDefaultTypeInternal _UnifyAuthResponse_default_instance_;
class UpdateSafeDeviceRequest;
class UpdateSafeDeviceRequestDefaultTypeInternal;
extern UpdateSafeDeviceRequestDefaultTypeInternal _UpdateSafeDeviceRequest_default_instance_;
class UpdateSafeDeviceResponse;
class UpdateSafeDeviceResponseDefaultTypeInternal;
extern UpdateSafeDeviceResponseDefaultTypeInternal _UpdateSafeDeviceResponse_default_instance_;
class UserInfoExt;
class UserInfoExtDefaultTypeInternal;
extern UserInfoExtDefaultTypeInternal _UserInfoExt_default_instance_;
class VerifyPswdRequest;
class VerifyPswdRequestDefaultTypeInternal;
extern VerifyPswdRequestDefaultTypeInternal _VerifyPswdRequest_default_instance_;
class VerifyPswdResponse;
class VerifyPswdResponseDefaultTypeInternal;
extern VerifyPswdResponseDefaultTypeInternal _VerifyPswdResponse_default_instance_;
class WTLoginImgReqInfo;
class WTLoginImgReqInfoDefaultTypeInternal;
extern WTLoginImgReqInfoDefaultTypeInternal _WTLoginImgReqInfo_default_instance_;
class WTLoginImgRespInfo;
class WTLoginImgRespInfoDefaultTypeInternal;
extern WTLoginImgRespInfoDefaultTypeInternal _WTLoginImgRespInfo_default_instance_;
class WinphoneRegRequest;
class WinphoneRegRequestDefaultTypeInternal;
extern WinphoneRegRequestDefaultTypeInternal _WinphoneRegRequest_default_instance_;
class WinphoneRegResponse;
class WinphoneRegResponseDefaultTypeInternal;
extern WinphoneRegResponseDefaultTypeInternal _WinphoneRegResponse_default_instance_;
class WinphoneUnRegRequest;
class WinphoneUnRegRequestDefaultTypeInternal;
extern WinphoneUnRegRequestDefaultTypeInternal _WinphoneUnRegRequest_default_instance_;
class WinphoneUnRegResponse;
class WinphoneUnRegResponseDefaultTypeInternal;
extern WinphoneUnRegResponseDefaultTypeInternal _WinphoneUnRegResponse_default_instance_;
class WxVerifyCodeReqInfo;
class WxVerifyCodeReqInfoDefaultTypeInternal;
extern WxVerifyCodeReqInfoDefaultTypeInternal _WxVerifyCodeReqInfo_default_instance_;
class WxVerifyCodeRespInfo;
class WxVerifyCodeRespInfoDefaultTypeInternal;
extern WxVerifyCodeRespInfoDefaultTypeInternal _WxVerifyCodeRespInfo_default_instance_;
}  // namespace micromsg

namespace micromsg {

namespace protobuf_mmlogin_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mmlogin_2eproto

// ===================================================================

class ECDHKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ECDHKey) */ {
 public:
  ECDHKey();
  virtual ~ECDHKey();

  ECDHKey(const ECDHKey& from);

  inline ECDHKey& operator=(const ECDHKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ECDHKey& default_instance();

  static inline const ECDHKey* internal_default_instance() {
    return reinterpret_cast<const ECDHKey*>(
               &_ECDHKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ECDHKey* other);

  // implements Message ----------------------------------------------

  inline ECDHKey* New() const PROTOBUF_FINAL { return New(NULL); }

  ECDHKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ECDHKey& from);
  void MergeFrom(const ECDHKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ECDHKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.SKBuiltinBuffer_t Key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& key() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_key();
  ::micromsg::SKBuiltinBuffer_t* release_key();
  void set_allocated_key(::micromsg::SKBuiltinBuffer_t* key);

  // required int32 Nid = 1;
  bool has_nid() const;
  void clear_nid();
  static const int kNidFieldNumber = 1;
  ::google::protobuf::int32 nid() const;
  void set_nid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.ECDHKey)
 private:
  void set_has_nid();
  void clear_has_nid();
  void set_has_key();
  void clear_has_key();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* key_;
  ::google::protobuf::int32 nid_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.NewRegRequest) */ {
 public:
  NewRegRequest();
  virtual ~NewRegRequest();

  NewRegRequest(const NewRegRequest& from);

  inline NewRegRequest& operator=(const NewRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewRegRequest& default_instance();

  static inline const NewRegRequest* internal_default_instance() {
    return reinterpret_cast<const NewRegRequest*>(
               &_NewRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(NewRegRequest* other);

  // implements Message ----------------------------------------------

  inline NewRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NewRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewRegRequest& from);
  void MergeFrom(const NewRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 2;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string Pwd = 3;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 3;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // optional string NickName = 4;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNickNameFieldNumber = 4;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional string BindEmail = 6;
  bool has_bindemail() const;
  void clear_bindemail();
  static const int kBindEmailFieldNumber = 6;
  const ::std::string& bindemail() const;
  void set_bindemail(const ::std::string& value);
  #if LANG_CXX11
  void set_bindemail(::std::string&& value);
  #endif
  void set_bindemail(const char* value);
  void set_bindemail(const char* value, size_t size);
  ::std::string* mutable_bindemail();
  ::std::string* release_bindemail();
  void set_allocated_bindemail(::std::string* bindemail);

  // optional string BindMobile = 7;
  bool has_bindmobile() const;
  void clear_bindmobile();
  static const int kBindMobileFieldNumber = 7;
  const ::std::string& bindmobile() const;
  void set_bindmobile(const ::std::string& value);
  #if LANG_CXX11
  void set_bindmobile(::std::string&& value);
  #endif
  void set_bindmobile(const char* value);
  void set_bindmobile(const char* value, size_t size);
  ::std::string* mutable_bindmobile();
  ::std::string* release_bindmobile();
  void set_allocated_bindmobile(::std::string* bindmobile);

  // optional string Ticket = 8;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 8;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // optional string TimeZone = 15;
  bool has_timezone() const;
  void clear_timezone();
  static const int kTimeZoneFieldNumber = 15;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  #if LANG_CXX11
  void set_timezone(::std::string&& value);
  #endif
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional string Language = 16;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 16;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string RealCountry = 18;
  bool has_realcountry() const;
  void clear_realcountry();
  static const int kRealCountryFieldNumber = 18;
  const ::std::string& realcountry() const;
  void set_realcountry(const ::std::string& value);
  #if LANG_CXX11
  void set_realcountry(::std::string&& value);
  #endif
  void set_realcountry(const char* value);
  void set_realcountry(const char* value, size_t size);
  ::std::string* mutable_realcountry();
  ::std::string* release_realcountry();
  void set_allocated_realcountry(::std::string* realcountry);

  // optional string Alias = 20;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 20;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // optional string VerifySignature = 21;
  bool has_verifysignature() const;
  void clear_verifysignature();
  static const int kVerifySignatureFieldNumber = 21;
  const ::std::string& verifysignature() const;
  void set_verifysignature(const ::std::string& value);
  #if LANG_CXX11
  void set_verifysignature(::std::string&& value);
  #endif
  void set_verifysignature(const char* value);
  void set_verifysignature(const char* value, size_t size);
  ::std::string* mutable_verifysignature();
  ::std::string* release_verifysignature();
  void set_allocated_verifysignature(::std::string* verifysignature);

  // optional string VerifyContent = 22;
  bool has_verifycontent() const;
  void clear_verifycontent();
  static const int kVerifyContentFieldNumber = 22;
  const ::std::string& verifycontent() const;
  void set_verifycontent(const ::std::string& value);
  #if LANG_CXX11
  void set_verifycontent(::std::string&& value);
  #endif
  void set_verifycontent(const char* value);
  void set_verifycontent(const char* value, size_t size);
  ::std::string* mutable_verifycontent();
  ::std::string* release_verifycontent();
  void set_allocated_verifycontent(::std::string* verifycontent);

  // optional string ClientSeqID = 31;
  bool has_clientseqid() const;
  void clear_clientseqid();
  static const int kClientSeqIDFieldNumber = 31;
  const ::std::string& clientseqid() const;
  void set_clientseqid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientseqid(::std::string&& value);
  #endif
  void set_clientseqid(const char* value);
  void set_clientseqid(const char* value, size_t size);
  ::std::string* mutable_clientseqid();
  ::std::string* release_clientseqid();
  void set_allocated_clientseqid(::std::string* clientseqid);

  // optional string AdSource = 32;
  bool has_adsource() const;
  void clear_adsource();
  static const int kAdSourceFieldNumber = 32;
  const ::std::string& adsource() const;
  void set_adsource(const ::std::string& value);
  #if LANG_CXX11
  void set_adsource(::std::string&& value);
  #endif
  void set_adsource(const char* value);
  void set_adsource(const char* value, size_t size);
  ::std::string* mutable_adsource();
  ::std::string* release_adsource();
  void set_allocated_adsource(::std::string* adsource);

  // optional string AndroidID = 33;
  bool has_androidid() const;
  void clear_androidid();
  static const int kAndroidIDFieldNumber = 33;
  const ::std::string& androidid() const;
  void set_androidid(const ::std::string& value);
  #if LANG_CXX11
  void set_androidid(::std::string&& value);
  #endif
  void set_androidid(const char* value);
  void set_androidid(const char* value, size_t size);
  ::std::string* mutable_androidid();
  ::std::string* release_androidid();
  void set_allocated_androidid(::std::string* androidid);

  // optional string MacAddr = 34;
  bool has_macaddr() const;
  void clear_macaddr();
  static const int kMacAddrFieldNumber = 34;
  const ::std::string& macaddr() const;
  void set_macaddr(const ::std::string& value);
  #if LANG_CXX11
  void set_macaddr(::std::string&& value);
  #endif
  void set_macaddr(const char* value);
  void set_macaddr(const char* value, size_t size);
  ::std::string* mutable_macaddr();
  ::std::string* release_macaddr();
  void set_allocated_macaddr(::std::string* macaddr);

  // optional string AndroidInstallRef = 35;
  bool has_androidinstallref() const;
  void clear_androidinstallref();
  static const int kAndroidInstallRefFieldNumber = 35;
  const ::std::string& androidinstallref() const;
  void set_androidinstallref(const ::std::string& value);
  #if LANG_CXX11
  void set_androidinstallref(::std::string&& value);
  #endif
  void set_androidinstallref(const char* value);
  void set_androidinstallref(const char* value, size_t size);
  ::std::string* mutable_androidinstallref();
  ::std::string* release_androidinstallref();
  void set_allocated_androidinstallref(::std::string* androidinstallref);

  // optional string ClientFingerprint = 36;
  bool has_clientfingerprint() const;
  void clear_clientfingerprint();
  static const int kClientFingerprintFieldNumber = 36;
  const ::std::string& clientfingerprint() const;
  void set_clientfingerprint(const ::std::string& value);
  #if LANG_CXX11
  void set_clientfingerprint(::std::string&& value);
  #endif
  void set_clientfingerprint(const char* value);
  void set_clientfingerprint(const char* value, size_t size);
  ::std::string* mutable_clientfingerprint();
  ::std::string* release_clientfingerprint();
  void set_allocated_clientfingerprint(::std::string* clientfingerprint);

  // optional string GoogleAid = 38;
  bool has_googleaid() const;
  void clear_googleaid();
  static const int kGoogleAidFieldNumber = 38;
  const ::std::string& googleaid() const;
  void set_googleaid(const ::std::string& value);
  #if LANG_CXX11
  void set_googleaid(::std::string&& value);
  #endif
  void set_googleaid(const char* value);
  void set_googleaid(const char* value, size_t size);
  ::std::string* mutable_googleaid();
  ::std::string* release_googleaid();
  void set_allocated_googleaid(::std::string* googleaid);

  // optional string BundleID = 39;
  bool has_bundleid() const;
  void clear_bundleid();
  static const int kBundleIDFieldNumber = 39;
  const ::std::string& bundleid() const;
  void set_bundleid(const ::std::string& value);
  #if LANG_CXX11
  void set_bundleid(::std::string&& value);
  #endif
  void set_bundleid(const char* value);
  void set_bundleid(const char* value, size_t size);
  ::std::string* mutable_bundleid();
  ::std::string* release_bundleid();
  void set_allocated_bundleid(::std::string* bundleid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.SKBuiltinBuffer_t RandomEncryKey = 19;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 19;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // optional .micromsg.ECDHKey CliPubECDHKey = 37;
  bool has_clipubecdhkey() const;
  void clear_clipubecdhkey();
  static const int kCliPubECDHKeyFieldNumber = 37;
  const ::micromsg::ECDHKey& clipubecdhkey() const;
  ::micromsg::ECDHKey* mutable_clipubecdhkey();
  ::micromsg::ECDHKey* release_clipubecdhkey();
  void set_allocated_clipubecdhkey(::micromsg::ECDHKey* clipubecdhkey);

  // optional uint32 BindUin = 5;
  bool has_binduin() const;
  void clear_binduin();
  static const int kBindUinFieldNumber = 5;
  ::google::protobuf::uint32 binduin() const;
  void set_binduin(::google::protobuf::uint32 value);

  // optional uint32 BuiltinIPSeq = 12;
  bool has_builtinipseq() const;
  void clear_builtinipseq();
  static const int kBuiltinIPSeqFieldNumber = 12;
  ::google::protobuf::uint32 builtinipseq() const;
  void set_builtinipseq(::google::protobuf::uint32 value);

  // optional uint32 DLSrc = 13;
  bool has_dlsrc() const;
  void clear_dlsrc();
  static const int kDLSrcFieldNumber = 13;
  ::google::protobuf::uint32 dlsrc() const;
  void set_dlsrc(::google::protobuf::uint32 value);

  // optional uint32 RegMode = 14;
  bool has_regmode() const;
  void clear_regmode();
  static const int kRegModeFieldNumber = 14;
  ::google::protobuf::uint32 regmode() const;
  void set_regmode(::google::protobuf::uint32 value);

  // optional uint32 ForceReg = 17;
  bool has_forcereg() const;
  void clear_forcereg();
  static const int kForceRegFieldNumber = 17;
  ::google::protobuf::uint32 forcereg() const;
  void set_forcereg(::google::protobuf::uint32 value);

  // optional uint32 HasHeadImg = 23;
  bool has_hasheadimg() const;
  void clear_hasheadimg();
  static const int kHasHeadImgFieldNumber = 23;
  ::google::protobuf::uint32 hasheadimg() const;
  void set_hasheadimg(::google::protobuf::uint32 value);

  // optional uint32 SuggestRet = 24;
  bool has_suggestret() const;
  void clear_suggestret();
  static const int kSuggestRetFieldNumber = 24;
  ::google::protobuf::uint32 suggestret() const;
  void set_suggestret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.NewRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_username();
  void clear_has_username();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_nickname();
  void clear_has_nickname();
  void set_has_binduin();
  void clear_has_binduin();
  void set_has_bindemail();
  void clear_has_bindemail();
  void set_has_bindmobile();
  void clear_has_bindmobile();
  void set_has_ticket();
  void clear_has_ticket();
  void set_has_builtinipseq();
  void clear_has_builtinipseq();
  void set_has_dlsrc();
  void clear_has_dlsrc();
  void set_has_regmode();
  void clear_has_regmode();
  void set_has_timezone();
  void clear_has_timezone();
  void set_has_language();
  void clear_has_language();
  void set_has_forcereg();
  void clear_has_forcereg();
  void set_has_realcountry();
  void clear_has_realcountry();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_alias();
  void clear_has_alias();
  void set_has_verifysignature();
  void clear_has_verifysignature();
  void set_has_verifycontent();
  void clear_has_verifycontent();
  void set_has_hasheadimg();
  void clear_has_hasheadimg();
  void set_has_suggestret();
  void clear_has_suggestret();
  void set_has_clientseqid();
  void clear_has_clientseqid();
  void set_has_adsource();
  void clear_has_adsource();
  void set_has_androidid();
  void clear_has_androidid();
  void set_has_macaddr();
  void clear_has_macaddr();
  void set_has_androidinstallref();
  void clear_has_androidinstallref();
  void set_has_clientfingerprint();
  void clear_has_clientfingerprint();
  void set_has_clipubecdhkey();
  void clear_has_clipubecdhkey();
  void set_has_googleaid();
  void clear_has_googleaid();
  void set_has_bundleid();
  void clear_has_bundleid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr bindemail_;
  ::google::protobuf::internal::ArenaStringPtr bindmobile_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr realcountry_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  ::google::protobuf::internal::ArenaStringPtr verifysignature_;
  ::google::protobuf::internal::ArenaStringPtr verifycontent_;
  ::google::protobuf::internal::ArenaStringPtr clientseqid_;
  ::google::protobuf::internal::ArenaStringPtr adsource_;
  ::google::protobuf::internal::ArenaStringPtr androidid_;
  ::google::protobuf::internal::ArenaStringPtr macaddr_;
  ::google::protobuf::internal::ArenaStringPtr androidinstallref_;
  ::google::protobuf::internal::ArenaStringPtr clientfingerprint_;
  ::google::protobuf::internal::ArenaStringPtr googleaid_;
  ::google::protobuf::internal::ArenaStringPtr bundleid_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::micromsg::ECDHKey* clipubecdhkey_;
  ::google::protobuf::uint32 binduin_;
  ::google::protobuf::uint32 builtinipseq_;
  ::google::protobuf::uint32 dlsrc_;
  ::google::protobuf::uint32 regmode_;
  ::google::protobuf::uint32 forcereg_;
  ::google::protobuf::uint32 hasheadimg_;
  ::google::protobuf::uint32 suggestret_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SecAuthRegKeySect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.SecAuthRegKeySect) */ {
 public:
  SecAuthRegKeySect();
  virtual ~SecAuthRegKeySect();

  SecAuthRegKeySect(const SecAuthRegKeySect& from);

  inline SecAuthRegKeySect& operator=(const SecAuthRegKeySect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecAuthRegKeySect& default_instance();

  static inline const SecAuthRegKeySect* internal_default_instance() {
    return reinterpret_cast<const SecAuthRegKeySect*>(
               &_SecAuthRegKeySect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SecAuthRegKeySect* other);

  // implements Message ----------------------------------------------

  inline SecAuthRegKeySect* New() const PROTOBUF_FINAL { return New(NULL); }

  SecAuthRegKeySect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SecAuthRegKeySect& from);
  void MergeFrom(const SecAuthRegKeySect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SecAuthRegKeySect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.SKBuiltinBuffer_t AutoAuthKey = 1;
  bool has_autoauthkey() const;
  void clear_autoauthkey();
  static const int kAutoAuthKeyFieldNumber = 1;
  const ::micromsg::SKBuiltinBuffer_t& autoauthkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* release_autoauthkey();
  void set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey);

  // required .micromsg.ECDHKey SvrPubECDHKey = 2;
  bool has_svrpubecdhkey() const;
  void clear_svrpubecdhkey();
  static const int kSvrPubECDHKeyFieldNumber = 2;
  const ::micromsg::ECDHKey& svrpubecdhkey() const;
  ::micromsg::ECDHKey* mutable_svrpubecdhkey();
  ::micromsg::ECDHKey* release_svrpubecdhkey();
  void set_allocated_svrpubecdhkey(::micromsg::ECDHKey* svrpubecdhkey);

  // required .micromsg.SKBuiltinBuffer_t SessionKey = 3;
  bool has_sessionkey() const;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& sessionkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_sessionkey();
  ::micromsg::SKBuiltinBuffer_t* release_sessionkey();
  void set_allocated_sessionkey(::micromsg::SKBuiltinBuffer_t* sessionkey);

  // required uint32 AuthResultFlag = 4;
  bool has_authresultflag() const;
  void clear_authresultflag();
  static const int kAuthResultFlagFieldNumber = 4;
  ::google::protobuf::uint32 authresultflag() const;
  void set_authresultflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.SecAuthRegKeySect)
 private:
  void set_has_autoauthkey();
  void clear_has_autoauthkey();
  void set_has_svrpubecdhkey();
  void clear_has_svrpubecdhkey();
  void set_has_sessionkey();
  void clear_has_sessionkey();
  void set_has_authresultflag();
  void clear_has_authresultflag();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* autoauthkey_;
  ::micromsg::ECDHKey* svrpubecdhkey_;
  ::micromsg::SKBuiltinBuffer_t* sessionkey_;
  ::google::protobuf::uint32 authresultflag_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.NewRegResponse) */ {
 public:
  NewRegResponse();
  virtual ~NewRegResponse();

  NewRegResponse(const NewRegResponse& from);

  inline NewRegResponse& operator=(const NewRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewRegResponse& default_instance();

  static inline const NewRegResponse* internal_default_instance() {
    return reinterpret_cast<const NewRegResponse*>(
               &_NewRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(NewRegResponse* other);

  // implements Message ----------------------------------------------

  inline NewRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NewRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewRegResponse& from);
  void MergeFrom(const NewRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string SessionKey = 3;
  bool has_sessionkey() const;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 3;
  const ::std::string& sessionkey() const;
  void set_sessionkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionkey(::std::string&& value);
  #endif
  void set_sessionkey(const char* value);
  void set_sessionkey(const char* value, size_t size);
  ::std::string* mutable_sessionkey();
  ::std::string* release_sessionkey();
  void set_allocated_sessionkey(::std::string* sessionkey);

  // optional string OfficialUserName = 4;
  bool has_officialusername() const;
  void clear_officialusername();
  static const int kOfficialUserNameFieldNumber = 4;
  const ::std::string& officialusername() const;
  void set_officialusername(const ::std::string& value);
  #if LANG_CXX11
  void set_officialusername(::std::string&& value);
  #endif
  void set_officialusername(const char* value);
  void set_officialusername(const char* value, size_t size);
  ::std::string* mutable_officialusername();
  ::std::string* release_officialusername();
  void set_allocated_officialusername(::std::string* officialusername);

  // optional string OfficialNickName = 5;
  bool has_officialnickname() const;
  void clear_officialnickname();
  static const int kOfficialNickNameFieldNumber = 5;
  const ::std::string& officialnickname() const;
  void set_officialnickname(const ::std::string& value);
  #if LANG_CXX11
  void set_officialnickname(::std::string&& value);
  #endif
  void set_officialnickname(const char* value);
  void set_officialnickname(const char* value, size_t size);
  ::std::string* mutable_officialnickname();
  ::std::string* release_officialnickname();
  void set_allocated_officialnickname(::std::string* officialnickname);

  // optional string QQMicroBlogUserName = 6;
  bool has_qqmicroblogusername() const;
  void clear_qqmicroblogusername();
  static const int kQQMicroBlogUserNameFieldNumber = 6;
  const ::std::string& qqmicroblogusername() const;
  void set_qqmicroblogusername(const ::std::string& value);
  #if LANG_CXX11
  void set_qqmicroblogusername(::std::string&& value);
  #endif
  void set_qqmicroblogusername(const char* value);
  void set_qqmicroblogusername(const char* value, size_t size);
  ::std::string* mutable_qqmicroblogusername();
  ::std::string* release_qqmicroblogusername();
  void set_allocated_qqmicroblogusername(::std::string* qqmicroblogusername);

  // optional string BindEmail = 7;
  bool has_bindemail() const;
  void clear_bindemail();
  static const int kBindEmailFieldNumber = 7;
  const ::std::string& bindemail() const;
  void set_bindemail(const ::std::string& value);
  #if LANG_CXX11
  void set_bindemail(::std::string&& value);
  #endif
  void set_bindemail(const char* value);
  void set_bindemail(const char* value, size_t size);
  ::std::string* mutable_bindemail();
  ::std::string* release_bindemail();
  void set_allocated_bindemail(::std::string* bindemail);

  // optional string PushMailSettingTicket = 10;
  bool has_pushmailsettingticket() const;
  void clear_pushmailsettingticket();
  static const int kPushMailSettingTicketFieldNumber = 10;
  const ::std::string& pushmailsettingticket() const;
  void set_pushmailsettingticket(const ::std::string& value);
  #if LANG_CXX11
  void set_pushmailsettingticket(::std::string&& value);
  #endif
  void set_pushmailsettingticket(const char* value);
  void set_pushmailsettingticket(const char* value, size_t size);
  ::std::string* mutable_pushmailsettingticket();
  ::std::string* release_pushmailsettingticket();
  void set_allocated_pushmailsettingticket(::std::string* pushmailsettingticket);

  // optional string FSURL = 15;
  bool has_fsurl() const;
  void clear_fsurl();
  static const int kFSURLFieldNumber = 15;
  const ::std::string& fsurl() const;
  void set_fsurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fsurl(::std::string&& value);
  #endif
  void set_fsurl(const char* value);
  void set_fsurl(const char* value, size_t size);
  ::std::string* mutable_fsurl();
  ::std::string* release_fsurl();
  void set_allocated_fsurl(::std::string* fsurl);

  // optional string UserName = 16;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 16;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string AuthKey = 21;
  bool has_authkey() const;
  void clear_authkey();
  static const int kAuthKeyFieldNumber = 21;
  const ::std::string& authkey() const;
  void set_authkey(const ::std::string& value);
  #if LANG_CXX11
  void set_authkey(::std::string&& value);
  #endif
  void set_authkey(const char* value);
  void set_authkey(const char* value, size_t size);
  ::std::string* mutable_authkey();
  ::std::string* release_authkey();
  void set_allocated_authkey(::std::string* authkey);

  // optional string Password = 23;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 23;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string AutoAuthTicket = 26;
  bool has_autoauthticket() const;
  void clear_autoauthticket();
  static const int kAutoAuthTicketFieldNumber = 26;
  const ::std::string& autoauthticket() const;
  void set_autoauthticket(const ::std::string& value);
  #if LANG_CXX11
  void set_autoauthticket(::std::string&& value);
  #endif
  void set_autoauthticket(const char* value);
  void set_autoauthticket(const char* value, size_t size);
  ::std::string* mutable_autoauthticket();
  ::std::string* release_autoauthticket();
  void set_allocated_autoauthticket(::std::string* autoauthticket);

  // optional string StepTicket = 28;
  bool has_stepticket() const;
  void clear_stepticket();
  static const int kStepTicketFieldNumber = 28;
  const ::std::string& stepticket() const;
  void set_stepticket(const ::std::string& value);
  #if LANG_CXX11
  void set_stepticket(::std::string&& value);
  #endif
  void set_stepticket(const char* value);
  void set_stepticket(const char* value, size_t size);
  ::std::string* mutable_stepticket();
  ::std::string* release_stepticket();
  void set_allocated_stepticket(::std::string* stepticket);

  // optional string VerifySignature = 29;
  bool has_verifysignature() const;
  void clear_verifysignature();
  static const int kVerifySignatureFieldNumber = 29;
  const ::std::string& verifysignature() const;
  void set_verifysignature(const ::std::string& value);
  #if LANG_CXX11
  void set_verifysignature(::std::string&& value);
  #endif
  void set_verifysignature(const char* value);
  void set_verifysignature(const char* value, size_t size);
  ::std::string* mutable_verifysignature();
  ::std::string* release_verifysignature();
  void set_allocated_verifysignature(::std::string* verifysignature);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.BuiltinIPList BuiltinIPList = 14;
  bool has_builtiniplist() const;
  void clear_builtiniplist();
  static const int kBuiltinIPListFieldNumber = 14;
  const ::micromsg::BuiltinIPList& builtiniplist() const;
  ::micromsg::BuiltinIPList* mutable_builtiniplist();
  ::micromsg::BuiltinIPList* release_builtiniplist();
  void set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist);

  // optional .micromsg.NetworkControl NetworkControl = 18;
  bool has_networkcontrol() const;
  void clear_networkcontrol();
  static const int kNetworkControlFieldNumber = 18;
  const ::micromsg::NetworkControl& networkcontrol() const;
  ::micromsg::NetworkControl* mutable_networkcontrol();
  ::micromsg::NetworkControl* release_networkcontrol();
  void set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol);

  // optional .micromsg.PluginKeyList PluginKeyList = 22;
  bool has_pluginkeylist() const;
  void clear_pluginkeylist();
  static const int kPluginKeyListFieldNumber = 22;
  const ::micromsg::PluginKeyList& pluginkeylist() const;
  ::micromsg::PluginKeyList* mutable_pluginkeylist();
  ::micromsg::PluginKeyList* release_pluginkeylist();
  void set_allocated_pluginkeylist(::micromsg::PluginKeyList* pluginkeylist);

  // optional .micromsg.HostList NewHostList = 25;
  bool has_newhostlist() const;
  void clear_newhostlist();
  static const int kNewHostListFieldNumber = 25;
  const ::micromsg::HostList& newhostlist() const;
  ::micromsg::HostList* mutable_newhostlist();
  ::micromsg::HostList* release_newhostlist();
  void set_allocated_newhostlist(::micromsg::HostList* newhostlist);

  // optional .micromsg.CDNDnsInfo DnsInfo = 27;
  bool has_dnsinfo() const;
  void clear_dnsinfo();
  static const int kDnsInfoFieldNumber = 27;
  const ::micromsg::CDNDnsInfo& dnsinfo() const;
  ::micromsg::CDNDnsInfo* mutable_dnsinfo();
  ::micromsg::CDNDnsInfo* release_dnsinfo();
  void set_allocated_dnsinfo(::micromsg::CDNDnsInfo* dnsinfo);

  // optional .micromsg.SKBuiltinBuffer_t VerifyBuff = 30;
  bool has_verifybuff() const;
  void clear_verifybuff();
  static const int kVerifyBuffFieldNumber = 30;
  const ::micromsg::SKBuiltinBuffer_t& verifybuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_verifybuff();
  ::micromsg::SKBuiltinBuffer_t* release_verifybuff();
  void set_allocated_verifybuff(::micromsg::SKBuiltinBuffer_t* verifybuff);

  // optional .micromsg.ShowStyleKey ShowStyle = 31;
  bool has_showstyle() const;
  void clear_showstyle();
  static const int kShowStyleFieldNumber = 31;
  const ::micromsg::ShowStyleKey& showstyle() const;
  ::micromsg::ShowStyleKey* mutable_showstyle();
  ::micromsg::ShowStyleKey* release_showstyle();
  void set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle);

  // optional .micromsg.CDNDnsInfo SnsDnsInfo = 32;
  bool has_snsdnsinfo() const;
  void clear_snsdnsinfo();
  static const int kSnsDnsInfoFieldNumber = 32;
  const ::micromsg::CDNDnsInfo& snsdnsinfo() const;
  ::micromsg::CDNDnsInfo* mutable_snsdnsinfo();
  ::micromsg::CDNDnsInfo* release_snsdnsinfo();
  void set_allocated_snsdnsinfo(::micromsg::CDNDnsInfo* snsdnsinfo);

  // optional .micromsg.CDNDnsInfo AppDnsInfo = 33;
  bool has_appdnsinfo() const;
  void clear_appdnsinfo();
  static const int kAppDnsInfoFieldNumber = 33;
  const ::micromsg::CDNDnsInfo& appdnsinfo() const;
  ::micromsg::CDNDnsInfo* mutable_appdnsinfo();
  ::micromsg::CDNDnsInfo* release_appdnsinfo();
  void set_allocated_appdnsinfo(::micromsg::CDNDnsInfo* appdnsinfo);

  // optional .micromsg.SecAuthRegKeySect SecAuthRegKeySect = 34;
  bool has_secauthregkeysect() const;
  void clear_secauthregkeysect();
  static const int kSecAuthRegKeySectFieldNumber = 34;
  const ::micromsg::SecAuthRegKeySect& secauthregkeysect() const;
  ::micromsg::SecAuthRegKeySect* mutable_secauthregkeysect();
  ::micromsg::SecAuthRegKeySect* release_secauthregkeysect();
  void set_allocated_secauthregkeysect(::micromsg::SecAuthRegKeySect* secauthregkeysect);

  // required uint32 Uin = 2;
  bool has_uin() const;
  void clear_uin();
  static const int kUinFieldNumber = 2;
  ::google::protobuf::uint32 uin() const;
  void set_uin(::google::protobuf::uint32 value);

  // required uint32 PushMailStatus = 8;
  bool has_pushmailstatus() const;
  void clear_pushmailstatus();
  static const int kPushMailStatusFieldNumber = 8;
  ::google::protobuf::uint32 pushmailstatus() const;
  void set_pushmailstatus(::google::protobuf::uint32 value);

  // optional uint32 SendCardBitFlag = 9;
  bool has_sendcardbitflag() const;
  void clear_sendcardbitflag();
  static const int kSendCardBitFlagFieldNumber = 9;
  ::google::protobuf::uint32 sendcardbitflag() const;
  void set_sendcardbitflag(::google::protobuf::uint32 value);

  // optional uint32 Status = 17;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 17;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // optional uint32 ReturnFlag = 19;
  bool has_returnflag() const;
  void clear_returnflag();
  static const int kReturnFlagFieldNumber = 19;
  ::google::protobuf::uint32 returnflag() const;
  void set_returnflag(::google::protobuf::uint32 value);

  // optional uint32 RegType = 20;
  bool has_regtype() const;
  void clear_regtype();
  static const int kRegTypeFieldNumber = 20;
  ::google::protobuf::uint32 regtype() const;
  void set_regtype(::google::protobuf::uint32 value);

  // optional uint32 ProfileFlag = 24;
  bool has_profileflag() const;
  void clear_profileflag();
  static const int kProfileFlagFieldNumber = 24;
  ::google::protobuf::uint32 profileflag() const;
  void set_profileflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.NewRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_uin();
  void clear_has_uin();
  void set_has_sessionkey();
  void clear_has_sessionkey();
  void set_has_officialusername();
  void clear_has_officialusername();
  void set_has_officialnickname();
  void clear_has_officialnickname();
  void set_has_qqmicroblogusername();
  void clear_has_qqmicroblogusername();
  void set_has_bindemail();
  void clear_has_bindemail();
  void set_has_pushmailstatus();
  void clear_has_pushmailstatus();
  void set_has_sendcardbitflag();
  void clear_has_sendcardbitflag();
  void set_has_pushmailsettingticket();
  void clear_has_pushmailsettingticket();
  void set_has_builtiniplist();
  void clear_has_builtiniplist();
  void set_has_fsurl();
  void clear_has_fsurl();
  void set_has_username();
  void clear_has_username();
  void set_has_status();
  void clear_has_status();
  void set_has_networkcontrol();
  void clear_has_networkcontrol();
  void set_has_returnflag();
  void clear_has_returnflag();
  void set_has_regtype();
  void clear_has_regtype();
  void set_has_authkey();
  void clear_has_authkey();
  void set_has_pluginkeylist();
  void clear_has_pluginkeylist();
  void set_has_password();
  void clear_has_password();
  void set_has_profileflag();
  void clear_has_profileflag();
  void set_has_newhostlist();
  void clear_has_newhostlist();
  void set_has_autoauthticket();
  void clear_has_autoauthticket();
  void set_has_dnsinfo();
  void clear_has_dnsinfo();
  void set_has_stepticket();
  void clear_has_stepticket();
  void set_has_verifysignature();
  void clear_has_verifysignature();
  void set_has_verifybuff();
  void clear_has_verifybuff();
  void set_has_showstyle();
  void clear_has_showstyle();
  void set_has_snsdnsinfo();
  void clear_has_snsdnsinfo();
  void set_has_appdnsinfo();
  void clear_has_appdnsinfo();
  void set_has_secauthregkeysect();
  void clear_has_secauthregkeysect();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sessionkey_;
  ::google::protobuf::internal::ArenaStringPtr officialusername_;
  ::google::protobuf::internal::ArenaStringPtr officialnickname_;
  ::google::protobuf::internal::ArenaStringPtr qqmicroblogusername_;
  ::google::protobuf::internal::ArenaStringPtr bindemail_;
  ::google::protobuf::internal::ArenaStringPtr pushmailsettingticket_;
  ::google::protobuf::internal::ArenaStringPtr fsurl_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr authkey_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr autoauthticket_;
  ::google::protobuf::internal::ArenaStringPtr stepticket_;
  ::google::protobuf::internal::ArenaStringPtr verifysignature_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::BuiltinIPList* builtiniplist_;
  ::micromsg::NetworkControl* networkcontrol_;
  ::micromsg::PluginKeyList* pluginkeylist_;
  ::micromsg::HostList* newhostlist_;
  ::micromsg::CDNDnsInfo* dnsinfo_;
  ::micromsg::SKBuiltinBuffer_t* verifybuff_;
  ::micromsg::ShowStyleKey* showstyle_;
  ::micromsg::CDNDnsInfo* snsdnsinfo_;
  ::micromsg::CDNDnsInfo* appdnsinfo_;
  ::micromsg::SecAuthRegKeySect* secauthregkeysect_;
  ::google::protobuf::uint32 uin_;
  ::google::protobuf::uint32 pushmailstatus_;
  ::google::protobuf::uint32 sendcardbitflag_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 returnflag_;
  ::google::protobuf::uint32 regtype_;
  ::google::protobuf::uint32 profileflag_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSuggestAliasRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetSuggestAliasRequest) */ {
 public:
  GetSuggestAliasRequest();
  virtual ~GetSuggestAliasRequest();

  GetSuggestAliasRequest(const GetSuggestAliasRequest& from);

  inline GetSuggestAliasRequest& operator=(const GetSuggestAliasRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSuggestAliasRequest& default_instance();

  static inline const GetSuggestAliasRequest* internal_default_instance() {
    return reinterpret_cast<const GetSuggestAliasRequest*>(
               &_GetSuggestAliasRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(GetSuggestAliasRequest* other);

  // implements Message ----------------------------------------------

  inline GetSuggestAliasRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetSuggestAliasRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetSuggestAliasRequest& from);
  void MergeFrom(const GetSuggestAliasRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetSuggestAliasRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RegBindName = 3;
  bool has_regbindname() const;
  void clear_regbindname();
  static const int kRegBindNameFieldNumber = 3;
  const ::std::string& regbindname() const;
  void set_regbindname(const ::std::string& value);
  #if LANG_CXX11
  void set_regbindname(::std::string&& value);
  #endif
  void set_regbindname(const char* value);
  void set_regbindname(const char* value, size_t size);
  ::std::string* mutable_regbindname();
  ::std::string* release_regbindname();
  void set_allocated_regbindname(::std::string* regbindname);

  // optional string RegTicket = 4;
  bool has_regticket() const;
  void clear_regticket();
  static const int kRegTicketFieldNumber = 4;
  const ::std::string& regticket() const;
  void set_regticket(const ::std::string& value);
  #if LANG_CXX11
  void set_regticket(::std::string&& value);
  #endif
  void set_regticket(const char* value);
  void set_regticket(const char* value, size_t size);
  ::std::string* mutable_regticket();
  ::std::string* release_regticket();
  void set_allocated_regticket(::std::string* regticket);

  // optional string NickName = 5;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNickNameFieldNumber = 5;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional string InputAlias = 6;
  bool has_inputalias() const;
  void clear_inputalias();
  static const int kInputAliasFieldNumber = 6;
  const ::std::string& inputalias() const;
  void set_inputalias(const ::std::string& value);
  #if LANG_CXX11
  void set_inputalias(::std::string&& value);
  #endif
  void set_inputalias(const char* value);
  void set_inputalias(const char* value, size_t size);
  ::std::string* mutable_inputalias();
  ::std::string* release_inputalias();
  void set_allocated_inputalias(::std::string* inputalias);

  // optional string VerifySignature = 7;
  bool has_verifysignature() const;
  void clear_verifysignature();
  static const int kVerifySignatureFieldNumber = 7;
  const ::std::string& verifysignature() const;
  void set_verifysignature(const ::std::string& value);
  #if LANG_CXX11
  void set_verifysignature(::std::string&& value);
  #endif
  void set_verifysignature(const char* value);
  void set_verifysignature(const char* value, size_t size);
  ::std::string* mutable_verifysignature();
  ::std::string* release_verifysignature();
  void set_allocated_verifysignature(::std::string* verifysignature);

  // optional string VerifyContent = 8;
  bool has_verifycontent() const;
  void clear_verifycontent();
  static const int kVerifyContentFieldNumber = 8;
  const ::std::string& verifycontent() const;
  void set_verifycontent(const ::std::string& value);
  #if LANG_CXX11
  void set_verifycontent(::std::string&& value);
  #endif
  void set_verifycontent(const char* value);
  void set_verifycontent(const char* value, size_t size);
  ::std::string* mutable_verifycontent();
  ::std::string* release_verifycontent();
  void set_allocated_verifycontent(::std::string* verifycontent);

  // optional string Language = 10;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 10;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string ClientSeqID = 11;
  bool has_clientseqid() const;
  void clear_clientseqid();
  static const int kClientSeqIDFieldNumber = 11;
  const ::std::string& clientseqid() const;
  void set_clientseqid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientseqid(::std::string&& value);
  #endif
  void set_clientseqid(const char* value);
  void set_clientseqid(const char* value, size_t size);
  ::std::string* mutable_clientseqid();
  ::std::string* release_clientseqid();
  void set_allocated_clientseqid(::std::string* clientseqid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // required uint32 RegMode = 9;
  bool has_regmode() const;
  void clear_regmode();
  static const int kRegModeFieldNumber = 9;
  ::google::protobuf::uint32 regmode() const;
  void set_regmode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetSuggestAliasRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_regbindname();
  void clear_has_regbindname();
  void set_has_regticket();
  void clear_has_regticket();
  void set_has_nickname();
  void clear_has_nickname();
  void set_has_inputalias();
  void clear_has_inputalias();
  void set_has_verifysignature();
  void clear_has_verifysignature();
  void set_has_verifycontent();
  void clear_has_verifycontent();
  void set_has_regmode();
  void clear_has_regmode();
  void set_has_language();
  void clear_has_language();
  void set_has_clientseqid();
  void clear_has_clientseqid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr regbindname_;
  ::google::protobuf::internal::ArenaStringPtr regticket_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr inputalias_;
  ::google::protobuf::internal::ArenaStringPtr verifysignature_;
  ::google::protobuf::internal::ArenaStringPtr verifycontent_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr clientseqid_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::google::protobuf::uint32 regmode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSuggestAliasResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetSuggestAliasResponse) */ {
 public:
  GetSuggestAliasResponse();
  virtual ~GetSuggestAliasResponse();

  GetSuggestAliasResponse(const GetSuggestAliasResponse& from);

  inline GetSuggestAliasResponse& operator=(const GetSuggestAliasResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSuggestAliasResponse& default_instance();

  static inline const GetSuggestAliasResponse* internal_default_instance() {
    return reinterpret_cast<const GetSuggestAliasResponse*>(
               &_GetSuggestAliasResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(GetSuggestAliasResponse* other);

  // implements Message ----------------------------------------------

  inline GetSuggestAliasResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetSuggestAliasResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetSuggestAliasResponse& from);
  void MergeFrom(const GetSuggestAliasResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetSuggestAliasResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .micromsg.SKBuiltinString_t List = 3;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 3;
  const ::micromsg::SKBuiltinString_t& list(int index) const;
  ::micromsg::SKBuiltinString_t* mutable_list(int index);
  ::micromsg::SKBuiltinString_t* add_list();
  ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t >*
      mutable_list();
  const ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t >&
      list() const;

  // optional string VerifySignature = 4;
  bool has_verifysignature() const;
  void clear_verifysignature();
  static const int kVerifySignatureFieldNumber = 4;
  const ::std::string& verifysignature() const;
  void set_verifysignature(const ::std::string& value);
  #if LANG_CXX11
  void set_verifysignature(::std::string&& value);
  #endif
  void set_verifysignature(const char* value);
  void set_verifysignature(const char* value, size_t size);
  ::std::string* mutable_verifysignature();
  ::std::string* release_verifysignature();
  void set_allocated_verifysignature(::std::string* verifysignature);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.SKBuiltinBuffer_t VerifyBuff = 5;
  bool has_verifybuff() const;
  void clear_verifybuff();
  static const int kVerifyBuffFieldNumber = 5;
  const ::micromsg::SKBuiltinBuffer_t& verifybuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_verifybuff();
  ::micromsg::SKBuiltinBuffer_t* release_verifybuff();
  void set_allocated_verifybuff(::micromsg::SKBuiltinBuffer_t* verifybuff);

  // required uint32 Count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // optional int32 UserNameRet = 6;
  bool has_usernameret() const;
  void clear_usernameret();
  static const int kUserNameRetFieldNumber = 6;
  ::google::protobuf::int32 usernameret() const;
  void set_usernameret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetSuggestAliasResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_count();
  void clear_has_count();
  void set_has_verifysignature();
  void clear_has_verifysignature();
  void set_has_verifybuff();
  void clear_has_verifybuff();
  void set_has_usernameret();
  void clear_has_usernameret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t > list_;
  ::google::protobuf::internal::ArenaStringPtr verifysignature_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinBuffer_t* verifybuff_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::int32 usernameret_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindOpMobileRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindOpMobileRequest) */ {
 public:
  BindOpMobileRequest();
  virtual ~BindOpMobileRequest();

  BindOpMobileRequest(const BindOpMobileRequest& from);

  inline BindOpMobileRequest& operator=(const BindOpMobileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindOpMobileRequest& default_instance();

  static inline const BindOpMobileRequest* internal_default_instance() {
    return reinterpret_cast<const BindOpMobileRequest*>(
               &_BindOpMobileRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(BindOpMobileRequest* other);

  // implements Message ----------------------------------------------

  inline BindOpMobileRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BindOpMobileRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindOpMobileRequest& from);
  void MergeFrom(const BindOpMobileRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindOpMobileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 2;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string Mobile = 3;
  bool has_mobile() const;
  void clear_mobile();
  static const int kMobileFieldNumber = 3;
  const ::std::string& mobile() const;
  void set_mobile(const ::std::string& value);
  #if LANG_CXX11
  void set_mobile(::std::string&& value);
  #endif
  void set_mobile(const char* value);
  void set_mobile(const char* value, size_t size);
  ::std::string* mutable_mobile();
  ::std::string* release_mobile();
  void set_allocated_mobile(::std::string* mobile);

  // optional string Verifycode = 5;
  bool has_verifycode() const;
  void clear_verifycode();
  static const int kVerifycodeFieldNumber = 5;
  const ::std::string& verifycode() const;
  void set_verifycode(const ::std::string& value);
  #if LANG_CXX11
  void set_verifycode(::std::string&& value);
  #endif
  void set_verifycode(const char* value);
  void set_verifycode(const char* value, size_t size);
  ::std::string* mutable_verifycode();
  ::std::string* release_verifycode();
  void set_allocated_verifycode(::std::string* verifycode);

  // optional string DialLang = 7;
  bool has_diallang() const;
  void clear_diallang();
  static const int kDialLangFieldNumber = 7;
  const ::std::string& diallang() const;
  void set_diallang(const ::std::string& value);
  #if LANG_CXX11
  void set_diallang(::std::string&& value);
  #endif
  void set_diallang(const char* value);
  void set_diallang(const char* value, size_t size);
  ::std::string* mutable_diallang();
  ::std::string* release_diallang();
  void set_allocated_diallang(::std::string* diallang);

  // optional string AuthTicket = 8;
  bool has_authticket() const;
  void clear_authticket();
  static const int kAuthTicketFieldNumber = 8;
  const ::std::string& authticket() const;
  void set_authticket(const ::std::string& value);
  #if LANG_CXX11
  void set_authticket(::std::string&& value);
  #endif
  void set_authticket(const char* value);
  void set_authticket(const char* value, size_t size);
  ::std::string* mutable_authticket();
  ::std::string* release_authticket();
  void set_allocated_authticket(::std::string* authticket);

  // optional string SafeDeviceName = 10;
  bool has_safedevicename() const;
  void clear_safedevicename();
  static const int kSafeDeviceNameFieldNumber = 10;
  const ::std::string& safedevicename() const;
  void set_safedevicename(const ::std::string& value);
  #if LANG_CXX11
  void set_safedevicename(::std::string&& value);
  #endif
  void set_safedevicename(const char* value);
  void set_safedevicename(const char* value, size_t size);
  ::std::string* mutable_safedevicename();
  ::std::string* release_safedevicename();
  void set_allocated_safedevicename(::std::string* safedevicename);

  // optional string SafeDeviceType = 11;
  bool has_safedevicetype() const;
  void clear_safedevicetype();
  static const int kSafeDeviceTypeFieldNumber = 11;
  const ::std::string& safedevicetype() const;
  void set_safedevicetype(const ::std::string& value);
  #if LANG_CXX11
  void set_safedevicetype(::std::string&& value);
  #endif
  void set_safedevicetype(const char* value);
  void set_safedevicetype(const char* value, size_t size);
  ::std::string* mutable_safedevicetype();
  ::std::string* release_safedevicetype();
  void set_allocated_safedevicetype(::std::string* safedevicetype);

  // optional string Language = 13;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 13;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string ClientSeqID = 16;
  bool has_clientseqid() const;
  void clear_clientseqid();
  static const int kClientSeqIDFieldNumber = 16;
  const ::std::string& clientseqid() const;
  void set_clientseqid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientseqid(::std::string&& value);
  #endif
  void set_clientseqid(const char* value);
  void set_clientseqid(const char* value, size_t size);
  ::std::string* mutable_clientseqid();
  ::std::string* release_clientseqid();
  void set_allocated_clientseqid(::std::string* clientseqid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.SKBuiltinBuffer_t RandomEncryKey = 12;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 12;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // required int32 Opcode = 4;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 4;
  ::google::protobuf::int32 opcode() const;
  void set_opcode(::google::protobuf::int32 value);

  // optional int32 DialFlag = 6;
  bool has_dialflag() const;
  void clear_dialflag();
  static const int kDialFlagFieldNumber = 6;
  ::google::protobuf::int32 dialflag() const;
  void set_dialflag(::google::protobuf::int32 value);

  // optional uint32 ForceReg = 9;
  bool has_forcereg() const;
  void clear_forcereg();
  static const int kForceRegFieldNumber = 9;
  ::google::protobuf::uint32 forcereg() const;
  void set_forcereg(::google::protobuf::uint32 value);

  // optional uint32 InputMobileRetrys = 14;
  bool has_inputmobileretrys() const;
  void clear_inputmobileretrys();
  static const int kInputMobileRetrysFieldNumber = 14;
  ::google::protobuf::uint32 inputmobileretrys() const;
  void set_inputmobileretrys(::google::protobuf::uint32 value);

  // optional uint32 AdjustRet = 15;
  bool has_adjustret() const;
  void clear_adjustret();
  static const int kAdjustRetFieldNumber = 15;
  ::google::protobuf::uint32 adjustret() const;
  void set_adjustret(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BindOpMobileRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_username();
  void clear_has_username();
  void set_has_mobile();
  void clear_has_mobile();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_verifycode();
  void clear_has_verifycode();
  void set_has_dialflag();
  void clear_has_dialflag();
  void set_has_diallang();
  void clear_has_diallang();
  void set_has_authticket();
  void clear_has_authticket();
  void set_has_forcereg();
  void clear_has_forcereg();
  void set_has_safedevicename();
  void clear_has_safedevicename();
  void set_has_safedevicetype();
  void clear_has_safedevicetype();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_language();
  void clear_has_language();
  void set_has_inputmobileretrys();
  void clear_has_inputmobileretrys();
  void set_has_adjustret();
  void clear_has_adjustret();
  void set_has_clientseqid();
  void clear_has_clientseqid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr mobile_;
  ::google::protobuf::internal::ArenaStringPtr verifycode_;
  ::google::protobuf::internal::ArenaStringPtr diallang_;
  ::google::protobuf::internal::ArenaStringPtr authticket_;
  ::google::protobuf::internal::ArenaStringPtr safedevicename_;
  ::google::protobuf::internal::ArenaStringPtr safedevicetype_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr clientseqid_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::google::protobuf::int32 opcode_;
  ::google::protobuf::int32 dialflag_;
  ::google::protobuf::uint32 forcereg_;
  ::google::protobuf::uint32 inputmobileretrys_;
  ::google::protobuf::uint32 adjustret_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindOpMobileResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindOpMobileResponse) */ {
 public:
  BindOpMobileResponse();
  virtual ~BindOpMobileResponse();

  BindOpMobileResponse(const BindOpMobileResponse& from);

  inline BindOpMobileResponse& operator=(const BindOpMobileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindOpMobileResponse& default_instance();

  static inline const BindOpMobileResponse* internal_default_instance() {
    return reinterpret_cast<const BindOpMobileResponse*>(
               &_BindOpMobileResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(BindOpMobileResponse* other);

  // implements Message ----------------------------------------------

  inline BindOpMobileResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BindOpMobileResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindOpMobileResponse& from);
  void MergeFrom(const BindOpMobileResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindOpMobileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ticket = 2;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 2;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // optional string SmsNo = 3;
  bool has_smsno() const;
  void clear_smsno();
  static const int kSmsNoFieldNumber = 3;
  const ::std::string& smsno() const;
  void set_smsno(const ::std::string& value);
  #if LANG_CXX11
  void set_smsno(::std::string&& value);
  #endif
  void set_smsno(const char* value);
  void set_smsno(const char* value, size_t size);
  ::std::string* mutable_smsno();
  ::std::string* release_smsno();
  void set_allocated_smsno(::std::string* smsno);

  // optional string Pwd = 5;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 5;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // optional string Username = 6;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 6;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string AuthTicket = 10;
  bool has_authticket() const;
  void clear_authticket();
  static const int kAuthTicketFieldNumber = 10;
  const ::std::string& authticket() const;
  void set_authticket(const ::std::string& value);
  #if LANG_CXX11
  void set_authticket(::std::string&& value);
  #endif
  void set_authticket(const char* value);
  void set_authticket(const char* value, size_t size);
  ::std::string* mutable_authticket();
  ::std::string* release_authticket();
  void set_allocated_authticket(::std::string* authticket);

  // optional string CC = 12;
  bool has_cc() const;
  void clear_cc();
  static const int kCCFieldNumber = 12;
  const ::std::string& cc() const;
  void set_cc(const ::std::string& value);
  #if LANG_CXX11
  void set_cc(::std::string&& value);
  #endif
  void set_cc(const char* value);
  void set_cc(const char* value, size_t size);
  ::std::string* mutable_cc();
  ::std::string* release_cc();
  void set_allocated_cc(::std::string* cc);

  // optional string PureMobile = 15;
  bool has_puremobile() const;
  void clear_puremobile();
  static const int kPureMobileFieldNumber = 15;
  const ::std::string& puremobile() const;
  void set_puremobile(const ::std::string& value);
  #if LANG_CXX11
  void set_puremobile(::std::string&& value);
  #endif
  void set_puremobile(const char* value);
  void set_puremobile(const char* value, size_t size);
  ::std::string* mutable_puremobile();
  ::std::string* release_puremobile();
  void set_allocated_puremobile(::std::string* puremobile);

  // optional string FormatedMobile = 16;
  bool has_formatedmobile() const;
  void clear_formatedmobile();
  static const int kFormatedMobileFieldNumber = 16;
  const ::std::string& formatedmobile() const;
  void set_formatedmobile(const ::std::string& value);
  #if LANG_CXX11
  void set_formatedmobile(::std::string&& value);
  #endif
  void set_formatedmobile(const char* value);
  void set_formatedmobile(const char* value, size_t size);
  ::std::string* mutable_formatedmobile();
  ::std::string* release_formatedmobile();
  void set_allocated_formatedmobile(::std::string* formatedmobile);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.HostList NewHostList = 7;
  bool has_newhostlist() const;
  void clear_newhostlist();
  static const int kNewHostListFieldNumber = 7;
  const ::micromsg::HostList& newhostlist() const;
  ::micromsg::HostList* mutable_newhostlist();
  ::micromsg::HostList* release_newhostlist();
  void set_allocated_newhostlist(::micromsg::HostList* newhostlist);

  // optional .micromsg.BuiltinIPList BuiltinIPList = 8;
  bool has_builtiniplist() const;
  void clear_builtiniplist();
  static const int kBuiltinIPListFieldNumber = 8;
  const ::micromsg::BuiltinIPList& builtiniplist() const;
  ::micromsg::BuiltinIPList* mutable_builtiniplist();
  ::micromsg::BuiltinIPList* release_builtiniplist();
  void set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist);

  // optional .micromsg.NetworkControl NetworkControl = 9;
  bool has_networkcontrol() const;
  void clear_networkcontrol();
  static const int kNetworkControlFieldNumber = 9;
  const ::micromsg::NetworkControl& networkcontrol() const;
  ::micromsg::NetworkControl* mutable_networkcontrol();
  ::micromsg::NetworkControl* release_networkcontrol();
  void set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol);

  // optional .micromsg.SafeDeviceList SafeDeviceList = 14;
  bool has_safedevicelist() const;
  void clear_safedevicelist();
  static const int kSafeDeviceListFieldNumber = 14;
  const ::micromsg::SafeDeviceList& safedevicelist() const;
  ::micromsg::SafeDeviceList* mutable_safedevicelist();
  ::micromsg::SafeDeviceList* release_safedevicelist();
  void set_allocated_safedevicelist(::micromsg::SafeDeviceList* safedevicelist);

  // optional .micromsg.ShowStyleKey ShowStyle = 17;
  bool has_showstyle() const;
  void clear_showstyle();
  static const int kShowStyleFieldNumber = 17;
  const ::micromsg::ShowStyleKey& showstyle() const;
  ::micromsg::ShowStyleKey* mutable_showstyle();
  ::micromsg::ShowStyleKey* release_showstyle();
  void set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle);

  // optional uint32 NeedSetPwd = 4;
  bool has_needsetpwd() const;
  void clear_needsetpwd();
  static const int kNeedSetPwdFieldNumber = 4;
  ::google::protobuf::uint32 needsetpwd() const;
  void set_needsetpwd(::google::protobuf::uint32 value);

  // optional uint32 SafeDevice = 11;
  bool has_safedevice() const;
  void clear_safedevice();
  static const int kSafeDeviceFieldNumber = 11;
  ::google::protobuf::uint32 safedevice() const;
  void set_safedevice(::google::protobuf::uint32 value);

  // optional uint32 ObsoleteItem1 = 13;
  bool has_obsoleteitem1() const;
  void clear_obsoleteitem1();
  static const int kObsoleteItem1FieldNumber = 13;
  ::google::protobuf::uint32 obsoleteitem1() const;
  void set_obsoleteitem1(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BindOpMobileResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_ticket();
  void clear_has_ticket();
  void set_has_smsno();
  void clear_has_smsno();
  void set_has_needsetpwd();
  void clear_has_needsetpwd();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_username();
  void clear_has_username();
  void set_has_newhostlist();
  void clear_has_newhostlist();
  void set_has_builtiniplist();
  void clear_has_builtiniplist();
  void set_has_networkcontrol();
  void clear_has_networkcontrol();
  void set_has_authticket();
  void clear_has_authticket();
  void set_has_safedevice();
  void clear_has_safedevice();
  void set_has_cc();
  void clear_has_cc();
  void set_has_obsoleteitem1();
  void clear_has_obsoleteitem1();
  void set_has_safedevicelist();
  void clear_has_safedevicelist();
  void set_has_puremobile();
  void clear_has_puremobile();
  void set_has_formatedmobile();
  void clear_has_formatedmobile();
  void set_has_showstyle();
  void clear_has_showstyle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::google::protobuf::internal::ArenaStringPtr smsno_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr authticket_;
  ::google::protobuf::internal::ArenaStringPtr cc_;
  ::google::protobuf::internal::ArenaStringPtr puremobile_;
  ::google::protobuf::internal::ArenaStringPtr formatedmobile_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::HostList* newhostlist_;
  ::micromsg::BuiltinIPList* builtiniplist_;
  ::micromsg::NetworkControl* networkcontrol_;
  ::micromsg::SafeDeviceList* safedevicelist_;
  ::micromsg::ShowStyleKey* showstyle_;
  ::google::protobuf::uint32 needsetpwd_;
  ::google::protobuf::uint32 safedevice_;
  ::google::protobuf::uint32 obsoleteitem1_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmailRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmailRegRequest) */ {
 public:
  EmailRegRequest();
  virtual ~EmailRegRequest();

  EmailRegRequest(const EmailRegRequest& from);

  inline EmailRegRequest& operator=(const EmailRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmailRegRequest& default_instance();

  static inline const EmailRegRequest* internal_default_instance() {
    return reinterpret_cast<const EmailRegRequest*>(
               &_EmailRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(EmailRegRequest* other);

  // implements Message ----------------------------------------------

  inline EmailRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  EmailRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmailRegRequest& from);
  void MergeFrom(const EmailRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmailRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Email = 4;
  bool has_email() const;
  void clear_email();
  static const int kEmailFieldNumber = 4;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // optional string Language = 5;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 5;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string Pwd = 6;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 6;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // optional string VerifyCode = 7;
  bool has_verifycode() const;
  void clear_verifycode();
  static const int kVerifyCodeFieldNumber = 7;
  const ::std::string& verifycode() const;
  void set_verifycode(const ::std::string& value);
  #if LANG_CXX11
  void set_verifycode(::std::string&& value);
  #endif
  void set_verifycode(const char* value);
  void set_verifycode(const char* value, size_t size);
  ::std::string* mutable_verifycode();
  ::std::string* release_verifycode();
  void set_allocated_verifycode(::std::string* verifycode);

  // optional string ClientSeqID = 8;
  bool has_clientseqid() const;
  void clear_clientseqid();
  static const int kClientSeqIDFieldNumber = 8;
  const ::std::string& clientseqid() const;
  void set_clientseqid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientseqid(::std::string&& value);
  #endif
  void set_clientseqid(const char* value);
  void set_clientseqid(const char* value, size_t size);
  ::std::string* mutable_clientseqid();
  ::std::string* release_clientseqid();
  void set_allocated_clientseqid(::std::string* clientseqid);

  // optional string RealCountry = 9;
  bool has_realcountry() const;
  void clear_realcountry();
  static const int kRealCountryFieldNumber = 9;
  const ::std::string& realcountry() const;
  void set_realcountry(const ::std::string& value);
  #if LANG_CXX11
  void set_realcountry(::std::string&& value);
  #endif
  void set_realcountry(const char* value);
  void set_realcountry(const char* value, size_t size);
  ::std::string* mutable_realcountry();
  ::std::string* release_realcountry();
  void set_allocated_realcountry(::std::string* realcountry);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // required uint32 Opcode = 3;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 3;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // optional uint32 VerifyScene = 10;
  bool has_verifyscene() const;
  void clear_verifyscene();
  static const int kVerifySceneFieldNumber = 10;
  ::google::protobuf::uint32 verifyscene() const;
  void set_verifyscene(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.EmailRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_email();
  void clear_has_email();
  void set_has_language();
  void clear_has_language();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_verifycode();
  void clear_has_verifycode();
  void set_has_clientseqid();
  void clear_has_clientseqid();
  void set_has_realcountry();
  void clear_has_realcountry();
  void set_has_verifyscene();
  void clear_has_verifyscene();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr verifycode_;
  ::google::protobuf::internal::ArenaStringPtr clientseqid_;
  ::google::protobuf::internal::ArenaStringPtr realcountry_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint32 verifyscene_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EmailRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.EmailRegResponse) */ {
 public:
  EmailRegResponse();
  virtual ~EmailRegResponse();

  EmailRegResponse(const EmailRegResponse& from);

  inline EmailRegResponse& operator=(const EmailRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmailRegResponse& default_instance();

  static inline const EmailRegResponse* internal_default_instance() {
    return reinterpret_cast<const EmailRegResponse*>(
               &_EmailRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(EmailRegResponse* other);

  // implements Message ----------------------------------------------

  inline EmailRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  EmailRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EmailRegResponse& from);
  void MergeFrom(const EmailRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EmailRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Ticket = 2;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 2;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.BuiltinIPList BuiltinIPList = 3;
  bool has_builtiniplist() const;
  void clear_builtiniplist();
  static const int kBuiltinIPListFieldNumber = 3;
  const ::micromsg::BuiltinIPList& builtiniplist() const;
  ::micromsg::BuiltinIPList* mutable_builtiniplist();
  ::micromsg::BuiltinIPList* release_builtiniplist();
  void set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist);

  // optional .micromsg.HostList NewHostList = 4;
  bool has_newhostlist() const;
  void clear_newhostlist();
  static const int kNewHostListFieldNumber = 4;
  const ::micromsg::HostList& newhostlist() const;
  ::micromsg::HostList* mutable_newhostlist();
  ::micromsg::HostList* release_newhostlist();
  void set_allocated_newhostlist(::micromsg::HostList* newhostlist);

  // optional .micromsg.ShowStyleKey ShowStyle = 5;
  bool has_showstyle() const;
  void clear_showstyle();
  static const int kShowStyleFieldNumber = 5;
  const ::micromsg::ShowStyleKey& showstyle() const;
  ::micromsg::ShowStyleKey* mutable_showstyle();
  ::micromsg::ShowStyleKey* release_showstyle();
  void set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle);

  // optional .micromsg.NetworkControl NetworkControl = 6;
  bool has_networkcontrol() const;
  void clear_networkcontrol();
  static const int kNetworkControlFieldNumber = 6;
  const ::micromsg::NetworkControl& networkcontrol() const;
  ::micromsg::NetworkControl* mutable_networkcontrol();
  ::micromsg::NetworkControl* release_networkcontrol();
  void set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol);

  // @@protoc_insertion_point(class_scope:micromsg.EmailRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_ticket();
  void clear_has_ticket();
  void set_has_builtiniplist();
  void clear_has_builtiniplist();
  void set_has_newhostlist();
  void clear_has_newhostlist();
  void set_has_showstyle();
  void clear_has_showstyle();
  void set_has_networkcontrol();
  void clear_has_networkcontrol();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::BuiltinIPList* builtiniplist_;
  ::micromsg::HostList* newhostlist_;
  ::micromsg::ShowStyleKey* showstyle_;
  ::micromsg::NetworkControl* networkcontrol_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetEmailPwdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.SetEmailPwdRequest) */ {
 public:
  SetEmailPwdRequest();
  virtual ~SetEmailPwdRequest();

  SetEmailPwdRequest(const SetEmailPwdRequest& from);

  inline SetEmailPwdRequest& operator=(const SetEmailPwdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetEmailPwdRequest& default_instance();

  static inline const SetEmailPwdRequest* internal_default_instance() {
    return reinterpret_cast<const SetEmailPwdRequest*>(
               &_SetEmailPwdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(SetEmailPwdRequest* other);

  // implements Message ----------------------------------------------

  inline SetEmailPwdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SetEmailPwdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetEmailPwdRequest& from);
  void MergeFrom(const SetEmailPwdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetEmailPwdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pwd = 2;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 2;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // optional string Ticket = 3;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 3;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.SetEmailPwdRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_ticket();
  void clear_has_ticket();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetEmailPwdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.SetEmailPwdResponse) */ {
 public:
  SetEmailPwdResponse();
  virtual ~SetEmailPwdResponse();

  SetEmailPwdResponse(const SetEmailPwdResponse& from);

  inline SetEmailPwdResponse& operator=(const SetEmailPwdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetEmailPwdResponse& default_instance();

  static inline const SetEmailPwdResponse* internal_default_instance() {
    return reinterpret_cast<const SetEmailPwdResponse*>(
               &_SetEmailPwdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SetEmailPwdResponse* other);

  // implements Message ----------------------------------------------

  inline SetEmailPwdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SetEmailPwdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetEmailPwdResponse& from);
  void MergeFrom(const SetEmailPwdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetEmailPwdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.SetEmailPwdResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateSafeDeviceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UpdateSafeDeviceRequest) */ {
 public:
  UpdateSafeDeviceRequest();
  virtual ~UpdateSafeDeviceRequest();

  UpdateSafeDeviceRequest(const UpdateSafeDeviceRequest& from);

  inline UpdateSafeDeviceRequest& operator=(const UpdateSafeDeviceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSafeDeviceRequest& default_instance();

  static inline const UpdateSafeDeviceRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateSafeDeviceRequest*>(
               &_UpdateSafeDeviceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(UpdateSafeDeviceRequest* other);

  // implements Message ----------------------------------------------

  inline UpdateSafeDeviceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateSafeDeviceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateSafeDeviceRequest& from);
  void MergeFrom(const UpdateSafeDeviceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateSafeDeviceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Uuid = 2;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 2;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional string Name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string DeviceType = 4;
  bool has_devicetype() const;
  void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 4;
  const ::std::string& devicetype() const;
  void set_devicetype(const ::std::string& value);
  #if LANG_CXX11
  void set_devicetype(::std::string&& value);
  #endif
  void set_devicetype(const char* value);
  void set_devicetype(const char* value, size_t size);
  ::std::string* mutable_devicetype();
  ::std::string* release_devicetype();
  void set_allocated_devicetype(::std::string* devicetype);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.UpdateSafeDeviceRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_name();
  void clear_has_name();
  void set_has_devicetype();
  void clear_has_devicetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr devicetype_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateSafeDeviceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UpdateSafeDeviceResponse) */ {
 public:
  UpdateSafeDeviceResponse();
  virtual ~UpdateSafeDeviceResponse();

  UpdateSafeDeviceResponse(const UpdateSafeDeviceResponse& from);

  inline UpdateSafeDeviceResponse& operator=(const UpdateSafeDeviceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSafeDeviceResponse& default_instance();

  static inline const UpdateSafeDeviceResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateSafeDeviceResponse*>(
               &_UpdateSafeDeviceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(UpdateSafeDeviceResponse* other);

  // implements Message ----------------------------------------------

  inline UpdateSafeDeviceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateSafeDeviceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateSafeDeviceResponse& from);
  void MergeFrom(const UpdateSafeDeviceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateSafeDeviceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional uint32 SafeDevice = 2;
  bool has_safedevice() const;
  void clear_safedevice();
  static const int kSafeDeviceFieldNumber = 2;
  ::google::protobuf::uint32 safedevice() const;
  void set_safedevice(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.UpdateSafeDeviceResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_safedevice();
  void clear_has_safedevice();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::google::protobuf::uint32 safedevice_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DelSafeDeviceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.DelSafeDeviceRequest) */ {
 public:
  DelSafeDeviceRequest();
  virtual ~DelSafeDeviceRequest();

  DelSafeDeviceRequest(const DelSafeDeviceRequest& from);

  inline DelSafeDeviceRequest& operator=(const DelSafeDeviceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelSafeDeviceRequest& default_instance();

  static inline const DelSafeDeviceRequest* internal_default_instance() {
    return reinterpret_cast<const DelSafeDeviceRequest*>(
               &_DelSafeDeviceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(DelSafeDeviceRequest* other);

  // implements Message ----------------------------------------------

  inline DelSafeDeviceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  DelSafeDeviceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DelSafeDeviceRequest& from);
  void MergeFrom(const DelSafeDeviceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DelSafeDeviceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Uuid = 2;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUuidFieldNumber = 2;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.DelSafeDeviceRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_uuid();
  void clear_has_uuid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DelSafeDeviceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.DelSafeDeviceResponse) */ {
 public:
  DelSafeDeviceResponse();
  virtual ~DelSafeDeviceResponse();

  DelSafeDeviceResponse(const DelSafeDeviceResponse& from);

  inline DelSafeDeviceResponse& operator=(const DelSafeDeviceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DelSafeDeviceResponse& default_instance();

  static inline const DelSafeDeviceResponse* internal_default_instance() {
    return reinterpret_cast<const DelSafeDeviceResponse*>(
               &_DelSafeDeviceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(DelSafeDeviceResponse* other);

  // implements Message ----------------------------------------------

  inline DelSafeDeviceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  DelSafeDeviceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DelSafeDeviceResponse& from);
  void MergeFrom(const DelSafeDeviceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DelSafeDeviceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional uint32 SafeDevice = 2;
  bool has_safedevice() const;
  void clear_safedevice();
  static const int kSafeDeviceFieldNumber = 2;
  ::google::protobuf::uint32 safedevice() const;
  void set_safedevice(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.DelSafeDeviceResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_safedevice();
  void clear_has_safedevice();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::google::protobuf::uint32 safedevice_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindSafeMobileRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindSafeMobileRequest) */ {
 public:
  BindSafeMobileRequest();
  virtual ~BindSafeMobileRequest();

  BindSafeMobileRequest(const BindSafeMobileRequest& from);

  inline BindSafeMobileRequest& operator=(const BindSafeMobileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindSafeMobileRequest& default_instance();

  static inline const BindSafeMobileRequest* internal_default_instance() {
    return reinterpret_cast<const BindSafeMobileRequest*>(
               &_BindSafeMobileRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(BindSafeMobileRequest* other);

  // implements Message ----------------------------------------------

  inline BindSafeMobileRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BindSafeMobileRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindSafeMobileRequest& from);
  void MergeFrom(const BindSafeMobileRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindSafeMobileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Mobile = 2;
  bool has_mobile() const;
  void clear_mobile();
  static const int kMobileFieldNumber = 2;
  const ::std::string& mobile() const;
  void set_mobile(const ::std::string& value);
  #if LANG_CXX11
  void set_mobile(::std::string&& value);
  #endif
  void set_mobile(const char* value);
  void set_mobile(const char* value, size_t size);
  ::std::string* mutable_mobile();
  ::std::string* release_mobile();
  void set_allocated_mobile(::std::string* mobile);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required int32 Opcode = 3;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 3;
  ::google::protobuf::int32 opcode() const;
  void set_opcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BindSafeMobileRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_mobile();
  void clear_has_mobile();
  void set_has_opcode();
  void clear_has_opcode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mobile_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::int32 opcode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindSafeMobileResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindSafeMobileResponse) */ {
 public:
  BindSafeMobileResponse();
  virtual ~BindSafeMobileResponse();

  BindSafeMobileResponse(const BindSafeMobileResponse& from);

  inline BindSafeMobileResponse& operator=(const BindSafeMobileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindSafeMobileResponse& default_instance();

  static inline const BindSafeMobileResponse* internal_default_instance() {
    return reinterpret_cast<const BindSafeMobileResponse*>(
               &_BindSafeMobileResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(BindSafeMobileResponse* other);

  // implements Message ----------------------------------------------

  inline BindSafeMobileResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BindSafeMobileResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindSafeMobileResponse& from);
  void MergeFrom(const BindSafeMobileResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindSafeMobileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.BindSafeMobileResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindQQRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindQQRequest) */ {
 public:
  BindQQRequest();
  virtual ~BindQQRequest();

  BindQQRequest(const BindQQRequest& from);

  inline BindQQRequest& operator=(const BindQQRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindQQRequest& default_instance();

  static inline const BindQQRequest* internal_default_instance() {
    return reinterpret_cast<const BindQQRequest*>(
               &_BindQQRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(BindQQRequest* other);

  // implements Message ----------------------------------------------

  inline BindQQRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BindQQRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindQQRequest& from);
  void MergeFrom(const BindQQRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindQQRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pwd = 3;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 3;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // optional string Pwd2 = 4;
  bool has_pwd2() const;
  void clear_pwd2();
  static const int kPwd2FieldNumber = 4;
  const ::std::string& pwd2() const;
  void set_pwd2(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd2(::std::string&& value);
  #endif
  void set_pwd2(const char* value);
  void set_pwd2(const char* value, size_t size);
  ::std::string* mutable_pwd2();
  ::std::string* release_pwd2();
  void set_allocated_pwd2(::std::string* pwd2);

  // optional string ImgSid = 5;
  bool has_imgsid() const;
  void clear_imgsid();
  static const int kImgSidFieldNumber = 5;
  const ::std::string& imgsid() const;
  void set_imgsid(const ::std::string& value);
  #if LANG_CXX11
  void set_imgsid(::std::string&& value);
  #endif
  void set_imgsid(const char* value);
  void set_imgsid(const char* value, size_t size);
  ::std::string* mutable_imgsid();
  ::std::string* release_imgsid();
  void set_allocated_imgsid(::std::string* imgsid);

  // optional string ImgCode = 6;
  bool has_imgcode() const;
  void clear_imgcode();
  static const int kImgCodeFieldNumber = 6;
  const ::std::string& imgcode() const;
  void set_imgcode(const ::std::string& value);
  #if LANG_CXX11
  void set_imgcode(::std::string&& value);
  #endif
  void set_imgcode(const char* value);
  void set_imgcode(const char* value, size_t size);
  ::std::string* mutable_imgcode();
  ::std::string* release_imgcode();
  void set_allocated_imgcode(::std::string* imgcode);

  // optional string SafeDeviceName = 11;
  bool has_safedevicename() const;
  void clear_safedevicename();
  static const int kSafeDeviceNameFieldNumber = 11;
  const ::std::string& safedevicename() const;
  void set_safedevicename(const ::std::string& value);
  #if LANG_CXX11
  void set_safedevicename(::std::string&& value);
  #endif
  void set_safedevicename(const char* value);
  void set_safedevicename(const char* value, size_t size);
  ::std::string* mutable_safedevicename();
  ::std::string* release_safedevicename();
  void set_allocated_safedevicename(::std::string* safedevicename);

  // optional string SafeDeviceType = 12;
  bool has_safedevicetype() const;
  void clear_safedevicetype();
  static const int kSafeDeviceTypeFieldNumber = 12;
  const ::std::string& safedevicetype() const;
  void set_safedevicetype(const ::std::string& value);
  #if LANG_CXX11
  void set_safedevicetype(::std::string&& value);
  #endif
  void set_safedevicetype(const char* value);
  void set_safedevicetype(const char* value, size_t size);
  ::std::string* mutable_safedevicetype();
  ::std::string* release_safedevicetype();
  void set_allocated_safedevicetype(::std::string* safedevicetype);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.SKBuiltinString_t ImgEncryptKey = 8;
  bool has_imgencryptkey() const;
  void clear_imgencryptkey();
  static const int kImgEncryptKeyFieldNumber = 8;
  const ::micromsg::SKBuiltinString_t& imgencryptkey() const;
  ::micromsg::SKBuiltinString_t* mutable_imgencryptkey();
  ::micromsg::SKBuiltinString_t* release_imgencryptkey();
  void set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t KSid = 9;
  bool has_ksid() const;
  void clear_ksid();
  static const int kKSidFieldNumber = 9;
  const ::micromsg::SKBuiltinBuffer_t& ksid() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_ksid();
  ::micromsg::SKBuiltinBuffer_t* release_ksid();
  void set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid);

  // optional .micromsg.SKBuiltinBuffer_t WTLoginReqBuff = 13;
  bool has_wtloginreqbuff() const;
  void clear_wtloginreqbuff();
  static const int kWTLoginReqBuffFieldNumber = 13;
  const ::micromsg::SKBuiltinBuffer_t& wtloginreqbuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_wtloginreqbuff();
  ::micromsg::SKBuiltinBuffer_t* release_wtloginreqbuff();
  void set_allocated_wtloginreqbuff(::micromsg::SKBuiltinBuffer_t* wtloginreqbuff);

  // required uint32 QQ = 2;
  bool has_qq() const;
  void clear_qq();
  static const int kQQFieldNumber = 2;
  ::google::protobuf::uint32 qq() const;
  void set_qq(::google::protobuf::uint32 value);

  // required uint32 OPCode = 7;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOPCodeFieldNumber = 7;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // optional uint32 SetAsMainAcct = 10;
  bool has_setasmainacct() const;
  void clear_setasmainacct();
  static const int kSetAsMainAcctFieldNumber = 10;
  ::google::protobuf::uint32 setasmainacct() const;
  void set_setasmainacct(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BindQQRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_qq();
  void clear_has_qq();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_pwd2();
  void clear_has_pwd2();
  void set_has_imgsid();
  void clear_has_imgsid();
  void set_has_imgcode();
  void clear_has_imgcode();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_imgencryptkey();
  void clear_has_imgencryptkey();
  void set_has_ksid();
  void clear_has_ksid();
  void set_has_setasmainacct();
  void clear_has_setasmainacct();
  void set_has_safedevicename();
  void clear_has_safedevicename();
  void set_has_safedevicetype();
  void clear_has_safedevicetype();
  void set_has_wtloginreqbuff();
  void clear_has_wtloginreqbuff();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr pwd2_;
  ::google::protobuf::internal::ArenaStringPtr imgsid_;
  ::google::protobuf::internal::ArenaStringPtr imgcode_;
  ::google::protobuf::internal::ArenaStringPtr safedevicename_;
  ::google::protobuf::internal::ArenaStringPtr safedevicetype_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinString_t* imgencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* ksid_;
  ::micromsg::SKBuiltinBuffer_t* wtloginreqbuff_;
  ::google::protobuf::uint32 qq_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint32 setasmainacct_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindQQResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindQQResponse) */ {
 public:
  BindQQResponse();
  virtual ~BindQQResponse();

  BindQQResponse(const BindQQResponse& from);

  inline BindQQResponse& operator=(const BindQQResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindQQResponse& default_instance();

  static inline const BindQQResponse* internal_default_instance() {
    return reinterpret_cast<const BindQQResponse*>(
               &_BindQQResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(BindQQResponse* other);

  // implements Message ----------------------------------------------

  inline BindQQResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BindQQResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindQQResponse& from);
  void MergeFrom(const BindQQResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindQQResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ImgSid = 2;
  bool has_imgsid() const;
  void clear_imgsid();
  static const int kImgSidFieldNumber = 2;
  const ::std::string& imgsid() const;
  void set_imgsid(const ::std::string& value);
  #if LANG_CXX11
  void set_imgsid(::std::string&& value);
  #endif
  void set_imgsid(const char* value);
  void set_imgsid(const char* value, size_t size);
  ::std::string* mutable_imgsid();
  ::std::string* release_imgsid();
  void set_allocated_imgsid(::std::string* imgsid);

  // optional string MicroBlogName = 6;
  bool has_microblogname() const;
  void clear_microblogname();
  static const int kMicroBlogNameFieldNumber = 6;
  const ::std::string& microblogname() const;
  void set_microblogname(const ::std::string& value);
  #if LANG_CXX11
  void set_microblogname(::std::string&& value);
  #endif
  void set_microblogname(const char* value);
  void set_microblogname(const char* value, size_t size);
  ::std::string* mutable_microblogname();
  ::std::string* release_microblogname();
  void set_allocated_microblogname(::std::string* microblogname);

  // optional string QQMailSkey = 8;
  bool has_qqmailskey() const;
  void clear_qqmailskey();
  static const int kQQMailSkeyFieldNumber = 8;
  const ::std::string& qqmailskey() const;
  void set_qqmailskey(const ::std::string& value);
  #if LANG_CXX11
  void set_qqmailskey(::std::string&& value);
  #endif
  void set_qqmailskey(const char* value);
  void set_qqmailskey(const char* value, size_t size);
  ::std::string* mutable_qqmailskey();
  ::std::string* release_qqmailskey();
  void set_allocated_qqmailskey(::std::string* qqmailskey);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.SKBuiltinBuffer_t ImgBuf = 3;
  bool has_imgbuf() const;
  void clear_imgbuf();
  static const int kImgBufFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& imgbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_imgbuf();
  ::micromsg::SKBuiltinBuffer_t* release_imgbuf();
  void set_allocated_imgbuf(::micromsg::SKBuiltinBuffer_t* imgbuf);

  // optional .micromsg.SKBuiltinString_t ImgEncryptKey = 9;
  bool has_imgencryptkey() const;
  void clear_imgencryptkey();
  static const int kImgEncryptKeyFieldNumber = 9;
  const ::micromsg::SKBuiltinString_t& imgencryptkey() const;
  ::micromsg::SKBuiltinString_t* mutable_imgencryptkey();
  ::micromsg::SKBuiltinString_t* release_imgencryptkey();
  void set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t A2Key = 10;
  bool has_a2key() const;
  void clear_a2key();
  static const int kA2KeyFieldNumber = 10;
  const ::micromsg::SKBuiltinBuffer_t& a2key() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_a2key();
  ::micromsg::SKBuiltinBuffer_t* release_a2key();
  void set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key);

  // optional .micromsg.SKBuiltinBuffer_t KSid = 11;
  bool has_ksid() const;
  void clear_ksid();
  static const int kKSidFieldNumber = 11;
  const ::micromsg::SKBuiltinBuffer_t& ksid() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_ksid();
  ::micromsg::SKBuiltinBuffer_t* release_ksid();
  void set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid);

  // optional .micromsg.SafeDeviceList SafeDeviceList = 12;
  bool has_safedevicelist() const;
  void clear_safedevicelist();
  static const int kSafeDeviceListFieldNumber = 12;
  const ::micromsg::SafeDeviceList& safedevicelist() const;
  ::micromsg::SafeDeviceList* mutable_safedevicelist();
  ::micromsg::SafeDeviceList* release_safedevicelist();
  void set_allocated_safedevicelist(::micromsg::SafeDeviceList* safedevicelist);

  // optional .micromsg.SKBuiltinBuffer_t WTLoginRspBuff = 14;
  bool has_wtloginrspbuff() const;
  void clear_wtloginrspbuff();
  static const int kWTLoginRspBuffFieldNumber = 14;
  const ::micromsg::SKBuiltinBuffer_t& wtloginrspbuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_wtloginrspbuff();
  ::micromsg::SKBuiltinBuffer_t* release_wtloginrspbuff();
  void set_allocated_wtloginrspbuff(::micromsg::SKBuiltinBuffer_t* wtloginrspbuff);

  // optional uint32 PushMailStatus = 4;
  bool has_pushmailstatus() const;
  void clear_pushmailstatus();
  static const int kPushMailStatusFieldNumber = 4;
  ::google::protobuf::uint32 pushmailstatus() const;
  void set_pushmailstatus(::google::protobuf::uint32 value);

  // optional uint32 PrivateMsgStatus = 5;
  bool has_privatemsgstatus() const;
  void clear_privatemsgstatus();
  static const int kPrivateMsgStatusFieldNumber = 5;
  ::google::protobuf::uint32 privatemsgstatus() const;
  void set_privatemsgstatus(::google::protobuf::uint32 value);

  // optional uint32 Status = 7;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // optional uint32 SafeDevice = 13;
  bool has_safedevice() const;
  void clear_safedevice();
  static const int kSafeDeviceFieldNumber = 13;
  ::google::protobuf::uint32 safedevice() const;
  void set_safedevice(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BindQQResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_imgsid();
  void clear_has_imgsid();
  void set_has_imgbuf();
  void clear_has_imgbuf();
  void set_has_pushmailstatus();
  void clear_has_pushmailstatus();
  void set_has_privatemsgstatus();
  void clear_has_privatemsgstatus();
  void set_has_microblogname();
  void clear_has_microblogname();
  void set_has_status();
  void clear_has_status();
  void set_has_qqmailskey();
  void clear_has_qqmailskey();
  void set_has_imgencryptkey();
  void clear_has_imgencryptkey();
  void set_has_a2key();
  void clear_has_a2key();
  void set_has_ksid();
  void clear_has_ksid();
  void set_has_safedevicelist();
  void clear_has_safedevicelist();
  void set_has_safedevice();
  void clear_has_safedevice();
  void set_has_wtloginrspbuff();
  void clear_has_wtloginrspbuff();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr imgsid_;
  ::google::protobuf::internal::ArenaStringPtr microblogname_;
  ::google::protobuf::internal::ArenaStringPtr qqmailskey_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinBuffer_t* imgbuf_;
  ::micromsg::SKBuiltinString_t* imgencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* a2key_;
  ::micromsg::SKBuiltinBuffer_t* ksid_;
  ::micromsg::SafeDeviceList* safedevicelist_;
  ::micromsg::SKBuiltinBuffer_t* wtloginrspbuff_;
  ::google::protobuf::uint32 pushmailstatus_;
  ::google::protobuf::uint32 privatemsgstatus_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 safedevice_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetPwdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ResetPwdRequest) */ {
 public:
  ResetPwdRequest();
  virtual ~ResetPwdRequest();

  ResetPwdRequest(const ResetPwdRequest& from);

  inline ResetPwdRequest& operator=(const ResetPwdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetPwdRequest& default_instance();

  static inline const ResetPwdRequest* internal_default_instance() {
    return reinterpret_cast<const ResetPwdRequest*>(
               &_ResetPwdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(ResetPwdRequest* other);

  // implements Message ----------------------------------------------

  inline ResetPwdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ResetPwdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetPwdRequest& from);
  void MergeFrom(const ResetPwdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetPwdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pwd = 3;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 3;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 OpCode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpCodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.ResetPwdRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_pwd();
  void clear_has_pwd();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetPwdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ResetPwdResponse) */ {
 public:
  ResetPwdResponse();
  virtual ~ResetPwdResponse();

  ResetPwdResponse(const ResetPwdResponse& from);

  inline ResetPwdResponse& operator=(const ResetPwdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetPwdResponse& default_instance();

  static inline const ResetPwdResponse* internal_default_instance() {
    return reinterpret_cast<const ResetPwdResponse*>(
               &_ResetPwdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(ResetPwdResponse* other);

  // implements Message ----------------------------------------------

  inline ResetPwdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ResetPwdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetPwdResponse& from);
  void MergeFrom(const ResetPwdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetPwdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.ResetPwdResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnBindQQRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UnBindQQRequest) */ {
 public:
  UnBindQQRequest();
  virtual ~UnBindQQRequest();

  UnBindQQRequest(const UnBindQQRequest& from);

  inline UnBindQQRequest& operator=(const UnBindQQRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnBindQQRequest& default_instance();

  static inline const UnBindQQRequest* internal_default_instance() {
    return reinterpret_cast<const UnBindQQRequest*>(
               &_UnBindQQRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(UnBindQQRequest* other);

  // implements Message ----------------------------------------------

  inline UnBindQQRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UnBindQQRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnBindQQRequest& from);
  void MergeFrom(const UnBindQQRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnBindQQRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Ticket = 2;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 2;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.UnBindQQRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_ticket();
  void clear_has_ticket();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnBindQQResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UnBindQQResponse) */ {
 public:
  UnBindQQResponse();
  virtual ~UnBindQQResponse();

  UnBindQQResponse(const UnBindQQResponse& from);

  inline UnBindQQResponse& operator=(const UnBindQQResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnBindQQResponse& default_instance();

  static inline const UnBindQQResponse* internal_default_instance() {
    return reinterpret_cast<const UnBindQQResponse*>(
               &_UnBindQQResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(UnBindQQResponse* other);

  // implements Message ----------------------------------------------

  inline UnBindQQResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UnBindQQResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnBindQQResponse& from);
  void MergeFrom(const UnBindQQResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnBindQQResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.UnBindQQResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckUnBindRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.CheckUnBindRequest) */ {
 public:
  CheckUnBindRequest();
  virtual ~CheckUnBindRequest();

  CheckUnBindRequest(const CheckUnBindRequest& from);

  inline CheckUnBindRequest& operator=(const CheckUnBindRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckUnBindRequest& default_instance();

  static inline const CheckUnBindRequest* internal_default_instance() {
    return reinterpret_cast<const CheckUnBindRequest*>(
               &_CheckUnBindRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(CheckUnBindRequest* other);

  // implements Message ----------------------------------------------

  inline CheckUnBindRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckUnBindRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckUnBindRequest& from);
  void MergeFrom(const CheckUnBindRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckUnBindRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required int32 BindType = 2;
  bool has_bindtype() const;
  void clear_bindtype();
  static const int kBindTypeFieldNumber = 2;
  ::google::protobuf::int32 bindtype() const;
  void set_bindtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.CheckUnBindRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_bindtype();
  void clear_has_bindtype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::int32 bindtype_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckUnBindResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.CheckUnBindResponse) */ {
 public:
  CheckUnBindResponse();
  virtual ~CheckUnBindResponse();

  CheckUnBindResponse(const CheckUnBindResponse& from);

  inline CheckUnBindResponse& operator=(const CheckUnBindResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckUnBindResponse& default_instance();

  static inline const CheckUnBindResponse* internal_default_instance() {
    return reinterpret_cast<const CheckUnBindResponse*>(
               &_CheckUnBindResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(CheckUnBindResponse* other);

  // implements Message ----------------------------------------------

  inline CheckUnBindResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckUnBindResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckUnBindResponse& from);
  void MergeFrom(const CheckUnBindResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckUnBindResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string RandomPasswd = 2;
  bool has_randompasswd() const;
  void clear_randompasswd();
  static const int kRandomPasswdFieldNumber = 2;
  const ::std::string& randompasswd() const;
  void set_randompasswd(const ::std::string& value);
  #if LANG_CXX11
  void set_randompasswd(::std::string&& value);
  #endif
  void set_randompasswd(const char* value);
  void set_randompasswd(const char* value, size_t size);
  ::std::string* mutable_randompasswd();
  ::std::string* release_randompasswd();
  void set_allocated_randompasswd(::std::string* randompasswd);

  // optional string CanUnbindNotice = 3;
  bool has_canunbindnotice() const;
  void clear_canunbindnotice();
  static const int kCanUnbindNoticeFieldNumber = 3;
  const ::std::string& canunbindnotice() const;
  void set_canunbindnotice(const ::std::string& value);
  #if LANG_CXX11
  void set_canunbindnotice(::std::string&& value);
  #endif
  void set_canunbindnotice(const char* value);
  void set_canunbindnotice(const char* value, size_t size);
  ::std::string* mutable_canunbindnotice();
  ::std::string* release_canunbindnotice();
  void set_allocated_canunbindnotice(::std::string* canunbindnotice);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.CheckUnBindResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_randompasswd();
  void clear_has_randompasswd();
  void set_has_canunbindnotice();
  void clear_has_canunbindnotice();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr randompasswd_;
  ::google::protobuf::internal::ArenaStringPtr canunbindnotice_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceBookAuthRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.FaceBookAuthRequest) */ {
 public:
  FaceBookAuthRequest();
  virtual ~FaceBookAuthRequest();

  FaceBookAuthRequest(const FaceBookAuthRequest& from);

  inline FaceBookAuthRequest& operator=(const FaceBookAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceBookAuthRequest& default_instance();

  static inline const FaceBookAuthRequest* internal_default_instance() {
    return reinterpret_cast<const FaceBookAuthRequest*>(
               &_FaceBookAuthRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(FaceBookAuthRequest* other);

  // implements Message ----------------------------------------------

  inline FaceBookAuthRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  FaceBookAuthRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FaceBookAuthRequest& from);
  void MergeFrom(const FaceBookAuthRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FaceBookAuthRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string AccessToken = 3;
  bool has_accesstoken() const;
  void clear_accesstoken();
  static const int kAccessTokenFieldNumber = 3;
  const ::std::string& accesstoken() const;
  void set_accesstoken(const ::std::string& value);
  #if LANG_CXX11
  void set_accesstoken(::std::string&& value);
  #endif
  void set_accesstoken(const char* value);
  void set_accesstoken(const char* value, size_t size);
  ::std::string* mutable_accesstoken();
  ::std::string* release_accesstoken();
  void set_allocated_accesstoken(::std::string* accesstoken);

  // optional string RandomEncryKey = 4;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 4;
  const ::std::string& randomencrykey() const;
  void set_randomencrykey(const ::std::string& value);
  #if LANG_CXX11
  void set_randomencrykey(::std::string&& value);
  #endif
  void set_randomencrykey(const char* value);
  void set_randomencrykey(const char* value, size_t size);
  ::std::string* mutable_randomencrykey();
  ::std::string* release_randomencrykey();
  void set_allocated_randomencrykey(::std::string* randomencrykey);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 OpType = 2;
  bool has_optype() const;
  void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  ::google::protobuf::uint32 optype() const;
  void set_optype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.FaceBookAuthRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_optype();
  void clear_has_optype();
  void set_has_accesstoken();
  void clear_has_accesstoken();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr accesstoken_;
  ::google::protobuf::internal::ArenaStringPtr randomencrykey_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 optype_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FaceBookAuthResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.FaceBookAuthResponse) */ {
 public:
  FaceBookAuthResponse();
  virtual ~FaceBookAuthResponse();

  FaceBookAuthResponse(const FaceBookAuthResponse& from);

  inline FaceBookAuthResponse& operator=(const FaceBookAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FaceBookAuthResponse& default_instance();

  static inline const FaceBookAuthResponse* internal_default_instance() {
    return reinterpret_cast<const FaceBookAuthResponse*>(
               &_FaceBookAuthResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(FaceBookAuthResponse* other);

  // implements Message ----------------------------------------------

  inline FaceBookAuthResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  FaceBookAuthResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FaceBookAuthResponse& from);
  void MergeFrom(const FaceBookAuthResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FaceBookAuthResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string FBUserName = 3;
  bool has_fbusername() const;
  void clear_fbusername();
  static const int kFBUserNameFieldNumber = 3;
  const ::std::string& fbusername() const;
  void set_fbusername(const ::std::string& value);
  #if LANG_CXX11
  void set_fbusername(::std::string&& value);
  #endif
  void set_fbusername(const char* value);
  void set_fbusername(const char* value, size_t size);
  ::std::string* mutable_fbusername();
  ::std::string* release_fbusername();
  void set_allocated_fbusername(::std::string* fbusername);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required uint64 FBUserID = 2;
  bool has_fbuserid() const;
  void clear_fbuserid();
  static const int kFBUserIDFieldNumber = 2;
  ::google::protobuf::uint64 fbuserid() const;
  void set_fbuserid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:micromsg.FaceBookAuthResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_fbuserid();
  void clear_has_fbuserid();
  void set_has_fbusername();
  void clear_has_fbusername();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fbusername_;
  ::micromsg::BaseResponse* baseresponse_;
  ::google::protobuf::uint64 fbuserid_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegEquipmentRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.RegEquipmentRequest) */ {
 public:
  RegEquipmentRequest();
  virtual ~RegEquipmentRequest();

  RegEquipmentRequest(const RegEquipmentRequest& from);

  inline RegEquipmentRequest& operator=(const RegEquipmentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegEquipmentRequest& default_instance();

  static inline const RegEquipmentRequest* internal_default_instance() {
    return reinterpret_cast<const RegEquipmentRequest*>(
               &_RegEquipmentRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(RegEquipmentRequest* other);

  // implements Message ----------------------------------------------

  inline RegEquipmentRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RegEquipmentRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegEquipmentRequest& from);
  void MergeFrom(const RegEquipmentRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegEquipmentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string SerialNumber = 3;
  bool has_serialnumber() const;
  void clear_serialnumber();
  static const int kSerialNumberFieldNumber = 3;
  const ::std::string& serialnumber() const;
  void set_serialnumber(const ::std::string& value);
  #if LANG_CXX11
  void set_serialnumber(::std::string&& value);
  #endif
  void set_serialnumber(const char* value);
  void set_serialnumber(const char* value, size_t size);
  ::std::string* mutable_serialnumber();
  ::std::string* release_serialnumber();
  void set_allocated_serialnumber(::std::string* serialnumber);

  // optional string IMEI = 4;
  bool has_imei() const;
  void clear_imei();
  static const int kIMEIFieldNumber = 4;
  const ::std::string& imei() const;
  void set_imei(const ::std::string& value);
  #if LANG_CXX11
  void set_imei(::std::string&& value);
  #endif
  void set_imei(const char* value);
  void set_imei(const char* value, size_t size);
  ::std::string* mutable_imei();
  ::std::string* release_imei();
  void set_allocated_imei(::std::string* imei);

  // optional string MAC = 5;
  bool has_mac() const;
  void clear_mac();
  static const int kMACFieldNumber = 5;
  const ::std::string& mac() const;
  void set_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_mac(::std::string&& value);
  #endif
  void set_mac(const char* value);
  void set_mac(const char* value, size_t size);
  ::std::string* mutable_mac();
  ::std::string* release_mac();
  void set_allocated_mac(::std::string* mac);

  // optional string NickName = 6;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNickNameFieldNumber = 6;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional string TimeZone = 10;
  bool has_timezone() const;
  void clear_timezone();
  static const int kTimeZoneFieldNumber = 10;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  #if LANG_CXX11
  void set_timezone(::std::string&& value);
  #endif
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional string Language = 11;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 11;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string RealCountry = 13;
  bool has_realcountry() const;
  void clear_realcountry();
  static const int kRealCountryFieldNumber = 13;
  const ::std::string& realcountry() const;
  void set_realcountry(const ::std::string& value);
  #if LANG_CXX11
  void set_realcountry(::std::string&& value);
  #endif
  void set_realcountry(const char* value);
  void set_realcountry(const char* value, size_t size);
  ::std::string* mutable_realcountry();
  ::std::string* release_realcountry();
  void set_allocated_realcountry(::std::string* realcountry);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 14;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 14;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // required uint32 Type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 BuiltinIPSeq = 7;
  bool has_builtinipseq() const;
  void clear_builtinipseq();
  static const int kBuiltinIPSeqFieldNumber = 7;
  ::google::protobuf::uint32 builtinipseq() const;
  void set_builtinipseq(::google::protobuf::uint32 value);

  // required uint32 DLSrc = 8;
  bool has_dlsrc() const;
  void clear_dlsrc();
  static const int kDLSrcFieldNumber = 8;
  ::google::protobuf::uint32 dlsrc() const;
  void set_dlsrc(::google::protobuf::uint32 value);

  // required uint32 RegMode = 9;
  bool has_regmode() const;
  void clear_regmode();
  static const int kRegModeFieldNumber = 9;
  ::google::protobuf::uint32 regmode() const;
  void set_regmode(::google::protobuf::uint32 value);

  // required uint32 ForceReg = 12;
  bool has_forcereg() const;
  void clear_forcereg();
  static const int kForceRegFieldNumber = 12;
  ::google::protobuf::uint32 forcereg() const;
  void set_forcereg(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.RegEquipmentRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_type();
  void clear_has_type();
  void set_has_serialnumber();
  void clear_has_serialnumber();
  void set_has_imei();
  void clear_has_imei();
  void set_has_mac();
  void clear_has_mac();
  void set_has_nickname();
  void clear_has_nickname();
  void set_has_builtinipseq();
  void clear_has_builtinipseq();
  void set_has_dlsrc();
  void clear_has_dlsrc();
  void set_has_regmode();
  void clear_has_regmode();
  void set_has_timezone();
  void clear_has_timezone();
  void set_has_language();
  void clear_has_language();
  void set_has_forcereg();
  void clear_has_forcereg();
  void set_has_realcountry();
  void clear_has_realcountry();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serialnumber_;
  ::google::protobuf::internal::ArenaStringPtr imei_;
  ::google::protobuf::internal::ArenaStringPtr mac_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr realcountry_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 builtinipseq_;
  ::google::protobuf::uint32 dlsrc_;
  ::google::protobuf::uint32 regmode_;
  ::google::protobuf::uint32 forcereg_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegEquipmentResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.RegEquipmentResponse) */ {
 public:
  RegEquipmentResponse();
  virtual ~RegEquipmentResponse();

  RegEquipmentResponse(const RegEquipmentResponse& from);

  inline RegEquipmentResponse& operator=(const RegEquipmentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegEquipmentResponse& default_instance();

  static inline const RegEquipmentResponse* internal_default_instance() {
    return reinterpret_cast<const RegEquipmentResponse*>(
               &_RegEquipmentResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(RegEquipmentResponse* other);

  // implements Message ----------------------------------------------

  inline RegEquipmentResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RegEquipmentResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegEquipmentResponse& from);
  void MergeFrom(const RegEquipmentResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegEquipmentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string SessionKey = 3;
  bool has_sessionkey() const;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 3;
  const ::std::string& sessionkey() const;
  void set_sessionkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionkey(::std::string&& value);
  #endif
  void set_sessionkey(const char* value);
  void set_sessionkey(const char* value, size_t size);
  ::std::string* mutable_sessionkey();
  ::std::string* release_sessionkey();
  void set_allocated_sessionkey(::std::string* sessionkey);

  // optional string OfficialUserName = 4;
  bool has_officialusername() const;
  void clear_officialusername();
  static const int kOfficialUserNameFieldNumber = 4;
  const ::std::string& officialusername() const;
  void set_officialusername(const ::std::string& value);
  #if LANG_CXX11
  void set_officialusername(::std::string&& value);
  #endif
  void set_officialusername(const char* value);
  void set_officialusername(const char* value, size_t size);
  ::std::string* mutable_officialusername();
  ::std::string* release_officialusername();
  void set_allocated_officialusername(::std::string* officialusername);

  // optional string OfficialNickName = 5;
  bool has_officialnickname() const;
  void clear_officialnickname();
  static const int kOfficialNickNameFieldNumber = 5;
  const ::std::string& officialnickname() const;
  void set_officialnickname(const ::std::string& value);
  #if LANG_CXX11
  void set_officialnickname(::std::string&& value);
  #endif
  void set_officialnickname(const char* value);
  void set_officialnickname(const char* value, size_t size);
  ::std::string* mutable_officialnickname();
  ::std::string* release_officialnickname();
  void set_allocated_officialnickname(::std::string* officialnickname);

  // optional string QQMicroBlogUserName = 6;
  bool has_qqmicroblogusername() const;
  void clear_qqmicroblogusername();
  static const int kQQMicroBlogUserNameFieldNumber = 6;
  const ::std::string& qqmicroblogusername() const;
  void set_qqmicroblogusername(const ::std::string& value);
  #if LANG_CXX11
  void set_qqmicroblogusername(::std::string&& value);
  #endif
  void set_qqmicroblogusername(const char* value);
  void set_qqmicroblogusername(const char* value, size_t size);
  ::std::string* mutable_qqmicroblogusername();
  ::std::string* release_qqmicroblogusername();
  void set_allocated_qqmicroblogusername(::std::string* qqmicroblogusername);

  // optional string BindEmail = 7;
  bool has_bindemail() const;
  void clear_bindemail();
  static const int kBindEmailFieldNumber = 7;
  const ::std::string& bindemail() const;
  void set_bindemail(const ::std::string& value);
  #if LANG_CXX11
  void set_bindemail(::std::string&& value);
  #endif
  void set_bindemail(const char* value);
  void set_bindemail(const char* value, size_t size);
  ::std::string* mutable_bindemail();
  ::std::string* release_bindemail();
  void set_allocated_bindemail(::std::string* bindemail);

  // optional string PushMailSettingTicket = 10;
  bool has_pushmailsettingticket() const;
  void clear_pushmailsettingticket();
  static const int kPushMailSettingTicketFieldNumber = 10;
  const ::std::string& pushmailsettingticket() const;
  void set_pushmailsettingticket(const ::std::string& value);
  #if LANG_CXX11
  void set_pushmailsettingticket(::std::string&& value);
  #endif
  void set_pushmailsettingticket(const char* value);
  void set_pushmailsettingticket(const char* value, size_t size);
  ::std::string* mutable_pushmailsettingticket();
  ::std::string* release_pushmailsettingticket();
  void set_allocated_pushmailsettingticket(::std::string* pushmailsettingticket);

  // optional string FSURL = 15;
  bool has_fsurl() const;
  void clear_fsurl();
  static const int kFSURLFieldNumber = 15;
  const ::std::string& fsurl() const;
  void set_fsurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fsurl(::std::string&& value);
  #endif
  void set_fsurl(const char* value);
  void set_fsurl(const char* value, size_t size);
  ::std::string* mutable_fsurl();
  ::std::string* release_fsurl();
  void set_allocated_fsurl(::std::string* fsurl);

  // optional string UserName = 16;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 16;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string AuthKey = 21;
  bool has_authkey() const;
  void clear_authkey();
  static const int kAuthKeyFieldNumber = 21;
  const ::std::string& authkey() const;
  void set_authkey(const ::std::string& value);
  #if LANG_CXX11
  void set_authkey(::std::string&& value);
  #endif
  void set_authkey(const char* value);
  void set_authkey(const char* value, size_t size);
  ::std::string* mutable_authkey();
  ::std::string* release_authkey();
  void set_allocated_authkey(::std::string* authkey);

  // optional string Password = 23;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 23;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.BuiltinIPList BuiltinIPList = 14;
  bool has_builtiniplist() const;
  void clear_builtiniplist();
  static const int kBuiltinIPListFieldNumber = 14;
  const ::micromsg::BuiltinIPList& builtiniplist() const;
  ::micromsg::BuiltinIPList* mutable_builtiniplist();
  ::micromsg::BuiltinIPList* release_builtiniplist();
  void set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist);

  // required .micromsg.NetworkControl NetworkControl = 18;
  bool has_networkcontrol() const;
  void clear_networkcontrol();
  static const int kNetworkControlFieldNumber = 18;
  const ::micromsg::NetworkControl& networkcontrol() const;
  ::micromsg::NetworkControl* mutable_networkcontrol();
  ::micromsg::NetworkControl* release_networkcontrol();
  void set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol);

  // required .micromsg.PluginKeyList PluginKeyList = 22;
  bool has_pluginkeylist() const;
  void clear_pluginkeylist();
  static const int kPluginKeyListFieldNumber = 22;
  const ::micromsg::PluginKeyList& pluginkeylist() const;
  ::micromsg::PluginKeyList* mutable_pluginkeylist();
  ::micromsg::PluginKeyList* release_pluginkeylist();
  void set_allocated_pluginkeylist(::micromsg::PluginKeyList* pluginkeylist);

  // required .micromsg.HostList NewHostList = 25;
  bool has_newhostlist() const;
  void clear_newhostlist();
  static const int kNewHostListFieldNumber = 25;
  const ::micromsg::HostList& newhostlist() const;
  ::micromsg::HostList* mutable_newhostlist();
  ::micromsg::HostList* release_newhostlist();
  void set_allocated_newhostlist(::micromsg::HostList* newhostlist);

  // required uint32 Uin = 2;
  bool has_uin() const;
  void clear_uin();
  static const int kUinFieldNumber = 2;
  ::google::protobuf::uint32 uin() const;
  void set_uin(::google::protobuf::uint32 value);

  // required uint32 PushMailStatus = 8;
  bool has_pushmailstatus() const;
  void clear_pushmailstatus();
  static const int kPushMailStatusFieldNumber = 8;
  ::google::protobuf::uint32 pushmailstatus() const;
  void set_pushmailstatus(::google::protobuf::uint32 value);

  // required uint32 SendCardBitFlag = 9;
  bool has_sendcardbitflag() const;
  void clear_sendcardbitflag();
  static const int kSendCardBitFlagFieldNumber = 9;
  ::google::protobuf::uint32 sendcardbitflag() const;
  void set_sendcardbitflag(::google::protobuf::uint32 value);

  // required uint32 Status = 17;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 17;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // required uint32 ReturnFlag = 19;
  bool has_returnflag() const;
  void clear_returnflag();
  static const int kReturnFlagFieldNumber = 19;
  ::google::protobuf::uint32 returnflag() const;
  void set_returnflag(::google::protobuf::uint32 value);

  // required uint32 RegType = 20;
  bool has_regtype() const;
  void clear_regtype();
  static const int kRegTypeFieldNumber = 20;
  ::google::protobuf::uint32 regtype() const;
  void set_regtype(::google::protobuf::uint32 value);

  // required uint32 ProfileFlag = 24;
  bool has_profileflag() const;
  void clear_profileflag();
  static const int kProfileFlagFieldNumber = 24;
  ::google::protobuf::uint32 profileflag() const;
  void set_profileflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.RegEquipmentResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_uin();
  void clear_has_uin();
  void set_has_sessionkey();
  void clear_has_sessionkey();
  void set_has_officialusername();
  void clear_has_officialusername();
  void set_has_officialnickname();
  void clear_has_officialnickname();
  void set_has_qqmicroblogusername();
  void clear_has_qqmicroblogusername();
  void set_has_bindemail();
  void clear_has_bindemail();
  void set_has_pushmailstatus();
  void clear_has_pushmailstatus();
  void set_has_sendcardbitflag();
  void clear_has_sendcardbitflag();
  void set_has_pushmailsettingticket();
  void clear_has_pushmailsettingticket();
  void set_has_builtiniplist();
  void clear_has_builtiniplist();
  void set_has_fsurl();
  void clear_has_fsurl();
  void set_has_username();
  void clear_has_username();
  void set_has_status();
  void clear_has_status();
  void set_has_networkcontrol();
  void clear_has_networkcontrol();
  void set_has_returnflag();
  void clear_has_returnflag();
  void set_has_regtype();
  void clear_has_regtype();
  void set_has_authkey();
  void clear_has_authkey();
  void set_has_pluginkeylist();
  void clear_has_pluginkeylist();
  void set_has_password();
  void clear_has_password();
  void set_has_profileflag();
  void clear_has_profileflag();
  void set_has_newhostlist();
  void clear_has_newhostlist();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sessionkey_;
  ::google::protobuf::internal::ArenaStringPtr officialusername_;
  ::google::protobuf::internal::ArenaStringPtr officialnickname_;
  ::google::protobuf::internal::ArenaStringPtr qqmicroblogusername_;
  ::google::protobuf::internal::ArenaStringPtr bindemail_;
  ::google::protobuf::internal::ArenaStringPtr pushmailsettingticket_;
  ::google::protobuf::internal::ArenaStringPtr fsurl_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr authkey_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::BuiltinIPList* builtiniplist_;
  ::micromsg::NetworkControl* networkcontrol_;
  ::micromsg::PluginKeyList* pluginkeylist_;
  ::micromsg::HostList* newhostlist_;
  ::google::protobuf::uint32 uin_;
  ::google::protobuf::uint32 pushmailstatus_;
  ::google::protobuf::uint32 sendcardbitflag_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 returnflag_;
  ::google::protobuf::uint32 regtype_;
  ::google::protobuf::uint32 profileflag_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetEquipmentRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ResetEquipmentRequest) */ {
 public:
  ResetEquipmentRequest();
  virtual ~ResetEquipmentRequest();

  ResetEquipmentRequest(const ResetEquipmentRequest& from);

  inline ResetEquipmentRequest& operator=(const ResetEquipmentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetEquipmentRequest& default_instance();

  static inline const ResetEquipmentRequest* internal_default_instance() {
    return reinterpret_cast<const ResetEquipmentRequest*>(
               &_ResetEquipmentRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(ResetEquipmentRequest* other);

  // implements Message ----------------------------------------------

  inline ResetEquipmentRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ResetEquipmentRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetEquipmentRequest& from);
  void MergeFrom(const ResetEquipmentRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetEquipmentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.ResetEquipmentRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetEquipmentResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ResetEquipmentResponse) */ {
 public:
  ResetEquipmentResponse();
  virtual ~ResetEquipmentResponse();

  ResetEquipmentResponse(const ResetEquipmentResponse& from);

  inline ResetEquipmentResponse& operator=(const ResetEquipmentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetEquipmentResponse& default_instance();

  static inline const ResetEquipmentResponse* internal_default_instance() {
    return reinterpret_cast<const ResetEquipmentResponse*>(
               &_ResetEquipmentResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(ResetEquipmentResponse* other);

  // implements Message ----------------------------------------------

  inline ResetEquipmentResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ResetEquipmentResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetEquipmentResponse& from);
  void MergeFrom(const ResetEquipmentResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetEquipmentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.ResetEquipmentResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetPwdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.SetPwdRequest) */ {
 public:
  SetPwdRequest();
  virtual ~SetPwdRequest();

  SetPwdRequest(const SetPwdRequest& from);

  inline SetPwdRequest& operator=(const SetPwdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPwdRequest& default_instance();

  static inline const SetPwdRequest* internal_default_instance() {
    return reinterpret_cast<const SetPwdRequest*>(
               &_SetPwdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(SetPwdRequest* other);

  // implements Message ----------------------------------------------

  inline SetPwdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SetPwdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetPwdRequest& from);
  void MergeFrom(const SetPwdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetPwdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string Ticket = 3;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 3;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.SKBuiltinBuffer_t AutoAuthKey = 4;
  bool has_autoauthkey() const;
  void clear_autoauthkey();
  static const int kAutoAuthKeyFieldNumber = 4;
  const ::micromsg::SKBuiltinBuffer_t& autoauthkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* release_autoauthkey();
  void set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey);

  // @@protoc_insertion_point(class_scope:micromsg.SetPwdRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_password();
  void clear_has_password();
  void set_has_ticket();
  void clear_has_ticket();
  void set_has_autoauthkey();
  void clear_has_autoauthkey();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* autoauthkey_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetPwdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.SetPwdResponse) */ {
 public:
  SetPwdResponse();
  virtual ~SetPwdResponse();

  SetPwdResponse(const SetPwdResponse& from);

  inline SetPwdResponse& operator=(const SetPwdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPwdResponse& default_instance();

  static inline const SetPwdResponse* internal_default_instance() {
    return reinterpret_cast<const SetPwdResponse*>(
               &_SetPwdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(SetPwdResponse* other);

  // implements Message ----------------------------------------------

  inline SetPwdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SetPwdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetPwdResponse& from);
  void MergeFrom(const SetPwdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetPwdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.SKBuiltinBuffer_t AutoAuthKey = 2;
  bool has_autoauthkey() const;
  void clear_autoauthkey();
  static const int kAutoAuthKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& autoauthkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* release_autoauthkey();
  void set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey);

  // @@protoc_insertion_point(class_scope:micromsg.SetPwdResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_autoauthkey();
  void clear_has_autoauthkey();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinBuffer_t* autoauthkey_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryHasPswdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.QueryHasPswdRequest) */ {
 public:
  QueryHasPswdRequest();
  virtual ~QueryHasPswdRequest();

  QueryHasPswdRequest(const QueryHasPswdRequest& from);

  inline QueryHasPswdRequest& operator=(const QueryHasPswdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryHasPswdRequest& default_instance();

  static inline const QueryHasPswdRequest* internal_default_instance() {
    return reinterpret_cast<const QueryHasPswdRequest*>(
               &_QueryHasPswdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(QueryHasPswdRequest* other);

  // implements Message ----------------------------------------------

  inline QueryHasPswdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryHasPswdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryHasPswdRequest& from);
  void MergeFrom(const QueryHasPswdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryHasPswdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required int32 Scene = 2;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 2;
  ::google::protobuf::int32 scene() const;
  void set_scene(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:micromsg.QueryHasPswdRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_scene();
  void clear_has_scene();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::int32 scene_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class QueryHasPswdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.QueryHasPswdResponse) */ {
 public:
  QueryHasPswdResponse();
  virtual ~QueryHasPswdResponse();

  QueryHasPswdResponse(const QueryHasPswdResponse& from);

  inline QueryHasPswdResponse& operator=(const QueryHasPswdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QueryHasPswdResponse& default_instance();

  static inline const QueryHasPswdResponse* internal_default_instance() {
    return reinterpret_cast<const QueryHasPswdResponse*>(
               &_QueryHasPswdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(QueryHasPswdResponse* other);

  // implements Message ----------------------------------------------

  inline QueryHasPswdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  QueryHasPswdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const QueryHasPswdResponse& from);
  void MergeFrom(const QueryHasPswdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(QueryHasPswdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.QueryHasPswdResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VerifyPswdRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.VerifyPswdRequest) */ {
 public:
  VerifyPswdRequest();
  virtual ~VerifyPswdRequest();

  VerifyPswdRequest(const VerifyPswdRequest& from);

  inline VerifyPswdRequest& operator=(const VerifyPswdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyPswdRequest& default_instance();

  static inline const VerifyPswdRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyPswdRequest*>(
               &_VerifyPswdRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(VerifyPswdRequest* other);

  // implements Message ----------------------------------------------

  inline VerifyPswdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  VerifyPswdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VerifyPswdRequest& from);
  void MergeFrom(const VerifyPswdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VerifyPswdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pwd1 = 3;
  bool has_pwd1() const;
  void clear_pwd1();
  static const int kPwd1FieldNumber = 3;
  const ::std::string& pwd1() const;
  void set_pwd1(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd1(::std::string&& value);
  #endif
  void set_pwd1(const char* value);
  void set_pwd1(const char* value, size_t size);
  ::std::string* mutable_pwd1();
  ::std::string* release_pwd1();
  void set_allocated_pwd1(::std::string* pwd1);

  // optional string Pwd2 = 4;
  bool has_pwd2() const;
  void clear_pwd2();
  static const int kPwd2FieldNumber = 4;
  const ::std::string& pwd2() const;
  void set_pwd2(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd2(::std::string&& value);
  #endif
  void set_pwd2(const char* value);
  void set_pwd2(const char* value, size_t size);
  ::std::string* mutable_pwd2();
  ::std::string* release_pwd2();
  void set_allocated_pwd2(::std::string* pwd2);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.SKBuiltinString_t ImgSid = 5;
  bool has_imgsid() const;
  void clear_imgsid();
  static const int kImgSidFieldNumber = 5;
  const ::micromsg::SKBuiltinString_t& imgsid() const;
  ::micromsg::SKBuiltinString_t* mutable_imgsid();
  ::micromsg::SKBuiltinString_t* release_imgsid();
  void set_allocated_imgsid(::micromsg::SKBuiltinString_t* imgsid);

  // optional .micromsg.SKBuiltinString_t ImgCode = 6;
  bool has_imgcode() const;
  void clear_imgcode();
  static const int kImgCodeFieldNumber = 6;
  const ::micromsg::SKBuiltinString_t& imgcode() const;
  ::micromsg::SKBuiltinString_t* mutable_imgcode();
  ::micromsg::SKBuiltinString_t* release_imgcode();
  void set_allocated_imgcode(::micromsg::SKBuiltinString_t* imgcode);

  // optional .micromsg.SKBuiltinString_t ImgEncryptKey = 7;
  bool has_imgencryptkey() const;
  void clear_imgencryptkey();
  static const int kImgEncryptKeyFieldNumber = 7;
  const ::micromsg::SKBuiltinString_t& imgencryptkey() const;
  ::micromsg::SKBuiltinString_t* mutable_imgencryptkey();
  ::micromsg::SKBuiltinString_t* release_imgencryptkey();
  void set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t KSid = 8;
  bool has_ksid() const;
  void clear_ksid();
  static const int kKSidFieldNumber = 8;
  const ::micromsg::SKBuiltinBuffer_t& ksid() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_ksid();
  ::micromsg::SKBuiltinBuffer_t* release_ksid();
  void set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid);

  // optional .micromsg.SKBuiltinBuffer_t WTLoginReqBuff = 10;
  bool has_wtloginreqbuff() const;
  void clear_wtloginreqbuff();
  static const int kWTLoginReqBuffFieldNumber = 10;
  const ::micromsg::SKBuiltinBuffer_t& wtloginreqbuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_wtloginreqbuff();
  ::micromsg::SKBuiltinBuffer_t* release_wtloginreqbuff();
  void set_allocated_wtloginreqbuff(::micromsg::SKBuiltinBuffer_t* wtloginreqbuff);

  // required uint32 OpCode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpCodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // optional uint32 Scence = 9;
  bool has_scence() const;
  void clear_scence();
  static const int kScenceFieldNumber = 9;
  ::google::protobuf::uint32 scence() const;
  void set_scence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.VerifyPswdRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_pwd1();
  void clear_has_pwd1();
  void set_has_pwd2();
  void clear_has_pwd2();
  void set_has_imgsid();
  void clear_has_imgsid();
  void set_has_imgcode();
  void clear_has_imgcode();
  void set_has_imgencryptkey();
  void clear_has_imgencryptkey();
  void set_has_ksid();
  void clear_has_ksid();
  void set_has_scence();
  void clear_has_scence();
  void set_has_wtloginreqbuff();
  void clear_has_wtloginreqbuff();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pwd1_;
  ::google::protobuf::internal::ArenaStringPtr pwd2_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinString_t* imgsid_;
  ::micromsg::SKBuiltinString_t* imgcode_;
  ::micromsg::SKBuiltinString_t* imgencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* ksid_;
  ::micromsg::SKBuiltinBuffer_t* wtloginreqbuff_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint32 scence_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VerifyPswdResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.VerifyPswdResponse) */ {
 public:
  VerifyPswdResponse();
  virtual ~VerifyPswdResponse();

  VerifyPswdResponse(const VerifyPswdResponse& from);

  inline VerifyPswdResponse& operator=(const VerifyPswdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyPswdResponse& default_instance();

  static inline const VerifyPswdResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyPswdResponse*>(
               &_VerifyPswdResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(VerifyPswdResponse* other);

  // implements Message ----------------------------------------------

  inline VerifyPswdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  VerifyPswdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VerifyPswdResponse& from);
  void MergeFrom(const VerifyPswdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VerifyPswdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Ticket = 4;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 4;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // optional string AuthKey = 8;
  bool has_authkey() const;
  void clear_authkey();
  static const int kAuthKeyFieldNumber = 8;
  const ::std::string& authkey() const;
  void set_authkey(const ::std::string& value);
  #if LANG_CXX11
  void set_authkey(::std::string&& value);
  #endif
  void set_authkey(const char* value);
  void set_authkey(const char* value, size_t size);
  ::std::string* mutable_authkey();
  ::std::string* release_authkey();
  void set_allocated_authkey(::std::string* authkey);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.SKBuiltinString_t ImgSid = 2;
  bool has_imgsid() const;
  void clear_imgsid();
  static const int kImgSidFieldNumber = 2;
  const ::micromsg::SKBuiltinString_t& imgsid() const;
  ::micromsg::SKBuiltinString_t* mutable_imgsid();
  ::micromsg::SKBuiltinString_t* release_imgsid();
  void set_allocated_imgsid(::micromsg::SKBuiltinString_t* imgsid);

  // required .micromsg.SKBuiltinBuffer_t ImgBuf = 3;
  bool has_imgbuf() const;
  void clear_imgbuf();
  static const int kImgBufFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& imgbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_imgbuf();
  ::micromsg::SKBuiltinBuffer_t* release_imgbuf();
  void set_allocated_imgbuf(::micromsg::SKBuiltinBuffer_t* imgbuf);

  // optional .micromsg.SKBuiltinString_t ImgEncryptKey = 5;
  bool has_imgencryptkey() const;
  void clear_imgencryptkey();
  static const int kImgEncryptKeyFieldNumber = 5;
  const ::micromsg::SKBuiltinString_t& imgencryptkey() const;
  ::micromsg::SKBuiltinString_t* mutable_imgencryptkey();
  ::micromsg::SKBuiltinString_t* release_imgencryptkey();
  void set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t A2Key = 6;
  bool has_a2key() const;
  void clear_a2key();
  static const int kA2KeyFieldNumber = 6;
  const ::micromsg::SKBuiltinBuffer_t& a2key() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_a2key();
  ::micromsg::SKBuiltinBuffer_t* release_a2key();
  void set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key);

  // optional .micromsg.SKBuiltinBuffer_t KSid = 7;
  bool has_ksid() const;
  void clear_ksid();
  static const int kKSidFieldNumber = 7;
  const ::micromsg::SKBuiltinBuffer_t& ksid() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_ksid();
  ::micromsg::SKBuiltinBuffer_t* release_ksid();
  void set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid);

  // optional .micromsg.SKBuiltinBuffer_t WTLoginRspBuff = 9;
  bool has_wtloginrspbuff() const;
  void clear_wtloginrspbuff();
  static const int kWTLoginRspBuffFieldNumber = 9;
  const ::micromsg::SKBuiltinBuffer_t& wtloginrspbuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_wtloginrspbuff();
  ::micromsg::SKBuiltinBuffer_t* release_wtloginrspbuff();
  void set_allocated_wtloginrspbuff(::micromsg::SKBuiltinBuffer_t* wtloginrspbuff);

  // @@protoc_insertion_point(class_scope:micromsg.VerifyPswdResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_imgsid();
  void clear_has_imgsid();
  void set_has_imgbuf();
  void clear_has_imgbuf();
  void set_has_ticket();
  void clear_has_ticket();
  void set_has_imgencryptkey();
  void clear_has_imgencryptkey();
  void set_has_a2key();
  void clear_has_a2key();
  void set_has_ksid();
  void clear_has_ksid();
  void set_has_authkey();
  void clear_has_authkey();
  void set_has_wtloginrspbuff();
  void clear_has_wtloginrspbuff();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::google::protobuf::internal::ArenaStringPtr authkey_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinString_t* imgsid_;
  ::micromsg::SKBuiltinBuffer_t* imgbuf_;
  ::micromsg::SKBuiltinString_t* imgencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* a2key_;
  ::micromsg::SKBuiltinBuffer_t* ksid_;
  ::micromsg::SKBuiltinBuffer_t* wtloginrspbuff_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetPawInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ResetPawInfo) */ {
 public:
  ResetPawInfo();
  virtual ~ResetPawInfo();

  ResetPawInfo(const ResetPawInfo& from);

  inline ResetPawInfo& operator=(const ResetPawInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetPawInfo& default_instance();

  static inline const ResetPawInfo* internal_default_instance() {
    return reinterpret_cast<const ResetPawInfo*>(
               &_ResetPawInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(ResetPawInfo* other);

  // implements Message ----------------------------------------------

  inline ResetPawInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ResetPawInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResetPawInfo& from);
  void MergeFrom(const ResetPawInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResetPawInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 CreateTime = 1;
  bool has_createtime() const;
  void clear_createtime();
  static const int kCreateTimeFieldNumber = 1;
  ::google::protobuf::uint32 createtime() const;
  void set_createtime(::google::protobuf::uint32 value);

  // required uint32 IsReset = 2;
  bool has_isreset() const;
  void clear_isreset();
  static const int kIsResetFieldNumber = 2;
  ::google::protobuf::uint32 isreset() const;
  void set_isreset(::google::protobuf::uint32 value);

  // required uint32 ID = 3;
  bool has_id() const;
  void clear_id();
  static const int kIDFieldNumber = 3;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.ResetPawInfo)
 private:
  void set_has_createtime();
  void clear_has_createtime();
  void set_has_isreset();
  void clear_has_isreset();
  void set_has_id();
  void clear_has_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 createtime_;
  ::google::protobuf::uint32 isreset_;
  ::google::protobuf::uint32 id_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApplyResetPawRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ApplyResetPawRequest) */ {
 public:
  ApplyResetPawRequest();
  virtual ~ApplyResetPawRequest();

  ApplyResetPawRequest(const ApplyResetPawRequest& from);

  inline ApplyResetPawRequest& operator=(const ApplyResetPawRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyResetPawRequest& default_instance();

  static inline const ApplyResetPawRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyResetPawRequest*>(
               &_ApplyResetPawRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(ApplyResetPawRequest* other);

  // implements Message ----------------------------------------------

  inline ApplyResetPawRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ApplyResetPawRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ApplyResetPawRequest& from);
  void MergeFrom(const ApplyResetPawRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ApplyResetPawRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ResetInfo = 3;
  bool has_resetinfo() const;
  void clear_resetinfo();
  static const int kResetInfoFieldNumber = 3;
  const ::std::string& resetinfo() const;
  void set_resetinfo(const ::std::string& value);
  #if LANG_CXX11
  void set_resetinfo(::std::string&& value);
  #endif
  void set_resetinfo(const char* value);
  void set_resetinfo(const char* value, size_t size);
  ::std::string* mutable_resetinfo();
  ::std::string* release_resetinfo();
  void set_allocated_resetinfo(::std::string* resetinfo);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.SKBuiltinBuffer_t RandomEncryKey = 5;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 5;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // required int32 Type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // optional uint32 GetMethod = 4;
  bool has_getmethod() const;
  void clear_getmethod();
  static const int kGetMethodFieldNumber = 4;
  ::google::protobuf::uint32 getmethod() const;
  void set_getmethod(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.ApplyResetPawRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_type();
  void clear_has_type();
  void set_has_resetinfo();
  void clear_has_resetinfo();
  void set_has_getmethod();
  void clear_has_getmethod();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr resetinfo_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::uint32 getmethod_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApplyResetPawResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ApplyResetPawResponse) */ {
 public:
  ApplyResetPawResponse();
  virtual ~ApplyResetPawResponse();

  ApplyResetPawResponse(const ApplyResetPawResponse& from);

  inline ApplyResetPawResponse& operator=(const ApplyResetPawResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyResetPawResponse& default_instance();

  static inline const ApplyResetPawResponse* internal_default_instance() {
    return reinterpret_cast<const ApplyResetPawResponse*>(
               &_ApplyResetPawResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(ApplyResetPawResponse* other);

  // implements Message ----------------------------------------------

  inline ApplyResetPawResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ApplyResetPawResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ApplyResetPawResponse& from);
  void MergeFrom(const ApplyResetPawResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ApplyResetPawResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.ApplyResetPawResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetWeiBoURLReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetWeiBoURLReq) */ {
 public:
  GetWeiBoURLReq();
  virtual ~GetWeiBoURLReq();

  GetWeiBoURLReq(const GetWeiBoURLReq& from);

  inline GetWeiBoURLReq& operator=(const GetWeiBoURLReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWeiBoURLReq& default_instance();

  static inline const GetWeiBoURLReq* internal_default_instance() {
    return reinterpret_cast<const GetWeiBoURLReq*>(
               &_GetWeiBoURLReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(GetWeiBoURLReq* other);

  // implements Message ----------------------------------------------

  inline GetWeiBoURLReq* New() const PROTOBUF_FINAL { return New(NULL); }

  GetWeiBoURLReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetWeiBoURLReq& from);
  void MergeFrom(const GetWeiBoURLReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetWeiBoURLReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 3;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string BlogUserName = 5;
  bool has_blogusername() const;
  void clear_blogusername();
  static const int kBlogUserNameFieldNumber = 5;
  const ::std::string& blogusername() const;
  void set_blogusername(const ::std::string& value);
  #if LANG_CXX11
  void set_blogusername(::std::string&& value);
  #endif
  void set_blogusername(const char* value);
  void set_blogusername(const char* value, size_t size);
  ::std::string* mutable_blogusername();
  ::std::string* release_blogusername();
  void set_allocated_blogusername(::std::string* blogusername);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t A2Key = 2;
  bool has_a2key() const;
  void clear_a2key();
  static const int kA2KeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& a2key() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_a2key();
  ::micromsg::SKBuiltinBuffer_t* release_a2key();
  void set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key);

  // optional .micromsg.SKBuiltinBuffer_t A2KeyNew = 6;
  bool has_a2keynew() const;
  void clear_a2keynew();
  static const int kA2KeyNewFieldNumber = 6;
  const ::micromsg::SKBuiltinBuffer_t& a2keynew() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_a2keynew();
  ::micromsg::SKBuiltinBuffer_t* release_a2keynew();
  void set_allocated_a2keynew(::micromsg::SKBuiltinBuffer_t* a2keynew);

  // optional uint32 Scene = 4;
  bool has_scene() const;
  void clear_scene();
  static const int kSceneFieldNumber = 4;
  ::google::protobuf::uint32 scene() const;
  void set_scene(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetWeiBoURLReq)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_a2key();
  void clear_has_a2key();
  void set_has_username();
  void clear_has_username();
  void set_has_scene();
  void clear_has_scene();
  void set_has_blogusername();
  void clear_has_blogusername();
  void set_has_a2keynew();
  void clear_has_a2keynew();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr blogusername_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* a2key_;
  ::micromsg::SKBuiltinBuffer_t* a2keynew_;
  ::google::protobuf::uint32 scene_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetWeiBoURLResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetWeiBoURLResp) */ {
 public:
  GetWeiBoURLResp();
  virtual ~GetWeiBoURLResp();

  GetWeiBoURLResp(const GetWeiBoURLResp& from);

  inline GetWeiBoURLResp& operator=(const GetWeiBoURLResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWeiBoURLResp& default_instance();

  static inline const GetWeiBoURLResp* internal_default_instance() {
    return reinterpret_cast<const GetWeiBoURLResp*>(
               &_GetWeiBoURLResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(GetWeiBoURLResp* other);

  // implements Message ----------------------------------------------

  inline GetWeiBoURLResp* New() const PROTOBUF_FINAL { return New(NULL); }

  GetWeiBoURLResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetWeiBoURLResp& from);
  void MergeFrom(const GetWeiBoURLResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetWeiBoURLResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string URL = 2;
  bool has_url() const;
  void clear_url();
  static const int kURLFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.GetWeiBoURLResp)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetUserNameRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetUserNameRequest) */ {
 public:
  GetUserNameRequest();
  virtual ~GetUserNameRequest();

  GetUserNameRequest(const GetUserNameRequest& from);

  inline GetUserNameRequest& operator=(const GetUserNameRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserNameRequest& default_instance();

  static inline const GetUserNameRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserNameRequest*>(
               &_GetUserNameRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(GetUserNameRequest* other);

  // implements Message ----------------------------------------------

  inline GetUserNameRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetUserNameRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetUserNameRequest& from);
  void MergeFrom(const GetUserNameRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetUserNameRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string NickName = 3;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNickNameFieldNumber = 3;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional string Ticket = 4;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 4;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // optional string Pwd = 5;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 5;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // optional string Mobile = 6;
  bool has_mobile() const;
  void clear_mobile();
  static const int kMobileFieldNumber = 6;
  const ::std::string& mobile() const;
  void set_mobile(const ::std::string& value);
  #if LANG_CXX11
  void set_mobile(::std::string&& value);
  #endif
  void set_mobile(const char* value);
  void set_mobile(const char* value, size_t size);
  ::std::string* mutable_mobile();
  ::std::string* release_mobile();
  void set_allocated_mobile(::std::string* mobile);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 BindUin = 2;
  bool has_binduin() const;
  void clear_binduin();
  static const int kBindUinFieldNumber = 2;
  ::google::protobuf::uint32 binduin() const;
  void set_binduin(::google::protobuf::uint32 value);

  // optional uint32 OpCode = 7;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpCodeFieldNumber = 7;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetUserNameRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_binduin();
  void clear_has_binduin();
  void set_has_nickname();
  void clear_has_nickname();
  void set_has_ticket();
  void clear_has_ticket();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_mobile();
  void clear_has_mobile();
  void set_has_opcode();
  void clear_has_opcode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr mobile_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 binduin_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetUserNameResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetUserNameResponse) */ {
 public:
  GetUserNameResponse();
  virtual ~GetUserNameResponse();

  GetUserNameResponse(const GetUserNameResponse& from);

  inline GetUserNameResponse& operator=(const GetUserNameResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserNameResponse& default_instance();

  static inline const GetUserNameResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserNameResponse*>(
               &_GetUserNameResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(GetUserNameResponse* other);

  // implements Message ----------------------------------------------

  inline GetUserNameResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetUserNameResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetUserNameResponse& from);
  void MergeFrom(const GetUserNameResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetUserNameResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 2;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string Ticket = 3;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 3;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.GetUserNameResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_username();
  void clear_has_username();
  void set_has_ticket();
  void clear_has_ticket();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IphoneRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.IphoneRegRequest) */ {
 public:
  IphoneRegRequest();
  virtual ~IphoneRegRequest();

  IphoneRegRequest(const IphoneRegRequest& from);

  inline IphoneRegRequest& operator=(const IphoneRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IphoneRegRequest& default_instance();

  static inline const IphoneRegRequest* internal_default_instance() {
    return reinterpret_cast<const IphoneRegRequest*>(
               &_IphoneRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(IphoneRegRequest* other);

  // implements Message ----------------------------------------------

  inline IphoneRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  IphoneRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IphoneRegRequest& from);
  void MergeFrom(const IphoneRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IphoneRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional string Sound = 3;
  bool has_sound() const;
  void clear_sound();
  static const int kSoundFieldNumber = 3;
  const ::std::string& sound() const;
  void set_sound(const ::std::string& value);
  #if LANG_CXX11
  void set_sound(::std::string&& value);
  #endif
  void set_sound(const char* value);
  void set_sound(const char* value, size_t size);
  ::std::string* mutable_sound();
  ::std::string* release_sound();
  void set_allocated_sound(::std::string* sound);

  // optional string VoipSound = 5;
  bool has_voipsound() const;
  void clear_voipsound();
  static const int kVoipSoundFieldNumber = 5;
  const ::std::string& voipsound() const;
  void set_voipsound(const ::std::string& value);
  #if LANG_CXX11
  void set_voipsound(::std::string&& value);
  #endif
  void set_voipsound(const char* value);
  void set_voipsound(const char* value, size_t size);
  ::std::string* mutable_voipsound();
  ::std::string* release_voipsound();
  void set_allocated_voipsound(::std::string* voipsound);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional uint32 Status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // optional uint32 TokenCert = 6;
  bool has_tokencert() const;
  void clear_tokencert();
  static const int kTokenCertFieldNumber = 6;
  ::google::protobuf::uint32 tokencert() const;
  void set_tokencert(::google::protobuf::uint32 value);

  // optional uint32 TokenEnv = 7;
  bool has_tokenenv() const;
  void clear_tokenenv();
  static const int kTokenEnvFieldNumber = 7;
  ::google::protobuf::uint32 tokenenv() const;
  void set_tokenenv(::google::protobuf::uint32 value);

  // optional uint32 TokenScene = 8;
  bool has_tokenscene() const;
  void clear_tokenscene();
  static const int kTokenSceneFieldNumber = 8;
  ::google::protobuf::uint32 tokenscene() const;
  void set_tokenscene(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.IphoneRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_token();
  void clear_has_token();
  void set_has_sound();
  void clear_has_sound();
  void set_has_status();
  void clear_has_status();
  void set_has_voipsound();
  void clear_has_voipsound();
  void set_has_tokencert();
  void clear_has_tokencert();
  void set_has_tokenenv();
  void clear_has_tokenenv();
  void set_has_tokenscene();
  void clear_has_tokenscene();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr sound_;
  ::google::protobuf::internal::ArenaStringPtr voipsound_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 tokencert_;
  ::google::protobuf::uint32 tokenenv_;
  ::google::protobuf::uint32 tokenscene_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IphoneRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.IphoneRegResponse) */ {
 public:
  IphoneRegResponse();
  virtual ~IphoneRegResponse();

  IphoneRegResponse(const IphoneRegResponse& from);

  inline IphoneRegResponse& operator=(const IphoneRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IphoneRegResponse& default_instance();

  static inline const IphoneRegResponse* internal_default_instance() {
    return reinterpret_cast<const IphoneRegResponse*>(
               &_IphoneRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(IphoneRegResponse* other);

  // implements Message ----------------------------------------------

  inline IphoneRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  IphoneRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IphoneRegResponse& from);
  void MergeFrom(const IphoneRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IphoneRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.IphoneRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IphoneUnRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.IphoneUnRegRequest) */ {
 public:
  IphoneUnRegRequest();
  virtual ~IphoneUnRegRequest();

  IphoneUnRegRequest(const IphoneUnRegRequest& from);

  inline IphoneUnRegRequest& operator=(const IphoneUnRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IphoneUnRegRequest& default_instance();

  static inline const IphoneUnRegRequest* internal_default_instance() {
    return reinterpret_cast<const IphoneUnRegRequest*>(
               &_IphoneUnRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(IphoneUnRegRequest* other);

  // implements Message ----------------------------------------------

  inline IphoneUnRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  IphoneUnRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IphoneUnRegRequest& from);
  void MergeFrom(const IphoneUnRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IphoneUnRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.IphoneUnRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_token();
  void clear_has_token();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IphoneUnRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.IphoneUnRegResponse) */ {
 public:
  IphoneUnRegResponse();
  virtual ~IphoneUnRegResponse();

  IphoneUnRegResponse(const IphoneUnRegResponse& from);

  inline IphoneUnRegResponse& operator=(const IphoneUnRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IphoneUnRegResponse& default_instance();

  static inline const IphoneUnRegResponse* internal_default_instance() {
    return reinterpret_cast<const IphoneUnRegResponse*>(
               &_IphoneUnRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(IphoneUnRegResponse* other);

  // implements Message ----------------------------------------------

  inline IphoneUnRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  IphoneUnRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IphoneUnRegResponse& from);
  void MergeFrom(const IphoneUnRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IphoneUnRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.IphoneUnRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WinphoneRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.WinphoneRegRequest) */ {
 public:
  WinphoneRegRequest();
  virtual ~WinphoneRegRequest();

  WinphoneRegRequest(const WinphoneRegRequest& from);

  inline WinphoneRegRequest& operator=(const WinphoneRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WinphoneRegRequest& default_instance();

  static inline const WinphoneRegRequest* internal_default_instance() {
    return reinterpret_cast<const WinphoneRegRequest*>(
               &_WinphoneRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(WinphoneRegRequest* other);

  // implements Message ----------------------------------------------

  inline WinphoneRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  WinphoneRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WinphoneRegRequest& from);
  void MergeFrom(const WinphoneRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WinphoneRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Uri = 2;
  bool has_uri() const;
  void clear_uri();
  static const int kUriFieldNumber = 2;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.WinphoneRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_uri();
  void clear_has_uri();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WinphoneRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.WinphoneRegResponse) */ {
 public:
  WinphoneRegResponse();
  virtual ~WinphoneRegResponse();

  WinphoneRegResponse(const WinphoneRegResponse& from);

  inline WinphoneRegResponse& operator=(const WinphoneRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WinphoneRegResponse& default_instance();

  static inline const WinphoneRegResponse* internal_default_instance() {
    return reinterpret_cast<const WinphoneRegResponse*>(
               &_WinphoneRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(WinphoneRegResponse* other);

  // implements Message ----------------------------------------------

  inline WinphoneRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  WinphoneRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WinphoneRegResponse& from);
  void MergeFrom(const WinphoneRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WinphoneRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.WinphoneRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WinphoneUnRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.WinphoneUnRegRequest) */ {
 public:
  WinphoneUnRegRequest();
  virtual ~WinphoneUnRegRequest();

  WinphoneUnRegRequest(const WinphoneUnRegRequest& from);

  inline WinphoneUnRegRequest& operator=(const WinphoneUnRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WinphoneUnRegRequest& default_instance();

  static inline const WinphoneUnRegRequest* internal_default_instance() {
    return reinterpret_cast<const WinphoneUnRegRequest*>(
               &_WinphoneUnRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(WinphoneUnRegRequest* other);

  // implements Message ----------------------------------------------

  inline WinphoneUnRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  WinphoneUnRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WinphoneUnRegRequest& from);
  void MergeFrom(const WinphoneUnRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WinphoneUnRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Uri = 2;
  bool has_uri() const;
  void clear_uri();
  static const int kUriFieldNumber = 2;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.WinphoneUnRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_uri();
  void clear_has_uri();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uri_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WinphoneUnRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.WinphoneUnRegResponse) */ {
 public:
  WinphoneUnRegResponse();
  virtual ~WinphoneUnRegResponse();

  WinphoneUnRegResponse(const WinphoneUnRegResponse& from);

  inline WinphoneUnRegResponse& operator=(const WinphoneUnRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WinphoneUnRegResponse& default_instance();

  static inline const WinphoneUnRegResponse* internal_default_instance() {
    return reinterpret_cast<const WinphoneUnRegResponse*>(
               &_WinphoneUnRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(WinphoneUnRegResponse* other);

  // implements Message ----------------------------------------------

  inline WinphoneUnRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  WinphoneUnRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WinphoneUnRegResponse& from);
  void MergeFrom(const WinphoneUnRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WinphoneUnRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.WinphoneUnRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AshaRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AshaRegRequest) */ {
 public:
  AshaRegRequest();
  virtual ~AshaRegRequest();

  AshaRegRequest(const AshaRegRequest& from);

  inline AshaRegRequest& operator=(const AshaRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AshaRegRequest& default_instance();

  static inline const AshaRegRequest* internal_default_instance() {
    return reinterpret_cast<const AshaRegRequest*>(
               &_AshaRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(AshaRegRequest* other);

  // implements Message ----------------------------------------------

  inline AshaRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AshaRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AshaRegRequest& from);
  void MergeFrom(const AshaRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AshaRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Nid = 2;
  bool has_nid() const;
  void clear_nid();
  static const int kNidFieldNumber = 2;
  const ::std::string& nid() const;
  void set_nid(const ::std::string& value);
  #if LANG_CXX11
  void set_nid(::std::string&& value);
  #endif
  void set_nid(const char* value);
  void set_nid(const char* value, size_t size);
  ::std::string* mutable_nid();
  ::std::string* release_nid();
  void set_allocated_nid(::std::string* nid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.AshaRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_nid();
  void clear_has_nid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nid_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AshaRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AshaRegResponse) */ {
 public:
  AshaRegResponse();
  virtual ~AshaRegResponse();

  AshaRegResponse(const AshaRegResponse& from);

  inline AshaRegResponse& operator=(const AshaRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AshaRegResponse& default_instance();

  static inline const AshaRegResponse* internal_default_instance() {
    return reinterpret_cast<const AshaRegResponse*>(
               &_AshaRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(AshaRegResponse* other);

  // implements Message ----------------------------------------------

  inline AshaRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AshaRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AshaRegResponse& from);
  void MergeFrom(const AshaRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AshaRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.AshaRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AshaUnRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AshaUnRegRequest) */ {
 public:
  AshaUnRegRequest();
  virtual ~AshaUnRegRequest();

  AshaUnRegRequest(const AshaUnRegRequest& from);

  inline AshaUnRegRequest& operator=(const AshaUnRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AshaUnRegRequest& default_instance();

  static inline const AshaUnRegRequest* internal_default_instance() {
    return reinterpret_cast<const AshaUnRegRequest*>(
               &_AshaUnRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(AshaUnRegRequest* other);

  // implements Message ----------------------------------------------

  inline AshaUnRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AshaUnRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AshaUnRegRequest& from);
  void MergeFrom(const AshaUnRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AshaUnRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Nid = 2;
  bool has_nid() const;
  void clear_nid();
  static const int kNidFieldNumber = 2;
  const ::std::string& nid() const;
  void set_nid(const ::std::string& value);
  #if LANG_CXX11
  void set_nid(::std::string&& value);
  #endif
  void set_nid(const char* value);
  void set_nid(const char* value, size_t size);
  ::std::string* mutable_nid();
  ::std::string* release_nid();
  void set_allocated_nid(::std::string* nid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.AshaUnRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_nid();
  void clear_has_nid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nid_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AshaUnRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AshaUnRegResponse) */ {
 public:
  AshaUnRegResponse();
  virtual ~AshaUnRegResponse();

  AshaUnRegResponse(const AshaUnRegResponse& from);

  inline AshaUnRegResponse& operator=(const AshaUnRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AshaUnRegResponse& default_instance();

  static inline const AshaUnRegResponse* internal_default_instance() {
    return reinterpret_cast<const AshaUnRegResponse*>(
               &_AshaUnRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(AshaUnRegResponse* other);

  // implements Message ----------------------------------------------

  inline AshaUnRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AshaUnRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AshaUnRegResponse& from);
  void MergeFrom(const AshaUnRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AshaUnRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.AshaUnRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlackBerryRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlackBerryRegRequest) */ {
 public:
  BlackBerryRegRequest();
  virtual ~BlackBerryRegRequest();

  BlackBerryRegRequest(const BlackBerryRegRequest& from);

  inline BlackBerryRegRequest& operator=(const BlackBerryRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlackBerryRegRequest& default_instance();

  static inline const BlackBerryRegRequest* internal_default_instance() {
    return reinterpret_cast<const BlackBerryRegRequest*>(
               &_BlackBerryRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(BlackBerryRegRequest* other);

  // implements Message ----------------------------------------------

  inline BlackBerryRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BlackBerryRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlackBerryRegRequest& from);
  void MergeFrom(const BlackBerryRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlackBerryRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pin = 2;
  bool has_pin() const;
  void clear_pin();
  static const int kPinFieldNumber = 2;
  const ::std::string& pin() const;
  void set_pin(const ::std::string& value);
  #if LANG_CXX11
  void set_pin(::std::string&& value);
  #endif
  void set_pin(const char* value);
  void set_pin(const char* value, size_t size);
  ::std::string* mutable_pin();
  ::std::string* release_pin();
  void set_allocated_pin(::std::string* pin);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 Port = 3;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BlackBerryRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_pin();
  void clear_has_pin();
  void set_has_port();
  void clear_has_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pin_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 port_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlackBerryRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlackBerryRegResponse) */ {
 public:
  BlackBerryRegResponse();
  virtual ~BlackBerryRegResponse();

  BlackBerryRegResponse(const BlackBerryRegResponse& from);

  inline BlackBerryRegResponse& operator=(const BlackBerryRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlackBerryRegResponse& default_instance();

  static inline const BlackBerryRegResponse* internal_default_instance() {
    return reinterpret_cast<const BlackBerryRegResponse*>(
               &_BlackBerryRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(BlackBerryRegResponse* other);

  // implements Message ----------------------------------------------

  inline BlackBerryRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BlackBerryRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlackBerryRegResponse& from);
  void MergeFrom(const BlackBerryRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlackBerryRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.BlackBerryRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlackBerryUnRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlackBerryUnRegRequest) */ {
 public:
  BlackBerryUnRegRequest();
  virtual ~BlackBerryUnRegRequest();

  BlackBerryUnRegRequest(const BlackBerryUnRegRequest& from);

  inline BlackBerryUnRegRequest& operator=(const BlackBerryUnRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlackBerryUnRegRequest& default_instance();

  static inline const BlackBerryUnRegRequest* internal_default_instance() {
    return reinterpret_cast<const BlackBerryUnRegRequest*>(
               &_BlackBerryUnRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(BlackBerryUnRegRequest* other);

  // implements Message ----------------------------------------------

  inline BlackBerryUnRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BlackBerryUnRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlackBerryUnRegRequest& from);
  void MergeFrom(const BlackBerryUnRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlackBerryUnRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pin = 2;
  bool has_pin() const;
  void clear_pin();
  static const int kPinFieldNumber = 2;
  const ::std::string& pin() const;
  void set_pin(const ::std::string& value);
  #if LANG_CXX11
  void set_pin(::std::string&& value);
  #endif
  void set_pin(const char* value);
  void set_pin(const char* value, size_t size);
  ::std::string* mutable_pin();
  ::std::string* release_pin();
  void set_allocated_pin(::std::string* pin);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.BlackBerryUnRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_pin();
  void clear_has_pin();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr pin_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlackBerryUnRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlackBerryUnRegResponse) */ {
 public:
  BlackBerryUnRegResponse();
  virtual ~BlackBerryUnRegResponse();

  BlackBerryUnRegResponse(const BlackBerryUnRegResponse& from);

  inline BlackBerryUnRegResponse& operator=(const BlackBerryUnRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlackBerryUnRegResponse& default_instance();

  static inline const BlackBerryUnRegResponse* internal_default_instance() {
    return reinterpret_cast<const BlackBerryUnRegResponse*>(
               &_BlackBerryUnRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(BlackBerryUnRegResponse* other);

  // implements Message ----------------------------------------------

  inline BlackBerryUnRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BlackBerryUnRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlackBerryUnRegResponse& from);
  void MergeFrom(const BlackBerryUnRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlackBerryUnRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.BlackBerryUnRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AndroidGCMRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AndroidGCMRegRequest) */ {
 public:
  AndroidGCMRegRequest();
  virtual ~AndroidGCMRegRequest();

  AndroidGCMRegRequest(const AndroidGCMRegRequest& from);

  inline AndroidGCMRegRequest& operator=(const AndroidGCMRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AndroidGCMRegRequest& default_instance();

  static inline const AndroidGCMRegRequest* internal_default_instance() {
    return reinterpret_cast<const AndroidGCMRegRequest*>(
               &_AndroidGCMRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(AndroidGCMRegRequest* other);

  // implements Message ----------------------------------------------

  inline AndroidGCMRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AndroidGCMRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AndroidGCMRegRequest& from);
  void MergeFrom(const AndroidGCMRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AndroidGCMRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.AndroidGCMRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_token();
  void clear_has_token();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AndroidGCMRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AndroidGCMRegResponse) */ {
 public:
  AndroidGCMRegResponse();
  virtual ~AndroidGCMRegResponse();

  AndroidGCMRegResponse(const AndroidGCMRegResponse& from);

  inline AndroidGCMRegResponse& operator=(const AndroidGCMRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AndroidGCMRegResponse& default_instance();

  static inline const AndroidGCMRegResponse* internal_default_instance() {
    return reinterpret_cast<const AndroidGCMRegResponse*>(
               &_AndroidGCMRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(AndroidGCMRegResponse* other);

  // implements Message ----------------------------------------------

  inline AndroidGCMRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AndroidGCMRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AndroidGCMRegResponse& from);
  void MergeFrom(const AndroidGCMRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AndroidGCMRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.AndroidGCMRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AndroidGCMUnRegRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AndroidGCMUnRegRequest) */ {
 public:
  AndroidGCMUnRegRequest();
  virtual ~AndroidGCMUnRegRequest();

  AndroidGCMUnRegRequest(const AndroidGCMUnRegRequest& from);

  inline AndroidGCMUnRegRequest& operator=(const AndroidGCMUnRegRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AndroidGCMUnRegRequest& default_instance();

  static inline const AndroidGCMUnRegRequest* internal_default_instance() {
    return reinterpret_cast<const AndroidGCMUnRegRequest*>(
               &_AndroidGCMUnRegRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(AndroidGCMUnRegRequest* other);

  // implements Message ----------------------------------------------

  inline AndroidGCMUnRegRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AndroidGCMUnRegRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AndroidGCMUnRegRequest& from);
  void MergeFrom(const AndroidGCMUnRegRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AndroidGCMUnRegRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.AndroidGCMUnRegRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_token();
  void clear_has_token();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AndroidGCMUnRegResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AndroidGCMUnRegResponse) */ {
 public:
  AndroidGCMUnRegResponse();
  virtual ~AndroidGCMUnRegResponse();

  AndroidGCMUnRegResponse(const AndroidGCMUnRegResponse& from);

  inline AndroidGCMUnRegResponse& operator=(const AndroidGCMUnRegResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AndroidGCMUnRegResponse& default_instance();

  static inline const AndroidGCMUnRegResponse* internal_default_instance() {
    return reinterpret_cast<const AndroidGCMUnRegResponse*>(
               &_AndroidGCMUnRegResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(AndroidGCMUnRegResponse* other);

  // implements Message ----------------------------------------------

  inline AndroidGCMUnRegResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AndroidGCMUnRegResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AndroidGCMUnRegResponse& from);
  void MergeFrom(const AndroidGCMUnRegResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AndroidGCMUnRegResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.AndroidGCMUnRegResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RSACert : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.RSACert) */ {
 public:
  RSACert();
  virtual ~RSACert();

  RSACert(const RSACert& from);

  inline RSACert& operator=(const RSACert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSACert& default_instance();

  static inline const RSACert* internal_default_instance() {
    return reinterpret_cast<const RSACert*>(
               &_RSACert_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void Swap(RSACert* other);

  // implements Message ----------------------------------------------

  inline RSACert* New() const PROTOBUF_FINAL { return New(NULL); }

  RSACert* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RSACert& from);
  void MergeFrom(const RSACert& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RSACert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string KeyN = 1;
  bool has_keyn() const;
  void clear_keyn();
  static const int kKeyNFieldNumber = 1;
  const ::std::string& keyn() const;
  void set_keyn(const ::std::string& value);
  #if LANG_CXX11
  void set_keyn(::std::string&& value);
  #endif
  void set_keyn(const char* value);
  void set_keyn(const char* value, size_t size);
  ::std::string* mutable_keyn();
  ::std::string* release_keyn();
  void set_allocated_keyn(::std::string* keyn);

  // optional string KeyE = 2;
  bool has_keye() const;
  void clear_keye();
  static const int kKeyEFieldNumber = 2;
  const ::std::string& keye() const;
  void set_keye(const ::std::string& value);
  #if LANG_CXX11
  void set_keye(::std::string&& value);
  #endif
  void set_keye(const char* value);
  void set_keye(const char* value, size_t size);
  ::std::string* mutable_keye();
  ::std::string* release_keye();
  void set_allocated_keye(::std::string* keye);

  // @@protoc_insertion_point(class_scope:micromsg.RSACert)
 private:
  void set_has_keyn();
  void clear_has_keyn();
  void set_has_keye();
  void clear_has_keye();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr keyn_;
  ::google::protobuf::internal::ArenaStringPtr keye_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetCertRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetCertRequest) */ {
 public:
  GetCertRequest();
  virtual ~GetCertRequest();

  GetCertRequest(const GetCertRequest& from);

  inline GetCertRequest& operator=(const GetCertRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCertRequest& default_instance();

  static inline const GetCertRequest* internal_default_instance() {
    return reinterpret_cast<const GetCertRequest*>(
               &_GetCertRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    66;

  void Swap(GetCertRequest* other);

  // implements Message ----------------------------------------------

  inline GetCertRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetCertRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetCertRequest& from);
  void MergeFrom(const GetCertRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetCertRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // required uint32 CurrentCertVersion = 3;
  bool has_currentcertversion() const;
  void clear_currentcertversion();
  static const int kCurrentCertVersionFieldNumber = 3;
  ::google::protobuf::uint32 currentcertversion() const;
  void set_currentcertversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetCertRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_currentcertversion();
  void clear_has_currentcertversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::google::protobuf::uint32 currentcertversion_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetCertResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetCertResponse) */ {
 public:
  GetCertResponse();
  virtual ~GetCertResponse();

  GetCertResponse(const GetCertResponse& from);

  inline GetCertResponse& operator=(const GetCertResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCertResponse& default_instance();

  static inline const GetCertResponse* internal_default_instance() {
    return reinterpret_cast<const GetCertResponse*>(
               &_GetCertResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    67;

  void Swap(GetCertResponse* other);

  // implements Message ----------------------------------------------

  inline GetCertResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetCertResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetCertResponse& from);
  void MergeFrom(const GetCertResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetCertResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.RSACert CertValue = 2;
  bool has_certvalue() const;
  void clear_certvalue();
  static const int kCertValueFieldNumber = 2;
  const ::micromsg::RSACert& certvalue() const;
  ::micromsg::RSACert* mutable_certvalue();
  ::micromsg::RSACert* release_certvalue();
  void set_allocated_certvalue(::micromsg::RSACert* certvalue);

  // required uint32 CertVersion = 3;
  bool has_certversion() const;
  void clear_certversion();
  static const int kCertVersionFieldNumber = 3;
  ::google::protobuf::uint32 certversion() const;
  void set_certversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetCertResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_certvalue();
  void clear_has_certvalue();
  void set_has_certversion();
  void clear_has_certversion();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::RSACert* certvalue_;
  ::google::protobuf::uint32 certversion_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewAuthRsaReqData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.NewAuthRsaReqData) */ {
 public:
  NewAuthRsaReqData();
  virtual ~NewAuthRsaReqData();

  NewAuthRsaReqData(const NewAuthRsaReqData& from);

  inline NewAuthRsaReqData& operator=(const NewAuthRsaReqData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewAuthRsaReqData& default_instance();

  static inline const NewAuthRsaReqData* internal_default_instance() {
    return reinterpret_cast<const NewAuthRsaReqData*>(
               &_NewAuthRsaReqData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    68;

  void Swap(NewAuthRsaReqData* other);

  // implements Message ----------------------------------------------

  inline NewAuthRsaReqData* New() const PROTOBUF_FINAL { return New(NULL); }

  NewAuthRsaReqData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewAuthRsaReqData& from);
  void MergeFrom(const NewAuthRsaReqData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewAuthRsaReqData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 1;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 1;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // @@protoc_insertion_point(class_scope:micromsg.NewAuthRsaReqData)
 private:
  void set_has_randomencrykey();
  void clear_has_randomencrykey();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewAuthRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.NewAuthRequest) */ {
 public:
  NewAuthRequest();
  virtual ~NewAuthRequest();

  NewAuthRequest(const NewAuthRequest& from);

  inline NewAuthRequest& operator=(const NewAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewAuthRequest& default_instance();

  static inline const NewAuthRequest* internal_default_instance() {
    return reinterpret_cast<const NewAuthRequest*>(
               &_NewAuthRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    69;

  void Swap(NewAuthRequest* other);

  // implements Message ----------------------------------------------

  inline NewAuthRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  NewAuthRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewAuthRequest& from);
  void MergeFrom(const NewAuthRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewAuthRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Pwd2 = 6;
  bool has_pwd2() const;
  void clear_pwd2();
  static const int kPwd2FieldNumber = 6;
  const ::std::string& pwd2() const;
  void set_pwd2(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd2(::std::string&& value);
  #endif
  void set_pwd2(const char* value);
  void set_pwd2(const char* value, size_t size);
  ::std::string* mutable_pwd2();
  ::std::string* release_pwd2();
  void set_allocated_pwd2(::std::string* pwd2);

  // optional string extPwd = 8;
  bool has_extpwd() const;
  void clear_extpwd();
  static const int kExtPwdFieldNumber = 8;
  const ::std::string& extpwd() const;
  void set_extpwd(const ::std::string& value);
  #if LANG_CXX11
  void set_extpwd(::std::string&& value);
  #endif
  void set_extpwd(const char* value);
  void set_extpwd(const char* value, size_t size);
  ::std::string* mutable_extpwd();
  ::std::string* release_extpwd();
  void set_allocated_extpwd(::std::string* extpwd);

  // optional string extPwd2 = 9;
  bool has_extpwd2() const;
  void clear_extpwd2();
  static const int kExtPwd2FieldNumber = 9;
  const ::std::string& extpwd2() const;
  void set_extpwd2(const ::std::string& value);
  #if LANG_CXX11
  void set_extpwd2(::std::string&& value);
  #endif
  void set_extpwd2(const char* value);
  void set_extpwd2(const char* value, size_t size);
  ::std::string* mutable_extpwd2();
  ::std::string* release_extpwd2();
  void set_allocated_extpwd2(::std::string* extpwd2);

  // optional string TimeZone = 10;
  bool has_timezone() const;
  void clear_timezone();
  static const int kTimeZoneFieldNumber = 10;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  #if LANG_CXX11
  void set_timezone(::std::string&& value);
  #endif
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional string Language = 11;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 11;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string IMEI = 12;
  bool has_imei() const;
  void clear_imei();
  static const int kIMEIFieldNumber = 12;
  const ::std::string& imei() const;
  void set_imei(const ::std::string& value);
  #if LANG_CXX11
  void set_imei(::std::string&& value);
  #endif
  void set_imei(const char* value);
  void set_imei(const char* value, size_t size);
  ::std::string* mutable_imei();
  ::std::string* release_imei();
  void set_allocated_imei(::std::string* imei);

  // optional string IPhoneVer = 14;
  bool has_iphonever() const;
  void clear_iphonever();
  static const int kIPhoneVerFieldNumber = 14;
  const ::std::string& iphonever() const;
  void set_iphonever(const ::std::string& value);
  #if LANG_CXX11
  void set_iphonever(::std::string&& value);
  #endif
  void set_iphonever(const char* value);
  void set_iphonever(const char* value, size_t size);
  ::std::string* mutable_iphonever();
  ::std::string* release_iphonever();
  void set_allocated_iphonever(::std::string* iphonever);

  // optional string DeviceBrand = 18;
  bool has_devicebrand() const;
  void clear_devicebrand();
  static const int kDeviceBrandFieldNumber = 18;
  const ::std::string& devicebrand() const;
  void set_devicebrand(const ::std::string& value);
  #if LANG_CXX11
  void set_devicebrand(::std::string&& value);
  #endif
  void set_devicebrand(const char* value);
  void set_devicebrand(const char* value, size_t size);
  ::std::string* mutable_devicebrand();
  ::std::string* release_devicebrand();
  void set_allocated_devicebrand(::std::string* devicebrand);

  // optional string DeviceModel = 19;
  bool has_devicemodel() const;
  void clear_devicemodel();
  static const int kDeviceModelFieldNumber = 19;
  const ::std::string& devicemodel() const;
  void set_devicemodel(const ::std::string& value);
  #if LANG_CXX11
  void set_devicemodel(::std::string&& value);
  #endif
  void set_devicemodel(const char* value);
  void set_devicemodel(const char* value, size_t size);
  ::std::string* mutable_devicemodel();
  ::std::string* release_devicemodel();
  void set_allocated_devicemodel(::std::string* devicemodel);

  // optional string OSType = 20;
  bool has_ostype() const;
  void clear_ostype();
  static const int kOSTypeFieldNumber = 20;
  const ::std::string& ostype() const;
  void set_ostype(const ::std::string& value);
  #if LANG_CXX11
  void set_ostype(::std::string&& value);
  #endif
  void set_ostype(const char* value);
  void set_ostype(const char* value, size_t size);
  ::std::string* mutable_ostype();
  ::std::string* release_ostype();
  void set_allocated_ostype(::std::string* ostype);

  // optional string DeviceType = 21;
  bool has_devicetype() const;
  void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 21;
  const ::std::string& devicetype() const;
  void set_devicetype(const ::std::string& value);
  #if LANG_CXX11
  void set_devicetype(::std::string&& value);
  #endif
  void set_devicetype(const char* value);
  void set_devicetype(const char* value, size_t size);
  ::std::string* mutable_devicetype();
  ::std::string* release_devicetype();
  void set_allocated_devicetype(::std::string* devicetype);

  // optional string SoftType = 22;
  bool has_softtype() const;
  void clear_softtype();
  static const int kSoftTypeFieldNumber = 22;
  const ::std::string& softtype() const;
  void set_softtype(const ::std::string& value);
  #if LANG_CXX11
  void set_softtype(::std::string&& value);
  #endif
  void set_softtype(const char* value);
  void set_softtype(const char* value, size_t size);
  ::std::string* mutable_softtype();
  ::std::string* release_softtype();
  void set_allocated_softtype(::std::string* softtype);

  // optional string AuthTicket = 23;
  bool has_authticket() const;
  void clear_authticket();
  static const int kAuthTicketFieldNumber = 23;
  const ::std::string& authticket() const;
  void set_authticket(const ::std::string& value);
  #if LANG_CXX11
  void set_authticket(::std::string&& value);
  #endif
  void set_authticket(const char* value);
  void set_authticket(const char* value, size_t size);
  ::std::string* mutable_authticket();
  ::std::string* release_authticket();
  void set_allocated_authticket(::std::string* authticket);

  // optional string RealCountry = 24;
  bool has_realcountry() const;
  void clear_realcountry();
  static const int kRealCountryFieldNumber = 24;
  const ::std::string& realcountry() const;
  void set_realcountry(const ::std::string& value);
  #if LANG_CXX11
  void set_realcountry(::std::string&& value);
  #endif
  void set_realcountry(const char* value);
  void set_realcountry(const char* value, size_t size);
  ::std::string* mutable_realcountry();
  ::std::string* release_realcountry();
  void set_allocated_realcountry(::std::string* realcountry);

  // optional string Signature = 25;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 25;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional string AutoAuthTicket = 27;
  bool has_autoauthticket() const;
  void clear_autoauthticket();
  static const int kAutoAuthTicketFieldNumber = 27;
  const ::std::string& autoauthticket() const;
  void set_autoauthticket(const ::std::string& value);
  #if LANG_CXX11
  void set_autoauthticket(::std::string&& value);
  #endif
  void set_autoauthticket(const char* value);
  void set_autoauthticket(const char* value, size_t size);
  ::std::string* mutable_autoauthticket();
  ::std::string* release_autoauthticket();
  void set_allocated_autoauthticket(::std::string* autoauthticket);

  // optional string DeviceName = 28;
  bool has_devicename() const;
  void clear_devicename();
  static const int kDeviceNameFieldNumber = 28;
  const ::std::string& devicename() const;
  void set_devicename(const ::std::string& value);
  #if LANG_CXX11
  void set_devicename(::std::string&& value);
  #endif
  void set_devicename(const char* value);
  void set_devicename(const char* value, size_t size);
  ::std::string* mutable_devicename();
  ::std::string* release_devicename();
  void set_allocated_devicename(::std::string* devicename);

  // optional string ClientSeqID = 31;
  bool has_clientseqid() const;
  void clear_clientseqid();
  static const int kClientSeqIDFieldNumber = 31;
  const ::std::string& clientseqid() const;
  void set_clientseqid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientseqid(::std::string&& value);
  #endif
  void set_clientseqid(const char* value);
  void set_clientseqid(const char* value, size_t size);
  ::std::string* mutable_clientseqid();
  ::std::string* release_clientseqid();
  void set_allocated_clientseqid(::std::string* clientseqid);

  // optional string BundleID = 32;
  bool has_bundleid() const;
  void clear_bundleid();
  static const int kBundleIDFieldNumber = 32;
  const ::std::string& bundleid() const;
  void set_bundleid(const ::std::string& value);
  #if LANG_CXX11
  void set_bundleid(::std::string&& value);
  #endif
  void set_bundleid(const char* value);
  void set_bundleid(const char* value, size_t size);
  ::std::string* mutable_bundleid();
  ::std::string* release_bundleid();
  void set_allocated_bundleid(::std::string* bundleid);

  // optional string AdSource = 33;
  bool has_adsource() const;
  void clear_adsource();
  static const int kAdSourceFieldNumber = 33;
  const ::std::string& adsource() const;
  void set_adsource(const ::std::string& value);
  #if LANG_CXX11
  void set_adsource(::std::string&& value);
  #endif
  void set_adsource(const char* value);
  void set_adsource(const char* value, size_t size);
  ::std::string* mutable_adsource();
  ::std::string* release_adsource();
  void set_allocated_adsource(::std::string* adsource);

  // optional string VerifySignature = 36;
  bool has_verifysignature() const;
  void clear_verifysignature();
  static const int kVerifySignatureFieldNumber = 36;
  const ::std::string& verifysignature() const;
  void set_verifysignature(const ::std::string& value);
  #if LANG_CXX11
  void set_verifysignature(::std::string&& value);
  #endif
  void set_verifysignature(const char* value);
  void set_verifysignature(const char* value, size_t size);
  ::std::string* mutable_verifysignature();
  ::std::string* release_verifysignature();
  void set_allocated_verifysignature(::std::string* verifysignature);

  // optional string VerifyContent = 37;
  bool has_verifycontent() const;
  void clear_verifycontent();
  static const int kVerifyContentFieldNumber = 37;
  const ::std::string& verifycontent() const;
  void set_verifycontent(const ::std::string& value);
  #if LANG_CXX11
  void set_verifycontent(::std::string&& value);
  #endif
  void set_verifycontent(const char* value);
  void set_verifycontent(const char* value, size_t size);
  ::std::string* mutable_verifycontent();
  ::std::string* release_verifycontent();
  void set_allocated_verifycontent(::std::string* verifycontent);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinString_t UserName = 2;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 2;
  const ::micromsg::SKBuiltinString_t& username() const;
  ::micromsg::SKBuiltinString_t* mutable_username();
  ::micromsg::SKBuiltinString_t* release_username();
  void set_allocated_username(::micromsg::SKBuiltinString_t* username);

  // required .micromsg.SKBuiltinString_t Pwd = 3;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 3;
  const ::micromsg::SKBuiltinString_t& pwd() const;
  ::micromsg::SKBuiltinString_t* mutable_pwd();
  ::micromsg::SKBuiltinString_t* release_pwd();
  void set_allocated_pwd(::micromsg::SKBuiltinString_t* pwd);

  // required .micromsg.SKBuiltinString_t ImgSid = 4;
  bool has_imgsid() const;
  void clear_imgsid();
  static const int kImgSidFieldNumber = 4;
  const ::micromsg::SKBuiltinString_t& imgsid() const;
  ::micromsg::SKBuiltinString_t* mutable_imgsid();
  ::micromsg::SKBuiltinString_t* release_imgsid();
  void set_allocated_imgsid(::micromsg::SKBuiltinString_t* imgsid);

  // required .micromsg.SKBuiltinString_t ImgCode = 5;
  bool has_imgcode() const;
  void clear_imgcode();
  static const int kImgCodeFieldNumber = 5;
  const ::micromsg::SKBuiltinString_t& imgcode() const;
  ::micromsg::SKBuiltinString_t* mutable_imgcode();
  ::micromsg::SKBuiltinString_t* release_imgcode();
  void set_allocated_imgcode(::micromsg::SKBuiltinString_t* imgcode);

  // optional .micromsg.SKBuiltinString_t ImgEncryptKey = 15;
  bool has_imgencryptkey() const;
  void clear_imgencryptkey();
  static const int kImgEncryptKeyFieldNumber = 15;
  const ::micromsg::SKBuiltinString_t& imgencryptkey() const;
  ::micromsg::SKBuiltinString_t* mutable_imgencryptkey();
  ::micromsg::SKBuiltinString_t* release_imgencryptkey();
  void set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t KSid = 16;
  bool has_ksid() const;
  void clear_ksid();
  static const int kKSidFieldNumber = 16;
  const ::micromsg::SKBuiltinBuffer_t& ksid() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_ksid();
  ::micromsg::SKBuiltinBuffer_t* release_ksid();
  void set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 26;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 26;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // optional .micromsg.SKBuiltinBuffer_t WTLoginReqBuff = 29;
  bool has_wtloginreqbuff() const;
  void clear_wtloginreqbuff();
  static const int kWTLoginReqBuffFieldNumber = 29;
  const ::micromsg::SKBuiltinBuffer_t& wtloginreqbuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_wtloginreqbuff();
  ::micromsg::SKBuiltinBuffer_t* release_wtloginreqbuff();
  void set_allocated_wtloginreqbuff(::micromsg::SKBuiltinBuffer_t* wtloginreqbuff);

  // optional .micromsg.SKBuiltinBuffer_t CliDBEncryptKey = 34;
  bool has_clidbencryptkey() const;
  void clear_clidbencryptkey();
  static const int kCliDBEncryptKeyFieldNumber = 34;
  const ::micromsg::SKBuiltinBuffer_t& clidbencryptkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_clidbencryptkey();
  ::micromsg::SKBuiltinBuffer_t* release_clidbencryptkey();
  void set_allocated_clidbencryptkey(::micromsg::SKBuiltinBuffer_t* clidbencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t CliDBEncryptInfo = 35;
  bool has_clidbencryptinfo() const;
  void clear_clidbencryptinfo();
  static const int kCliDBEncryptInfoFieldNumber = 35;
  const ::micromsg::SKBuiltinBuffer_t& clidbencryptinfo() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_clidbencryptinfo();
  ::micromsg::SKBuiltinBuffer_t* release_clidbencryptinfo();
  void set_allocated_clidbencryptinfo(::micromsg::SKBuiltinBuffer_t* clidbencryptinfo);

  // optional uint32 BuiltinIPSeq = 7;
  bool has_builtinipseq() const;
  void clear_builtinipseq();
  static const int kBuiltinIPSeqFieldNumber = 7;
  ::google::protobuf::uint32 builtinipseq() const;
  void set_builtinipseq(::google::protobuf::uint32 value);

  // optional int32 Channel = 13;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 13;
  ::google::protobuf::int32 channel() const;
  void set_channel(::google::protobuf::int32 value);

  // optional uint32 TimeStamp = 17;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 17;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 InputType = 30;
  bool has_inputtype() const;
  void clear_inputtype();
  static const int kInputTypeFieldNumber = 30;
  ::google::protobuf::uint32 inputtype() const;
  void set_inputtype(::google::protobuf::uint32 value);

  // optional uint32 SessionMode = 38;
  bool has_sessionmode() const;
  void clear_sessionmode();
  static const int kSessionModeFieldNumber = 38;
  ::google::protobuf::uint32 sessionmode() const;
  void set_sessionmode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.NewAuthRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_username();
  void clear_has_username();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_imgsid();
  void clear_has_imgsid();
  void set_has_imgcode();
  void clear_has_imgcode();
  void set_has_pwd2();
  void clear_has_pwd2();
  void set_has_builtinipseq();
  void clear_has_builtinipseq();
  void set_has_extpwd();
  void clear_has_extpwd();
  void set_has_extpwd2();
  void clear_has_extpwd2();
  void set_has_timezone();
  void clear_has_timezone();
  void set_has_language();
  void clear_has_language();
  void set_has_imei();
  void clear_has_imei();
  void set_has_channel();
  void clear_has_channel();
  void set_has_iphonever();
  void clear_has_iphonever();
  void set_has_imgencryptkey();
  void clear_has_imgencryptkey();
  void set_has_ksid();
  void clear_has_ksid();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_devicebrand();
  void clear_has_devicebrand();
  void set_has_devicemodel();
  void clear_has_devicemodel();
  void set_has_ostype();
  void clear_has_ostype();
  void set_has_devicetype();
  void clear_has_devicetype();
  void set_has_softtype();
  void clear_has_softtype();
  void set_has_authticket();
  void clear_has_authticket();
  void set_has_realcountry();
  void clear_has_realcountry();
  void set_has_signature();
  void clear_has_signature();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_autoauthticket();
  void clear_has_autoauthticket();
  void set_has_devicename();
  void clear_has_devicename();
  void set_has_wtloginreqbuff();
  void clear_has_wtloginreqbuff();
  void set_has_inputtype();
  void clear_has_inputtype();
  void set_has_clientseqid();
  void clear_has_clientseqid();
  void set_has_bundleid();
  void clear_has_bundleid();
  void set_has_adsource();
  void clear_has_adsource();
  void set_has_clidbencryptkey();
  void clear_has_clidbencryptkey();
  void set_has_clidbencryptinfo();
  void clear_has_clidbencryptinfo();
  void set_has_verifysignature();
  void clear_has_verifysignature();
  void set_has_verifycontent();
  void clear_has_verifycontent();
  void set_has_sessionmode();
  void clear_has_sessionmode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::internal::ArenaStringPtr pwd2_;
  ::google::protobuf::internal::ArenaStringPtr extpwd_;
  ::google::protobuf::internal::ArenaStringPtr extpwd2_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr imei_;
  ::google::protobuf::internal::ArenaStringPtr iphonever_;
  ::google::protobuf::internal::ArenaStringPtr devicebrand_;
  ::google::protobuf::internal::ArenaStringPtr devicemodel_;
  ::google::protobuf::internal::ArenaStringPtr ostype_;
  ::google::protobuf::internal::ArenaStringPtr devicetype_;
  ::google::protobuf::internal::ArenaStringPtr softtype_;
  ::google::protobuf::internal::ArenaStringPtr authticket_;
  ::google::protobuf::internal::ArenaStringPtr realcountry_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr autoauthticket_;
  ::google::protobuf::internal::ArenaStringPtr devicename_;
  ::google::protobuf::internal::ArenaStringPtr clientseqid_;
  ::google::protobuf::internal::ArenaStringPtr bundleid_;
  ::google::protobuf::internal::ArenaStringPtr adsource_;
  ::google::protobuf::internal::ArenaStringPtr verifysignature_;
  ::google::protobuf::internal::ArenaStringPtr verifycontent_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinString_t* username_;
  ::micromsg::SKBuiltinString_t* pwd_;
  ::micromsg::SKBuiltinString_t* imgsid_;
  ::micromsg::SKBuiltinString_t* imgcode_;
  ::micromsg::SKBuiltinString_t* imgencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* ksid_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::micromsg::SKBuiltinBuffer_t* wtloginreqbuff_;
  ::micromsg::SKBuiltinBuffer_t* clidbencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* clidbencryptinfo_;
  ::google::protobuf::uint32 builtinipseq_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 inputtype_;
  ::google::protobuf::uint32 sessionmode_;
  mutable int _cached_size_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewAuthResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.NewAuthResponse) */ {
 public:
  NewAuthResponse();
  virtual ~NewAuthResponse();

  NewAuthResponse(const NewAuthResponse& from);

  inline NewAuthResponse& operator=(const NewAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewAuthResponse& default_instance();

  static inline const NewAuthResponse* internal_default_instance() {
    return reinterpret_cast<const NewAuthResponse*>(
               &_NewAuthResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    70;

  void Swap(NewAuthResponse* other);

  // implements Message ----------------------------------------------

  inline NewAuthResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  NewAuthResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NewAuthResponse& from);
  void MergeFrom(const NewAuthResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NewAuthResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes SessionKey = 9;
  bool has_sessionkey() const;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 9;
  const ::std::string& sessionkey() const;
  void set_sessionkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sessionkey(::std::string&& value);
  #endif
  void set_sessionkey(const char* value);
  void set_sessionkey(const void* value, size_t size);
  ::std::string* mutable_sessionkey();
  ::std::string* release_sessionkey();
  void set_allocated_sessionkey(::std::string* sessionkey);

  // optional string Ticket = 17;
  bool has_ticket() const;
  void clear_ticket();
  static const int kTicketFieldNumber = 17;
  const ::std::string& ticket() const;
  void set_ticket(const ::std::string& value);
  #if LANG_CXX11
  void set_ticket(::std::string&& value);
  #endif
  void set_ticket(const char* value);
  void set_ticket(const char* value, size_t size);
  ::std::string* mutable_ticket();
  ::std::string* release_ticket();
  void set_allocated_ticket(::std::string* ticket);

  // optional string PushMailSettingTicket = 20;
  bool has_pushmailsettingticket() const;
  void clear_pushmailsettingticket();
  static const int kPushMailSettingTicketFieldNumber = 20;
  const ::std::string& pushmailsettingticket() const;
  void set_pushmailsettingticket(const ::std::string& value);
  #if LANG_CXX11
  void set_pushmailsettingticket(::std::string&& value);
  #endif
  void set_pushmailsettingticket(const char* value);
  void set_pushmailsettingticket(const char* value, size_t size);
  ::std::string* mutable_pushmailsettingticket();
  ::std::string* release_pushmailsettingticket();
  void set_allocated_pushmailsettingticket(::std::string* pushmailsettingticket);

  // optional string FSURL = 22;
  bool has_fsurl() const;
  void clear_fsurl();
  static const int kFSURLFieldNumber = 22;
  const ::std::string& fsurl() const;
  void set_fsurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fsurl(::std::string&& value);
  #endif
  void set_fsurl(const char* value);
  void set_fsurl(const char* value, size_t size);
  ::std::string* mutable_fsurl();
  ::std::string* release_fsurl();
  void set_allocated_fsurl(::std::string* fsurl);

  // optional string Alias = 25;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 25;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // optional string AuthKey = 27;
  bool has_authkey() const;
  void clear_authkey();
  static const int kAuthKeyFieldNumber = 27;
  const ::std::string& authkey() const;
  void set_authkey(const ::std::string& value);
  #if LANG_CXX11
  void set_authkey(::std::string&& value);
  #endif
  void set_authkey(const char* value);
  void set_authkey(const char* value, size_t size);
  ::std::string* mutable_authkey();
  ::std::string* release_authkey();
  void set_allocated_authkey(::std::string* authkey);

  // optional string Sid = 28;
  bool has_sid() const;
  void clear_sid();
  static const int kSidFieldNumber = 28;
  const ::std::string& sid() const;
  void set_sid(const ::std::string& value);
  #if LANG_CXX11
  void set_sid(::std::string&& value);
  #endif
  void set_sid(const char* value);
  void set_sid(const char* value, size_t size);
  ::std::string* mutable_sid();
  ::std::string* release_sid();
  void set_allocated_sid(::std::string* sid);

  // optional string Password = 34;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 34;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string KickResponse = 37;
  bool has_kickresponse() const;
  void clear_kickresponse();
  static const int kKickResponseFieldNumber = 37;
  const ::std::string& kickresponse() const;
  void set_kickresponse(const ::std::string& value);
  #if LANG_CXX11
  void set_kickresponse(::std::string&& value);
  #endif
  void set_kickresponse(const char* value);
  void set_kickresponse(const char* value, size_t size);
  ::std::string* mutable_kickresponse();
  ::std::string* release_kickresponse();
  void set_allocated_kickresponse(::std::string* kickresponse);

  // optional string ApplyBetaUrl = 38;
  bool has_applybetaurl() const;
  void clear_applybetaurl();
  static const int kApplyBetaUrlFieldNumber = 38;
  const ::std::string& applybetaurl() const;
  void set_applybetaurl(const ::std::string& value);
  #if LANG_CXX11
  void set_applybetaurl(::std::string&& value);
  #endif
  void set_applybetaurl(const char* value);
  void set_applybetaurl(const char* value, size_t size);
  ::std::string* mutable_applybetaurl();
  ::std::string* release_applybetaurl();
  void set_allocated_applybetaurl(::std::string* applybetaurl);

  // optional string DeviceInfoXml = 39;
  bool has_deviceinfoxml() const;
  void clear_deviceinfoxml();
  static const int kDeviceInfoXmlFieldNumber = 39;
  const ::std::string& deviceinfoxml() const;
  void set_deviceinfoxml(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceinfoxml(::std::string&& value);
  #endif
  void set_deviceinfoxml(const char* value);
  void set_deviceinfoxml(const char* value, size_t size);
  ::std::string* mutable_deviceinfoxml();
  ::std::string* release_deviceinfoxml();
  void set_allocated_deviceinfoxml(::std::string* deviceinfoxml);

  // optional string SoftConfigXml = 40;
  bool has_softconfigxml() const;
  void clear_softconfigxml();
  static const int kSoftConfigXmlFieldNumber = 40;
  const ::std::string& softconfigxml() const;
  void set_softconfigxml(const ::std::string& value);
  #if LANG_CXX11
  void set_softconfigxml(::std::string&& value);
  #endif
  void set_softconfigxml(const char* value);
  void set_softconfigxml(const char* value, size_t size);
  ::std::string* mutable_softconfigxml();
  ::std::string* release_softconfigxml();
  void set_allocated_softconfigxml(::std::string* softconfigxml);

  // optional string AuthTicket = 42;
  bool has_authticket() const;
  void clear_authticket();
  static const int kAuthTicketFieldNumber = 42;
  const ::std::string& authticket() const;
  void set_authticket(const ::std::string& value);
  #if LANG_CXX11
  void set_authticket(::std::string&& value);
  #endif
  void set_authticket(const char* value);
  void set_authticket(const char* value, size_t size);
  ::std::string* mutable_authticket();
  ::std::string* release_authticket();
  void set_allocated_authticket(::std::string* authticket);

  // optional string HintMsg = 46;
  bool has_hintmsg() const;
  void clear_hintmsg();
  static const int kHintMsgFieldNumber = 46;
  const ::std::string& hintmsg() const;
  void set_hintmsg(const ::std::string& value);
  #if LANG_CXX11
  void set_hintmsg(::std::string&& value);
  #endif
  void set_hintmsg(const char* value);
  void set_hintmsg(const char* value, size_t size);
  ::std::string* mutable_hintmsg();
  ::std::string* release_hintmsg();
  void set_allocated_hintmsg(::std::string* hintmsg);

  // optional string AutoAuthTicket = 47;
  bool has_autoauthticket() const;
  void clear_autoauthticket();
  static const int kAutoAuthTicketFieldNumber = 47;
  const ::std::string& autoauthticket() const;
  void set_autoauthticket(const ::std::string& value);
  #if LANG_CXX11
  void set_autoauthticket(::std::string&& value);
  #endif
  void set_autoauthticket(const char* value);
  void set_autoauthticket(const char* value, size_t size);
  ::std::string* mutable_autoauthticket();
  ::std::string* release_autoauthticket();
  void set_allocated_autoauthticket(::std::string* autoauthticket);

  // optional string VerifySignature = 57;
  bool has_verifysignature() const;
  void clear_verifysignature();
  static const int kVerifySignatureFieldNumber = 57;
  const ::std::string& verifysignature() const;
  void set_verifysignature(const ::std::string& value);
  #if LANG_CXX11
  void set_verifysignature(::std::string&& value);
  #endif
  void set_verifysignature(const char* value);
  void set_verifysignature(const char* value, size_t size);
  ::std::string* mutable_verifysignature();
  ::std::string* release_verifysignature();
  void set_allocated_verifysignature(::std::string* verifysignature);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.SKBuiltinString_t UserName = 3;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 3;
  const ::micromsg::SKBuiltinString_t& username() const;
  ::micromsg::SKBuiltinString_t* mutable_username();
  ::micromsg::SKBuiltinString_t* release_username();
  void set_allocated_username(::micromsg::SKBuiltinString_t* username);

  // required .micromsg.SKBuiltinString_t NickName = 4;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNickNameFieldNumber = 4;
  const ::micromsg::SKBuiltinString_t& nickname() const;
  ::micromsg::SKBuiltinString_t* mutable_nickname();
  ::micromsg::SKBuiltinString_t* release_nickname();
  void set_allocated_nickname(::micromsg::SKBuiltinString_t* nickname);

  // required .micromsg.SKBuiltinString_t BindEmail = 6;
  bool has_bindemail() const;
  void clear_bindemail();
  static const int kBindEmailFieldNumber = 6;
  const ::micromsg::SKBuiltinString_t& bindemail() const;
  ::micromsg::SKBuiltinString_t* mutable_bindemail();
  ::micromsg::SKBuiltinString_t* release_bindemail();
  void set_allocated_bindemail(::micromsg::SKBuiltinString_t* bindemail);

  // required .micromsg.SKBuiltinString_t BindMobile = 7;
  bool has_bindmobile() const;
  void clear_bindmobile();
  static const int kBindMobileFieldNumber = 7;
  const ::micromsg::SKBuiltinString_t& bindmobile() const;
  ::micromsg::SKBuiltinString_t* mutable_bindmobile();
  ::micromsg::SKBuiltinString_t* release_bindmobile();
  void set_allocated_bindmobile(::micromsg::SKBuiltinString_t* bindmobile);

  // required .micromsg.SKBuiltinString_t ImgSid = 10;
  bool has_imgsid() const;
  void clear_imgsid();
  static const int kImgSidFieldNumber = 10;
  const ::micromsg::SKBuiltinString_t& imgsid() const;
  ::micromsg::SKBuiltinString_t* mutable_imgsid();
  ::micromsg::SKBuiltinString_t* release_imgsid();
  void set_allocated_imgsid(::micromsg::SKBuiltinString_t* imgsid);

  // required .micromsg.SKBuiltinBuffer_t ImgBuf = 11;
  bool has_imgbuf() const;
  void clear_imgbuf();
  static const int kImgBufFieldNumber = 11;
  const ::micromsg::SKBuiltinBuffer_t& imgbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_imgbuf();
  ::micromsg::SKBuiltinBuffer_t* release_imgbuf();
  void set_allocated_imgbuf(::micromsg::SKBuiltinBuffer_t* imgbuf);

  // required .micromsg.SKBuiltinString_t OfficialUserName = 12;
  bool has_officialusername() const;
  void clear_officialusername();
  static const int kOfficialUserNameFieldNumber = 12;
  const ::micromsg::SKBuiltinString_t& officialusername() const;
  ::micromsg::SKBuiltinString_t* mutable_officialusername();
  ::micromsg::SKBuiltinString_t* release_officialusername();
  void set_allocated_officialusername(::micromsg::SKBuiltinString_t* officialusername);

  // required .micromsg.SKBuiltinString_t OfficialNickName = 13;
  bool has_officialnickname() const;
  void clear_officialnickname();
  static const int kOfficialNickNameFieldNumber = 13;
  const ::micromsg::SKBuiltinString_t& officialnickname() const;
  ::micromsg::SKBuiltinString_t* mutable_officialnickname();
  ::micromsg::SKBuiltinString_t* release_officialnickname();
  void set_allocated_officialnickname(::micromsg::SKBuiltinString_t* officialnickname);

  // optional .micromsg.SKBuiltinString_t QQMicroBlogUserName = 14;
  bool has_qqmicroblogusername() const;
  void clear_qqmicroblogusername();
  static const int kQQMicroBlogUserNameFieldNumber = 14;
  const ::micromsg::SKBuiltinString_t& qqmicroblogusername() const;
  ::micromsg::SKBuiltinString_t* mutable_qqmicroblogusername();
  ::micromsg::SKBuiltinString_t* release_qqmicroblogusername();
  void set_allocated_qqmicroblogusername(::micromsg::SKBuiltinString_t* qqmicroblogusername);

  // optional .micromsg.BuiltinIPList BuiltinIPList = 21;
  bool has_builtiniplist() const;
  void clear_builtiniplist();
  static const int kBuiltinIPListFieldNumber = 21;
  const ::micromsg::BuiltinIPList& builtiniplist() const;
  ::micromsg::BuiltinIPList* mutable_builtiniplist();
  ::micromsg::BuiltinIPList* release_builtiniplist();
  void set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist);

  // optional .micromsg.NetworkControl NetworkControl = 23;
  bool has_networkcontrol() const;
  void clear_networkcontrol();
  static const int kNetworkControlFieldNumber = 23;
  const ::micromsg::NetworkControl& networkcontrol() const;
  ::micromsg::NetworkControl* mutable_networkcontrol();
  ::micromsg::NetworkControl* release_networkcontrol();
  void set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol);

  // optional .micromsg.PluginKeyList PluginKeyList = 29;
  bool has_pluginkeylist() const;
  void clear_pluginkeylist();
  static const int kPluginKeyListFieldNumber = 29;
  const ::micromsg::PluginKeyList& pluginkeylist() const;
  ::micromsg::PluginKeyList* mutable_pluginkeylist();
  ::micromsg::PluginKeyList* release_pluginkeylist();
  void set_allocated_pluginkeylist(::micromsg::PluginKeyList* pluginkeylist);

  // optional .micromsg.SKBuiltinString_t ImgEncryptKey = 30;
  bool has_imgencryptkey() const;
  void clear_imgencryptkey();
  static const int kImgEncryptKeyFieldNumber = 30;
  const ::micromsg::SKBuiltinString_t& imgencryptkey() const;
  ::micromsg::SKBuiltinString_t* mutable_imgencryptkey();
  ::micromsg::SKBuiltinString_t* release_imgencryptkey();
  void set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t A2Key = 31;
  bool has_a2key() const;
  void clear_a2key();
  static const int kA2KeyFieldNumber = 31;
  const ::micromsg::SKBuiltinBuffer_t& a2key() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_a2key();
  ::micromsg::SKBuiltinBuffer_t* release_a2key();
  void set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key);

  // optional .micromsg.SKBuiltinBuffer_t KSid = 32;
  bool has_ksid() const;
  void clear_ksid();
  static const int kKSidFieldNumber = 32;
  const ::micromsg::SKBuiltinBuffer_t& ksid() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_ksid();
  ::micromsg::SKBuiltinBuffer_t* release_ksid();
  void set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid);

  // optional .micromsg.HostList NewHostList = 41;
  bool has_newhostlist() const;
  void clear_newhostlist();
  static const int kNewHostListFieldNumber = 41;
  const ::micromsg::HostList& newhostlist() const;
  ::micromsg::HostList* mutable_newhostlist();
  ::micromsg::HostList* release_newhostlist();
  void set_allocated_newhostlist(::micromsg::HostList* newhostlist);

  // optional .micromsg.CDNDnsInfo DnsInfo = 48;
  bool has_dnsinfo() const;
  void clear_dnsinfo();
  static const int kDnsInfoFieldNumber = 48;
  const ::micromsg::CDNDnsInfo& dnsinfo() const;
  ::micromsg::CDNDnsInfo* mutable_dnsinfo();
  ::micromsg::CDNDnsInfo* release_dnsinfo();
  void set_allocated_dnsinfo(::micromsg::CDNDnsInfo* dnsinfo);

  // optional .micromsg.SKBuiltinBuffer_t WTLoginRspBuff = 50;
  bool has_wtloginrspbuff() const;
  void clear_wtloginrspbuff();
  static const int kWTLoginRspBuffFieldNumber = 50;
  const ::micromsg::SKBuiltinBuffer_t& wtloginrspbuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_wtloginrspbuff();
  ::micromsg::SKBuiltinBuffer_t* release_wtloginrspbuff();
  void set_allocated_wtloginrspbuff(::micromsg::SKBuiltinBuffer_t* wtloginrspbuff);

  // optional .micromsg.ShowStyleKey ShowStyle = 51;
  bool has_showstyle() const;
  void clear_showstyle();
  static const int kShowStyleFieldNumber = 51;
  const ::micromsg::ShowStyleKey& showstyle() const;
  ::micromsg::ShowStyleKey* mutable_showstyle();
  ::micromsg::ShowStyleKey* release_showstyle();
  void set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle);

  // optional .micromsg.SKBuiltinBuffer_t CliDBEncryptKey = 52;
  bool has_clidbencryptkey() const;
  void clear_clidbencryptkey();
  static const int kCliDBEncryptKeyFieldNumber = 52;
  const ::micromsg::SKBuiltinBuffer_t& clidbencryptkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_clidbencryptkey();
  ::micromsg::SKBuiltinBuffer_t* release_clidbencryptkey();
  void set_allocated_clidbencryptkey(::micromsg::SKBuiltinBuffer_t* clidbencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t CliDBEncryptInfo = 53;
  bool has_clidbencryptinfo() const;
  void clear_clidbencryptinfo();
  static const int kCliDBEncryptInfoFieldNumber = 53;
  const ::micromsg::SKBuiltinBuffer_t& clidbencryptinfo() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_clidbencryptinfo();
  ::micromsg::SKBuiltinBuffer_t* release_clidbencryptinfo();
  void set_allocated_clidbencryptinfo(::micromsg::SKBuiltinBuffer_t* clidbencryptinfo);

  // optional .micromsg.CDNDnsInfo SnsDnsInfo = 55;
  bool has_snsdnsinfo() const;
  void clear_snsdnsinfo();
  static const int kSnsDnsInfoFieldNumber = 55;
  const ::micromsg::CDNDnsInfo& snsdnsinfo() const;
  ::micromsg::CDNDnsInfo* mutable_snsdnsinfo();
  ::micromsg::CDNDnsInfo* release_snsdnsinfo();
  void set_allocated_snsdnsinfo(::micromsg::CDNDnsInfo* snsdnsinfo);

  // optional .micromsg.CDNDnsInfo AppDnsInfo = 56;
  bool has_appdnsinfo() const;
  void clear_appdnsinfo();
  static const int kAppDnsInfoFieldNumber = 56;
  const ::micromsg::CDNDnsInfo& appdnsinfo() const;
  ::micromsg::CDNDnsInfo* mutable_appdnsinfo();
  ::micromsg::CDNDnsInfo* release_appdnsinfo();
  void set_allocated_appdnsinfo(::micromsg::CDNDnsInfo* appdnsinfo);

  // optional .micromsg.SKBuiltinBuffer_t VerifyBuff = 58;
  bool has_verifybuff() const;
  void clear_verifybuff();
  static const int kVerifyBuffFieldNumber = 58;
  const ::micromsg::SKBuiltinBuffer_t& verifybuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_verifybuff();
  ::micromsg::SKBuiltinBuffer_t* release_verifybuff();
  void set_allocated_verifybuff(::micromsg::SKBuiltinBuffer_t* verifybuff);

  // required uint32 Uin = 2;
  bool has_uin() const;
  void clear_uin();
  static const int kUinFieldNumber = 2;
  ::google::protobuf::uint32 uin() const;
  void set_uin(::google::protobuf::uint32 value);

  // required uint32 BindUin = 5;
  bool has_binduin() const;
  void clear_binduin();
  static const int kBindUinFieldNumber = 5;
  ::google::protobuf::uint32 binduin() const;
  void set_binduin(::google::protobuf::uint32 value);

  // required uint32 Status = 8;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 8;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // optional uint32 QQMicroBlogStatus = 15;
  bool has_qqmicroblogstatus() const;
  void clear_qqmicroblogstatus();
  static const int kQQMicroBlogStatusFieldNumber = 15;
  ::google::protobuf::uint32 qqmicroblogstatus() const;
  void set_qqmicroblogstatus(::google::protobuf::uint32 value);

  // optional uint32 NewVersion = 16;
  bool has_newversion() const;
  void clear_newversion();
  static const int kNewVersionFieldNumber = 16;
  ::google::protobuf::uint32 newversion() const;
  void set_newversion(::google::protobuf::uint32 value);

  // optional uint32 PushMailStatus = 18;
  bool has_pushmailstatus() const;
  void clear_pushmailstatus();
  static const int kPushMailStatusFieldNumber = 18;
  ::google::protobuf::uint32 pushmailstatus() const;
  void set_pushmailstatus(::google::protobuf::uint32 value);

  // optional uint32 SendCardBitFlag = 19;
  bool has_sendcardbitflag() const;
  void clear_sendcardbitflag();
  static const int kSendCardBitFlagFieldNumber = 19;
  ::google::protobuf::uint32 sendcardbitflag() const;
  void set_sendcardbitflag(::google::protobuf::uint32 value);

  // optional uint32 PluginFlag = 24;
  bool has_pluginflag() const;
  void clear_pluginflag();
  static const int kPluginFlagFieldNumber = 24;
  ::google::protobuf::uint32 pluginflag() const;
  void set_pluginflag(::google::protobuf::uint32 value);

  // optional uint32 RegType = 26;
  bool has_regtype() const;
  void clear_regtype();
  static const int kRegTypeFieldNumber = 26;
  ::google::protobuf::uint32 regtype() const;
  void set_regtype(::google::protobuf::uint32 value);

  // optional uint32 ProfileFlag = 33;
  bool has_profileflag() const;
  void clear_profileflag();
  static const int kProfileFlagFieldNumber = 33;
  ::google::protobuf::uint32 profileflag() const;
  void set_profileflag(::google::protobuf::uint32 value);

  // optional uint32 TimeStamp = 35;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 35;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 IsAutoReg = 36;
  bool has_isautoreg() const;
  void clear_isautoreg();
  static const int kIsAutoRegFieldNumber = 36;
  ::google::protobuf::uint32 isautoreg() const;
  void set_isautoreg(::google::protobuf::uint32 value);

  // optional uint32 SafeDevice = 43;
  bool has_safedevice() const;
  void clear_safedevice();
  static const int kSafeDeviceFieldNumber = 43;
  ::google::protobuf::uint32 safedevice() const;
  void set_safedevice(::google::protobuf::uint32 value);

  // optional uint32 ObsoleteItem1 = 44;
  bool has_obsoleteitem1() const;
  void clear_obsoleteitem1();
  static const int kObsoleteItem1FieldNumber = 44;
  ::google::protobuf::uint32 obsoleteitem1() const;
  void set_obsoleteitem1(::google::protobuf::uint32 value);

  // optional uint32 NeedSetEmailPwd = 45;
  bool has_needsetemailpwd() const;
  void clear_needsetemailpwd();
  static const int kNeedSetEmailPwdFieldNumber = 45;
  ::google::protobuf::uint32 needsetemailpwd() const;
  void set_needsetemailpwd(::google::protobuf::uint32 value);

  // optional uint32 NextAuthType = 49;
  bool has_nextauthtype() const;
  void clear_nextauthtype();
  static const int kNextAuthTypeFieldNumber = 49;
  ::google::protobuf::uint32 nextauthtype() const;
  void set_nextauthtype(::google::protobuf::uint32 value);

  // optional uint32 Flag = 54;
  bool has_flag() const;
  void clear_flag();
  static const int kFlagFieldNumber = 54;
  ::google::protobuf::uint32 flag() const;
  void set_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.NewAuthResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_uin();
  void clear_has_uin();
  void set_has_username();
  void clear_has_username();
  void set_has_nickname();
  void clear_has_nickname();
  void set_has_binduin();
  void clear_has_binduin();
  void set_has_bindemail();
  void clear_has_bindemail();
  void set_has_bindmobile();
  void clear_has_bindmobile();
  void set_has_status();
  void clear_has_status();
  void set_has_sessionkey();
  void clear_has_sessionkey();
  void set_has_imgsid();
  void clear_has_imgsid();
  void set_has_imgbuf();
  void clear_has_imgbuf();
  void set_has_officialusername();
  void clear_has_officialusername();
  void set_has_officialnickname();
  void clear_has_officialnickname();
  void set_has_qqmicroblogusername();
  void clear_has_qqmicroblogusername();
  void set_has_qqmicroblogstatus();
  void clear_has_qqmicroblogstatus();
  void set_has_newversion();
  void clear_has_newversion();
  void set_has_ticket();
  void clear_has_ticket();
  void set_has_pushmailstatus();
  void clear_has_pushmailstatus();
  void set_has_sendcardbitflag();
  void clear_has_sendcardbitflag();
  void set_has_pushmailsettingticket();
  void clear_has_pushmailsettingticket();
  void set_has_builtiniplist();
  void clear_has_builtiniplist();
  void set_has_fsurl();
  void clear_has_fsurl();
  void set_has_networkcontrol();
  void clear_has_networkcontrol();
  void set_has_pluginflag();
  void clear_has_pluginflag();
  void set_has_alias();
  void clear_has_alias();
  void set_has_regtype();
  void clear_has_regtype();
  void set_has_authkey();
  void clear_has_authkey();
  void set_has_sid();
  void clear_has_sid();
  void set_has_pluginkeylist();
  void clear_has_pluginkeylist();
  void set_has_imgencryptkey();
  void clear_has_imgencryptkey();
  void set_has_a2key();
  void clear_has_a2key();
  void set_has_ksid();
  void clear_has_ksid();
  void set_has_profileflag();
  void clear_has_profileflag();
  void set_has_password();
  void clear_has_password();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_isautoreg();
  void clear_has_isautoreg();
  void set_has_kickresponse();
  void clear_has_kickresponse();
  void set_has_applybetaurl();
  void clear_has_applybetaurl();
  void set_has_deviceinfoxml();
  void clear_has_deviceinfoxml();
  void set_has_softconfigxml();
  void clear_has_softconfigxml();
  void set_has_newhostlist();
  void clear_has_newhostlist();
  void set_has_authticket();
  void clear_has_authticket();
  void set_has_safedevice();
  void clear_has_safedevice();
  void set_has_obsoleteitem1();
  void clear_has_obsoleteitem1();
  void set_has_needsetemailpwd();
  void clear_has_needsetemailpwd();
  void set_has_hintmsg();
  void clear_has_hintmsg();
  void set_has_autoauthticket();
  void clear_has_autoauthticket();
  void set_has_dnsinfo();
  void clear_has_dnsinfo();
  void set_has_nextauthtype();
  void clear_has_nextauthtype();
  void set_has_wtloginrspbuff();
  void clear_has_wtloginrspbuff();
  void set_has_showstyle();
  void clear_has_showstyle();
  void set_has_clidbencryptkey();
  void clear_has_clidbencryptkey();
  void set_has_clidbencryptinfo();
  void clear_has_clidbencryptinfo();
  void set_has_flag();
  void clear_has_flag();
  void set_has_snsdnsinfo();
  void clear_has_snsdnsinfo();
  void set_has_appdnsinfo();
  void clear_has_appdnsinfo();
  void set_has_verifysignature();
  void clear_has_verifysignature();
  void set_has_verifybuff();
  void clear_has_verifybuff();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::internal::ArenaStringPtr sessionkey_;
  ::google::protobuf::internal::ArenaStringPtr ticket_;
  ::google::protobuf::internal::ArenaStringPtr pushmailsettingticket_;
  ::google::protobuf::internal::ArenaStringPtr fsurl_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  ::google::protobuf::internal::ArenaStringPtr authkey_;
  ::google::protobuf::internal::ArenaStringPtr sid_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr kickresponse_;
  ::google::protobuf::internal::ArenaStringPtr applybetaurl_;
  ::google::protobuf::internal::ArenaStringPtr deviceinfoxml_;
  ::google::protobuf::internal::ArenaStringPtr softconfigxml_;
  ::google::protobuf::internal::ArenaStringPtr authticket_;
  ::google::protobuf::internal::ArenaStringPtr hintmsg_;
  ::google::protobuf::internal::ArenaStringPtr autoauthticket_;
  ::google::protobuf::internal::ArenaStringPtr verifysignature_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinString_t* username_;
  ::micromsg::SKBuiltinString_t* nickname_;
  ::micromsg::SKBuiltinString_t* bindemail_;
  ::micromsg::SKBuiltinString_t* bindmobile_;
  ::micromsg::SKBuiltinString_t* imgsid_;
  ::micromsg::SKBuiltinBuffer_t* imgbuf_;
  ::micromsg::SKBuiltinString_t* officialusername_;
  ::micromsg::SKBuiltinString_t* officialnickname_;
  ::micromsg::SKBuiltinString_t* qqmicroblogusername_;
  ::micromsg::BuiltinIPList* builtiniplist_;
  ::micromsg::NetworkControl* networkcontrol_;
  ::micromsg::PluginKeyList* pluginkeylist_;
  ::micromsg::SKBuiltinString_t* imgencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* a2key_;
  ::micromsg::SKBuiltinBuffer_t* ksid_;
  ::micromsg::HostList* newhostlist_;
  ::micromsg::CDNDnsInfo* dnsinfo_;
  ::micromsg::SKBuiltinBuffer_t* wtloginrspbuff_;
  ::micromsg::ShowStyleKey* showstyle_;
  ::micromsg::SKBuiltinBuffer_t* clidbencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* clidbencryptinfo_;
  ::micromsg::CDNDnsInfo* snsdnsinfo_;
  ::micromsg::CDNDnsInfo* appdnsinfo_;
  ::micromsg::SKBuiltinBuffer_t* verifybuff_;
  ::google::protobuf::uint32 uin_;
  ::google::protobuf::uint32 binduin_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 qqmicroblogstatus_;
  ::google::protobuf::uint32 newversion_;
  ::google::protobuf::uint32 pushmailstatus_;
  ::google::protobuf::uint32 sendcardbitflag_;
  ::google::protobuf::uint32 pluginflag_;
  ::google::protobuf::uint32 regtype_;
  ::google::protobuf::uint32 profileflag_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 isautoreg_;
  ::google::protobuf::uint32 safedevice_;
  ::google::protobuf::uint32 obsoleteitem1_;
  ::google::protobuf::uint32 needsetemailpwd_;
  ::google::protobuf::uint32 nextauthtype_;
  ::google::protobuf::uint32 flag_;
  mutable int _cached_size_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindGoogleContactRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindGoogleContactRequest) */ {
 public:
  BindGoogleContactRequest();
  virtual ~BindGoogleContactRequest();

  BindGoogleContactRequest(const BindGoogleContactRequest& from);

  inline BindGoogleContactRequest& operator=(const BindGoogleContactRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindGoogleContactRequest& default_instance();

  static inline const BindGoogleContactRequest* internal_default_instance() {
    return reinterpret_cast<const BindGoogleContactRequest*>(
               &_BindGoogleContactRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    71;

  void Swap(BindGoogleContactRequest* other);

  // implements Message ----------------------------------------------

  inline BindGoogleContactRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BindGoogleContactRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindGoogleContactRequest& from);
  void MergeFrom(const BindGoogleContactRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindGoogleContactRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string GoogleContactName = 3;
  bool has_googlecontactname() const;
  void clear_googlecontactname();
  static const int kGoogleContactNameFieldNumber = 3;
  const ::std::string& googlecontactname() const;
  void set_googlecontactname(const ::std::string& value);
  #if LANG_CXX11
  void set_googlecontactname(::std::string&& value);
  #endif
  void set_googlecontactname(const char* value);
  void set_googlecontactname(const char* value, size_t size);
  ::std::string* mutable_googlecontactname();
  ::std::string* release_googlecontactname();
  void set_allocated_googlecontactname(::std::string* googlecontactname);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 Opcode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // required uint32 Force = 4;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 4;
  ::google::protobuf::uint32 force() const;
  void set_force(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BindGoogleContactRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_googlecontactname();
  void clear_has_googlecontactname();
  void set_has_force();
  void clear_has_force();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr googlecontactname_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint32 force_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindGoogleContactResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindGoogleContactResponse) */ {
 public:
  BindGoogleContactResponse();
  virtual ~BindGoogleContactResponse();

  BindGoogleContactResponse(const BindGoogleContactResponse& from);

  inline BindGoogleContactResponse& operator=(const BindGoogleContactResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindGoogleContactResponse& default_instance();

  static inline const BindGoogleContactResponse* internal_default_instance() {
    return reinterpret_cast<const BindGoogleContactResponse*>(
               &_BindGoogleContactResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    72;

  void Swap(BindGoogleContactResponse* other);

  // implements Message ----------------------------------------------

  inline BindGoogleContactResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BindGoogleContactResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindGoogleContactResponse& from);
  void MergeFrom(const BindGoogleContactResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindGoogleContactResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.BindGoogleContactResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindLinkedinContactRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindLinkedinContactRequest) */ {
 public:
  BindLinkedinContactRequest();
  virtual ~BindLinkedinContactRequest();

  BindLinkedinContactRequest(const BindLinkedinContactRequest& from);

  inline BindLinkedinContactRequest& operator=(const BindLinkedinContactRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindLinkedinContactRequest& default_instance();

  static inline const BindLinkedinContactRequest* internal_default_instance() {
    return reinterpret_cast<const BindLinkedinContactRequest*>(
               &_BindLinkedinContactRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    73;

  void Swap(BindLinkedinContactRequest* other);

  // implements Message ----------------------------------------------

  inline BindLinkedinContactRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BindLinkedinContactRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindLinkedinContactRequest& from);
  void MergeFrom(const BindLinkedinContactRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindLinkedinContactRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string LinkedinMemberID = 4;
  bool has_linkedinmemberid() const;
  void clear_linkedinmemberid();
  static const int kLinkedinMemberIDFieldNumber = 4;
  const ::std::string& linkedinmemberid() const;
  void set_linkedinmemberid(const ::std::string& value);
  #if LANG_CXX11
  void set_linkedinmemberid(::std::string&& value);
  #endif
  void set_linkedinmemberid(const char* value);
  void set_linkedinmemberid(const char* value, size_t size);
  ::std::string* mutable_linkedinmemberid();
  ::std::string* release_linkedinmemberid();
  void set_allocated_linkedinmemberid(::std::string* linkedinmemberid);

  // optional string LinkedinName = 5;
  bool has_linkedinname() const;
  void clear_linkedinname();
  static const int kLinkedinNameFieldNumber = 5;
  const ::std::string& linkedinname() const;
  void set_linkedinname(const ::std::string& value);
  #if LANG_CXX11
  void set_linkedinname(::std::string&& value);
  #endif
  void set_linkedinname(const char* value);
  void set_linkedinname(const char* value, size_t size);
  ::std::string* mutable_linkedinname();
  ::std::string* release_linkedinname();
  void set_allocated_linkedinname(::std::string* linkedinname);

  // optional string LinkedinPublicUrl = 6;
  bool has_linkedinpublicurl() const;
  void clear_linkedinpublicurl();
  static const int kLinkedinPublicUrlFieldNumber = 6;
  const ::std::string& linkedinpublicurl() const;
  void set_linkedinpublicurl(const ::std::string& value);
  #if LANG_CXX11
  void set_linkedinpublicurl(::std::string&& value);
  #endif
  void set_linkedinpublicurl(const char* value);
  void set_linkedinpublicurl(const char* value, size_t size);
  ::std::string* mutable_linkedinpublicurl();
  ::std::string* release_linkedinpublicurl();
  void set_allocated_linkedinpublicurl(::std::string* linkedinpublicurl);

  // optional string Timestamp = 7;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  const ::std::string& timestamp() const;
  void set_timestamp(const ::std::string& value);
  #if LANG_CXX11
  void set_timestamp(::std::string&& value);
  #endif
  void set_timestamp(const char* value);
  void set_timestamp(const char* value, size_t size);
  ::std::string* mutable_timestamp();
  ::std::string* release_timestamp();
  void set_allocated_timestamp(::std::string* timestamp);

  // optional string Nounce = 8;
  bool has_nounce() const;
  void clear_nounce();
  static const int kNounceFieldNumber = 8;
  const ::std::string& nounce() const;
  void set_nounce(const ::std::string& value);
  #if LANG_CXX11
  void set_nounce(::std::string&& value);
  #endif
  void set_nounce(const char* value);
  void set_nounce(const char* value, size_t size);
  ::std::string* mutable_nounce();
  ::std::string* release_nounce();
  void set_allocated_nounce(::std::string* nounce);

  // optional string LinkedinSignature = 9;
  bool has_linkedinsignature() const;
  void clear_linkedinsignature();
  static const int kLinkedinSignatureFieldNumber = 9;
  const ::std::string& linkedinsignature() const;
  void set_linkedinsignature(const ::std::string& value);
  #if LANG_CXX11
  void set_linkedinsignature(::std::string&& value);
  #endif
  void set_linkedinsignature(const char* value);
  void set_linkedinsignature(const char* value, size_t size);
  ::std::string* mutable_linkedinsignature();
  ::std::string* release_linkedinsignature();
  void set_allocated_linkedinsignature(::std::string* linkedinsignature);

  // optional string LinkedinReturnSignature = 10;
  bool has_linkedinreturnsignature() const;
  void clear_linkedinreturnsignature();
  static const int kLinkedinReturnSignatureFieldNumber = 10;
  const ::std::string& linkedinreturnsignature() const;
  void set_linkedinreturnsignature(const ::std::string& value);
  #if LANG_CXX11
  void set_linkedinreturnsignature(::std::string&& value);
  #endif
  void set_linkedinreturnsignature(const char* value);
  void set_linkedinreturnsignature(const char* value, size_t size);
  ::std::string* mutable_linkedinreturnsignature();
  ::std::string* release_linkedinreturnsignature();
  void set_allocated_linkedinreturnsignature(::std::string* linkedinreturnsignature);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 Opcode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // required uint32 Visible = 3;
  bool has_visible() const;
  void clear_visible();
  static const int kVisibleFieldNumber = 3;
  ::google::protobuf::uint32 visible() const;
  void set_visible(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BindLinkedinContactRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_visible();
  void clear_has_visible();
  void set_has_linkedinmemberid();
  void clear_has_linkedinmemberid();
  void set_has_linkedinname();
  void clear_has_linkedinname();
  void set_has_linkedinpublicurl();
  void clear_has_linkedinpublicurl();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_nounce();
  void clear_has_nounce();
  void set_has_linkedinsignature();
  void clear_has_linkedinsignature();
  void set_has_linkedinreturnsignature();
  void clear_has_linkedinreturnsignature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr linkedinmemberid_;
  ::google::protobuf::internal::ArenaStringPtr linkedinname_;
  ::google::protobuf::internal::ArenaStringPtr linkedinpublicurl_;
  ::google::protobuf::internal::ArenaStringPtr timestamp_;
  ::google::protobuf::internal::ArenaStringPtr nounce_;
  ::google::protobuf::internal::ArenaStringPtr linkedinsignature_;
  ::google::protobuf::internal::ArenaStringPtr linkedinreturnsignature_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint32 visible_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindLinkedinContactResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindLinkedinContactResponse) */ {
 public:
  BindLinkedinContactResponse();
  virtual ~BindLinkedinContactResponse();

  BindLinkedinContactResponse(const BindLinkedinContactResponse& from);

  inline BindLinkedinContactResponse& operator=(const BindLinkedinContactResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindLinkedinContactResponse& default_instance();

  static inline const BindLinkedinContactResponse* internal_default_instance() {
    return reinterpret_cast<const BindLinkedinContactResponse*>(
               &_BindLinkedinContactResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    74;

  void Swap(BindLinkedinContactResponse* other);

  // implements Message ----------------------------------------------

  inline BindLinkedinContactResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BindLinkedinContactResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindLinkedinContactResponse& from);
  void MergeFrom(const BindLinkedinContactResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindLinkedinContactResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.BindLinkedinContactResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnBindLinkedinContactRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UnBindLinkedinContactRequest) */ {
 public:
  UnBindLinkedinContactRequest();
  virtual ~UnBindLinkedinContactRequest();

  UnBindLinkedinContactRequest(const UnBindLinkedinContactRequest& from);

  inline UnBindLinkedinContactRequest& operator=(const UnBindLinkedinContactRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnBindLinkedinContactRequest& default_instance();

  static inline const UnBindLinkedinContactRequest* internal_default_instance() {
    return reinterpret_cast<const UnBindLinkedinContactRequest*>(
               &_UnBindLinkedinContactRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    75;

  void Swap(UnBindLinkedinContactRequest* other);

  // implements Message ----------------------------------------------

  inline UnBindLinkedinContactRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UnBindLinkedinContactRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnBindLinkedinContactRequest& from);
  void MergeFrom(const UnBindLinkedinContactRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnBindLinkedinContactRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 Opcode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.UnBindLinkedinContactRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_opcode();
  void clear_has_opcode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnBindLinkedinContactResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UnBindLinkedinContactResponse) */ {
 public:
  UnBindLinkedinContactResponse();
  virtual ~UnBindLinkedinContactResponse();

  UnBindLinkedinContactResponse(const UnBindLinkedinContactResponse& from);

  inline UnBindLinkedinContactResponse& operator=(const UnBindLinkedinContactResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnBindLinkedinContactResponse& default_instance();

  static inline const UnBindLinkedinContactResponse* internal_default_instance() {
    return reinterpret_cast<const UnBindLinkedinContactResponse*>(
               &_UnBindLinkedinContactResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    76;

  void Swap(UnBindLinkedinContactResponse* other);

  // implements Message ----------------------------------------------

  inline UnBindLinkedinContactResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UnBindLinkedinContactResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnBindLinkedinContactResponse& from);
  void MergeFrom(const UnBindLinkedinContactResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnBindLinkedinContactResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.UnBindLinkedinContactResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginQRCodeNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.LoginQRCodeNotify) */ {
 public:
  LoginQRCodeNotify();
  virtual ~LoginQRCodeNotify();

  LoginQRCodeNotify(const LoginQRCodeNotify& from);

  inline LoginQRCodeNotify& operator=(const LoginQRCodeNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginQRCodeNotify& default_instance();

  static inline const LoginQRCodeNotify* internal_default_instance() {
    return reinterpret_cast<const LoginQRCodeNotify*>(
               &_LoginQRCodeNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    77;

  void Swap(LoginQRCodeNotify* other);

  // implements Message ----------------------------------------------

  inline LoginQRCodeNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginQRCodeNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginQRCodeNotify& from);
  void MergeFrom(const LoginQRCodeNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginQRCodeNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UUID = 1;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUUIDFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional string UserName = 3;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string Pwd = 4;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 4;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // optional string HeadImgURL = 5;
  bool has_headimgurl() const;
  void clear_headimgurl();
  static const int kHeadImgURLFieldNumber = 5;
  const ::std::string& headimgurl() const;
  void set_headimgurl(const ::std::string& value);
  #if LANG_CXX11
  void set_headimgurl(::std::string&& value);
  #endif
  void set_headimgurl(const char* value);
  void set_headimgurl(const char* value, size_t size);
  ::std::string* mutable_headimgurl();
  ::std::string* release_headimgurl();
  void set_allocated_headimgurl(::std::string* headimgurl);

  // optional string NickName = 7;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNickNameFieldNumber = 7;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional string PairWaitTip = 9;
  bool has_pairwaittip() const;
  void clear_pairwaittip();
  static const int kPairWaitTipFieldNumber = 9;
  const ::std::string& pairwaittip() const;
  void set_pairwaittip(const ::std::string& value);
  #if LANG_CXX11
  void set_pairwaittip(::std::string&& value);
  #endif
  void set_pairwaittip(const char* value);
  void set_pairwaittip(const char* value, size_t size);
  ::std::string* mutable_pairwaittip();
  ::std::string* release_pairwaittip();
  void set_allocated_pairwaittip(::std::string* pairwaittip);

  // optional string AuthorDeviceType = 11;
  bool has_authordevicetype() const;
  void clear_authordevicetype();
  static const int kAuthorDeviceTypeFieldNumber = 11;
  const ::std::string& authordevicetype() const;
  void set_authordevicetype(const ::std::string& value);
  #if LANG_CXX11
  void set_authordevicetype(::std::string&& value);
  #endif
  void set_authordevicetype(const char* value);
  void set_authordevicetype(const char* value, size_t size);
  ::std::string* mutable_authordevicetype();
  ::std::string* release_authordevicetype();
  void set_allocated_authordevicetype(::std::string* authordevicetype);

  // required uint32 Status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // optional uint32 PushLoginURLExpiredTime = 6;
  bool has_pushloginurlexpiredtime() const;
  void clear_pushloginurlexpiredtime();
  static const int kPushLoginURLExpiredTimeFieldNumber = 6;
  ::google::protobuf::uint32 pushloginurlexpiredtime() const;
  void set_pushloginurlexpiredtime(::google::protobuf::uint32 value);

  // optional uint32 ExpiredTime = 8;
  bool has_expiredtime() const;
  void clear_expiredtime();
  static const int kExpiredTimeFieldNumber = 8;
  ::google::protobuf::uint32 expiredtime() const;
  void set_expiredtime(::google::protobuf::uint32 value);

  // optional uint32 AuthorClientVersion = 10;
  bool has_authorclientversion() const;
  void clear_authorclientversion();
  static const int kAuthorClientVersionFieldNumber = 10;
  ::google::protobuf::uint32 authorclientversion() const;
  void set_authorclientversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.LoginQRCodeNotify)
 private:
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_status();
  void clear_has_status();
  void set_has_username();
  void clear_has_username();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_headimgurl();
  void clear_has_headimgurl();
  void set_has_pushloginurlexpiredtime();
  void clear_has_pushloginurlexpiredtime();
  void set_has_nickname();
  void clear_has_nickname();
  void set_has_expiredtime();
  void clear_has_expiredtime();
  void set_has_pairwaittip();
  void clear_has_pairwaittip();
  void set_has_authorclientversion();
  void clear_has_authorclientversion();
  void set_has_authordevicetype();
  void clear_has_authordevicetype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr headimgurl_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr pairwaittip_;
  ::google::protobuf::internal::ArenaStringPtr authordevicetype_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 pushloginurlexpiredtime_;
  ::google::protobuf::uint32 expiredtime_;
  ::google::protobuf::uint32 authorclientversion_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LoginQRCodeNotifyPkg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.LoginQRCodeNotifyPkg) */ {
 public:
  LoginQRCodeNotifyPkg();
  virtual ~LoginQRCodeNotifyPkg();

  LoginQRCodeNotifyPkg(const LoginQRCodeNotifyPkg& from);

  inline LoginQRCodeNotifyPkg& operator=(const LoginQRCodeNotifyPkg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginQRCodeNotifyPkg& default_instance();

  static inline const LoginQRCodeNotifyPkg* internal_default_instance() {
    return reinterpret_cast<const LoginQRCodeNotifyPkg*>(
               &_LoginQRCodeNotifyPkg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    78;

  void Swap(LoginQRCodeNotifyPkg* other);

  // implements Message ----------------------------------------------

  inline LoginQRCodeNotifyPkg* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginQRCodeNotifyPkg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginQRCodeNotifyPkg& from);
  void MergeFrom(const LoginQRCodeNotifyPkg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginQRCodeNotifyPkg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.SKBuiltinBuffer_t NotifyData = 1;
  bool has_notifydata() const;
  void clear_notifydata();
  static const int kNotifyDataFieldNumber = 1;
  const ::micromsg::SKBuiltinBuffer_t& notifydata() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_notifydata();
  ::micromsg::SKBuiltinBuffer_t* release_notifydata();
  void set_allocated_notifydata(::micromsg::SKBuiltinBuffer_t* notifydata);

  // required uint32 OPCode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOPCodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.LoginQRCodeNotifyPkg)
 private:
  void set_has_notifydata();
  void clear_has_notifydata();
  void set_has_opcode();
  void clear_has_opcode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* notifydata_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLoginQRCodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetLoginQRCodeRequest) */ {
 public:
  GetLoginQRCodeRequest();
  virtual ~GetLoginQRCodeRequest();

  GetLoginQRCodeRequest(const GetLoginQRCodeRequest& from);

  inline GetLoginQRCodeRequest& operator=(const GetLoginQRCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLoginQRCodeRequest& default_instance();

  static inline const GetLoginQRCodeRequest* internal_default_instance() {
    return reinterpret_cast<const GetLoginQRCodeRequest*>(
               &_GetLoginQRCodeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    79;

  void Swap(GetLoginQRCodeRequest* other);

  // implements Message ----------------------------------------------

  inline GetLoginQRCodeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLoginQRCodeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLoginQRCodeRequest& from);
  void MergeFrom(const GetLoginQRCodeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLoginQRCodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string DeviceName = 4;
  bool has_devicename() const;
  void clear_devicename();
  static const int kDeviceNameFieldNumber = 4;
  const ::std::string& devicename() const;
  void set_devicename(const ::std::string& value);
  #if LANG_CXX11
  void set_devicename(::std::string&& value);
  #endif
  void set_devicename(const char* value);
  void set_devicename(const char* value, size_t size);
  ::std::string* mutable_devicename();
  ::std::string* release_devicename();
  void set_allocated_devicename(::std::string* devicename);

  // optional string UserName = 5;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 5;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // optional uint32 OPCode = 3;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOPCodeFieldNumber = 3;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // optional uint32 ExtDevLoginType = 6;
  bool has_extdevlogintype() const;
  void clear_extdevlogintype();
  static const int kExtDevLoginTypeFieldNumber = 6;
  ::google::protobuf::uint32 extdevlogintype() const;
  void set_extdevlogintype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetLoginQRCodeRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_devicename();
  void clear_has_devicename();
  void set_has_username();
  void clear_has_username();
  void set_has_extdevlogintype();
  void clear_has_extdevlogintype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr devicename_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint32 extdevlogintype_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLoginQRCodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetLoginQRCodeResponse) */ {
 public:
  GetLoginQRCodeResponse();
  virtual ~GetLoginQRCodeResponse();

  GetLoginQRCodeResponse(const GetLoginQRCodeResponse& from);

  inline GetLoginQRCodeResponse& operator=(const GetLoginQRCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLoginQRCodeResponse& default_instance();

  static inline const GetLoginQRCodeResponse* internal_default_instance() {
    return reinterpret_cast<const GetLoginQRCodeResponse*>(
               &_GetLoginQRCodeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    80;

  void Swap(GetLoginQRCodeResponse* other);

  // implements Message ----------------------------------------------

  inline GetLoginQRCodeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLoginQRCodeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLoginQRCodeResponse& from);
  void MergeFrom(const GetLoginQRCodeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLoginQRCodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UUID = 3;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUUIDFieldNumber = 3;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional string BlueToothBroadCastUUID = 7;
  bool has_bluetoothbroadcastuuid() const;
  void clear_bluetoothbroadcastuuid();
  static const int kBlueToothBroadCastUUIDFieldNumber = 7;
  const ::std::string& bluetoothbroadcastuuid() const;
  void set_bluetoothbroadcastuuid(const ::std::string& value);
  #if LANG_CXX11
  void set_bluetoothbroadcastuuid(::std::string&& value);
  #endif
  void set_bluetoothbroadcastuuid(const char* value);
  void set_bluetoothbroadcastuuid(const char* value, size_t size);
  ::std::string* mutable_bluetoothbroadcastuuid();
  ::std::string* release_bluetoothbroadcastuuid();
  void set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.SKBuiltinBuffer_t QRCode = 2;
  bool has_qrcode() const;
  void clear_qrcode();
  static const int kQRCodeFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& qrcode() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_qrcode();
  ::micromsg::SKBuiltinBuffer_t* release_qrcode();
  void set_allocated_qrcode(::micromsg::SKBuiltinBuffer_t* qrcode);

  // required .micromsg.SKBuiltinBuffer_t NotifyKey = 5;
  bool has_notifykey() const;
  void clear_notifykey();
  static const int kNotifyKeyFieldNumber = 5;
  const ::micromsg::SKBuiltinBuffer_t& notifykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_notifykey();
  ::micromsg::SKBuiltinBuffer_t* release_notifykey();
  void set_allocated_notifykey(::micromsg::SKBuiltinBuffer_t* notifykey);

  // optional .micromsg.SKBuiltinBuffer_t BlueToothBroadCastContent = 8;
  bool has_bluetoothbroadcastcontent() const;
  void clear_bluetoothbroadcastcontent();
  static const int kBlueToothBroadCastContentFieldNumber = 8;
  const ::micromsg::SKBuiltinBuffer_t& bluetoothbroadcastcontent() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_bluetoothbroadcastcontent();
  ::micromsg::SKBuiltinBuffer_t* release_bluetoothbroadcastcontent();
  void set_allocated_bluetoothbroadcastcontent(::micromsg::SKBuiltinBuffer_t* bluetoothbroadcastcontent);

  // required uint32 CheckTime = 4;
  bool has_checktime() const;
  void clear_checktime();
  static const int kCheckTimeFieldNumber = 4;
  ::google::protobuf::uint32 checktime() const;
  void set_checktime(::google::protobuf::uint32 value);

  // optional uint32 ExpiredTime = 6;
  bool has_expiredtime() const;
  void clear_expiredtime();
  static const int kExpiredTimeFieldNumber = 6;
  ::google::protobuf::uint32 expiredtime() const;
  void set_expiredtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetLoginQRCodeResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_qrcode();
  void clear_has_qrcode();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_checktime();
  void clear_has_checktime();
  void set_has_notifykey();
  void clear_has_notifykey();
  void set_has_expiredtime();
  void clear_has_expiredtime();
  void set_has_bluetoothbroadcastuuid();
  void clear_has_bluetoothbroadcastuuid();
  void set_has_bluetoothbroadcastcontent();
  void clear_has_bluetoothbroadcastcontent();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr bluetoothbroadcastuuid_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinBuffer_t* qrcode_;
  ::micromsg::SKBuiltinBuffer_t* notifykey_;
  ::micromsg::SKBuiltinBuffer_t* bluetoothbroadcastcontent_;
  ::google::protobuf::uint32 checktime_;
  ::google::protobuf::uint32 expiredtime_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckLoginQRCodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.CheckLoginQRCodeRequest) */ {
 public:
  CheckLoginQRCodeRequest();
  virtual ~CheckLoginQRCodeRequest();

  CheckLoginQRCodeRequest(const CheckLoginQRCodeRequest& from);

  inline CheckLoginQRCodeRequest& operator=(const CheckLoginQRCodeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckLoginQRCodeRequest& default_instance();

  static inline const CheckLoginQRCodeRequest* internal_default_instance() {
    return reinterpret_cast<const CheckLoginQRCodeRequest*>(
               &_CheckLoginQRCodeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    81;

  void Swap(CheckLoginQRCodeRequest* other);

  // implements Message ----------------------------------------------

  inline CheckLoginQRCodeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckLoginQRCodeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckLoginQRCodeRequest& from);
  void MergeFrom(const CheckLoginQRCodeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckLoginQRCodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UUID = 3;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUUIDFieldNumber = 3;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // required uint32 TimeStamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 4;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 OPCode = 5;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOPCodeFieldNumber = 5;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.CheckLoginQRCodeRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_opcode();
  void clear_has_opcode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CheckLoginQRCodeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.CheckLoginQRCodeResponse) */ {
 public:
  CheckLoginQRCodeResponse();
  virtual ~CheckLoginQRCodeResponse();

  CheckLoginQRCodeResponse(const CheckLoginQRCodeResponse& from);

  inline CheckLoginQRCodeResponse& operator=(const CheckLoginQRCodeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckLoginQRCodeResponse& default_instance();

  static inline const CheckLoginQRCodeResponse* internal_default_instance() {
    return reinterpret_cast<const CheckLoginQRCodeResponse*>(
               &_CheckLoginQRCodeResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    82;

  void Swap(CheckLoginQRCodeResponse* other);

  // implements Message ----------------------------------------------

  inline CheckLoginQRCodeResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  CheckLoginQRCodeResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CheckLoginQRCodeResponse& from);
  void MergeFrom(const CheckLoginQRCodeResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CheckLoginQRCodeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.LoginQRCodeNotifyPkg NotifyPkg = 3;
  bool has_notifypkg() const;
  void clear_notifypkg();
  static const int kNotifyPkgFieldNumber = 3;
  const ::micromsg::LoginQRCodeNotifyPkg& notifypkg() const;
  ::micromsg::LoginQRCodeNotifyPkg* mutable_notifypkg();
  ::micromsg::LoginQRCodeNotifyPkg* release_notifypkg();
  void set_allocated_notifypkg(::micromsg::LoginQRCodeNotifyPkg* notifypkg);

  // @@protoc_insertion_point(class_scope:micromsg.CheckLoginQRCodeResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_notifypkg();
  void clear_has_notifypkg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::LoginQRCodeNotifyPkg* notifypkg_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLoginURLRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetLoginURLRequest) */ {
 public:
  GetLoginURLRequest();
  virtual ~GetLoginURLRequest();

  GetLoginURLRequest(const GetLoginURLRequest& from);

  inline GetLoginURLRequest& operator=(const GetLoginURLRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLoginURLRequest& default_instance();

  static inline const GetLoginURLRequest* internal_default_instance() {
    return reinterpret_cast<const GetLoginURLRequest*>(
               &_GetLoginURLRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    83;

  void Swap(GetLoginURLRequest* other);

  // implements Message ----------------------------------------------

  inline GetLoginURLRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLoginURLRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLoginURLRequest& from);
  void MergeFrom(const GetLoginURLRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLoginURLRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UUID = 2;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUUIDFieldNumber = 2;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional bytes FromDeviceID = 3;
  bool has_fromdeviceid() const;
  void clear_fromdeviceid();
  static const int kFromDeviceIDFieldNumber = 3;
  const ::std::string& fromdeviceid() const;
  void set_fromdeviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_fromdeviceid(::std::string&& value);
  #endif
  void set_fromdeviceid(const char* value);
  void set_fromdeviceid(const void* value, size_t size);
  ::std::string* mutable_fromdeviceid();
  ::std::string* release_fromdeviceid();
  void set_allocated_fromdeviceid(::std::string* fromdeviceid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // @@protoc_insertion_point(class_scope:micromsg.GetLoginURLRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_fromdeviceid();
  void clear_has_fromdeviceid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr fromdeviceid_;
  ::micromsg::BaseRequest* baserequest_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLoginURLResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetLoginURLResponse) */ {
 public:
  GetLoginURLResponse();
  virtual ~GetLoginURLResponse();

  GetLoginURLResponse(const GetLoginURLResponse& from);

  inline GetLoginURLResponse& operator=(const GetLoginURLResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLoginURLResponse& default_instance();

  static inline const GetLoginURLResponse* internal_default_instance() {
    return reinterpret_cast<const GetLoginURLResponse*>(
               &_GetLoginURLResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    84;

  void Swap(GetLoginURLResponse* other);

  // implements Message ----------------------------------------------

  inline GetLoginURLResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLoginURLResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLoginURLResponse& from);
  void MergeFrom(const GetLoginURLResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLoginURLResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string URL = 2;
  bool has_url() const;
  void clear_url();
  static const int kURLFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.GetLoginURLResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_url();
  void clear_has_url();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PushLoginURLRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.PushLoginURLRequest) */ {
 public:
  PushLoginURLRequest();
  virtual ~PushLoginURLRequest();

  PushLoginURLRequest(const PushLoginURLRequest& from);

  inline PushLoginURLRequest& operator=(const PushLoginURLRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushLoginURLRequest& default_instance();

  static inline const PushLoginURLRequest* internal_default_instance() {
    return reinterpret_cast<const PushLoginURLRequest*>(
               &_PushLoginURLRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    85;

  void Swap(PushLoginURLRequest* other);

  // implements Message ----------------------------------------------

  inline PushLoginURLRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  PushLoginURLRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PushLoginURLRequest& from);
  void MergeFrom(const PushLoginURLRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PushLoginURLRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 2;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string AutoAuthTicket = 3;
  bool has_autoauthticket() const;
  void clear_autoauthticket();
  static const int kAutoAuthTicketFieldNumber = 3;
  const ::std::string& autoauthticket() const;
  void set_autoauthticket(const ::std::string& value);
  #if LANG_CXX11
  void set_autoauthticket(::std::string&& value);
  #endif
  void set_autoauthticket(const char* value);
  void set_autoauthticket(const char* value, size_t size);
  ::std::string* mutable_autoauthticket();
  ::std::string* release_autoauthticket();
  void set_allocated_autoauthticket(::std::string* autoauthticket);

  // optional string ClientID = 4;
  bool has_clientid() const;
  void clear_clientid();
  static const int kClientIDFieldNumber = 4;
  const ::std::string& clientid() const;
  void set_clientid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientid(::std::string&& value);
  #endif
  void set_clientid(const char* value);
  void set_clientid(const char* value, size_t size);
  ::std::string* mutable_clientid();
  ::std::string* release_clientid();
  void set_allocated_clientid(::std::string* clientid);

  // optional string DeviceName = 7;
  bool has_devicename() const;
  void clear_devicename();
  static const int kDeviceNameFieldNumber = 7;
  const ::std::string& devicename() const;
  void set_devicename(const ::std::string& value);
  #if LANG_CXX11
  void set_devicename(::std::string&& value);
  #endif
  void set_devicename(const char* value);
  void set_devicename(const char* value, size_t size);
  ::std::string* mutable_devicename();
  ::std::string* release_devicename();
  void set_allocated_devicename(::std::string* devicename);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 5;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 5;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // optional .micromsg.SKBuiltinBuffer_t AutoAuthKey = 8;
  bool has_autoauthkey() const;
  void clear_autoauthkey();
  static const int kAutoAuthKeyFieldNumber = 8;
  const ::micromsg::SKBuiltinBuffer_t& autoauthkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* release_autoauthkey();
  void set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey);

  // required uint32 OPCode = 6;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOPCodeFieldNumber = 6;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.PushLoginURLRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_username();
  void clear_has_username();
  void set_has_autoauthticket();
  void clear_has_autoauthticket();
  void set_has_clientid();
  void clear_has_clientid();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_devicename();
  void clear_has_devicename();
  void set_has_autoauthkey();
  void clear_has_autoauthkey();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr autoauthticket_;
  ::google::protobuf::internal::ArenaStringPtr clientid_;
  ::google::protobuf::internal::ArenaStringPtr devicename_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::micromsg::SKBuiltinBuffer_t* autoauthkey_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PushLoginURLResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.PushLoginURLResponse) */ {
 public:
  PushLoginURLResponse();
  virtual ~PushLoginURLResponse();

  PushLoginURLResponse(const PushLoginURLResponse& from);

  inline PushLoginURLResponse& operator=(const PushLoginURLResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushLoginURLResponse& default_instance();

  static inline const PushLoginURLResponse* internal_default_instance() {
    return reinterpret_cast<const PushLoginURLResponse*>(
               &_PushLoginURLResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    86;

  void Swap(PushLoginURLResponse* other);

  // implements Message ----------------------------------------------

  inline PushLoginURLResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  PushLoginURLResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PushLoginURLResponse& from);
  void MergeFrom(const PushLoginURLResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PushLoginURLResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UUID = 2;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUUIDFieldNumber = 2;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional string BlueToothBroadCastUUID = 6;
  bool has_bluetoothbroadcastuuid() const;
  void clear_bluetoothbroadcastuuid();
  static const int kBlueToothBroadCastUUIDFieldNumber = 6;
  const ::std::string& bluetoothbroadcastuuid() const;
  void set_bluetoothbroadcastuuid(const ::std::string& value);
  #if LANG_CXX11
  void set_bluetoothbroadcastuuid(::std::string&& value);
  #endif
  void set_bluetoothbroadcastuuid(const char* value);
  void set_bluetoothbroadcastuuid(const char* value, size_t size);
  ::std::string* mutable_bluetoothbroadcastuuid();
  ::std::string* release_bluetoothbroadcastuuid();
  void set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.SKBuiltinBuffer_t NotifyKey = 3;
  bool has_notifykey() const;
  void clear_notifykey();
  static const int kNotifyKeyFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& notifykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_notifykey();
  ::micromsg::SKBuiltinBuffer_t* release_notifykey();
  void set_allocated_notifykey(::micromsg::SKBuiltinBuffer_t* notifykey);

  // optional .micromsg.SKBuiltinBuffer_t BlueToothBroadCastContent = 7;
  bool has_bluetoothbroadcastcontent() const;
  void clear_bluetoothbroadcastcontent();
  static const int kBlueToothBroadCastContentFieldNumber = 7;
  const ::micromsg::SKBuiltinBuffer_t& bluetoothbroadcastcontent() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_bluetoothbroadcastcontent();
  ::micromsg::SKBuiltinBuffer_t* release_bluetoothbroadcastcontent();
  void set_allocated_bluetoothbroadcastcontent(::micromsg::SKBuiltinBuffer_t* bluetoothbroadcastcontent);

  // required uint32 CheckTime = 4;
  bool has_checktime() const;
  void clear_checktime();
  static const int kCheckTimeFieldNumber = 4;
  ::google::protobuf::uint32 checktime() const;
  void set_checktime(::google::protobuf::uint32 value);

  // required uint32 ExpiredTime = 5;
  bool has_expiredtime() const;
  void clear_expiredtime();
  static const int kExpiredTimeFieldNumber = 5;
  ::google::protobuf::uint32 expiredtime() const;
  void set_expiredtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.PushLoginURLResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_notifykey();
  void clear_has_notifykey();
  void set_has_checktime();
  void clear_has_checktime();
  void set_has_expiredtime();
  void clear_has_expiredtime();
  void set_has_bluetoothbroadcastuuid();
  void clear_has_bluetoothbroadcastuuid();
  void set_has_bluetoothbroadcastcontent();
  void clear_has_bluetoothbroadcastcontent();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr bluetoothbroadcastuuid_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinBuffer_t* notifykey_;
  ::micromsg::SKBuiltinBuffer_t* bluetoothbroadcastcontent_;
  ::google::protobuf::uint32 checktime_;
  ::google::protobuf::uint32 expiredtime_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlueToothBindLoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlueToothBindLoginRequest) */ {
 public:
  BlueToothBindLoginRequest();
  virtual ~BlueToothBindLoginRequest();

  BlueToothBindLoginRequest(const BlueToothBindLoginRequest& from);

  inline BlueToothBindLoginRequest& operator=(const BlueToothBindLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlueToothBindLoginRequest& default_instance();

  static inline const BlueToothBindLoginRequest* internal_default_instance() {
    return reinterpret_cast<const BlueToothBindLoginRequest*>(
               &_BlueToothBindLoginRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    87;

  void Swap(BlueToothBindLoginRequest* other);

  // implements Message ----------------------------------------------

  inline BlueToothBindLoginRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BlueToothBindLoginRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlueToothBindLoginRequest& from);
  void MergeFrom(const BlueToothBindLoginRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlueToothBindLoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string URL = 2;
  bool has_url() const;
  void clear_url();
  static const int kURLFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 OPCode = 3;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOPCodeFieldNumber = 3;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BlueToothBindLoginRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_url();
  void clear_has_url();
  void set_has_opcode();
  void clear_has_opcode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlueToothBindLoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlueToothBindLoginResponse) */ {
 public:
  BlueToothBindLoginResponse();
  virtual ~BlueToothBindLoginResponse();

  BlueToothBindLoginResponse(const BlueToothBindLoginResponse& from);

  inline BlueToothBindLoginResponse& operator=(const BlueToothBindLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlueToothBindLoginResponse& default_instance();

  static inline const BlueToothBindLoginResponse* internal_default_instance() {
    return reinterpret_cast<const BlueToothBindLoginResponse*>(
               &_BlueToothBindLoginResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    88;

  void Swap(BlueToothBindLoginResponse* other);

  // implements Message ----------------------------------------------

  inline BlueToothBindLoginResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BlueToothBindLoginResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlueToothBindLoginResponse& from);
  void MergeFrom(const BlueToothBindLoginResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlueToothBindLoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string DeviceName = 2;
  bool has_devicename() const;
  void clear_devicename();
  static const int kDeviceNameFieldNumber = 2;
  const ::std::string& devicename() const;
  void set_devicename(const ::std::string& value);
  #if LANG_CXX11
  void set_devicename(::std::string&& value);
  #endif
  void set_devicename(const char* value);
  void set_devicename(const char* value, size_t size);
  ::std::string* mutable_devicename();
  ::std::string* release_devicename();
  void set_allocated_devicename(::std::string* devicename);

  // optional string UUID = 4;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUUIDFieldNumber = 4;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional string BlueToothBroadCastUUID = 5;
  bool has_bluetoothbroadcastuuid() const;
  void clear_bluetoothbroadcastuuid();
  static const int kBlueToothBroadCastUUIDFieldNumber = 5;
  const ::std::string& bluetoothbroadcastuuid() const;
  void set_bluetoothbroadcastuuid(const ::std::string& value);
  #if LANG_CXX11
  void set_bluetoothbroadcastuuid(::std::string&& value);
  #endif
  void set_bluetoothbroadcastuuid(const char* value);
  void set_bluetoothbroadcastuuid(const char* value, size_t size);
  ::std::string* mutable_bluetoothbroadcastuuid();
  ::std::string* release_bluetoothbroadcastuuid();
  void set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required uint32 ExpiredTime = 3;
  bool has_expiredtime() const;
  void clear_expiredtime();
  static const int kExpiredTimeFieldNumber = 3;
  ::google::protobuf::uint32 expiredtime() const;
  void set_expiredtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BlueToothBindLoginResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_devicename();
  void clear_has_devicename();
  void set_has_expiredtime();
  void clear_has_expiredtime();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_bluetoothbroadcastuuid();
  void clear_has_bluetoothbroadcastuuid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr devicename_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr bluetoothbroadcastuuid_;
  ::micromsg::BaseResponse* baseresponse_;
  ::google::protobuf::uint32 expiredtime_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlueToothAutoLoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlueToothAutoLoginRequest) */ {
 public:
  BlueToothAutoLoginRequest();
  virtual ~BlueToothAutoLoginRequest();

  BlueToothAutoLoginRequest(const BlueToothAutoLoginRequest& from);

  inline BlueToothAutoLoginRequest& operator=(const BlueToothAutoLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlueToothAutoLoginRequest& default_instance();

  static inline const BlueToothAutoLoginRequest* internal_default_instance() {
    return reinterpret_cast<const BlueToothAutoLoginRequest*>(
               &_BlueToothAutoLoginRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    89;

  void Swap(BlueToothAutoLoginRequest* other);

  // implements Message ----------------------------------------------

  inline BlueToothAutoLoginRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BlueToothAutoLoginRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlueToothAutoLoginRequest& from);
  void MergeFrom(const BlueToothAutoLoginRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlueToothAutoLoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 2;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string UUID = 3;
  bool has_uuid() const;
  void clear_uuid();
  static const int kUUIDFieldNumber = 3;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // optional string AutoAuthTicket = 4;
  bool has_autoauthticket() const;
  void clear_autoauthticket();
  static const int kAutoAuthTicketFieldNumber = 4;
  const ::std::string& autoauthticket() const;
  void set_autoauthticket(const ::std::string& value);
  #if LANG_CXX11
  void set_autoauthticket(::std::string&& value);
  #endif
  void set_autoauthticket(const char* value);
  void set_autoauthticket(const char* value, size_t size);
  ::std::string* mutable_autoauthticket();
  ::std::string* release_autoauthticket();
  void set_allocated_autoauthticket(::std::string* autoauthticket);

  // optional string BlueToothBroadCastUUID = 7;
  bool has_bluetoothbroadcastuuid() const;
  void clear_bluetoothbroadcastuuid();
  static const int kBlueToothBroadCastUUIDFieldNumber = 7;
  const ::std::string& bluetoothbroadcastuuid() const;
  void set_bluetoothbroadcastuuid(const ::std::string& value);
  #if LANG_CXX11
  void set_bluetoothbroadcastuuid(::std::string&& value);
  #endif
  void set_bluetoothbroadcastuuid(const char* value);
  void set_bluetoothbroadcastuuid(const char* value, size_t size);
  ::std::string* mutable_bluetoothbroadcastuuid();
  ::std::string* release_bluetoothbroadcastuuid();
  void set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t LoginInfoData = 5;
  bool has_logininfodata() const;
  void clear_logininfodata();
  static const int kLoginInfoDataFieldNumber = 5;
  const ::micromsg::SKBuiltinBuffer_t& logininfodata() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_logininfodata();
  ::micromsg::SKBuiltinBuffer_t* release_logininfodata();
  void set_allocated_logininfodata(::micromsg::SKBuiltinBuffer_t* logininfodata);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 6;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 6;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // @@protoc_insertion_point(class_scope:micromsg.BlueToothAutoLoginRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_username();
  void clear_has_username();
  void set_has_uuid();
  void clear_has_uuid();
  void set_has_autoauthticket();
  void clear_has_autoauthticket();
  void set_has_logininfodata();
  void clear_has_logininfodata();
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_bluetoothbroadcastuuid();
  void clear_has_bluetoothbroadcastuuid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr autoauthticket_;
  ::google::protobuf::internal::ArenaStringPtr bluetoothbroadcastuuid_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* logininfodata_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlueToothAutoLoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlueToothAutoLoginResponse) */ {
 public:
  BlueToothAutoLoginResponse();
  virtual ~BlueToothAutoLoginResponse();

  BlueToothAutoLoginResponse(const BlueToothAutoLoginResponse& from);

  inline BlueToothAutoLoginResponse& operator=(const BlueToothAutoLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlueToothAutoLoginResponse& default_instance();

  static inline const BlueToothAutoLoginResponse* internal_default_instance() {
    return reinterpret_cast<const BlueToothAutoLoginResponse*>(
               &_BlueToothAutoLoginResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    90;

  void Swap(BlueToothAutoLoginResponse* other);

  // implements Message ----------------------------------------------

  inline BlueToothAutoLoginResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BlueToothAutoLoginResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlueToothAutoLoginResponse& from);
  void MergeFrom(const BlueToothAutoLoginResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlueToothAutoLoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 2;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string Password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.BlueToothAutoLoginResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_username();
  void clear_has_username();
  void set_has_password();
  void clear_has_password();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlueToothAutoLoginInfoPkg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlueToothAutoLoginInfoPkg) */ {
 public:
  BlueToothAutoLoginInfoPkg();
  virtual ~BlueToothAutoLoginInfoPkg();

  BlueToothAutoLoginInfoPkg(const BlueToothAutoLoginInfoPkg& from);

  inline BlueToothAutoLoginInfoPkg& operator=(const BlueToothAutoLoginInfoPkg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlueToothAutoLoginInfoPkg& default_instance();

  static inline const BlueToothAutoLoginInfoPkg* internal_default_instance() {
    return reinterpret_cast<const BlueToothAutoLoginInfoPkg*>(
               &_BlueToothAutoLoginInfoPkg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    91;

  void Swap(BlueToothAutoLoginInfoPkg* other);

  // implements Message ----------------------------------------------

  inline BlueToothAutoLoginInfoPkg* New() const PROTOBUF_FINAL { return New(NULL); }

  BlueToothAutoLoginInfoPkg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlueToothAutoLoginInfoPkg& from);
  void MergeFrom(const BlueToothAutoLoginInfoPkg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlueToothAutoLoginInfoPkg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.SKBuiltinBuffer_t Salt = 1;
  bool has_salt() const;
  void clear_salt();
  static const int kSaltFieldNumber = 1;
  const ::micromsg::SKBuiltinBuffer_t& salt() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_salt();
  ::micromsg::SKBuiltinBuffer_t* release_salt();
  void set_allocated_salt(::micromsg::SKBuiltinBuffer_t* salt);

  // required .micromsg.SKBuiltinBuffer_t Data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& data() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_data();
  ::micromsg::SKBuiltinBuffer_t* release_data();
  void set_allocated_data(::micromsg::SKBuiltinBuffer_t* data);

  // @@protoc_insertion_point(class_scope:micromsg.BlueToothAutoLoginInfoPkg)
 private:
  void set_has_salt();
  void clear_has_salt();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* salt_;
  ::micromsg::SKBuiltinBuffer_t* data_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlueToothAutoLoginInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BlueToothAutoLoginInfo) */ {
 public:
  BlueToothAutoLoginInfo();
  virtual ~BlueToothAutoLoginInfo();

  BlueToothAutoLoginInfo(const BlueToothAutoLoginInfo& from);

  inline BlueToothAutoLoginInfo& operator=(const BlueToothAutoLoginInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlueToothAutoLoginInfo& default_instance();

  static inline const BlueToothAutoLoginInfo* internal_default_instance() {
    return reinterpret_cast<const BlueToothAutoLoginInfo*>(
               &_BlueToothAutoLoginInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    92;

  void Swap(BlueToothAutoLoginInfo* other);

  // implements Message ----------------------------------------------

  inline BlueToothAutoLoginInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BlueToothAutoLoginInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlueToothAutoLoginInfo& from);
  void MergeFrom(const BlueToothAutoLoginInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlueToothAutoLoginInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string DeviceType = 2;
  bool has_devicetype() const;
  void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 2;
  const ::std::string& devicetype() const;
  void set_devicetype(const ::std::string& value);
  #if LANG_CXX11
  void set_devicetype(::std::string&& value);
  #endif
  void set_devicetype(const char* value);
  void set_devicetype(const char* value, size_t size);
  ::std::string* mutable_devicetype();
  ::std::string* release_devicetype();
  void set_allocated_devicetype(::std::string* devicetype);

  // optional bytes DeviceID = 4;
  bool has_deviceid() const;
  void clear_deviceid();
  static const int kDeviceIDFieldNumber = 4;
  const ::std::string& deviceid() const;
  void set_deviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceid(::std::string&& value);
  #endif
  void set_deviceid(const char* value);
  void set_deviceid(const void* value, size_t size);
  ::std::string* mutable_deviceid();
  ::std::string* release_deviceid();
  void set_allocated_deviceid(::std::string* deviceid);

  // required uint32 Uin = 1;
  bool has_uin() const;
  void clear_uin();
  static const int kUinFieldNumber = 1;
  ::google::protobuf::uint32 uin() const;
  void set_uin(::google::protobuf::uint32 value);

  // required uint32 ClientVersion = 3;
  bool has_clientversion() const;
  void clear_clientversion();
  static const int kClientVersionFieldNumber = 3;
  ::google::protobuf::uint32 clientversion() const;
  void set_clientversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BlueToothAutoLoginInfo)
 private:
  void set_has_uin();
  void clear_has_uin();
  void set_has_devicetype();
  void clear_has_devicetype();
  void set_has_clientversion();
  void clear_has_clientversion();
  void set_has_deviceid();
  void clear_has_deviceid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr devicetype_;
  ::google::protobuf::internal::ArenaStringPtr deviceid_;
  ::google::protobuf::uint32 uin_;
  ::google::protobuf::uint32 clientversion_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindBlackberryPPIDRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindBlackberryPPIDRequest) */ {
 public:
  BindBlackberryPPIDRequest();
  virtual ~BindBlackberryPPIDRequest();

  BindBlackberryPPIDRequest(const BindBlackberryPPIDRequest& from);

  inline BindBlackberryPPIDRequest& operator=(const BindBlackberryPPIDRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindBlackberryPPIDRequest& default_instance();

  static inline const BindBlackberryPPIDRequest* internal_default_instance() {
    return reinterpret_cast<const BindBlackberryPPIDRequest*>(
               &_BindBlackberryPPIDRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    93;

  void Swap(BindBlackberryPPIDRequest* other);

  // implements Message ----------------------------------------------

  inline BindBlackberryPPIDRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  BindBlackberryPPIDRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindBlackberryPPIDRequest& from);
  void MergeFrom(const BindBlackberryPPIDRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindBlackberryPPIDRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string BBPPID = 3;
  bool has_bbppid() const;
  void clear_bbppid();
  static const int kBBPPIDFieldNumber = 3;
  const ::std::string& bbppid() const;
  void set_bbppid(const ::std::string& value);
  #if LANG_CXX11
  void set_bbppid(::std::string&& value);
  #endif
  void set_bbppid(const char* value);
  void set_bbppid(const char* value, size_t size);
  ::std::string* mutable_bbppid();
  ::std::string* release_bbppid();
  void set_allocated_bbppid(::std::string* bbppid);

  // optional string BBPIN = 4;
  bool has_bbpin() const;
  void clear_bbpin();
  static const int kBBPINFieldNumber = 4;
  const ::std::string& bbpin() const;
  void set_bbpin(const ::std::string& value);
  #if LANG_CXX11
  void set_bbpin(::std::string&& value);
  #endif
  void set_bbpin(const char* value);
  void set_bbpin(const char* value, size_t size);
  ::std::string* mutable_bbpin();
  ::std::string* release_bbpin();
  void set_allocated_bbpin(::std::string* bbpin);

  // optional string BBMNickName = 5;
  bool has_bbmnickname() const;
  void clear_bbmnickname();
  static const int kBBMNickNameFieldNumber = 5;
  const ::std::string& bbmnickname() const;
  void set_bbmnickname(const ::std::string& value);
  #if LANG_CXX11
  void set_bbmnickname(::std::string&& value);
  #endif
  void set_bbmnickname(const char* value);
  void set_bbmnickname(const char* value, size_t size);
  ::std::string* mutable_bbmnickname();
  ::std::string* release_bbmnickname();
  void set_allocated_bbmnickname(::std::string* bbmnickname);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required uint32 Opcode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // required uint32 Force = 6;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 6;
  ::google::protobuf::uint32 force() const;
  void set_force(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BindBlackberryPPIDRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_bbppid();
  void clear_has_bbppid();
  void set_has_bbpin();
  void clear_has_bbpin();
  void set_has_bbmnickname();
  void clear_has_bbmnickname();
  void set_has_force();
  void clear_has_force();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bbppid_;
  ::google::protobuf::internal::ArenaStringPtr bbpin_;
  ::google::protobuf::internal::ArenaStringPtr bbmnickname_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint32 force_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BindBlackberryPPIDResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BindBlackberryPPIDResponse) */ {
 public:
  BindBlackberryPPIDResponse();
  virtual ~BindBlackberryPPIDResponse();

  BindBlackberryPPIDResponse(const BindBlackberryPPIDResponse& from);

  inline BindBlackberryPPIDResponse& operator=(const BindBlackberryPPIDResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BindBlackberryPPIDResponse& default_instance();

  static inline const BindBlackberryPPIDResponse* internal_default_instance() {
    return reinterpret_cast<const BindBlackberryPPIDResponse*>(
               &_BindBlackberryPPIDResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    94;

  void Swap(BindBlackberryPPIDResponse* other);

  // implements Message ----------------------------------------------

  inline BindBlackberryPPIDResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  BindBlackberryPPIDResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BindBlackberryPPIDResponse& from);
  void MergeFrom(const BindBlackberryPPIDResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BindBlackberryPPIDResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.BindBlackberryPPIDResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockWebDeviceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.LockWebDeviceRequest) */ {
 public:
  LockWebDeviceRequest();
  virtual ~LockWebDeviceRequest();

  LockWebDeviceRequest(const LockWebDeviceRequest& from);

  inline LockWebDeviceRequest& operator=(const LockWebDeviceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LockWebDeviceRequest& default_instance();

  static inline const LockWebDeviceRequest* internal_default_instance() {
    return reinterpret_cast<const LockWebDeviceRequest*>(
               &_LockWebDeviceRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    95;

  void Swap(LockWebDeviceRequest* other);

  // implements Message ----------------------------------------------

  inline LockWebDeviceRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LockWebDeviceRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockWebDeviceRequest& from);
  void MergeFrom(const LockWebDeviceRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockWebDeviceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string BlueToothBroadCastUUID = 3;
  bool has_bluetoothbroadcastuuid() const;
  void clear_bluetoothbroadcastuuid();
  static const int kBlueToothBroadCastUUIDFieldNumber = 3;
  const ::std::string& bluetoothbroadcastuuid() const;
  void set_bluetoothbroadcastuuid(const ::std::string& value);
  #if LANG_CXX11
  void set_bluetoothbroadcastuuid(::std::string&& value);
  #endif
  void set_bluetoothbroadcastuuid(const char* value);
  void set_bluetoothbroadcastuuid(const char* value, size_t size);
  ::std::string* mutable_bluetoothbroadcastuuid();
  ::std::string* release_bluetoothbroadcastuuid();
  void set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // required .micromsg.SKBuiltinBuffer_t BlueToothBroadCastContent = 4;
  bool has_bluetoothbroadcastcontent() const;
  void clear_bluetoothbroadcastcontent();
  static const int kBlueToothBroadCastContentFieldNumber = 4;
  const ::micromsg::SKBuiltinBuffer_t& bluetoothbroadcastcontent() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_bluetoothbroadcastcontent();
  ::micromsg::SKBuiltinBuffer_t* release_bluetoothbroadcastcontent();
  void set_allocated_bluetoothbroadcastcontent(::micromsg::SKBuiltinBuffer_t* bluetoothbroadcastcontent);

  // required uint32 OPCode = 2;
  bool has_opcode() const;
  void clear_opcode();
  static const int kOPCodeFieldNumber = 2;
  ::google::protobuf::uint32 opcode() const;
  void set_opcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.LockWebDeviceRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_opcode();
  void clear_has_opcode();
  void set_has_bluetoothbroadcastuuid();
  void clear_has_bluetoothbroadcastuuid();
  void set_has_bluetoothbroadcastcontent();
  void clear_has_bluetoothbroadcastcontent();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bluetoothbroadcastuuid_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* bluetoothbroadcastcontent_;
  ::google::protobuf::uint32 opcode_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LockWebDeviceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.LockWebDeviceResponse) */ {
 public:
  LockWebDeviceResponse();
  virtual ~LockWebDeviceResponse();

  LockWebDeviceResponse(const LockWebDeviceResponse& from);

  inline LockWebDeviceResponse& operator=(const LockWebDeviceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LockWebDeviceResponse& default_instance();

  static inline const LockWebDeviceResponse* internal_default_instance() {
    return reinterpret_cast<const LockWebDeviceResponse*>(
               &_LockWebDeviceResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    96;

  void Swap(LockWebDeviceResponse* other);

  // implements Message ----------------------------------------------

  inline LockWebDeviceResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LockWebDeviceResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LockWebDeviceResponse& from);
  void MergeFrom(const LockWebDeviceResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LockWebDeviceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // @@protoc_insertion_point(class_scope:micromsg.LockWebDeviceResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetIosExtensionKeyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetIosExtensionKeyRequest) */ {
 public:
  GetIosExtensionKeyRequest();
  virtual ~GetIosExtensionKeyRequest();

  GetIosExtensionKeyRequest(const GetIosExtensionKeyRequest& from);

  inline GetIosExtensionKeyRequest& operator=(const GetIosExtensionKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIosExtensionKeyRequest& default_instance();

  static inline const GetIosExtensionKeyRequest* internal_default_instance() {
    return reinterpret_cast<const GetIosExtensionKeyRequest*>(
               &_GetIosExtensionKeyRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    97;

  void Swap(GetIosExtensionKeyRequest* other);

  // implements Message ----------------------------------------------

  inline GetIosExtensionKeyRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GetIosExtensionKeyRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetIosExtensionKeyRequest& from);
  void MergeFrom(const GetIosExtensionKeyRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetIosExtensionKeyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes ExtensionDeviceId = 3;
  bool has_extensiondeviceid() const;
  void clear_extensiondeviceid();
  static const int kExtensionDeviceIdFieldNumber = 3;
  const ::std::string& extensiondeviceid() const;
  void set_extensiondeviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_extensiondeviceid(::std::string&& value);
  #endif
  void set_extensiondeviceid(const char* value);
  void set_extensiondeviceid(const void* value, size_t size);
  ::std::string* mutable_extensiondeviceid();
  ::std::string* release_extensiondeviceid();
  void set_allocated_extensiondeviceid(::std::string* extensiondeviceid);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional uint32 ExtensionSessionType = 2;
  bool has_extensionsessiontype() const;
  void clear_extensionsessiontype();
  static const int kExtensionSessionTypeFieldNumber = 2;
  ::google::protobuf::uint32 extensionsessiontype() const;
  void set_extensionsessiontype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.GetIosExtensionKeyRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_extensionsessiontype();
  void clear_has_extensionsessiontype();
  void set_has_extensiondeviceid();
  void clear_has_extensiondeviceid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr extensiondeviceid_;
  ::micromsg::BaseRequest* baserequest_;
  ::google::protobuf::uint32 extensionsessiontype_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExtSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ExtSession) */ {
 public:
  ExtSession();
  virtual ~ExtSession();

  ExtSession(const ExtSession& from);

  inline ExtSession& operator=(const ExtSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtSession& default_instance();

  static inline const ExtSession* internal_default_instance() {
    return reinterpret_cast<const ExtSession*>(
               &_ExtSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    98;

  void Swap(ExtSession* other);

  // implements Message ----------------------------------------------

  inline ExtSession* New() const PROTOBUF_FINAL { return New(NULL); }

  ExtSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExtSession& from);
  void MergeFrom(const ExtSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExtSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.SKBuiltinBuffer_t SessionKey = 2;
  bool has_sessionkey() const;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& sessionkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_sessionkey();
  ::micromsg::SKBuiltinBuffer_t* release_sessionkey();
  void set_allocated_sessionkey(::micromsg::SKBuiltinBuffer_t* sessionkey);

  // required .micromsg.SKBuiltinBuffer_t ServerId = 3;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIdFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& serverid() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_serverid();
  ::micromsg::SKBuiltinBuffer_t* release_serverid();
  void set_allocated_serverid(::micromsg::SKBuiltinBuffer_t* serverid);

  // required uint32 SessionType = 1;
  bool has_sessiontype() const;
  void clear_sessiontype();
  static const int kSessionTypeFieldNumber = 1;
  ::google::protobuf::uint32 sessiontype() const;
  void set_sessiontype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.ExtSession)
 private:
  void set_has_sessiontype();
  void clear_has_sessiontype();
  void set_has_sessionkey();
  void clear_has_sessionkey();
  void set_has_serverid();
  void clear_has_serverid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* sessionkey_;
  ::micromsg::SKBuiltinBuffer_t* serverid_;
  ::google::protobuf::uint32 sessiontype_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetIosExtensionKeyResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.GetIosExtensionKeyResponse) */ {
 public:
  GetIosExtensionKeyResponse();
  virtual ~GetIosExtensionKeyResponse();

  GetIosExtensionKeyResponse(const GetIosExtensionKeyResponse& from);

  inline GetIosExtensionKeyResponse& operator=(const GetIosExtensionKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetIosExtensionKeyResponse& default_instance();

  static inline const GetIosExtensionKeyResponse* internal_default_instance() {
    return reinterpret_cast<const GetIosExtensionKeyResponse*>(
               &_GetIosExtensionKeyResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    99;

  void Swap(GetIosExtensionKeyResponse* other);

  // implements Message ----------------------------------------------

  inline GetIosExtensionKeyResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetIosExtensionKeyResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetIosExtensionKeyResponse& from);
  void MergeFrom(const GetIosExtensionKeyResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetIosExtensionKeyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // required .micromsg.SKBuiltinBuffer_t Key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& key() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_key();
  ::micromsg::SKBuiltinBuffer_t* release_key();
  void set_allocated_key(::micromsg::SKBuiltinBuffer_t* key);

  // optional .micromsg.ExtSession ExtensionSession = 3;
  bool has_extensionsession() const;
  void clear_extensionsession();
  static const int kExtensionSessionFieldNumber = 3;
  const ::micromsg::ExtSession& extensionsession() const;
  ::micromsg::ExtSession* mutable_extensionsession();
  ::micromsg::ExtSession* release_extensionsession();
  void set_allocated_extensionsession(::micromsg::ExtSession* extensionsession);

  // @@protoc_insertion_point(class_scope:micromsg.GetIosExtensionKeyResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_key();
  void clear_has_key();
  void set_has_extensionsession();
  void clear_has_extensionsession();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::SKBuiltinBuffer_t* key_;
  ::micromsg::ExtSession* extensionsession_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PatternLockBuffer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.PatternLockBuffer) */ {
 public:
  PatternLockBuffer();
  virtual ~PatternLockBuffer();

  PatternLockBuffer(const PatternLockBuffer& from);

  inline PatternLockBuffer& operator=(const PatternLockBuffer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatternLockBuffer& default_instance();

  static inline const PatternLockBuffer* internal_default_instance() {
    return reinterpret_cast<const PatternLockBuffer*>(
               &_PatternLockBuffer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    100;

  void Swap(PatternLockBuffer* other);

  // implements Message ----------------------------------------------

  inline PatternLockBuffer* New() const PROTOBUF_FINAL { return New(NULL); }

  PatternLockBuffer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PatternLockBuffer& from);
  void MergeFrom(const PatternLockBuffer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PatternLockBuffer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .micromsg.SKBuiltinBuffer_t svrpatternhash = 3;
  bool has_svrpatternhash() const;
  void clear_svrpatternhash();
  static const int kSvrpatternhashFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& svrpatternhash() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_svrpatternhash();
  ::micromsg::SKBuiltinBuffer_t* release_svrpatternhash();
  void set_allocated_svrpatternhash(::micromsg::SKBuiltinBuffer_t* svrpatternhash);

  // optional .micromsg.SKBuiltinBuffer_t sign = 5;
  bool has_sign() const;
  void clear_sign();
  static const int kSignFieldNumber = 5;
  const ::micromsg::SKBuiltinBuffer_t& sign() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_sign();
  ::micromsg::SKBuiltinBuffer_t* release_sign();
  void set_allocated_sign(::micromsg::SKBuiltinBuffer_t* sign);

  // optional uint32 uin = 1;
  bool has_uin() const;
  void clear_uin();
  static const int kUinFieldNumber = 1;
  ::google::protobuf::uint32 uin() const;
  void set_uin(::google::protobuf::uint32 value);

  // optional uint32 version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional uint32 lockstatus = 4;
  bool has_lockstatus() const;
  void clear_lockstatus();
  static const int kLockstatusFieldNumber = 4;
  ::google::protobuf::uint32 lockstatus() const;
  void set_lockstatus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.PatternLockBuffer)
 private:
  void set_has_uin();
  void clear_has_uin();
  void set_has_version();
  void clear_has_version();
  void set_has_svrpatternhash();
  void clear_has_svrpatternhash();
  void set_has_lockstatus();
  void clear_has_lockstatus();
  void set_has_sign();
  void clear_has_sign();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* svrpatternhash_;
  ::micromsg::SKBuiltinBuffer_t* sign_;
  ::google::protobuf::uint32 uin_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 lockstatus_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterNewPatternLockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.RegisterNewPatternLockRequest) */ {
 public:
  RegisterNewPatternLockRequest();
  virtual ~RegisterNewPatternLockRequest();

  RegisterNewPatternLockRequest(const RegisterNewPatternLockRequest& from);

  inline RegisterNewPatternLockRequest& operator=(const RegisterNewPatternLockRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterNewPatternLockRequest& default_instance();

  static inline const RegisterNewPatternLockRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterNewPatternLockRequest*>(
               &_RegisterNewPatternLockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    101;

  void Swap(RegisterNewPatternLockRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterNewPatternLockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterNewPatternLockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterNewPatternLockRequest& from);
  void MergeFrom(const RegisterNewPatternLockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterNewPatternLockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.SKBuiltinBuffer_t paytoken = 2;
  bool has_paytoken() const;
  void clear_paytoken();
  static const int kPaytokenFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& paytoken() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_paytoken();
  ::micromsg::SKBuiltinBuffer_t* release_paytoken();
  void set_allocated_paytoken(::micromsg::SKBuiltinBuffer_t* paytoken);

  // optional .micromsg.SKBuiltinBuffer_t patternhash = 3;
  bool has_patternhash() const;
  void clear_patternhash();
  static const int kPatternhashFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& patternhash() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_patternhash();
  ::micromsg::SKBuiltinBuffer_t* release_patternhash();
  void set_allocated_patternhash(::micromsg::SKBuiltinBuffer_t* patternhash);

  // optional uint32 cmd = 4;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 4;
  ::google::protobuf::uint32 cmd() const;
  void set_cmd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.RegisterNewPatternLockRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_paytoken();
  void clear_has_paytoken();
  void set_has_patternhash();
  void clear_has_patternhash();
  void set_has_cmd();
  void clear_has_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* paytoken_;
  ::micromsg::SKBuiltinBuffer_t* patternhash_;
  ::google::protobuf::uint32 cmd_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterNewPatternLockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.RegisterNewPatternLockResponse) */ {
 public:
  RegisterNewPatternLockResponse();
  virtual ~RegisterNewPatternLockResponse();

  RegisterNewPatternLockResponse(const RegisterNewPatternLockResponse& from);

  inline RegisterNewPatternLockResponse& operator=(const RegisterNewPatternLockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterNewPatternLockResponse& default_instance();

  static inline const RegisterNewPatternLockResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterNewPatternLockResponse*>(
               &_RegisterNewPatternLockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    102;

  void Swap(RegisterNewPatternLockResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterNewPatternLockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RegisterNewPatternLockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RegisterNewPatternLockResponse& from);
  void MergeFrom(const RegisterNewPatternLockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RegisterNewPatternLockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.PatternLockBuffer patternlockbuf = 2;
  bool has_patternlockbuf() const;
  void clear_patternlockbuf();
  static const int kPatternlockbufFieldNumber = 2;
  const ::micromsg::PatternLockBuffer& patternlockbuf() const;
  ::micromsg::PatternLockBuffer* mutable_patternlockbuf();
  ::micromsg::PatternLockBuffer* release_patternlockbuf();
  void set_allocated_patternlockbuf(::micromsg::PatternLockBuffer* patternlockbuf);

  // @@protoc_insertion_point(class_scope:micromsg.RegisterNewPatternLockResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_patternlockbuf();
  void clear_has_patternlockbuf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::PatternLockBuffer* patternlockbuf_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpPatternLockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.OpPatternLockRequest) */ {
 public:
  OpPatternLockRequest();
  virtual ~OpPatternLockRequest();

  OpPatternLockRequest(const OpPatternLockRequest& from);

  inline OpPatternLockRequest& operator=(const OpPatternLockRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpPatternLockRequest& default_instance();

  static inline const OpPatternLockRequest* internal_default_instance() {
    return reinterpret_cast<const OpPatternLockRequest*>(
               &_OpPatternLockRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    103;

  void Swap(OpPatternLockRequest* other);

  // implements Message ----------------------------------------------

  inline OpPatternLockRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  OpPatternLockRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OpPatternLockRequest& from);
  void MergeFrom(const OpPatternLockRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OpPatternLockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.SKBuiltinBuffer_t nowpatternhash = 3;
  bool has_nowpatternhash() const;
  void clear_nowpatternhash();
  static const int kNowpatternhashFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& nowpatternhash() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_nowpatternhash();
  ::micromsg::SKBuiltinBuffer_t* release_nowpatternhash();
  void set_allocated_nowpatternhash(::micromsg::SKBuiltinBuffer_t* nowpatternhash);

  // optional .micromsg.SKBuiltinBuffer_t newpatternhash = 4;
  bool has_newpatternhash() const;
  void clear_newpatternhash();
  static const int kNewpatternhashFieldNumber = 4;
  const ::micromsg::SKBuiltinBuffer_t& newpatternhash() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_newpatternhash();
  ::micromsg::SKBuiltinBuffer_t* release_newpatternhash();
  void set_allocated_newpatternhash(::micromsg::SKBuiltinBuffer_t* newpatternhash);

  // optional uint32 cmd = 2;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 2;
  ::google::protobuf::uint32 cmd() const;
  void set_cmd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.OpPatternLockRequest)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_cmd();
  void clear_has_cmd();
  void set_has_nowpatternhash();
  void clear_has_nowpatternhash();
  void set_has_newpatternhash();
  void clear_has_newpatternhash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::SKBuiltinBuffer_t* nowpatternhash_;
  ::micromsg::SKBuiltinBuffer_t* newpatternhash_;
  ::google::protobuf::uint32 cmd_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpPatternLockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.OpPatternLockResponse) */ {
 public:
  OpPatternLockResponse();
  virtual ~OpPatternLockResponse();

  OpPatternLockResponse(const OpPatternLockResponse& from);

  inline OpPatternLockResponse& operator=(const OpPatternLockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpPatternLockResponse& default_instance();

  static inline const OpPatternLockResponse* internal_default_instance() {
    return reinterpret_cast<const OpPatternLockResponse*>(
               &_OpPatternLockResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    104;

  void Swap(OpPatternLockResponse* other);

  // implements Message ----------------------------------------------

  inline OpPatternLockResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  OpPatternLockResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OpPatternLockResponse& from);
  void MergeFrom(const OpPatternLockResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OpPatternLockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.PatternLockBuffer patternlockbuf = 2;
  bool has_patternlockbuf() const;
  void clear_patternlockbuf();
  static const int kPatternlockbufFieldNumber = 2;
  const ::micromsg::PatternLockBuffer& patternlockbuf() const;
  ::micromsg::PatternLockBuffer* mutable_patternlockbuf();
  ::micromsg::PatternLockBuffer* release_patternlockbuf();
  void set_allocated_patternlockbuf(::micromsg::PatternLockBuffer* patternlockbuf);

  // @@protoc_insertion_point(class_scope:micromsg.OpPatternLockResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_patternlockbuf();
  void clear_has_patternlockbuf();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::PatternLockBuffer* patternlockbuf_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WTLoginImgReqInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.WTLoginImgReqInfo) */ {
 public:
  WTLoginImgReqInfo();
  virtual ~WTLoginImgReqInfo();

  WTLoginImgReqInfo(const WTLoginImgReqInfo& from);

  inline WTLoginImgReqInfo& operator=(const WTLoginImgReqInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WTLoginImgReqInfo& default_instance();

  static inline const WTLoginImgReqInfo* internal_default_instance() {
    return reinterpret_cast<const WTLoginImgReqInfo*>(
               &_WTLoginImgReqInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    105;

  void Swap(WTLoginImgReqInfo* other);

  // implements Message ----------------------------------------------

  inline WTLoginImgReqInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  WTLoginImgReqInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WTLoginImgReqInfo& from);
  void MergeFrom(const WTLoginImgReqInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WTLoginImgReqInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ImgSid = 1;
  bool has_imgsid() const;
  void clear_imgsid();
  static const int kImgSidFieldNumber = 1;
  const ::std::string& imgsid() const;
  void set_imgsid(const ::std::string& value);
  #if LANG_CXX11
  void set_imgsid(::std::string&& value);
  #endif
  void set_imgsid(const char* value);
  void set_imgsid(const char* value, size_t size);
  ::std::string* mutable_imgsid();
  ::std::string* release_imgsid();
  void set_allocated_imgsid(::std::string* imgsid);

  // optional string ImgCode = 2;
  bool has_imgcode() const;
  void clear_imgcode();
  static const int kImgCodeFieldNumber = 2;
  const ::std::string& imgcode() const;
  void set_imgcode(const ::std::string& value);
  #if LANG_CXX11
  void set_imgcode(::std::string&& value);
  #endif
  void set_imgcode(const char* value);
  void set_imgcode(const char* value, size_t size);
  ::std::string* mutable_imgcode();
  ::std::string* release_imgcode();
  void set_allocated_imgcode(::std::string* imgcode);

  // optional string ImgEncryptKey = 3;
  bool has_imgencryptkey() const;
  void clear_imgencryptkey();
  static const int kImgEncryptKeyFieldNumber = 3;
  const ::std::string& imgencryptkey() const;
  void set_imgencryptkey(const ::std::string& value);
  #if LANG_CXX11
  void set_imgencryptkey(::std::string&& value);
  #endif
  void set_imgencryptkey(const char* value);
  void set_imgencryptkey(const char* value, size_t size);
  ::std::string* mutable_imgencryptkey();
  ::std::string* release_imgencryptkey();
  void set_allocated_imgencryptkey(::std::string* imgencryptkey);

  // required .micromsg.SKBuiltinBuffer_t KSid = 4;
  bool has_ksid() const;
  void clear_ksid();
  static const int kKSidFieldNumber = 4;
  const ::micromsg::SKBuiltinBuffer_t& ksid() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_ksid();
  ::micromsg::SKBuiltinBuffer_t* release_ksid();
  void set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid);

  // @@protoc_insertion_point(class_scope:micromsg.WTLoginImgReqInfo)
 private:
  void set_has_imgsid();
  void clear_has_imgsid();
  void set_has_imgcode();
  void clear_has_imgcode();
  void set_has_imgencryptkey();
  void clear_has_imgencryptkey();
  void set_has_ksid();
  void clear_has_ksid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr imgsid_;
  ::google::protobuf::internal::ArenaStringPtr imgcode_;
  ::google::protobuf::internal::ArenaStringPtr imgencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* ksid_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WTLoginImgRespInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.WTLoginImgRespInfo) */ {
 public:
  WTLoginImgRespInfo();
  virtual ~WTLoginImgRespInfo();

  WTLoginImgRespInfo(const WTLoginImgRespInfo& from);

  inline WTLoginImgRespInfo& operator=(const WTLoginImgRespInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WTLoginImgRespInfo& default_instance();

  static inline const WTLoginImgRespInfo* internal_default_instance() {
    return reinterpret_cast<const WTLoginImgRespInfo*>(
               &_WTLoginImgRespInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    106;

  void Swap(WTLoginImgRespInfo* other);

  // implements Message ----------------------------------------------

  inline WTLoginImgRespInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  WTLoginImgRespInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WTLoginImgRespInfo& from);
  void MergeFrom(const WTLoginImgRespInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WTLoginImgRespInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ImgEncryptKey = 1;
  bool has_imgencryptkey() const;
  void clear_imgencryptkey();
  static const int kImgEncryptKeyFieldNumber = 1;
  const ::std::string& imgencryptkey() const;
  void set_imgencryptkey(const ::std::string& value);
  #if LANG_CXX11
  void set_imgencryptkey(::std::string&& value);
  #endif
  void set_imgencryptkey(const char* value);
  void set_imgencryptkey(const char* value, size_t size);
  ::std::string* mutable_imgencryptkey();
  ::std::string* release_imgencryptkey();
  void set_allocated_imgencryptkey(::std::string* imgencryptkey);

  // optional string ImgSid = 3;
  bool has_imgsid() const;
  void clear_imgsid();
  static const int kImgSidFieldNumber = 3;
  const ::std::string& imgsid() const;
  void set_imgsid(const ::std::string& value);
  #if LANG_CXX11
  void set_imgsid(::std::string&& value);
  #endif
  void set_imgsid(const char* value);
  void set_imgsid(const char* value, size_t size);
  ::std::string* mutable_imgsid();
  ::std::string* release_imgsid();
  void set_allocated_imgsid(::std::string* imgsid);

  // required .micromsg.SKBuiltinBuffer_t KSid = 2;
  bool has_ksid() const;
  void clear_ksid();
  static const int kKSidFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& ksid() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_ksid();
  ::micromsg::SKBuiltinBuffer_t* release_ksid();
  void set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid);

  // required .micromsg.SKBuiltinBuffer_t ImgBuf = 4;
  bool has_imgbuf() const;
  void clear_imgbuf();
  static const int kImgBufFieldNumber = 4;
  const ::micromsg::SKBuiltinBuffer_t& imgbuf() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_imgbuf();
  ::micromsg::SKBuiltinBuffer_t* release_imgbuf();
  void set_allocated_imgbuf(::micromsg::SKBuiltinBuffer_t* imgbuf);

  // @@protoc_insertion_point(class_scope:micromsg.WTLoginImgRespInfo)
 private:
  void set_has_imgencryptkey();
  void clear_has_imgencryptkey();
  void set_has_ksid();
  void clear_has_ksid();
  void set_has_imgsid();
  void clear_has_imgsid();
  void set_has_imgbuf();
  void clear_has_imgbuf();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr imgencryptkey_;
  ::google::protobuf::internal::ArenaStringPtr imgsid_;
  ::micromsg::SKBuiltinBuffer_t* ksid_;
  ::micromsg::SKBuiltinBuffer_t* imgbuf_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WxVerifyCodeReqInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.WxVerifyCodeReqInfo) */ {
 public:
  WxVerifyCodeReqInfo();
  virtual ~WxVerifyCodeReqInfo();

  WxVerifyCodeReqInfo(const WxVerifyCodeReqInfo& from);

  inline WxVerifyCodeReqInfo& operator=(const WxVerifyCodeReqInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WxVerifyCodeReqInfo& default_instance();

  static inline const WxVerifyCodeReqInfo* internal_default_instance() {
    return reinterpret_cast<const WxVerifyCodeReqInfo*>(
               &_WxVerifyCodeReqInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    107;

  void Swap(WxVerifyCodeReqInfo* other);

  // implements Message ----------------------------------------------

  inline WxVerifyCodeReqInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  WxVerifyCodeReqInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WxVerifyCodeReqInfo& from);
  void MergeFrom(const WxVerifyCodeReqInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WxVerifyCodeReqInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string VerifySignature = 1;
  bool has_verifysignature() const;
  void clear_verifysignature();
  static const int kVerifySignatureFieldNumber = 1;
  const ::std::string& verifysignature() const;
  void set_verifysignature(const ::std::string& value);
  #if LANG_CXX11
  void set_verifysignature(::std::string&& value);
  #endif
  void set_verifysignature(const char* value);
  void set_verifysignature(const char* value, size_t size);
  ::std::string* mutable_verifysignature();
  ::std::string* release_verifysignature();
  void set_allocated_verifysignature(::std::string* verifysignature);

  // optional string VerifyContent = 2;
  bool has_verifycontent() const;
  void clear_verifycontent();
  static const int kVerifyContentFieldNumber = 2;
  const ::std::string& verifycontent() const;
  void set_verifycontent(const ::std::string& value);
  #if LANG_CXX11
  void set_verifycontent(::std::string&& value);
  #endif
  void set_verifycontent(const char* value);
  void set_verifycontent(const char* value, size_t size);
  ::std::string* mutable_verifycontent();
  ::std::string* release_verifycontent();
  void set_allocated_verifycontent(::std::string* verifycontent);

  // @@protoc_insertion_point(class_scope:micromsg.WxVerifyCodeReqInfo)
 private:
  void set_has_verifysignature();
  void clear_has_verifysignature();
  void set_has_verifycontent();
  void clear_has_verifycontent();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr verifysignature_;
  ::google::protobuf::internal::ArenaStringPtr verifycontent_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WxVerifyCodeRespInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.WxVerifyCodeRespInfo) */ {
 public:
  WxVerifyCodeRespInfo();
  virtual ~WxVerifyCodeRespInfo();

  WxVerifyCodeRespInfo(const WxVerifyCodeRespInfo& from);

  inline WxVerifyCodeRespInfo& operator=(const WxVerifyCodeRespInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WxVerifyCodeRespInfo& default_instance();

  static inline const WxVerifyCodeRespInfo* internal_default_instance() {
    return reinterpret_cast<const WxVerifyCodeRespInfo*>(
               &_WxVerifyCodeRespInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    108;

  void Swap(WxVerifyCodeRespInfo* other);

  // implements Message ----------------------------------------------

  inline WxVerifyCodeRespInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  WxVerifyCodeRespInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WxVerifyCodeRespInfo& from);
  void MergeFrom(const WxVerifyCodeRespInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WxVerifyCodeRespInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string VerifySignature = 1;
  bool has_verifysignature() const;
  void clear_verifysignature();
  static const int kVerifySignatureFieldNumber = 1;
  const ::std::string& verifysignature() const;
  void set_verifysignature(const ::std::string& value);
  #if LANG_CXX11
  void set_verifysignature(::std::string&& value);
  #endif
  void set_verifysignature(const char* value);
  void set_verifysignature(const char* value, size_t size);
  ::std::string* mutable_verifysignature();
  ::std::string* release_verifysignature();
  void set_allocated_verifysignature(::std::string* verifysignature);

  // required .micromsg.SKBuiltinBuffer_t VerifyBuff = 2;
  bool has_verifybuff() const;
  void clear_verifybuff();
  static const int kVerifyBuffFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& verifybuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_verifybuff();
  ::micromsg::SKBuiltinBuffer_t* release_verifybuff();
  void set_allocated_verifybuff(::micromsg::SKBuiltinBuffer_t* verifybuff);

  // @@protoc_insertion_point(class_scope:micromsg.WxVerifyCodeRespInfo)
 private:
  void set_has_verifysignature();
  void clear_has_verifysignature();
  void set_has_verifybuff();
  void clear_has_verifybuff();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr verifysignature_;
  ::micromsg::SKBuiltinBuffer_t* verifybuff_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BaseAuthReqInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.BaseAuthReqInfo) */ {
 public:
  BaseAuthReqInfo();
  virtual ~BaseAuthReqInfo();

  BaseAuthReqInfo(const BaseAuthReqInfo& from);

  inline BaseAuthReqInfo& operator=(const BaseAuthReqInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseAuthReqInfo& default_instance();

  static inline const BaseAuthReqInfo* internal_default_instance() {
    return reinterpret_cast<const BaseAuthReqInfo*>(
               &_BaseAuthReqInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    109;

  void Swap(BaseAuthReqInfo* other);

  // implements Message ----------------------------------------------

  inline BaseAuthReqInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  BaseAuthReqInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BaseAuthReqInfo& from);
  void MergeFrom(const BaseAuthReqInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BaseAuthReqInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string AuthTicket = 7;
  bool has_authticket() const;
  void clear_authticket();
  static const int kAuthTicketFieldNumber = 7;
  const ::std::string& authticket() const;
  void set_authticket(const ::std::string& value);
  #if LANG_CXX11
  void set_authticket(::std::string&& value);
  #endif
  void set_authticket(const char* value);
  void set_authticket(const char* value, size_t size);
  ::std::string* mutable_authticket();
  ::std::string* release_authticket();
  void set_allocated_authticket(::std::string* authticket);

  // optional .micromsg.SKBuiltinBuffer_t WTLoginReqBuff = 1;
  bool has_wtloginreqbuff() const;
  void clear_wtloginreqbuff();
  static const int kWTLoginReqBuffFieldNumber = 1;
  const ::micromsg::SKBuiltinBuffer_t& wtloginreqbuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_wtloginreqbuff();
  ::micromsg::SKBuiltinBuffer_t* release_wtloginreqbuff();
  void set_allocated_wtloginreqbuff(::micromsg::SKBuiltinBuffer_t* wtloginreqbuff);

  // optional .micromsg.WTLoginImgReqInfo WTLoginImgReqInfo = 2;
  bool has_wtloginimgreqinfo() const;
  void clear_wtloginimgreqinfo();
  static const int kWTLoginImgReqInfoFieldNumber = 2;
  const ::micromsg::WTLoginImgReqInfo& wtloginimgreqinfo() const;
  ::micromsg::WTLoginImgReqInfo* mutable_wtloginimgreqinfo();
  ::micromsg::WTLoginImgReqInfo* release_wtloginimgreqinfo();
  void set_allocated_wtloginimgreqinfo(::micromsg::WTLoginImgReqInfo* wtloginimgreqinfo);

  // optional .micromsg.WxVerifyCodeReqInfo WxVerifyCodeReqInfo = 3;
  bool has_wxverifycodereqinfo() const;
  void clear_wxverifycodereqinfo();
  static const int kWxVerifyCodeReqInfoFieldNumber = 3;
  const ::micromsg::WxVerifyCodeReqInfo& wxverifycodereqinfo() const;
  ::micromsg::WxVerifyCodeReqInfo* mutable_wxverifycodereqinfo();
  ::micromsg::WxVerifyCodeReqInfo* release_wxverifycodereqinfo();
  void set_allocated_wxverifycodereqinfo(::micromsg::WxVerifyCodeReqInfo* wxverifycodereqinfo);

  // optional .micromsg.SKBuiltinBuffer_t CliDBEncryptKey = 4;
  bool has_clidbencryptkey() const;
  void clear_clidbencryptkey();
  static const int kCliDBEncryptKeyFieldNumber = 4;
  const ::micromsg::SKBuiltinBuffer_t& clidbencryptkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_clidbencryptkey();
  ::micromsg::SKBuiltinBuffer_t* release_clidbencryptkey();
  void set_allocated_clidbencryptkey(::micromsg::SKBuiltinBuffer_t* clidbencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t CliDBEncryptInfo = 5;
  bool has_clidbencryptinfo() const;
  void clear_clidbencryptinfo();
  static const int kCliDBEncryptInfoFieldNumber = 5;
  const ::micromsg::SKBuiltinBuffer_t& clidbencryptinfo() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_clidbencryptinfo();
  ::micromsg::SKBuiltinBuffer_t* release_clidbencryptinfo();
  void set_allocated_clidbencryptinfo(::micromsg::SKBuiltinBuffer_t* clidbencryptinfo);

  // optional uint32 AuthReqFlag = 6;
  bool has_authreqflag() const;
  void clear_authreqflag();
  static const int kAuthReqFlagFieldNumber = 6;
  ::google::protobuf::uint32 authreqflag() const;
  void set_authreqflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.BaseAuthReqInfo)
 private:
  void set_has_wtloginreqbuff();
  void clear_has_wtloginreqbuff();
  void set_has_wtloginimgreqinfo();
  void clear_has_wtloginimgreqinfo();
  void set_has_wxverifycodereqinfo();
  void clear_has_wxverifycodereqinfo();
  void set_has_clidbencryptkey();
  void clear_has_clidbencryptkey();
  void set_has_clidbencryptinfo();
  void clear_has_clidbencryptinfo();
  void set_has_authreqflag();
  void clear_has_authreqflag();
  void set_has_authticket();
  void clear_has_authticket();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr authticket_;
  ::micromsg::SKBuiltinBuffer_t* wtloginreqbuff_;
  ::micromsg::WTLoginImgReqInfo* wtloginimgreqinfo_;
  ::micromsg::WxVerifyCodeReqInfo* wxverifycodereqinfo_;
  ::micromsg::SKBuiltinBuffer_t* clidbencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* clidbencryptinfo_;
  ::google::protobuf::uint32 authreqflag_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ManualAuthRsaReqData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ManualAuthRsaReqData) */ {
 public:
  ManualAuthRsaReqData();
  virtual ~ManualAuthRsaReqData();

  ManualAuthRsaReqData(const ManualAuthRsaReqData& from);

  inline ManualAuthRsaReqData& operator=(const ManualAuthRsaReqData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualAuthRsaReqData& default_instance();

  static inline const ManualAuthRsaReqData* internal_default_instance() {
    return reinterpret_cast<const ManualAuthRsaReqData*>(
               &_ManualAuthRsaReqData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    110;

  void Swap(ManualAuthRsaReqData* other);

  // implements Message ----------------------------------------------

  inline ManualAuthRsaReqData* New() const PROTOBUF_FINAL { return New(NULL); }

  ManualAuthRsaReqData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ManualAuthRsaReqData& from);
  void MergeFrom(const ManualAuthRsaReqData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ManualAuthRsaReqData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 3;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 3;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string Pwd = 4;
  bool has_pwd() const;
  void clear_pwd();
  static const int kPwdFieldNumber = 4;
  const ::std::string& pwd() const;
  void set_pwd(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd(::std::string&& value);
  #endif
  void set_pwd(const char* value);
  void set_pwd(const char* value, size_t size);
  ::std::string* mutable_pwd();
  ::std::string* release_pwd();
  void set_allocated_pwd(::std::string* pwd);

  // optional string Pwd2 = 5;
  bool has_pwd2() const;
  void clear_pwd2();
  static const int kPwd2FieldNumber = 5;
  const ::std::string& pwd2() const;
  void set_pwd2(const ::std::string& value);
  #if LANG_CXX11
  void set_pwd2(::std::string&& value);
  #endif
  void set_pwd2(const char* value);
  void set_pwd2(const char* value, size_t size);
  ::std::string* mutable_pwd2();
  ::std::string* release_pwd2();
  void set_allocated_pwd2(::std::string* pwd2);

  // required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 1;
  bool has_randomencrykey() const;
  void clear_randomencrykey();
  static const int kRandomEncryKeyFieldNumber = 1;
  const ::micromsg::SKBuiltinBuffer_t& randomencrykey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* release_randomencrykey();
  void set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey);

  // required .micromsg.ECDHKey CliPubECDHKey = 2;
  bool has_clipubecdhkey() const;
  void clear_clipubecdhkey();
  static const int kCliPubECDHKeyFieldNumber = 2;
  const ::micromsg::ECDHKey& clipubecdhkey() const;
  ::micromsg::ECDHKey* mutable_clipubecdhkey();
  ::micromsg::ECDHKey* release_clipubecdhkey();
  void set_allocated_clipubecdhkey(::micromsg::ECDHKey* clipubecdhkey);

  // @@protoc_insertion_point(class_scope:micromsg.ManualAuthRsaReqData)
 private:
  void set_has_randomencrykey();
  void clear_has_randomencrykey();
  void set_has_clipubecdhkey();
  void clear_has_clipubecdhkey();
  void set_has_username();
  void clear_has_username();
  void set_has_pwd();
  void clear_has_pwd();
  void set_has_pwd2();
  void clear_has_pwd2();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr pwd_;
  ::google::protobuf::internal::ArenaStringPtr pwd2_;
  ::micromsg::SKBuiltinBuffer_t* randomencrykey_;
  ::micromsg::ECDHKey* clipubecdhkey_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ManualAuthAesReqData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ManualAuthAesReqData) */ {
 public:
  ManualAuthAesReqData();
  virtual ~ManualAuthAesReqData();

  ManualAuthAesReqData(const ManualAuthAesReqData& from);

  inline ManualAuthAesReqData& operator=(const ManualAuthAesReqData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualAuthAesReqData& default_instance();

  static inline const ManualAuthAesReqData* internal_default_instance() {
    return reinterpret_cast<const ManualAuthAesReqData*>(
               &_ManualAuthAesReqData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    111;

  void Swap(ManualAuthAesReqData* other);

  // implements Message ----------------------------------------------

  inline ManualAuthAesReqData* New() const PROTOBUF_FINAL { return New(NULL); }

  ManualAuthAesReqData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ManualAuthAesReqData& from);
  void MergeFrom(const ManualAuthAesReqData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ManualAuthAesReqData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string IMEI = 3;
  bool has_imei() const;
  void clear_imei();
  static const int kIMEIFieldNumber = 3;
  const ::std::string& imei() const;
  void set_imei(const ::std::string& value);
  #if LANG_CXX11
  void set_imei(::std::string&& value);
  #endif
  void set_imei(const char* value);
  void set_imei(const char* value, size_t size);
  ::std::string* mutable_imei();
  ::std::string* release_imei();
  void set_allocated_imei(::std::string* imei);

  // optional string SoftType = 4;
  bool has_softtype() const;
  void clear_softtype();
  static const int kSoftTypeFieldNumber = 4;
  const ::std::string& softtype() const;
  void set_softtype(const ::std::string& value);
  #if LANG_CXX11
  void set_softtype(::std::string&& value);
  #endif
  void set_softtype(const char* value);
  void set_softtype(const char* value, size_t size);
  ::std::string* mutable_softtype();
  ::std::string* release_softtype();
  void set_allocated_softtype(::std::string* softtype);

  // optional string ClientSeqID = 6;
  bool has_clientseqid() const;
  void clear_clientseqid();
  static const int kClientSeqIDFieldNumber = 6;
  const ::std::string& clientseqid() const;
  void set_clientseqid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientseqid(::std::string&& value);
  #endif
  void set_clientseqid(const char* value);
  void set_clientseqid(const char* value, size_t size);
  ::std::string* mutable_clientseqid();
  ::std::string* release_clientseqid();
  void set_allocated_clientseqid(::std::string* clientseqid);

  // optional string Signature = 7;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 7;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional string DeviceName = 8;
  bool has_devicename() const;
  void clear_devicename();
  static const int kDeviceNameFieldNumber = 8;
  const ::std::string& devicename() const;
  void set_devicename(const ::std::string& value);
  #if LANG_CXX11
  void set_devicename(::std::string&& value);
  #endif
  void set_devicename(const char* value);
  void set_devicename(const char* value, size_t size);
  ::std::string* mutable_devicename();
  ::std::string* release_devicename();
  void set_allocated_devicename(::std::string* devicename);

  // optional string DeviceType = 9;
  bool has_devicetype() const;
  void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 9;
  const ::std::string& devicetype() const;
  void set_devicetype(const ::std::string& value);
  #if LANG_CXX11
  void set_devicetype(::std::string&& value);
  #endif
  void set_devicetype(const char* value);
  void set_devicetype(const char* value, size_t size);
  ::std::string* mutable_devicetype();
  ::std::string* release_devicetype();
  void set_allocated_devicetype(::std::string* devicetype);

  // optional string Language = 10;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 10;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string TimeZone = 11;
  bool has_timezone() const;
  void clear_timezone();
  static const int kTimeZoneFieldNumber = 11;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  #if LANG_CXX11
  void set_timezone(::std::string&& value);
  #endif
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional string DeviceBrand = 15;
  bool has_devicebrand() const;
  void clear_devicebrand();
  static const int kDeviceBrandFieldNumber = 15;
  const ::std::string& devicebrand() const;
  void set_devicebrand(const ::std::string& value);
  #if LANG_CXX11
  void set_devicebrand(::std::string&& value);
  #endif
  void set_devicebrand(const char* value);
  void set_devicebrand(const char* value, size_t size);
  ::std::string* mutable_devicebrand();
  ::std::string* release_devicebrand();
  void set_allocated_devicebrand(::std::string* devicebrand);

  // optional string DeviceModel = 16;
  bool has_devicemodel() const;
  void clear_devicemodel();
  static const int kDeviceModelFieldNumber = 16;
  const ::std::string& devicemodel() const;
  void set_devicemodel(const ::std::string& value);
  #if LANG_CXX11
  void set_devicemodel(::std::string&& value);
  #endif
  void set_devicemodel(const char* value);
  void set_devicemodel(const char* value, size_t size);
  ::std::string* mutable_devicemodel();
  ::std::string* release_devicemodel();
  void set_allocated_devicemodel(::std::string* devicemodel);

  // optional string OSType = 17;
  bool has_ostype() const;
  void clear_ostype();
  static const int kOSTypeFieldNumber = 17;
  const ::std::string& ostype() const;
  void set_ostype(const ::std::string& value);
  #if LANG_CXX11
  void set_ostype(::std::string&& value);
  #endif
  void set_ostype(const char* value);
  void set_ostype(const char* value, size_t size);
  ::std::string* mutable_ostype();
  ::std::string* release_ostype();
  void set_allocated_ostype(::std::string* ostype);

  // optional string RealCountry = 18;
  bool has_realcountry() const;
  void clear_realcountry();
  static const int kRealCountryFieldNumber = 18;
  const ::std::string& realcountry() const;
  void set_realcountry(const ::std::string& value);
  #if LANG_CXX11
  void set_realcountry(::std::string&& value);
  #endif
  void set_realcountry(const char* value);
  void set_realcountry(const char* value, size_t size);
  ::std::string* mutable_realcountry();
  ::std::string* release_realcountry();
  void set_allocated_realcountry(::std::string* realcountry);

  // optional string BundleID = 19;
  bool has_bundleid() const;
  void clear_bundleid();
  static const int kBundleIDFieldNumber = 19;
  const ::std::string& bundleid() const;
  void set_bundleid(const ::std::string& value);
  #if LANG_CXX11
  void set_bundleid(::std::string&& value);
  #endif
  void set_bundleid(const char* value);
  void set_bundleid(const char* value, size_t size);
  ::std::string* mutable_bundleid();
  ::std::string* release_bundleid();
  void set_allocated_bundleid(::std::string* bundleid);

  // optional string AdSource = 20;
  bool has_adsource() const;
  void clear_adsource();
  static const int kAdSourceFieldNumber = 20;
  const ::std::string& adsource() const;
  void set_adsource(const ::std::string& value);
  #if LANG_CXX11
  void set_adsource(::std::string&& value);
  #endif
  void set_adsource(const char* value);
  void set_adsource(const char* value, size_t size);
  ::std::string* mutable_adsource();
  ::std::string* release_adsource();
  void set_allocated_adsource(::std::string* adsource);

  // optional string IPhoneVer = 21;
  bool has_iphonever() const;
  void clear_iphonever();
  static const int kIPhoneVerFieldNumber = 21;
  const ::std::string& iphonever() const;
  void set_iphonever(const ::std::string& value);
  #if LANG_CXX11
  void set_iphonever(::std::string&& value);
  #endif
  void set_iphonever(const char* value);
  void set_iphonever(const char* value, size_t size);
  ::std::string* mutable_iphonever();
  ::std::string* release_iphonever();
  void set_allocated_iphonever(::std::string* iphonever);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.BaseAuthReqInfo BaseReqInfo = 2;
  bool has_basereqinfo() const;
  void clear_basereqinfo();
  static const int kBaseReqInfoFieldNumber = 2;
  const ::micromsg::BaseAuthReqInfo& basereqinfo() const;
  ::micromsg::BaseAuthReqInfo* mutable_basereqinfo();
  ::micromsg::BaseAuthReqInfo* release_basereqinfo();
  void set_allocated_basereqinfo(::micromsg::BaseAuthReqInfo* basereqinfo);

  // optional .micromsg.SKBuiltinBuffer_t Clientcheckdat = 23;
  bool has_clientcheckdat() const;
  void clear_clientcheckdat();
  static const int kClientcheckdatFieldNumber = 23;
  const ::micromsg::SKBuiltinBuffer_t& clientcheckdat() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_clientcheckdat();
  ::micromsg::SKBuiltinBuffer_t* release_clientcheckdat();
  void set_allocated_clientcheckdat(::micromsg::SKBuiltinBuffer_t* clientcheckdat);

  // required uint32 BuiltinIPSeq = 5;
  bool has_builtinipseq() const;
  void clear_builtinipseq();
  static const int kBuiltinIPSeqFieldNumber = 5;
  ::google::protobuf::uint32 builtinipseq() const;
  void set_builtinipseq(::google::protobuf::uint32 value);

  // optional int32 Channel = 13;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 13;
  ::google::protobuf::int32 channel() const;
  void set_channel(::google::protobuf::int32 value);

  // optional uint32 TimeStamp = 14;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 14;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // required uint32 InputType = 22;
  bool has_inputtype() const;
  void clear_inputtype();
  static const int kInputTypeFieldNumber = 22;
  ::google::protobuf::uint32 inputtype() const;
  void set_inputtype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.ManualAuthAesReqData)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_basereqinfo();
  void clear_has_basereqinfo();
  void set_has_imei();
  void clear_has_imei();
  void set_has_softtype();
  void clear_has_softtype();
  void set_has_builtinipseq();
  void clear_has_builtinipseq();
  void set_has_clientseqid();
  void clear_has_clientseqid();
  void set_has_signature();
  void clear_has_signature();
  void set_has_devicename();
  void clear_has_devicename();
  void set_has_devicetype();
  void clear_has_devicetype();
  void set_has_language();
  void clear_has_language();
  void set_has_timezone();
  void clear_has_timezone();
  void set_has_channel();
  void clear_has_channel();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_devicebrand();
  void clear_has_devicebrand();
  void set_has_devicemodel();
  void clear_has_devicemodel();
  void set_has_ostype();
  void clear_has_ostype();
  void set_has_realcountry();
  void clear_has_realcountry();
  void set_has_bundleid();
  void clear_has_bundleid();
  void set_has_adsource();
  void clear_has_adsource();
  void set_has_iphonever();
  void clear_has_iphonever();
  void set_has_inputtype();
  void clear_has_inputtype();
  void set_has_clientcheckdat();
  void clear_has_clientcheckdat();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr imei_;
  ::google::protobuf::internal::ArenaStringPtr softtype_;
  ::google::protobuf::internal::ArenaStringPtr clientseqid_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr devicename_;
  ::google::protobuf::internal::ArenaStringPtr devicetype_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::google::protobuf::internal::ArenaStringPtr devicebrand_;
  ::google::protobuf::internal::ArenaStringPtr devicemodel_;
  ::google::protobuf::internal::ArenaStringPtr ostype_;
  ::google::protobuf::internal::ArenaStringPtr realcountry_;
  ::google::protobuf::internal::ArenaStringPtr bundleid_;
  ::google::protobuf::internal::ArenaStringPtr adsource_;
  ::google::protobuf::internal::ArenaStringPtr iphonever_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::BaseAuthReqInfo* basereqinfo_;
  ::micromsg::SKBuiltinBuffer_t* clientcheckdat_;
  ::google::protobuf::uint32 builtinipseq_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 inputtype_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ManualAuthRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.ManualAuthRequest) */ {
 public:
  ManualAuthRequest();
  virtual ~ManualAuthRequest();

  ManualAuthRequest(const ManualAuthRequest& from);

  inline ManualAuthRequest& operator=(const ManualAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManualAuthRequest& default_instance();

  static inline const ManualAuthRequest* internal_default_instance() {
    return reinterpret_cast<const ManualAuthRequest*>(
               &_ManualAuthRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    112;

  void Swap(ManualAuthRequest* other);

  // implements Message ----------------------------------------------

  inline ManualAuthRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ManualAuthRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ManualAuthRequest& from);
  void MergeFrom(const ManualAuthRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ManualAuthRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.ManualAuthRsaReqData RsaReqData = 1;
  bool has_rsareqdata() const;
  void clear_rsareqdata();
  static const int kRsaReqDataFieldNumber = 1;
  const ::micromsg::ManualAuthRsaReqData& rsareqdata() const;
  ::micromsg::ManualAuthRsaReqData* mutable_rsareqdata();
  ::micromsg::ManualAuthRsaReqData* release_rsareqdata();
  void set_allocated_rsareqdata(::micromsg::ManualAuthRsaReqData* rsareqdata);

  // required .micromsg.ManualAuthAesReqData AesReqData = 2;
  bool has_aesreqdata() const;
  void clear_aesreqdata();
  static const int kAesReqDataFieldNumber = 2;
  const ::micromsg::ManualAuthAesReqData& aesreqdata() const;
  ::micromsg::ManualAuthAesReqData* mutable_aesreqdata();
  ::micromsg::ManualAuthAesReqData* release_aesreqdata();
  void set_allocated_aesreqdata(::micromsg::ManualAuthAesReqData* aesreqdata);

  // @@protoc_insertion_point(class_scope:micromsg.ManualAuthRequest)
 private:
  void set_has_rsareqdata();
  void clear_has_rsareqdata();
  void set_has_aesreqdata();
  void clear_has_aesreqdata();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::ManualAuthRsaReqData* rsareqdata_;
  ::micromsg::ManualAuthAesReqData* aesreqdata_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AutoAuthRsaReqData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AutoAuthRsaReqData) */ {
 public:
  AutoAuthRsaReqData();
  virtual ~AutoAuthRsaReqData();

  AutoAuthRsaReqData(const AutoAuthRsaReqData& from);

  inline AutoAuthRsaReqData& operator=(const AutoAuthRsaReqData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoAuthRsaReqData& default_instance();

  static inline const AutoAuthRsaReqData* internal_default_instance() {
    return reinterpret_cast<const AutoAuthRsaReqData*>(
               &_AutoAuthRsaReqData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    113;

  void Swap(AutoAuthRsaReqData* other);

  // implements Message ----------------------------------------------

  inline AutoAuthRsaReqData* New() const PROTOBUF_FINAL { return New(NULL); }

  AutoAuthRsaReqData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AutoAuthRsaReqData& from);
  void MergeFrom(const AutoAuthRsaReqData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AutoAuthRsaReqData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.SKBuiltinBuffer_t AesEncryptKey = 2;
  bool has_aesencryptkey() const;
  void clear_aesencryptkey();
  static const int kAesEncryptKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& aesencryptkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_aesencryptkey();
  ::micromsg::SKBuiltinBuffer_t* release_aesencryptkey();
  void set_allocated_aesencryptkey(::micromsg::SKBuiltinBuffer_t* aesencryptkey);

  // optional .micromsg.ECDHKey CliPubECDHKey = 3;
  bool has_clipubecdhkey() const;
  void clear_clipubecdhkey();
  static const int kCliPubECDHKeyFieldNumber = 3;
  const ::micromsg::ECDHKey& clipubecdhkey() const;
  ::micromsg::ECDHKey* mutable_clipubecdhkey();
  ::micromsg::ECDHKey* release_clipubecdhkey();
  void set_allocated_clipubecdhkey(::micromsg::ECDHKey* clipubecdhkey);

  // @@protoc_insertion_point(class_scope:micromsg.AutoAuthRsaReqData)
 private:
  void set_has_aesencryptkey();
  void clear_has_aesencryptkey();
  void set_has_clipubecdhkey();
  void clear_has_clipubecdhkey();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* aesencryptkey_;
  ::micromsg::ECDHKey* clipubecdhkey_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AutoAuthKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AutoAuthKey) */ {
 public:
  AutoAuthKey();
  virtual ~AutoAuthKey();

  AutoAuthKey(const AutoAuthKey& from);

  inline AutoAuthKey& operator=(const AutoAuthKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoAuthKey& default_instance();

  static inline const AutoAuthKey* internal_default_instance() {
    return reinterpret_cast<const AutoAuthKey*>(
               &_AutoAuthKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    114;

  void Swap(AutoAuthKey* other);

  // implements Message ----------------------------------------------

  inline AutoAuthKey* New() const PROTOBUF_FINAL { return New(NULL); }

  AutoAuthKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AutoAuthKey& from);
  void MergeFrom(const AutoAuthKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AutoAuthKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.SKBuiltinBuffer_t EncryptKey = 1;
  bool has_encryptkey() const;
  void clear_encryptkey();
  static const int kEncryptKeyFieldNumber = 1;
  const ::micromsg::SKBuiltinBuffer_t& encryptkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_encryptkey();
  ::micromsg::SKBuiltinBuffer_t* release_encryptkey();
  void set_allocated_encryptkey(::micromsg::SKBuiltinBuffer_t* encryptkey);

  // required .micromsg.SKBuiltinBuffer_t Key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::micromsg::SKBuiltinBuffer_t& key() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_key();
  ::micromsg::SKBuiltinBuffer_t* release_key();
  void set_allocated_key(::micromsg::SKBuiltinBuffer_t* key);

  // @@protoc_insertion_point(class_scope:micromsg.AutoAuthKey)
 private:
  void set_has_encryptkey();
  void clear_has_encryptkey();
  void set_has_key();
  void clear_has_key();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::SKBuiltinBuffer_t* encryptkey_;
  ::micromsg::SKBuiltinBuffer_t* key_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AutoAuthAesReqData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AutoAuthAesReqData) */ {
 public:
  AutoAuthAesReqData();
  virtual ~AutoAuthAesReqData();

  AutoAuthAesReqData(const AutoAuthAesReqData& from);

  inline AutoAuthAesReqData& operator=(const AutoAuthAesReqData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoAuthAesReqData& default_instance();

  static inline const AutoAuthAesReqData* internal_default_instance() {
    return reinterpret_cast<const AutoAuthAesReqData*>(
               &_AutoAuthAesReqData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    115;

  void Swap(AutoAuthAesReqData* other);

  // implements Message ----------------------------------------------

  inline AutoAuthAesReqData* New() const PROTOBUF_FINAL { return New(NULL); }

  AutoAuthAesReqData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AutoAuthAesReqData& from);
  void MergeFrom(const AutoAuthAesReqData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AutoAuthAesReqData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string IMEI = 4;
  bool has_imei() const;
  void clear_imei();
  static const int kIMEIFieldNumber = 4;
  const ::std::string& imei() const;
  void set_imei(const ::std::string& value);
  #if LANG_CXX11
  void set_imei(::std::string&& value);
  #endif
  void set_imei(const char* value);
  void set_imei(const char* value, size_t size);
  ::std::string* mutable_imei();
  ::std::string* release_imei();
  void set_allocated_imei(::std::string* imei);

  // optional string SoftType = 5;
  bool has_softtype() const;
  void clear_softtype();
  static const int kSoftTypeFieldNumber = 5;
  const ::std::string& softtype() const;
  void set_softtype(const ::std::string& value);
  #if LANG_CXX11
  void set_softtype(::std::string&& value);
  #endif
  void set_softtype(const char* value);
  void set_softtype(const char* value, size_t size);
  ::std::string* mutable_softtype();
  ::std::string* release_softtype();
  void set_allocated_softtype(::std::string* softtype);

  // optional string ClientSeqID = 7;
  bool has_clientseqid() const;
  void clear_clientseqid();
  static const int kClientSeqIDFieldNumber = 7;
  const ::std::string& clientseqid() const;
  void set_clientseqid(const ::std::string& value);
  #if LANG_CXX11
  void set_clientseqid(::std::string&& value);
  #endif
  void set_clientseqid(const char* value);
  void set_clientseqid(const char* value, size_t size);
  ::std::string* mutable_clientseqid();
  ::std::string* release_clientseqid();
  void set_allocated_clientseqid(::std::string* clientseqid);

  // optional string Signature = 8;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 8;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // optional string DeviceName = 9;
  bool has_devicename() const;
  void clear_devicename();
  static const int kDeviceNameFieldNumber = 9;
  const ::std::string& devicename() const;
  void set_devicename(const ::std::string& value);
  #if LANG_CXX11
  void set_devicename(::std::string&& value);
  #endif
  void set_devicename(const char* value);
  void set_devicename(const char* value, size_t size);
  ::std::string* mutable_devicename();
  ::std::string* release_devicename();
  void set_allocated_devicename(::std::string* devicename);

  // optional string DeviceType = 10;
  bool has_devicetype() const;
  void clear_devicetype();
  static const int kDeviceTypeFieldNumber = 10;
  const ::std::string& devicetype() const;
  void set_devicetype(const ::std::string& value);
  #if LANG_CXX11
  void set_devicetype(::std::string&& value);
  #endif
  void set_devicetype(const char* value);
  void set_devicetype(const char* value, size_t size);
  ::std::string* mutable_devicetype();
  ::std::string* release_devicetype();
  void set_allocated_devicetype(::std::string* devicetype);

  // optional string Language = 11;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 11;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string TimeZone = 12;
  bool has_timezone() const;
  void clear_timezone();
  static const int kTimeZoneFieldNumber = 12;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  #if LANG_CXX11
  void set_timezone(::std::string&& value);
  #endif
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // required .micromsg.BaseRequest BaseRequest = 1;
  bool has_baserequest() const;
  void clear_baserequest();
  static const int kBaseRequestFieldNumber = 1;
  const ::micromsg::BaseRequest& baserequest() const;
  ::micromsg::BaseRequest* mutable_baserequest();
  ::micromsg::BaseRequest* release_baserequest();
  void set_allocated_baserequest(::micromsg::BaseRequest* baserequest);

  // optional .micromsg.BaseAuthReqInfo BaseReqInfo = 2;
  bool has_basereqinfo() const;
  void clear_basereqinfo();
  static const int kBaseReqInfoFieldNumber = 2;
  const ::micromsg::BaseAuthReqInfo& basereqinfo() const;
  ::micromsg::BaseAuthReqInfo* mutable_basereqinfo();
  ::micromsg::BaseAuthReqInfo* release_basereqinfo();
  void set_allocated_basereqinfo(::micromsg::BaseAuthReqInfo* basereqinfo);

  // required .micromsg.SKBuiltinBuffer_t AutoAuthKey = 3;
  bool has_autoauthkey() const;
  void clear_autoauthkey();
  static const int kAutoAuthKeyFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& autoauthkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* release_autoauthkey();
  void set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey);

  // required uint32 BuiltinIPSeq = 6;
  bool has_builtinipseq() const;
  void clear_builtinipseq();
  static const int kBuiltinIPSeqFieldNumber = 6;
  ::google::protobuf::uint32 builtinipseq() const;
  void set_builtinipseq(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.AutoAuthAesReqData)
 private:
  void set_has_baserequest();
  void clear_has_baserequest();
  void set_has_basereqinfo();
  void clear_has_basereqinfo();
  void set_has_autoauthkey();
  void clear_has_autoauthkey();
  void set_has_imei();
  void clear_has_imei();
  void set_has_softtype();
  void clear_has_softtype();
  void set_has_builtinipseq();
  void clear_has_builtinipseq();
  void set_has_clientseqid();
  void clear_has_clientseqid();
  void set_has_signature();
  void clear_has_signature();
  void set_has_devicename();
  void clear_has_devicename();
  void set_has_devicetype();
  void clear_has_devicetype();
  void set_has_language();
  void clear_has_language();
  void set_has_timezone();
  void clear_has_timezone();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr imei_;
  ::google::protobuf::internal::ArenaStringPtr softtype_;
  ::google::protobuf::internal::ArenaStringPtr clientseqid_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::internal::ArenaStringPtr devicename_;
  ::google::protobuf::internal::ArenaStringPtr devicetype_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  ::micromsg::BaseRequest* baserequest_;
  ::micromsg::BaseAuthReqInfo* basereqinfo_;
  ::micromsg::SKBuiltinBuffer_t* autoauthkey_;
  ::google::protobuf::uint32 builtinipseq_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AutoAuthRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AutoAuthRequest) */ {
 public:
  AutoAuthRequest();
  virtual ~AutoAuthRequest();

  AutoAuthRequest(const AutoAuthRequest& from);

  inline AutoAuthRequest& operator=(const AutoAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoAuthRequest& default_instance();

  static inline const AutoAuthRequest* internal_default_instance() {
    return reinterpret_cast<const AutoAuthRequest*>(
               &_AutoAuthRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    116;

  void Swap(AutoAuthRequest* other);

  // implements Message ----------------------------------------------

  inline AutoAuthRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AutoAuthRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AutoAuthRequest& from);
  void MergeFrom(const AutoAuthRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AutoAuthRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.AutoAuthRsaReqData RsaReqData = 1;
  bool has_rsareqdata() const;
  void clear_rsareqdata();
  static const int kRsaReqDataFieldNumber = 1;
  const ::micromsg::AutoAuthRsaReqData& rsareqdata() const;
  ::micromsg::AutoAuthRsaReqData* mutable_rsareqdata();
  ::micromsg::AutoAuthRsaReqData* release_rsareqdata();
  void set_allocated_rsareqdata(::micromsg::AutoAuthRsaReqData* rsareqdata);

  // required .micromsg.AutoAuthAesReqData AesReqData = 2;
  bool has_aesreqdata() const;
  void clear_aesreqdata();
  static const int kAesReqDataFieldNumber = 2;
  const ::micromsg::AutoAuthAesReqData& aesreqdata() const;
  ::micromsg::AutoAuthAesReqData* mutable_aesreqdata();
  ::micromsg::AutoAuthAesReqData* release_aesreqdata();
  void set_allocated_aesreqdata(::micromsg::AutoAuthAesReqData* aesreqdata);

  // @@protoc_insertion_point(class_scope:micromsg.AutoAuthRequest)
 private:
  void set_has_rsareqdata();
  void clear_has_rsareqdata();
  void set_has_aesreqdata();
  void clear_has_aesreqdata();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::AutoAuthRsaReqData* rsareqdata_;
  ::micromsg::AutoAuthAesReqData* aesreqdata_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetworkSectResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.NetworkSectResp) */ {
 public:
  NetworkSectResp();
  virtual ~NetworkSectResp();

  NetworkSectResp(const NetworkSectResp& from);

  inline NetworkSectResp& operator=(const NetworkSectResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkSectResp& default_instance();

  static inline const NetworkSectResp* internal_default_instance() {
    return reinterpret_cast<const NetworkSectResp*>(
               &_NetworkSectResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    117;

  void Swap(NetworkSectResp* other);

  // implements Message ----------------------------------------------

  inline NetworkSectResp* New() const PROTOBUF_FINAL { return New(NULL); }

  NetworkSectResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetworkSectResp& from);
  void MergeFrom(const NetworkSectResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetworkSectResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .micromsg.HostList NewHostList = 1;
  bool has_newhostlist() const;
  void clear_newhostlist();
  static const int kNewHostListFieldNumber = 1;
  const ::micromsg::HostList& newhostlist() const;
  ::micromsg::HostList* mutable_newhostlist();
  ::micromsg::HostList* release_newhostlist();
  void set_allocated_newhostlist(::micromsg::HostList* newhostlist);

  // optional .micromsg.NetworkControl NetworkControl = 2;
  bool has_networkcontrol() const;
  void clear_networkcontrol();
  static const int kNetworkControlFieldNumber = 2;
  const ::micromsg::NetworkControl& networkcontrol() const;
  ::micromsg::NetworkControl* mutable_networkcontrol();
  ::micromsg::NetworkControl* release_networkcontrol();
  void set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol);

  // optional .micromsg.BuiltinIPList BuiltinIPList = 3;
  bool has_builtiniplist() const;
  void clear_builtiniplist();
  static const int kBuiltinIPListFieldNumber = 3;
  const ::micromsg::BuiltinIPList& builtiniplist() const;
  ::micromsg::BuiltinIPList* mutable_builtiniplist();
  ::micromsg::BuiltinIPList* release_builtiniplist();
  void set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist);

  // @@protoc_insertion_point(class_scope:micromsg.NetworkSectResp)
 private:
  void set_has_newhostlist();
  void clear_has_newhostlist();
  void set_has_networkcontrol();
  void clear_has_networkcontrol();
  void set_has_builtiniplist();
  void clear_has_builtiniplist();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::HostList* newhostlist_;
  ::micromsg::NetworkControl* networkcontrol_;
  ::micromsg::BuiltinIPList* builtiniplist_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuthSectResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AuthSectResp) */ {
 public:
  AuthSectResp();
  virtual ~AuthSectResp();

  AuthSectResp(const AuthSectResp& from);

  inline AuthSectResp& operator=(const AuthSectResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthSectResp& default_instance();

  static inline const AuthSectResp* internal_default_instance() {
    return reinterpret_cast<const AuthSectResp*>(
               &_AuthSectResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    118;

  void Swap(AuthSectResp* other);

  // implements Message ----------------------------------------------

  inline AuthSectResp* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthSectResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthSectResp& from);
  void MergeFrom(const AuthSectResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthSectResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string AuthKey = 11;
  bool has_authkey() const;
  void clear_authkey();
  static const int kAuthKeyFieldNumber = 11;
  const ::std::string& authkey() const;
  void set_authkey(const ::std::string& value);
  #if LANG_CXX11
  void set_authkey(::std::string&& value);
  #endif
  void set_authkey(const char* value);
  void set_authkey(const char* value, size_t size);
  ::std::string* mutable_authkey();
  ::std::string* release_authkey();
  void set_allocated_authkey(::std::string* authkey);

  // optional string ApplyBetaUrl = 14;
  bool has_applybetaurl() const;
  void clear_applybetaurl();
  static const int kApplyBetaUrlFieldNumber = 14;
  const ::std::string& applybetaurl() const;
  void set_applybetaurl(const ::std::string& value);
  #if LANG_CXX11
  void set_applybetaurl(::std::string&& value);
  #endif
  void set_applybetaurl(const char* value);
  void set_applybetaurl(const char* value, size_t size);
  ::std::string* mutable_applybetaurl();
  ::std::string* release_applybetaurl();
  void set_allocated_applybetaurl(::std::string* applybetaurl);

  // optional string AuthTicket = 16;
  bool has_authticket() const;
  void clear_authticket();
  static const int kAuthTicketFieldNumber = 16;
  const ::std::string& authticket() const;
  void set_authticket(const ::std::string& value);
  #if LANG_CXX11
  void set_authticket(::std::string&& value);
  #endif
  void set_authticket(const char* value);
  void set_authticket(const char* value, size_t size);
  ::std::string* mutable_authticket();
  ::std::string* release_authticket();
  void set_allocated_authticket(::std::string* authticket);

  // optional string FSURL = 20;
  bool has_fsurl() const;
  void clear_fsurl();
  static const int kFSURLFieldNumber = 20;
  const ::std::string& fsurl() const;
  void set_fsurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fsurl(::std::string&& value);
  #endif
  void set_fsurl(const char* value);
  void set_fsurl(const char* value, size_t size);
  ::std::string* mutable_fsurl();
  ::std::string* release_fsurl();
  void set_allocated_fsurl(::std::string* fsurl);

  // required .micromsg.ECDHKey SvrPubECDHKey = 2;
  bool has_svrpubecdhkey() const;
  void clear_svrpubecdhkey();
  static const int kSvrPubECDHKeyFieldNumber = 2;
  const ::micromsg::ECDHKey& svrpubecdhkey() const;
  ::micromsg::ECDHKey* mutable_svrpubecdhkey();
  ::micromsg::ECDHKey* release_svrpubecdhkey();
  void set_allocated_svrpubecdhkey(::micromsg::ECDHKey* svrpubecdhkey);

  // required .micromsg.SKBuiltinBuffer_t SessionKey = 3;
  bool has_sessionkey() const;
  void clear_sessionkey();
  static const int kSessionKeyFieldNumber = 3;
  const ::micromsg::SKBuiltinBuffer_t& sessionkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_sessionkey();
  ::micromsg::SKBuiltinBuffer_t* release_sessionkey();
  void set_allocated_sessionkey(::micromsg::SKBuiltinBuffer_t* sessionkey);

  // required .micromsg.SKBuiltinBuffer_t AutoAuthKey = 4;
  bool has_autoauthkey() const;
  void clear_autoauthkey();
  static const int kAutoAuthKeyFieldNumber = 4;
  const ::micromsg::SKBuiltinBuffer_t& autoauthkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* release_autoauthkey();
  void set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey);

  // optional .micromsg.SKBuiltinBuffer_t WTLoginRspBuff = 6;
  bool has_wtloginrspbuff() const;
  void clear_wtloginrspbuff();
  static const int kWTLoginRspBuffFieldNumber = 6;
  const ::micromsg::SKBuiltinBuffer_t& wtloginrspbuff() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_wtloginrspbuff();
  ::micromsg::SKBuiltinBuffer_t* release_wtloginrspbuff();
  void set_allocated_wtloginrspbuff(::micromsg::SKBuiltinBuffer_t* wtloginrspbuff);

  // optional .micromsg.WTLoginImgRespInfo WTLoginImgRespInfo = 7;
  bool has_wtloginimgrespinfo() const;
  void clear_wtloginimgrespinfo();
  static const int kWTLoginImgRespInfoFieldNumber = 7;
  const ::micromsg::WTLoginImgRespInfo& wtloginimgrespinfo() const;
  ::micromsg::WTLoginImgRespInfo* mutable_wtloginimgrespinfo();
  ::micromsg::WTLoginImgRespInfo* release_wtloginimgrespinfo();
  void set_allocated_wtloginimgrespinfo(::micromsg::WTLoginImgRespInfo* wtloginimgrespinfo);

  // optional .micromsg.WxVerifyCodeRespInfo WxVerifyCodeRespInfo = 8;
  bool has_wxverifycoderespinfo() const;
  void clear_wxverifycoderespinfo();
  static const int kWxVerifyCodeRespInfoFieldNumber = 8;
  const ::micromsg::WxVerifyCodeRespInfo& wxverifycoderespinfo() const;
  ::micromsg::WxVerifyCodeRespInfo* mutable_wxverifycoderespinfo();
  ::micromsg::WxVerifyCodeRespInfo* release_wxverifycoderespinfo();
  void set_allocated_wxverifycoderespinfo(::micromsg::WxVerifyCodeRespInfo* wxverifycoderespinfo);

  // optional .micromsg.SKBuiltinBuffer_t CliDBEncryptKey = 9;
  bool has_clidbencryptkey() const;
  void clear_clidbencryptkey();
  static const int kCliDBEncryptKeyFieldNumber = 9;
  const ::micromsg::SKBuiltinBuffer_t& clidbencryptkey() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_clidbencryptkey();
  ::micromsg::SKBuiltinBuffer_t* release_clidbencryptkey();
  void set_allocated_clidbencryptkey(::micromsg::SKBuiltinBuffer_t* clidbencryptkey);

  // optional .micromsg.SKBuiltinBuffer_t CliDBEncryptInfo = 10;
  bool has_clidbencryptinfo() const;
  void clear_clidbencryptinfo();
  static const int kCliDBEncryptInfoFieldNumber = 10;
  const ::micromsg::SKBuiltinBuffer_t& clidbencryptinfo() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_clidbencryptinfo();
  ::micromsg::SKBuiltinBuffer_t* release_clidbencryptinfo();
  void set_allocated_clidbencryptinfo(::micromsg::SKBuiltinBuffer_t* clidbencryptinfo);

  // optional .micromsg.SKBuiltinBuffer_t A2Key = 12;
  bool has_a2key() const;
  void clear_a2key();
  static const int kA2KeyFieldNumber = 12;
  const ::micromsg::SKBuiltinBuffer_t& a2key() const;
  ::micromsg::SKBuiltinBuffer_t* mutable_a2key();
  ::micromsg::SKBuiltinBuffer_t* release_a2key();
  void set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key);

  // optional .micromsg.ShowStyleKey ShowStyle = 15;
  bool has_showstyle() const;
  void clear_showstyle();
  static const int kShowStyleFieldNumber = 15;
  const ::micromsg::ShowStyleKey& showstyle() const;
  ::micromsg::ShowStyleKey* mutable_showstyle();
  ::micromsg::ShowStyleKey* release_showstyle();
  void set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle);

  // required uint32 Uin = 1;
  bool has_uin() const;
  void clear_uin();
  static const int kUinFieldNumber = 1;
  ::google::protobuf::uint32 uin() const;
  void set_uin(::google::protobuf::uint32 value);

  // required uint32 WTLoginRspBuffFlag = 5;
  bool has_wtloginrspbuffflag() const;
  void clear_wtloginrspbuffflag();
  static const int kWTLoginRspBuffFlagFieldNumber = 5;
  ::google::protobuf::uint32 wtloginrspbuffflag() const;
  void set_wtloginrspbuffflag(::google::protobuf::uint32 value);

  // optional uint32 NewVersion = 17;
  bool has_newversion() const;
  void clear_newversion();
  static const int kNewVersionFieldNumber = 17;
  ::google::protobuf::uint32 newversion() const;
  void set_newversion(::google::protobuf::uint32 value);

  // optional uint32 UpdateFlag = 18;
  bool has_updateflag() const;
  void clear_updateflag();
  static const int kUpdateFlagFieldNumber = 18;
  ::google::protobuf::uint32 updateflag() const;
  void set_updateflag(::google::protobuf::uint32 value);

  // optional uint32 AuthResultFlag = 19;
  bool has_authresultflag() const;
  void clear_authresultflag();
  static const int kAuthResultFlagFieldNumber = 19;
  ::google::protobuf::uint32 authresultflag() const;
  void set_authresultflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.AuthSectResp)
 private:
  void set_has_uin();
  void clear_has_uin();
  void set_has_svrpubecdhkey();
  void clear_has_svrpubecdhkey();
  void set_has_sessionkey();
  void clear_has_sessionkey();
  void set_has_autoauthkey();
  void clear_has_autoauthkey();
  void set_has_wtloginrspbuffflag();
  void clear_has_wtloginrspbuffflag();
  void set_has_wtloginrspbuff();
  void clear_has_wtloginrspbuff();
  void set_has_wtloginimgrespinfo();
  void clear_has_wtloginimgrespinfo();
  void set_has_wxverifycoderespinfo();
  void clear_has_wxverifycoderespinfo();
  void set_has_clidbencryptkey();
  void clear_has_clidbencryptkey();
  void set_has_clidbencryptinfo();
  void clear_has_clidbencryptinfo();
  void set_has_authkey();
  void clear_has_authkey();
  void set_has_a2key();
  void clear_has_a2key();
  void set_has_applybetaurl();
  void clear_has_applybetaurl();
  void set_has_showstyle();
  void clear_has_showstyle();
  void set_has_authticket();
  void clear_has_authticket();
  void set_has_newversion();
  void clear_has_newversion();
  void set_has_updateflag();
  void clear_has_updateflag();
  void set_has_authresultflag();
  void clear_has_authresultflag();
  void set_has_fsurl();
  void clear_has_fsurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr authkey_;
  ::google::protobuf::internal::ArenaStringPtr applybetaurl_;
  ::google::protobuf::internal::ArenaStringPtr authticket_;
  ::google::protobuf::internal::ArenaStringPtr fsurl_;
  ::micromsg::ECDHKey* svrpubecdhkey_;
  ::micromsg::SKBuiltinBuffer_t* sessionkey_;
  ::micromsg::SKBuiltinBuffer_t* autoauthkey_;
  ::micromsg::SKBuiltinBuffer_t* wtloginrspbuff_;
  ::micromsg::WTLoginImgRespInfo* wtloginimgrespinfo_;
  ::micromsg::WxVerifyCodeRespInfo* wxverifycoderespinfo_;
  ::micromsg::SKBuiltinBuffer_t* clidbencryptkey_;
  ::micromsg::SKBuiltinBuffer_t* clidbencryptinfo_;
  ::micromsg::SKBuiltinBuffer_t* a2key_;
  ::micromsg::ShowStyleKey* showstyle_;
  ::google::protobuf::uint32 uin_;
  ::google::protobuf::uint32 wtloginrspbuffflag_;
  ::google::protobuf::uint32 newversion_;
  ::google::protobuf::uint32 updateflag_;
  ::google::protobuf::uint32 authresultflag_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AcctSectResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.AcctSectResp) */ {
 public:
  AcctSectResp();
  virtual ~AcctSectResp();

  AcctSectResp(const AcctSectResp& from);

  inline AcctSectResp& operator=(const AcctSectResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcctSectResp& default_instance();

  static inline const AcctSectResp* internal_default_instance() {
    return reinterpret_cast<const AcctSectResp*>(
               &_AcctSectResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    119;

  void Swap(AcctSectResp* other);

  // implements Message ----------------------------------------------

  inline AcctSectResp* New() const PROTOBUF_FINAL { return New(NULL); }

  AcctSectResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AcctSectResp& from);
  void MergeFrom(const AcctSectResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AcctSectResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string UserName = 1;
  bool has_username() const;
  void clear_username();
  static const int kUserNameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string NickName = 2;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional string BindEmail = 4;
  bool has_bindemail() const;
  void clear_bindemail();
  static const int kBindEmailFieldNumber = 4;
  const ::std::string& bindemail() const;
  void set_bindemail(const ::std::string& value);
  #if LANG_CXX11
  void set_bindemail(::std::string&& value);
  #endif
  void set_bindemail(const char* value);
  void set_bindemail(const char* value, size_t size);
  ::std::string* mutable_bindemail();
  ::std::string* release_bindemail();
  void set_allocated_bindemail(::std::string* bindemail);

  // optional string BindMobile = 5;
  bool has_bindmobile() const;
  void clear_bindmobile();
  static const int kBindMobileFieldNumber = 5;
  const ::std::string& bindmobile() const;
  void set_bindmobile(const ::std::string& value);
  #if LANG_CXX11
  void set_bindmobile(::std::string&& value);
  #endif
  void set_bindmobile(const char* value);
  void set_bindmobile(const char* value, size_t size);
  ::std::string* mutable_bindmobile();
  ::std::string* release_bindmobile();
  void set_allocated_bindmobile(::std::string* bindmobile);

  // optional string Alias = 6;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 6;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // optional string DeviceInfoXml = 11;
  bool has_deviceinfoxml() const;
  void clear_deviceinfoxml();
  static const int kDeviceInfoXmlFieldNumber = 11;
  const ::std::string& deviceinfoxml() const;
  void set_deviceinfoxml(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceinfoxml(::std::string&& value);
  #endif
  void set_deviceinfoxml(const char* value);
  void set_deviceinfoxml(const char* value, size_t size);
  ::std::string* mutable_deviceinfoxml();
  ::std::string* release_deviceinfoxml();
  void set_allocated_deviceinfoxml(::std::string* deviceinfoxml);

  // optional string OfficialUserName = 13;
  bool has_officialusername() const;
  void clear_officialusername();
  static const int kOfficialUserNameFieldNumber = 13;
  const ::std::string& officialusername() const;
  void set_officialusername(const ::std::string& value);
  #if LANG_CXX11
  void set_officialusername(::std::string&& value);
  #endif
  void set_officialusername(const char* value);
  void set_officialusername(const char* value, size_t size);
  ::std::string* mutable_officialusername();
  ::std::string* release_officialusername();
  void set_allocated_officialusername(::std::string* officialusername);

  // optional string OfficialNickName = 14;
  bool has_officialnickname() const;
  void clear_officialnickname();
  static const int kOfficialNickNameFieldNumber = 14;
  const ::std::string& officialnickname() const;
  void set_officialnickname(const ::std::string& value);
  #if LANG_CXX11
  void set_officialnickname(::std::string&& value);
  #endif
  void set_officialnickname(const char* value);
  void set_officialnickname(const char* value, size_t size);
  ::std::string* mutable_officialnickname();
  ::std::string* release_officialnickname();
  void set_allocated_officialnickname(::std::string* officialnickname);

  // optional string FSURL = 16;
  bool has_fsurl() const;
  void clear_fsurl();
  static const int kFSURLFieldNumber = 16;
  const ::std::string& fsurl() const;
  void set_fsurl(const ::std::string& value);
  #if LANG_CXX11
  void set_fsurl(::std::string&& value);
  #endif
  void set_fsurl(const char* value);
  void set_fsurl(const char* value, size_t size);
  ::std::string* mutable_fsurl();
  ::std::string* release_fsurl();
  void set_allocated_fsurl(::std::string* fsurl);

  // required uint32 BindUin = 3;
  bool has_binduin() const;
  void clear_binduin();
  static const int kBindUinFieldNumber = 3;
  ::google::protobuf::uint32 binduin() const;
  void set_binduin(::google::protobuf::uint32 value);

  // required uint32 Status = 8;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 8;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // optional uint32 PluginFlag = 9;
  bool has_pluginflag() const;
  void clear_pluginflag();
  static const int kPluginFlagFieldNumber = 9;
  ::google::protobuf::uint32 pluginflag() const;
  void set_pluginflag(::google::protobuf::uint32 value);

  // optional uint32 RegType = 10;
  bool has_regtype() const;
  void clear_regtype();
  static const int kRegTypeFieldNumber = 10;
  ::google::protobuf::uint32 regtype() const;
  void set_regtype(::google::protobuf::uint32 value);

  // optional uint32 SafeDevice = 12;
  bool has_safedevice() const;
  void clear_safedevice();
  static const int kSafeDeviceFieldNumber = 12;
  ::google::protobuf::uint32 safedevice() const;
  void set_safedevice(::google::protobuf::uint32 value);

  // optional uint32 PushMailStatus = 15;
  bool has_pushmailstatus() const;
  void clear_pushmailstatus();
  static const int kPushMailStatusFieldNumber = 15;
  ::google::protobuf::uint32 pushmailstatus() const;
  void set_pushmailstatus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.AcctSectResp)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_nickname();
  void clear_has_nickname();
  void set_has_binduin();
  void clear_has_binduin();
  void set_has_bindemail();
  void clear_has_bindemail();
  void set_has_bindmobile();
  void clear_has_bindmobile();
  void set_has_alias();
  void clear_has_alias();
  void set_has_status();
  void clear_has_status();
  void set_has_pluginflag();
  void clear_has_pluginflag();
  void set_has_regtype();
  void clear_has_regtype();
  void set_has_deviceinfoxml();
  void clear_has_deviceinfoxml();
  void set_has_safedevice();
  void clear_has_safedevice();
  void set_has_officialusername();
  void clear_has_officialusername();
  void set_has_officialnickname();
  void clear_has_officialnickname();
  void set_has_pushmailstatus();
  void clear_has_pushmailstatus();
  void set_has_fsurl();
  void clear_has_fsurl();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr bindemail_;
  ::google::protobuf::internal::ArenaStringPtr bindmobile_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  ::google::protobuf::internal::ArenaStringPtr deviceinfoxml_;
  ::google::protobuf::internal::ArenaStringPtr officialusername_;
  ::google::protobuf::internal::ArenaStringPtr officialnickname_;
  ::google::protobuf::internal::ArenaStringPtr fsurl_;
  ::google::protobuf::uint32 binduin_;
  ::google::protobuf::uint32 status_;
  ::google::protobuf::uint32 pluginflag_;
  ::google::protobuf::uint32 regtype_;
  ::google::protobuf::uint32 safedevice_;
  ::google::protobuf::uint32 pushmailstatus_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnifyAuthResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:micromsg.UnifyAuthResponse) */ {
 public:
  UnifyAuthResponse();
  virtual ~UnifyAuthResponse();

  UnifyAuthResponse(const UnifyAuthResponse& from);

  inline UnifyAuthResponse& operator=(const UnifyAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnifyAuthResponse& default_instance();

  static inline const UnifyAuthResponse* internal_default_instance() {
    return reinterpret_cast<const UnifyAuthResponse*>(
               &_UnifyAuthResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    120;

  void Swap(UnifyAuthResponse* other);

  // implements Message ----------------------------------------------

  inline UnifyAuthResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UnifyAuthResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnifyAuthResponse& from);
  void MergeFrom(const UnifyAuthResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnifyAuthResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .micromsg.BaseResponse BaseResponse = 1;
  bool has_baseresponse() const;
  void clear_baseresponse();
  static const int kBaseResponseFieldNumber = 1;
  const ::micromsg::BaseResponse& baseresponse() const;
  ::micromsg::BaseResponse* mutable_baseresponse();
  ::micromsg::BaseResponse* release_baseresponse();
  void set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse);

  // optional .micromsg.AuthSectResp AuthSectResp = 3;
  bool has_authsectresp() const;
  void clear_authsectresp();
  static const int kAuthSectRespFieldNumber = 3;
  const ::micromsg::AuthSectResp& authsectresp() const;
  ::micromsg::AuthSectResp* mutable_authsectresp();
  ::micromsg::AuthSectResp* release_authsectresp();
  void set_allocated_authsectresp(::micromsg::AuthSectResp* authsectresp);

  // optional .micromsg.AcctSectResp AcctSectResp = 4;
  bool has_acctsectresp() const;
  void clear_acctsectresp();
  static const int kAcctSectRespFieldNumber = 4;
  const ::micromsg::AcctSectResp& acctsectresp() const;
  ::micromsg::AcctSectResp* mutable_acctsectresp();
  ::micromsg::AcctSectResp* release_acctsectresp();
  void set_allocated_acctsectresp(::micromsg::AcctSectResp* acctsectresp);

  // optional .micromsg.NetworkSectResp NetworkSectResp = 5;
  bool has_networksectresp() const;
  void clear_networksectresp();
  static const int kNetworkSectRespFieldNumber = 5;
  const ::micromsg::NetworkSectResp& networksectresp() const;
  ::micromsg::NetworkSectResp* mutable_networksectresp();
  ::micromsg::NetworkSectResp* release_networksectresp();
  void set_allocated_networksectresp(::micromsg::NetworkSectResp* networksectresp);

  // optional uint32 UnifyAuthSectFlag = 2;
  bool has_unifyauthsectflag() const;
  void clear_unifyauthsectflag();
  static const int kUnifyAuthSectFlagFieldNumber = 2;
  ::google::protobuf::uint32 unifyauthsectflag() const;
  void set_unifyauthsectflag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:micromsg.UnifyAuthResponse)
 private:
  void set_has_baseresponse();
  void clear_has_baseresponse();
  void set_has_unifyauthsectflag();
  void clear_has_unifyauthsectflag();
  void set_has_authsectresp();
  void clear_has_authsectresp();
  void set_has_acctsectresp();
  void clear_has_acctsectresp();
  void set_has_networksectresp();
  void clear_has_networksectresp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::micromsg::BaseResponse* baseresponse_;
  ::micromsg::AuthSectResp* authsectresp_;
  ::micromsg::AcctSectResp* acctsectresp_;
  ::micromsg::NetworkSectResp* networksectresp_;
  ::google::protobuf::uint32 unifyauthsectflag_;
  friend struct protobuf_mmlogin_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ECDHKey

// required int32 Nid = 1;
inline bool ECDHKey::has_nid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ECDHKey::set_has_nid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ECDHKey::clear_has_nid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ECDHKey::clear_nid() {
  nid_ = 0;
  clear_has_nid();
}
inline ::google::protobuf::int32 ECDHKey::nid() const {
  // @@protoc_insertion_point(field_get:micromsg.ECDHKey.Nid)
  return nid_;
}
inline void ECDHKey::set_nid(::google::protobuf::int32 value) {
  set_has_nid();
  nid_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ECDHKey.Nid)
}

// required .micromsg.SKBuiltinBuffer_t Key = 2;
inline bool ECDHKey::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ECDHKey::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ECDHKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ECDHKey::clear_key() {
  if (key_ != NULL) key_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_key();
}
inline const ::micromsg::SKBuiltinBuffer_t& ECDHKey::key() const {
  // @@protoc_insertion_point(field_get:micromsg.ECDHKey.Key)
  return key_ != NULL ? *key_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* ECDHKey::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    key_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ECDHKey.Key)
  return key_;
}
inline ::micromsg::SKBuiltinBuffer_t* ECDHKey::release_key() {
  // @@protoc_insertion_point(field_release:micromsg.ECDHKey.Key)
  clear_has_key();
  ::micromsg::SKBuiltinBuffer_t* temp = key_;
  key_ = NULL;
  return temp;
}
inline void ECDHKey::set_allocated_key(::micromsg::SKBuiltinBuffer_t* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ECDHKey.Key)
}

// -------------------------------------------------------------------

// NewRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool NewRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NewRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NewRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NewRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& NewRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* NewRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* NewRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void NewRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.BaseRequest)
}

// optional string UserName = 2;
inline bool NewRegRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewRegRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewRegRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewRegRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& NewRegRequest::username() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.UserName)
  return username_.GetNoArena();
}
inline void NewRegRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.UserName)
}
#if LANG_CXX11
inline void NewRegRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.UserName)
}
#endif
inline void NewRegRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.UserName)
}
inline void NewRegRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.UserName)
}
inline ::std::string* NewRegRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.UserName)
}

// optional string Pwd = 3;
inline bool NewRegRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewRegRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewRegRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewRegRequest::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd();
}
inline const ::std::string& NewRegRequest::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.Pwd)
  return pwd_.GetNoArena();
}
inline void NewRegRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.Pwd)
}
#if LANG_CXX11
inline void NewRegRequest::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.Pwd)
}
#endif
inline void NewRegRequest::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.Pwd)
}
inline void NewRegRequest::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.Pwd)
}
inline ::std::string* NewRegRequest::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.Pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.Pwd)
  clear_has_pwd();
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.Pwd)
}

// optional string NickName = 4;
inline bool NewRegRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewRegRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewRegRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewRegRequest::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& NewRegRequest::nickname() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.NickName)
  return nickname_.GetNoArena();
}
inline void NewRegRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.NickName)
}
#if LANG_CXX11
inline void NewRegRequest::set_nickname(::std::string&& value) {
  set_has_nickname();
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.NickName)
}
#endif
inline void NewRegRequest::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.NickName)
}
inline void NewRegRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.NickName)
}
inline ::std::string* NewRegRequest::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.NickName)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_nickname() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.NickName)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.NickName)
}

// optional uint32 BindUin = 5;
inline bool NewRegRequest::has_binduin() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void NewRegRequest::set_has_binduin() {
  _has_bits_[0] |= 0x00800000u;
}
inline void NewRegRequest::clear_has_binduin() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void NewRegRequest::clear_binduin() {
  binduin_ = 0u;
  clear_has_binduin();
}
inline ::google::protobuf::uint32 NewRegRequest::binduin() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.BindUin)
  return binduin_;
}
inline void NewRegRequest::set_binduin(::google::protobuf::uint32 value) {
  set_has_binduin();
  binduin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.BindUin)
}

// optional string BindEmail = 6;
inline bool NewRegRequest::has_bindemail() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewRegRequest::set_has_bindemail() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewRegRequest::clear_has_bindemail() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewRegRequest::clear_bindemail() {
  bindemail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bindemail();
}
inline const ::std::string& NewRegRequest::bindemail() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.BindEmail)
  return bindemail_.GetNoArena();
}
inline void NewRegRequest::set_bindemail(const ::std::string& value) {
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.BindEmail)
}
#if LANG_CXX11
inline void NewRegRequest::set_bindemail(::std::string&& value) {
  set_has_bindemail();
  bindemail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.BindEmail)
}
#endif
inline void NewRegRequest::set_bindemail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.BindEmail)
}
inline void NewRegRequest::set_bindemail(const char* value, size_t size) {
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.BindEmail)
}
inline ::std::string* NewRegRequest::mutable_bindemail() {
  set_has_bindemail();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.BindEmail)
  return bindemail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_bindemail() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.BindEmail)
  clear_has_bindemail();
  return bindemail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_bindemail(::std::string* bindemail) {
  if (bindemail != NULL) {
    set_has_bindemail();
  } else {
    clear_has_bindemail();
  }
  bindemail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bindemail);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.BindEmail)
}

// optional string BindMobile = 7;
inline bool NewRegRequest::has_bindmobile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewRegRequest::set_has_bindmobile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewRegRequest::clear_has_bindmobile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewRegRequest::clear_bindmobile() {
  bindmobile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bindmobile();
}
inline const ::std::string& NewRegRequest::bindmobile() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.BindMobile)
  return bindmobile_.GetNoArena();
}
inline void NewRegRequest::set_bindmobile(const ::std::string& value) {
  set_has_bindmobile();
  bindmobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.BindMobile)
}
#if LANG_CXX11
inline void NewRegRequest::set_bindmobile(::std::string&& value) {
  set_has_bindmobile();
  bindmobile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.BindMobile)
}
#endif
inline void NewRegRequest::set_bindmobile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bindmobile();
  bindmobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.BindMobile)
}
inline void NewRegRequest::set_bindmobile(const char* value, size_t size) {
  set_has_bindmobile();
  bindmobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.BindMobile)
}
inline ::std::string* NewRegRequest::mutable_bindmobile() {
  set_has_bindmobile();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.BindMobile)
  return bindmobile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_bindmobile() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.BindMobile)
  clear_has_bindmobile();
  return bindmobile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_bindmobile(::std::string* bindmobile) {
  if (bindmobile != NULL) {
    set_has_bindmobile();
  } else {
    clear_has_bindmobile();
  }
  bindmobile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bindmobile);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.BindMobile)
}

// optional string Ticket = 8;
inline bool NewRegRequest::has_ticket() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewRegRequest::set_has_ticket() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewRegRequest::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewRegRequest::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& NewRegRequest::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.Ticket)
  return ticket_.GetNoArena();
}
inline void NewRegRequest::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.Ticket)
}
#if LANG_CXX11
inline void NewRegRequest::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.Ticket)
}
#endif
inline void NewRegRequest::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.Ticket)
}
inline void NewRegRequest::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.Ticket)
}
inline ::std::string* NewRegRequest::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.Ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.Ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.Ticket)
}

// optional uint32 BuiltinIPSeq = 12;
inline bool NewRegRequest::has_builtinipseq() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void NewRegRequest::set_has_builtinipseq() {
  _has_bits_[0] |= 0x01000000u;
}
inline void NewRegRequest::clear_has_builtinipseq() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void NewRegRequest::clear_builtinipseq() {
  builtinipseq_ = 0u;
  clear_has_builtinipseq();
}
inline ::google::protobuf::uint32 NewRegRequest::builtinipseq() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.BuiltinIPSeq)
  return builtinipseq_;
}
inline void NewRegRequest::set_builtinipseq(::google::protobuf::uint32 value) {
  set_has_builtinipseq();
  builtinipseq_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.BuiltinIPSeq)
}

// optional uint32 DLSrc = 13;
inline bool NewRegRequest::has_dlsrc() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void NewRegRequest::set_has_dlsrc() {
  _has_bits_[0] |= 0x02000000u;
}
inline void NewRegRequest::clear_has_dlsrc() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void NewRegRequest::clear_dlsrc() {
  dlsrc_ = 0u;
  clear_has_dlsrc();
}
inline ::google::protobuf::uint32 NewRegRequest::dlsrc() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.DLSrc)
  return dlsrc_;
}
inline void NewRegRequest::set_dlsrc(::google::protobuf::uint32 value) {
  set_has_dlsrc();
  dlsrc_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.DLSrc)
}

// optional uint32 RegMode = 14;
inline bool NewRegRequest::has_regmode() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void NewRegRequest::set_has_regmode() {
  _has_bits_[0] |= 0x04000000u;
}
inline void NewRegRequest::clear_has_regmode() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void NewRegRequest::clear_regmode() {
  regmode_ = 0u;
  clear_has_regmode();
}
inline ::google::protobuf::uint32 NewRegRequest::regmode() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.RegMode)
  return regmode_;
}
inline void NewRegRequest::set_regmode(::google::protobuf::uint32 value) {
  set_has_regmode();
  regmode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.RegMode)
}

// optional string TimeZone = 15;
inline bool NewRegRequest::has_timezone() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewRegRequest::set_has_timezone() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewRegRequest::clear_has_timezone() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewRegRequest::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timezone();
}
inline const ::std::string& NewRegRequest::timezone() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.TimeZone)
  return timezone_.GetNoArena();
}
inline void NewRegRequest::set_timezone(const ::std::string& value) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.TimeZone)
}
#if LANG_CXX11
inline void NewRegRequest::set_timezone(::std::string&& value) {
  set_has_timezone();
  timezone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.TimeZone)
}
#endif
inline void NewRegRequest::set_timezone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.TimeZone)
}
inline void NewRegRequest::set_timezone(const char* value, size_t size) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.TimeZone)
}
inline ::std::string* NewRegRequest::mutable_timezone() {
  set_has_timezone();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.TimeZone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_timezone() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.TimeZone)
  clear_has_timezone();
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    set_has_timezone();
  } else {
    clear_has_timezone();
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.TimeZone)
}

// optional string Language = 16;
inline bool NewRegRequest::has_language() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NewRegRequest::set_has_language() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NewRegRequest::clear_has_language() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NewRegRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& NewRegRequest::language() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.Language)
  return language_.GetNoArena();
}
inline void NewRegRequest::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.Language)
}
#if LANG_CXX11
inline void NewRegRequest::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.Language)
}
#endif
inline void NewRegRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.Language)
}
inline void NewRegRequest::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.Language)
}
inline ::std::string* NewRegRequest::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.Language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_language() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.Language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.Language)
}

// optional uint32 ForceReg = 17;
inline bool NewRegRequest::has_forcereg() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void NewRegRequest::set_has_forcereg() {
  _has_bits_[0] |= 0x08000000u;
}
inline void NewRegRequest::clear_has_forcereg() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void NewRegRequest::clear_forcereg() {
  forcereg_ = 0u;
  clear_has_forcereg();
}
inline ::google::protobuf::uint32 NewRegRequest::forcereg() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.ForceReg)
  return forcereg_;
}
inline void NewRegRequest::set_forcereg(::google::protobuf::uint32 value) {
  set_has_forcereg();
  forcereg_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.ForceReg)
}

// optional string RealCountry = 18;
inline bool NewRegRequest::has_realcountry() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NewRegRequest::set_has_realcountry() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NewRegRequest::clear_has_realcountry() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NewRegRequest::clear_realcountry() {
  realcountry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_realcountry();
}
inline const ::std::string& NewRegRequest::realcountry() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.RealCountry)
  return realcountry_.GetNoArena();
}
inline void NewRegRequest::set_realcountry(const ::std::string& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.RealCountry)
}
#if LANG_CXX11
inline void NewRegRequest::set_realcountry(::std::string&& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.RealCountry)
}
#endif
inline void NewRegRequest::set_realcountry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.RealCountry)
}
inline void NewRegRequest::set_realcountry(const char* value, size_t size) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.RealCountry)
}
inline ::std::string* NewRegRequest::mutable_realcountry() {
  set_has_realcountry();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.RealCountry)
  return realcountry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_realcountry() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.RealCountry)
  clear_has_realcountry();
  return realcountry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_realcountry(::std::string* realcountry) {
  if (realcountry != NULL) {
    set_has_realcountry();
  } else {
    clear_has_realcountry();
  }
  realcountry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), realcountry);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.RealCountry)
}

// optional .micromsg.SKBuiltinBuffer_t RandomEncryKey = 19;
inline bool NewRegRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NewRegRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NewRegRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NewRegRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewRegRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewRegRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewRegRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void NewRegRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.RandomEncryKey)
}

// optional string Alias = 20;
inline bool NewRegRequest::has_alias() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NewRegRequest::set_has_alias() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NewRegRequest::clear_has_alias() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NewRegRequest::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
inline const ::std::string& NewRegRequest::alias() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.Alias)
  return alias_.GetNoArena();
}
inline void NewRegRequest::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.Alias)
}
#if LANG_CXX11
inline void NewRegRequest::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.Alias)
}
#endif
inline void NewRegRequest::set_alias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.Alias)
}
inline void NewRegRequest::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.Alias)
}
inline ::std::string* NewRegRequest::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.Alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_alias() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.Alias)
  clear_has_alias();
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.Alias)
}

// optional string VerifySignature = 21;
inline bool NewRegRequest::has_verifysignature() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NewRegRequest::set_has_verifysignature() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NewRegRequest::clear_has_verifysignature() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NewRegRequest::clear_verifysignature() {
  verifysignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifysignature();
}
inline const ::std::string& NewRegRequest::verifysignature() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.VerifySignature)
  return verifysignature_.GetNoArena();
}
inline void NewRegRequest::set_verifysignature(const ::std::string& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.VerifySignature)
}
#if LANG_CXX11
inline void NewRegRequest::set_verifysignature(::std::string&& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.VerifySignature)
}
#endif
inline void NewRegRequest::set_verifysignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.VerifySignature)
}
inline void NewRegRequest::set_verifysignature(const char* value, size_t size) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.VerifySignature)
}
inline ::std::string* NewRegRequest::mutable_verifysignature() {
  set_has_verifysignature();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.VerifySignature)
  return verifysignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_verifysignature() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.VerifySignature)
  clear_has_verifysignature();
  return verifysignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_verifysignature(::std::string* verifysignature) {
  if (verifysignature != NULL) {
    set_has_verifysignature();
  } else {
    clear_has_verifysignature();
  }
  verifysignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifysignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.VerifySignature)
}

// optional string VerifyContent = 22;
inline bool NewRegRequest::has_verifycontent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NewRegRequest::set_has_verifycontent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NewRegRequest::clear_has_verifycontent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NewRegRequest::clear_verifycontent() {
  verifycontent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifycontent();
}
inline const ::std::string& NewRegRequest::verifycontent() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.VerifyContent)
  return verifycontent_.GetNoArena();
}
inline void NewRegRequest::set_verifycontent(const ::std::string& value) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.VerifyContent)
}
#if LANG_CXX11
inline void NewRegRequest::set_verifycontent(::std::string&& value) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.VerifyContent)
}
#endif
inline void NewRegRequest::set_verifycontent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.VerifyContent)
}
inline void NewRegRequest::set_verifycontent(const char* value, size_t size) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.VerifyContent)
}
inline ::std::string* NewRegRequest::mutable_verifycontent() {
  set_has_verifycontent();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.VerifyContent)
  return verifycontent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_verifycontent() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.VerifyContent)
  clear_has_verifycontent();
  return verifycontent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_verifycontent(::std::string* verifycontent) {
  if (verifycontent != NULL) {
    set_has_verifycontent();
  } else {
    clear_has_verifycontent();
  }
  verifycontent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifycontent);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.VerifyContent)
}

// optional uint32 HasHeadImg = 23;
inline bool NewRegRequest::has_hasheadimg() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void NewRegRequest::set_has_hasheadimg() {
  _has_bits_[0] |= 0x10000000u;
}
inline void NewRegRequest::clear_has_hasheadimg() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void NewRegRequest::clear_hasheadimg() {
  hasheadimg_ = 0u;
  clear_has_hasheadimg();
}
inline ::google::protobuf::uint32 NewRegRequest::hasheadimg() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.HasHeadImg)
  return hasheadimg_;
}
inline void NewRegRequest::set_hasheadimg(::google::protobuf::uint32 value) {
  set_has_hasheadimg();
  hasheadimg_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.HasHeadImg)
}

// optional uint32 SuggestRet = 24;
inline bool NewRegRequest::has_suggestret() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void NewRegRequest::set_has_suggestret() {
  _has_bits_[0] |= 0x20000000u;
}
inline void NewRegRequest::clear_has_suggestret() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void NewRegRequest::clear_suggestret() {
  suggestret_ = 0u;
  clear_has_suggestret();
}
inline ::google::protobuf::uint32 NewRegRequest::suggestret() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.SuggestRet)
  return suggestret_;
}
inline void NewRegRequest::set_suggestret(::google::protobuf::uint32 value) {
  set_has_suggestret();
  suggestret_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.SuggestRet)
}

// optional string ClientSeqID = 31;
inline bool NewRegRequest::has_clientseqid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NewRegRequest::set_has_clientseqid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NewRegRequest::clear_has_clientseqid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NewRegRequest::clear_clientseqid() {
  clientseqid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientseqid();
}
inline const ::std::string& NewRegRequest::clientseqid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.ClientSeqID)
  return clientseqid_.GetNoArena();
}
inline void NewRegRequest::set_clientseqid(const ::std::string& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.ClientSeqID)
}
#if LANG_CXX11
inline void NewRegRequest::set_clientseqid(::std::string&& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.ClientSeqID)
}
#endif
inline void NewRegRequest::set_clientseqid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.ClientSeqID)
}
inline void NewRegRequest::set_clientseqid(const char* value, size_t size) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.ClientSeqID)
}
inline ::std::string* NewRegRequest::mutable_clientseqid() {
  set_has_clientseqid();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.ClientSeqID)
  return clientseqid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_clientseqid() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.ClientSeqID)
  clear_has_clientseqid();
  return clientseqid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_clientseqid(::std::string* clientseqid) {
  if (clientseqid != NULL) {
    set_has_clientseqid();
  } else {
    clear_has_clientseqid();
  }
  clientseqid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientseqid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.ClientSeqID)
}

// optional string AdSource = 32;
inline bool NewRegRequest::has_adsource() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NewRegRequest::set_has_adsource() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NewRegRequest::clear_has_adsource() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NewRegRequest::clear_adsource() {
  adsource_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_adsource();
}
inline const ::std::string& NewRegRequest::adsource() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.AdSource)
  return adsource_.GetNoArena();
}
inline void NewRegRequest::set_adsource(const ::std::string& value) {
  set_has_adsource();
  adsource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.AdSource)
}
#if LANG_CXX11
inline void NewRegRequest::set_adsource(::std::string&& value) {
  set_has_adsource();
  adsource_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.AdSource)
}
#endif
inline void NewRegRequest::set_adsource(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_adsource();
  adsource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.AdSource)
}
inline void NewRegRequest::set_adsource(const char* value, size_t size) {
  set_has_adsource();
  adsource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.AdSource)
}
inline ::std::string* NewRegRequest::mutable_adsource() {
  set_has_adsource();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.AdSource)
  return adsource_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_adsource() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.AdSource)
  clear_has_adsource();
  return adsource_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_adsource(::std::string* adsource) {
  if (adsource != NULL) {
    set_has_adsource();
  } else {
    clear_has_adsource();
  }
  adsource_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adsource);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.AdSource)
}

// optional string AndroidID = 33;
inline bool NewRegRequest::has_androidid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NewRegRequest::set_has_androidid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NewRegRequest::clear_has_androidid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NewRegRequest::clear_androidid() {
  androidid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_androidid();
}
inline const ::std::string& NewRegRequest::androidid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.AndroidID)
  return androidid_.GetNoArena();
}
inline void NewRegRequest::set_androidid(const ::std::string& value) {
  set_has_androidid();
  androidid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.AndroidID)
}
#if LANG_CXX11
inline void NewRegRequest::set_androidid(::std::string&& value) {
  set_has_androidid();
  androidid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.AndroidID)
}
#endif
inline void NewRegRequest::set_androidid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_androidid();
  androidid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.AndroidID)
}
inline void NewRegRequest::set_androidid(const char* value, size_t size) {
  set_has_androidid();
  androidid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.AndroidID)
}
inline ::std::string* NewRegRequest::mutable_androidid() {
  set_has_androidid();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.AndroidID)
  return androidid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_androidid() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.AndroidID)
  clear_has_androidid();
  return androidid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_androidid(::std::string* androidid) {
  if (androidid != NULL) {
    set_has_androidid();
  } else {
    clear_has_androidid();
  }
  androidid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), androidid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.AndroidID)
}

// optional string MacAddr = 34;
inline bool NewRegRequest::has_macaddr() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NewRegRequest::set_has_macaddr() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NewRegRequest::clear_has_macaddr() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NewRegRequest::clear_macaddr() {
  macaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_macaddr();
}
inline const ::std::string& NewRegRequest::macaddr() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.MacAddr)
  return macaddr_.GetNoArena();
}
inline void NewRegRequest::set_macaddr(const ::std::string& value) {
  set_has_macaddr();
  macaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.MacAddr)
}
#if LANG_CXX11
inline void NewRegRequest::set_macaddr(::std::string&& value) {
  set_has_macaddr();
  macaddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.MacAddr)
}
#endif
inline void NewRegRequest::set_macaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_macaddr();
  macaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.MacAddr)
}
inline void NewRegRequest::set_macaddr(const char* value, size_t size) {
  set_has_macaddr();
  macaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.MacAddr)
}
inline ::std::string* NewRegRequest::mutable_macaddr() {
  set_has_macaddr();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.MacAddr)
  return macaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_macaddr() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.MacAddr)
  clear_has_macaddr();
  return macaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_macaddr(::std::string* macaddr) {
  if (macaddr != NULL) {
    set_has_macaddr();
  } else {
    clear_has_macaddr();
  }
  macaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), macaddr);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.MacAddr)
}

// optional string AndroidInstallRef = 35;
inline bool NewRegRequest::has_androidinstallref() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NewRegRequest::set_has_androidinstallref() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NewRegRequest::clear_has_androidinstallref() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NewRegRequest::clear_androidinstallref() {
  androidinstallref_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_androidinstallref();
}
inline const ::std::string& NewRegRequest::androidinstallref() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.AndroidInstallRef)
  return androidinstallref_.GetNoArena();
}
inline void NewRegRequest::set_androidinstallref(const ::std::string& value) {
  set_has_androidinstallref();
  androidinstallref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.AndroidInstallRef)
}
#if LANG_CXX11
inline void NewRegRequest::set_androidinstallref(::std::string&& value) {
  set_has_androidinstallref();
  androidinstallref_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.AndroidInstallRef)
}
#endif
inline void NewRegRequest::set_androidinstallref(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_androidinstallref();
  androidinstallref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.AndroidInstallRef)
}
inline void NewRegRequest::set_androidinstallref(const char* value, size_t size) {
  set_has_androidinstallref();
  androidinstallref_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.AndroidInstallRef)
}
inline ::std::string* NewRegRequest::mutable_androidinstallref() {
  set_has_androidinstallref();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.AndroidInstallRef)
  return androidinstallref_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_androidinstallref() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.AndroidInstallRef)
  clear_has_androidinstallref();
  return androidinstallref_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_androidinstallref(::std::string* androidinstallref) {
  if (androidinstallref != NULL) {
    set_has_androidinstallref();
  } else {
    clear_has_androidinstallref();
  }
  androidinstallref_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), androidinstallref);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.AndroidInstallRef)
}

// optional string ClientFingerprint = 36;
inline bool NewRegRequest::has_clientfingerprint() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NewRegRequest::set_has_clientfingerprint() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NewRegRequest::clear_has_clientfingerprint() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NewRegRequest::clear_clientfingerprint() {
  clientfingerprint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientfingerprint();
}
inline const ::std::string& NewRegRequest::clientfingerprint() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.ClientFingerprint)
  return clientfingerprint_.GetNoArena();
}
inline void NewRegRequest::set_clientfingerprint(const ::std::string& value) {
  set_has_clientfingerprint();
  clientfingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.ClientFingerprint)
}
#if LANG_CXX11
inline void NewRegRequest::set_clientfingerprint(::std::string&& value) {
  set_has_clientfingerprint();
  clientfingerprint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.ClientFingerprint)
}
#endif
inline void NewRegRequest::set_clientfingerprint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientfingerprint();
  clientfingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.ClientFingerprint)
}
inline void NewRegRequest::set_clientfingerprint(const char* value, size_t size) {
  set_has_clientfingerprint();
  clientfingerprint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.ClientFingerprint)
}
inline ::std::string* NewRegRequest::mutable_clientfingerprint() {
  set_has_clientfingerprint();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.ClientFingerprint)
  return clientfingerprint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_clientfingerprint() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.ClientFingerprint)
  clear_has_clientfingerprint();
  return clientfingerprint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_clientfingerprint(::std::string* clientfingerprint) {
  if (clientfingerprint != NULL) {
    set_has_clientfingerprint();
  } else {
    clear_has_clientfingerprint();
  }
  clientfingerprint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientfingerprint);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.ClientFingerprint)
}

// optional .micromsg.ECDHKey CliPubECDHKey = 37;
inline bool NewRegRequest::has_clipubecdhkey() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NewRegRequest::set_has_clipubecdhkey() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NewRegRequest::clear_has_clipubecdhkey() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NewRegRequest::clear_clipubecdhkey() {
  if (clipubecdhkey_ != NULL) clipubecdhkey_->::micromsg::ECDHKey::Clear();
  clear_has_clipubecdhkey();
}
inline const ::micromsg::ECDHKey& NewRegRequest::clipubecdhkey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.CliPubECDHKey)
  return clipubecdhkey_ != NULL ? *clipubecdhkey_
                         : *::micromsg::ECDHKey::internal_default_instance();
}
inline ::micromsg::ECDHKey* NewRegRequest::mutable_clipubecdhkey() {
  set_has_clipubecdhkey();
  if (clipubecdhkey_ == NULL) {
    clipubecdhkey_ = new ::micromsg::ECDHKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.CliPubECDHKey)
  return clipubecdhkey_;
}
inline ::micromsg::ECDHKey* NewRegRequest::release_clipubecdhkey() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.CliPubECDHKey)
  clear_has_clipubecdhkey();
  ::micromsg::ECDHKey* temp = clipubecdhkey_;
  clipubecdhkey_ = NULL;
  return temp;
}
inline void NewRegRequest::set_allocated_clipubecdhkey(::micromsg::ECDHKey* clipubecdhkey) {
  delete clipubecdhkey_;
  clipubecdhkey_ = clipubecdhkey;
  if (clipubecdhkey) {
    set_has_clipubecdhkey();
  } else {
    clear_has_clipubecdhkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.CliPubECDHKey)
}

// optional string GoogleAid = 38;
inline bool NewRegRequest::has_googleaid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NewRegRequest::set_has_googleaid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NewRegRequest::clear_has_googleaid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NewRegRequest::clear_googleaid() {
  googleaid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_googleaid();
}
inline const ::std::string& NewRegRequest::googleaid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.GoogleAid)
  return googleaid_.GetNoArena();
}
inline void NewRegRequest::set_googleaid(const ::std::string& value) {
  set_has_googleaid();
  googleaid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.GoogleAid)
}
#if LANG_CXX11
inline void NewRegRequest::set_googleaid(::std::string&& value) {
  set_has_googleaid();
  googleaid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.GoogleAid)
}
#endif
inline void NewRegRequest::set_googleaid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_googleaid();
  googleaid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.GoogleAid)
}
inline void NewRegRequest::set_googleaid(const char* value, size_t size) {
  set_has_googleaid();
  googleaid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.GoogleAid)
}
inline ::std::string* NewRegRequest::mutable_googleaid() {
  set_has_googleaid();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.GoogleAid)
  return googleaid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_googleaid() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.GoogleAid)
  clear_has_googleaid();
  return googleaid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_googleaid(::std::string* googleaid) {
  if (googleaid != NULL) {
    set_has_googleaid();
  } else {
    clear_has_googleaid();
  }
  googleaid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), googleaid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.GoogleAid)
}

// optional string BundleID = 39;
inline bool NewRegRequest::has_bundleid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NewRegRequest::set_has_bundleid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NewRegRequest::clear_has_bundleid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NewRegRequest::clear_bundleid() {
  bundleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bundleid();
}
inline const ::std::string& NewRegRequest::bundleid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegRequest.BundleID)
  return bundleid_.GetNoArena();
}
inline void NewRegRequest::set_bundleid(const ::std::string& value) {
  set_has_bundleid();
  bundleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegRequest.BundleID)
}
#if LANG_CXX11
inline void NewRegRequest::set_bundleid(::std::string&& value) {
  set_has_bundleid();
  bundleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegRequest.BundleID)
}
#endif
inline void NewRegRequest::set_bundleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bundleid();
  bundleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegRequest.BundleID)
}
inline void NewRegRequest::set_bundleid(const char* value, size_t size) {
  set_has_bundleid();
  bundleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegRequest.BundleID)
}
inline ::std::string* NewRegRequest::mutable_bundleid() {
  set_has_bundleid();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegRequest.BundleID)
  return bundleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegRequest::release_bundleid() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegRequest.BundleID)
  clear_has_bundleid();
  return bundleid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegRequest::set_allocated_bundleid(::std::string* bundleid) {
  if (bundleid != NULL) {
    set_has_bundleid();
  } else {
    clear_has_bundleid();
  }
  bundleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bundleid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegRequest.BundleID)
}

// -------------------------------------------------------------------

// SecAuthRegKeySect

// required .micromsg.SKBuiltinBuffer_t AutoAuthKey = 1;
inline bool SecAuthRegKeySect::has_autoauthkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecAuthRegKeySect::set_has_autoauthkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecAuthRegKeySect::clear_has_autoauthkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecAuthRegKeySect::clear_autoauthkey() {
  if (autoauthkey_ != NULL) autoauthkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_autoauthkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& SecAuthRegKeySect::autoauthkey() const {
  // @@protoc_insertion_point(field_get:micromsg.SecAuthRegKeySect.AutoAuthKey)
  return autoauthkey_ != NULL ? *autoauthkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* SecAuthRegKeySect::mutable_autoauthkey() {
  set_has_autoauthkey();
  if (autoauthkey_ == NULL) {
    autoauthkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.SecAuthRegKeySect.AutoAuthKey)
  return autoauthkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* SecAuthRegKeySect::release_autoauthkey() {
  // @@protoc_insertion_point(field_release:micromsg.SecAuthRegKeySect.AutoAuthKey)
  clear_has_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* temp = autoauthkey_;
  autoauthkey_ = NULL;
  return temp;
}
inline void SecAuthRegKeySect::set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey) {
  delete autoauthkey_;
  autoauthkey_ = autoauthkey;
  if (autoauthkey) {
    set_has_autoauthkey();
  } else {
    clear_has_autoauthkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.SecAuthRegKeySect.AutoAuthKey)
}

// required .micromsg.ECDHKey SvrPubECDHKey = 2;
inline bool SecAuthRegKeySect::has_svrpubecdhkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecAuthRegKeySect::set_has_svrpubecdhkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecAuthRegKeySect::clear_has_svrpubecdhkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecAuthRegKeySect::clear_svrpubecdhkey() {
  if (svrpubecdhkey_ != NULL) svrpubecdhkey_->::micromsg::ECDHKey::Clear();
  clear_has_svrpubecdhkey();
}
inline const ::micromsg::ECDHKey& SecAuthRegKeySect::svrpubecdhkey() const {
  // @@protoc_insertion_point(field_get:micromsg.SecAuthRegKeySect.SvrPubECDHKey)
  return svrpubecdhkey_ != NULL ? *svrpubecdhkey_
                         : *::micromsg::ECDHKey::internal_default_instance();
}
inline ::micromsg::ECDHKey* SecAuthRegKeySect::mutable_svrpubecdhkey() {
  set_has_svrpubecdhkey();
  if (svrpubecdhkey_ == NULL) {
    svrpubecdhkey_ = new ::micromsg::ECDHKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.SecAuthRegKeySect.SvrPubECDHKey)
  return svrpubecdhkey_;
}
inline ::micromsg::ECDHKey* SecAuthRegKeySect::release_svrpubecdhkey() {
  // @@protoc_insertion_point(field_release:micromsg.SecAuthRegKeySect.SvrPubECDHKey)
  clear_has_svrpubecdhkey();
  ::micromsg::ECDHKey* temp = svrpubecdhkey_;
  svrpubecdhkey_ = NULL;
  return temp;
}
inline void SecAuthRegKeySect::set_allocated_svrpubecdhkey(::micromsg::ECDHKey* svrpubecdhkey) {
  delete svrpubecdhkey_;
  svrpubecdhkey_ = svrpubecdhkey;
  if (svrpubecdhkey) {
    set_has_svrpubecdhkey();
  } else {
    clear_has_svrpubecdhkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.SecAuthRegKeySect.SvrPubECDHKey)
}

// required .micromsg.SKBuiltinBuffer_t SessionKey = 3;
inline bool SecAuthRegKeySect::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecAuthRegKeySect::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecAuthRegKeySect::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecAuthRegKeySect::clear_sessionkey() {
  if (sessionkey_ != NULL) sessionkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_sessionkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& SecAuthRegKeySect::sessionkey() const {
  // @@protoc_insertion_point(field_get:micromsg.SecAuthRegKeySect.SessionKey)
  return sessionkey_ != NULL ? *sessionkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* SecAuthRegKeySect::mutable_sessionkey() {
  set_has_sessionkey();
  if (sessionkey_ == NULL) {
    sessionkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.SecAuthRegKeySect.SessionKey)
  return sessionkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* SecAuthRegKeySect::release_sessionkey() {
  // @@protoc_insertion_point(field_release:micromsg.SecAuthRegKeySect.SessionKey)
  clear_has_sessionkey();
  ::micromsg::SKBuiltinBuffer_t* temp = sessionkey_;
  sessionkey_ = NULL;
  return temp;
}
inline void SecAuthRegKeySect::set_allocated_sessionkey(::micromsg::SKBuiltinBuffer_t* sessionkey) {
  delete sessionkey_;
  sessionkey_ = sessionkey;
  if (sessionkey) {
    set_has_sessionkey();
  } else {
    clear_has_sessionkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.SecAuthRegKeySect.SessionKey)
}

// required uint32 AuthResultFlag = 4;
inline bool SecAuthRegKeySect::has_authresultflag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecAuthRegKeySect::set_has_authresultflag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecAuthRegKeySect::clear_has_authresultflag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecAuthRegKeySect::clear_authresultflag() {
  authresultflag_ = 0u;
  clear_has_authresultflag();
}
inline ::google::protobuf::uint32 SecAuthRegKeySect::authresultflag() const {
  // @@protoc_insertion_point(field_get:micromsg.SecAuthRegKeySect.AuthResultFlag)
  return authresultflag_;
}
inline void SecAuthRegKeySect::set_authresultflag(::google::protobuf::uint32 value) {
  set_has_authresultflag();
  authresultflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.SecAuthRegKeySect.AuthResultFlag)
}

// -------------------------------------------------------------------

// NewRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool NewRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NewRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NewRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NewRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& NewRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* NewRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* NewRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.BaseResponse)
}

// required uint32 Uin = 2;
inline bool NewRegResponse::has_uin() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void NewRegResponse::set_has_uin() {
  _has_bits_[0] |= 0x01000000u;
}
inline void NewRegResponse::clear_has_uin() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void NewRegResponse::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 NewRegResponse::uin() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.Uin)
  return uin_;
}
inline void NewRegResponse::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.Uin)
}

// optional string SessionKey = 3;
inline bool NewRegResponse::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewRegResponse::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewRegResponse::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewRegResponse::clear_sessionkey() {
  sessionkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionkey();
}
inline const ::std::string& NewRegResponse::sessionkey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.SessionKey)
  return sessionkey_.GetNoArena();
}
inline void NewRegResponse::set_sessionkey(const ::std::string& value) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.SessionKey)
}
#if LANG_CXX11
inline void NewRegResponse::set_sessionkey(::std::string&& value) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.SessionKey)
}
#endif
inline void NewRegResponse::set_sessionkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.SessionKey)
}
inline void NewRegResponse::set_sessionkey(const char* value, size_t size) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.SessionKey)
}
inline ::std::string* NewRegResponse::mutable_sessionkey() {
  set_has_sessionkey();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.SessionKey)
  return sessionkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_sessionkey() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.SessionKey)
  clear_has_sessionkey();
  return sessionkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_sessionkey(::std::string* sessionkey) {
  if (sessionkey != NULL) {
    set_has_sessionkey();
  } else {
    clear_has_sessionkey();
  }
  sessionkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.SessionKey)
}

// optional string OfficialUserName = 4;
inline bool NewRegResponse::has_officialusername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewRegResponse::set_has_officialusername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewRegResponse::clear_has_officialusername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewRegResponse::clear_officialusername() {
  officialusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_officialusername();
}
inline const ::std::string& NewRegResponse::officialusername() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.OfficialUserName)
  return officialusername_.GetNoArena();
}
inline void NewRegResponse::set_officialusername(const ::std::string& value) {
  set_has_officialusername();
  officialusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.OfficialUserName)
}
#if LANG_CXX11
inline void NewRegResponse::set_officialusername(::std::string&& value) {
  set_has_officialusername();
  officialusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.OfficialUserName)
}
#endif
inline void NewRegResponse::set_officialusername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_officialusername();
  officialusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.OfficialUserName)
}
inline void NewRegResponse::set_officialusername(const char* value, size_t size) {
  set_has_officialusername();
  officialusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.OfficialUserName)
}
inline ::std::string* NewRegResponse::mutable_officialusername() {
  set_has_officialusername();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.OfficialUserName)
  return officialusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_officialusername() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.OfficialUserName)
  clear_has_officialusername();
  return officialusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_officialusername(::std::string* officialusername) {
  if (officialusername != NULL) {
    set_has_officialusername();
  } else {
    clear_has_officialusername();
  }
  officialusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), officialusername);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.OfficialUserName)
}

// optional string OfficialNickName = 5;
inline bool NewRegResponse::has_officialnickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewRegResponse::set_has_officialnickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewRegResponse::clear_has_officialnickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewRegResponse::clear_officialnickname() {
  officialnickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_officialnickname();
}
inline const ::std::string& NewRegResponse::officialnickname() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.OfficialNickName)
  return officialnickname_.GetNoArena();
}
inline void NewRegResponse::set_officialnickname(const ::std::string& value) {
  set_has_officialnickname();
  officialnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.OfficialNickName)
}
#if LANG_CXX11
inline void NewRegResponse::set_officialnickname(::std::string&& value) {
  set_has_officialnickname();
  officialnickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.OfficialNickName)
}
#endif
inline void NewRegResponse::set_officialnickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_officialnickname();
  officialnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.OfficialNickName)
}
inline void NewRegResponse::set_officialnickname(const char* value, size_t size) {
  set_has_officialnickname();
  officialnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.OfficialNickName)
}
inline ::std::string* NewRegResponse::mutable_officialnickname() {
  set_has_officialnickname();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.OfficialNickName)
  return officialnickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_officialnickname() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.OfficialNickName)
  clear_has_officialnickname();
  return officialnickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_officialnickname(::std::string* officialnickname) {
  if (officialnickname != NULL) {
    set_has_officialnickname();
  } else {
    clear_has_officialnickname();
  }
  officialnickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), officialnickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.OfficialNickName)
}

// optional string QQMicroBlogUserName = 6;
inline bool NewRegResponse::has_qqmicroblogusername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewRegResponse::set_has_qqmicroblogusername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewRegResponse::clear_has_qqmicroblogusername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewRegResponse::clear_qqmicroblogusername() {
  qqmicroblogusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_qqmicroblogusername();
}
inline const ::std::string& NewRegResponse::qqmicroblogusername() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.QQMicroBlogUserName)
  return qqmicroblogusername_.GetNoArena();
}
inline void NewRegResponse::set_qqmicroblogusername(const ::std::string& value) {
  set_has_qqmicroblogusername();
  qqmicroblogusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.QQMicroBlogUserName)
}
#if LANG_CXX11
inline void NewRegResponse::set_qqmicroblogusername(::std::string&& value) {
  set_has_qqmicroblogusername();
  qqmicroblogusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.QQMicroBlogUserName)
}
#endif
inline void NewRegResponse::set_qqmicroblogusername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_qqmicroblogusername();
  qqmicroblogusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.QQMicroBlogUserName)
}
inline void NewRegResponse::set_qqmicroblogusername(const char* value, size_t size) {
  set_has_qqmicroblogusername();
  qqmicroblogusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.QQMicroBlogUserName)
}
inline ::std::string* NewRegResponse::mutable_qqmicroblogusername() {
  set_has_qqmicroblogusername();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.QQMicroBlogUserName)
  return qqmicroblogusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_qqmicroblogusername() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.QQMicroBlogUserName)
  clear_has_qqmicroblogusername();
  return qqmicroblogusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_qqmicroblogusername(::std::string* qqmicroblogusername) {
  if (qqmicroblogusername != NULL) {
    set_has_qqmicroblogusername();
  } else {
    clear_has_qqmicroblogusername();
  }
  qqmicroblogusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qqmicroblogusername);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.QQMicroBlogUserName)
}

// optional string BindEmail = 7;
inline bool NewRegResponse::has_bindemail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewRegResponse::set_has_bindemail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewRegResponse::clear_has_bindemail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewRegResponse::clear_bindemail() {
  bindemail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bindemail();
}
inline const ::std::string& NewRegResponse::bindemail() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.BindEmail)
  return bindemail_.GetNoArena();
}
inline void NewRegResponse::set_bindemail(const ::std::string& value) {
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.BindEmail)
}
#if LANG_CXX11
inline void NewRegResponse::set_bindemail(::std::string&& value) {
  set_has_bindemail();
  bindemail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.BindEmail)
}
#endif
inline void NewRegResponse::set_bindemail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.BindEmail)
}
inline void NewRegResponse::set_bindemail(const char* value, size_t size) {
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.BindEmail)
}
inline ::std::string* NewRegResponse::mutable_bindemail() {
  set_has_bindemail();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.BindEmail)
  return bindemail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_bindemail() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.BindEmail)
  clear_has_bindemail();
  return bindemail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_bindemail(::std::string* bindemail) {
  if (bindemail != NULL) {
    set_has_bindemail();
  } else {
    clear_has_bindemail();
  }
  bindemail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bindemail);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.BindEmail)
}

// required uint32 PushMailStatus = 8;
inline bool NewRegResponse::has_pushmailstatus() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void NewRegResponse::set_has_pushmailstatus() {
  _has_bits_[0] |= 0x02000000u;
}
inline void NewRegResponse::clear_has_pushmailstatus() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void NewRegResponse::clear_pushmailstatus() {
  pushmailstatus_ = 0u;
  clear_has_pushmailstatus();
}
inline ::google::protobuf::uint32 NewRegResponse::pushmailstatus() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.PushMailStatus)
  return pushmailstatus_;
}
inline void NewRegResponse::set_pushmailstatus(::google::protobuf::uint32 value) {
  set_has_pushmailstatus();
  pushmailstatus_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.PushMailStatus)
}

// optional uint32 SendCardBitFlag = 9;
inline bool NewRegResponse::has_sendcardbitflag() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void NewRegResponse::set_has_sendcardbitflag() {
  _has_bits_[0] |= 0x04000000u;
}
inline void NewRegResponse::clear_has_sendcardbitflag() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void NewRegResponse::clear_sendcardbitflag() {
  sendcardbitflag_ = 0u;
  clear_has_sendcardbitflag();
}
inline ::google::protobuf::uint32 NewRegResponse::sendcardbitflag() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.SendCardBitFlag)
  return sendcardbitflag_;
}
inline void NewRegResponse::set_sendcardbitflag(::google::protobuf::uint32 value) {
  set_has_sendcardbitflag();
  sendcardbitflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.SendCardBitFlag)
}

// optional string PushMailSettingTicket = 10;
inline bool NewRegResponse::has_pushmailsettingticket() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewRegResponse::set_has_pushmailsettingticket() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewRegResponse::clear_has_pushmailsettingticket() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewRegResponse::clear_pushmailsettingticket() {
  pushmailsettingticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pushmailsettingticket();
}
inline const ::std::string& NewRegResponse::pushmailsettingticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.PushMailSettingTicket)
  return pushmailsettingticket_.GetNoArena();
}
inline void NewRegResponse::set_pushmailsettingticket(const ::std::string& value) {
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.PushMailSettingTicket)
}
#if LANG_CXX11
inline void NewRegResponse::set_pushmailsettingticket(::std::string&& value) {
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.PushMailSettingTicket)
}
#endif
inline void NewRegResponse::set_pushmailsettingticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.PushMailSettingTicket)
}
inline void NewRegResponse::set_pushmailsettingticket(const char* value, size_t size) {
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.PushMailSettingTicket)
}
inline ::std::string* NewRegResponse::mutable_pushmailsettingticket() {
  set_has_pushmailsettingticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.PushMailSettingTicket)
  return pushmailsettingticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_pushmailsettingticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.PushMailSettingTicket)
  clear_has_pushmailsettingticket();
  return pushmailsettingticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_pushmailsettingticket(::std::string* pushmailsettingticket) {
  if (pushmailsettingticket != NULL) {
    set_has_pushmailsettingticket();
  } else {
    clear_has_pushmailsettingticket();
  }
  pushmailsettingticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pushmailsettingticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.PushMailSettingTicket)
}

// optional .micromsg.BuiltinIPList BuiltinIPList = 14;
inline bool NewRegResponse::has_builtiniplist() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NewRegResponse::set_has_builtiniplist() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NewRegResponse::clear_has_builtiniplist() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NewRegResponse::clear_builtiniplist() {
  if (builtiniplist_ != NULL) builtiniplist_->::micromsg::BuiltinIPList::Clear();
  clear_has_builtiniplist();
}
inline const ::micromsg::BuiltinIPList& NewRegResponse::builtiniplist() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.BuiltinIPList)
  return builtiniplist_ != NULL ? *builtiniplist_
                         : *::micromsg::BuiltinIPList::internal_default_instance();
}
inline ::micromsg::BuiltinIPList* NewRegResponse::mutable_builtiniplist() {
  set_has_builtiniplist();
  if (builtiniplist_ == NULL) {
    builtiniplist_ = new ::micromsg::BuiltinIPList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.BuiltinIPList)
  return builtiniplist_;
}
inline ::micromsg::BuiltinIPList* NewRegResponse::release_builtiniplist() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.BuiltinIPList)
  clear_has_builtiniplist();
  ::micromsg::BuiltinIPList* temp = builtiniplist_;
  builtiniplist_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist) {
  delete builtiniplist_;
  builtiniplist_ = builtiniplist;
  if (builtiniplist) {
    set_has_builtiniplist();
  } else {
    clear_has_builtiniplist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.BuiltinIPList)
}

// optional string FSURL = 15;
inline bool NewRegResponse::has_fsurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewRegResponse::set_has_fsurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewRegResponse::clear_has_fsurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewRegResponse::clear_fsurl() {
  fsurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fsurl();
}
inline const ::std::string& NewRegResponse::fsurl() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.FSURL)
  return fsurl_.GetNoArena();
}
inline void NewRegResponse::set_fsurl(const ::std::string& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.FSURL)
}
#if LANG_CXX11
inline void NewRegResponse::set_fsurl(::std::string&& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.FSURL)
}
#endif
inline void NewRegResponse::set_fsurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.FSURL)
}
inline void NewRegResponse::set_fsurl(const char* value, size_t size) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.FSURL)
}
inline ::std::string* NewRegResponse::mutable_fsurl() {
  set_has_fsurl();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.FSURL)
  return fsurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_fsurl() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.FSURL)
  clear_has_fsurl();
  return fsurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_fsurl(::std::string* fsurl) {
  if (fsurl != NULL) {
    set_has_fsurl();
  } else {
    clear_has_fsurl();
  }
  fsurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fsurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.FSURL)
}

// optional string UserName = 16;
inline bool NewRegResponse::has_username() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NewRegResponse::set_has_username() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NewRegResponse::clear_has_username() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NewRegResponse::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& NewRegResponse::username() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.UserName)
  return username_.GetNoArena();
}
inline void NewRegResponse::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.UserName)
}
#if LANG_CXX11
inline void NewRegResponse::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.UserName)
}
#endif
inline void NewRegResponse::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.UserName)
}
inline void NewRegResponse::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.UserName)
}
inline ::std::string* NewRegResponse::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.UserName)
}

// optional uint32 Status = 17;
inline bool NewRegResponse::has_status() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void NewRegResponse::set_has_status() {
  _has_bits_[0] |= 0x08000000u;
}
inline void NewRegResponse::clear_has_status() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void NewRegResponse::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 NewRegResponse::status() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.Status)
  return status_;
}
inline void NewRegResponse::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.Status)
}

// optional .micromsg.NetworkControl NetworkControl = 18;
inline bool NewRegResponse::has_networkcontrol() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NewRegResponse::set_has_networkcontrol() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NewRegResponse::clear_has_networkcontrol() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NewRegResponse::clear_networkcontrol() {
  if (networkcontrol_ != NULL) networkcontrol_->::micromsg::NetworkControl::Clear();
  clear_has_networkcontrol();
}
inline const ::micromsg::NetworkControl& NewRegResponse::networkcontrol() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.NetworkControl)
  return networkcontrol_ != NULL ? *networkcontrol_
                         : *::micromsg::NetworkControl::internal_default_instance();
}
inline ::micromsg::NetworkControl* NewRegResponse::mutable_networkcontrol() {
  set_has_networkcontrol();
  if (networkcontrol_ == NULL) {
    networkcontrol_ = new ::micromsg::NetworkControl;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.NetworkControl)
  return networkcontrol_;
}
inline ::micromsg::NetworkControl* NewRegResponse::release_networkcontrol() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.NetworkControl)
  clear_has_networkcontrol();
  ::micromsg::NetworkControl* temp = networkcontrol_;
  networkcontrol_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol) {
  delete networkcontrol_;
  networkcontrol_ = networkcontrol;
  if (networkcontrol) {
    set_has_networkcontrol();
  } else {
    clear_has_networkcontrol();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.NetworkControl)
}

// optional uint32 ReturnFlag = 19;
inline bool NewRegResponse::has_returnflag() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void NewRegResponse::set_has_returnflag() {
  _has_bits_[0] |= 0x10000000u;
}
inline void NewRegResponse::clear_has_returnflag() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void NewRegResponse::clear_returnflag() {
  returnflag_ = 0u;
  clear_has_returnflag();
}
inline ::google::protobuf::uint32 NewRegResponse::returnflag() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.ReturnFlag)
  return returnflag_;
}
inline void NewRegResponse::set_returnflag(::google::protobuf::uint32 value) {
  set_has_returnflag();
  returnflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.ReturnFlag)
}

// optional uint32 RegType = 20;
inline bool NewRegResponse::has_regtype() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void NewRegResponse::set_has_regtype() {
  _has_bits_[0] |= 0x20000000u;
}
inline void NewRegResponse::clear_has_regtype() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void NewRegResponse::clear_regtype() {
  regtype_ = 0u;
  clear_has_regtype();
}
inline ::google::protobuf::uint32 NewRegResponse::regtype() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.RegType)
  return regtype_;
}
inline void NewRegResponse::set_regtype(::google::protobuf::uint32 value) {
  set_has_regtype();
  regtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.RegType)
}

// optional string AuthKey = 21;
inline bool NewRegResponse::has_authkey() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NewRegResponse::set_has_authkey() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NewRegResponse::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NewRegResponse::clear_authkey() {
  authkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authkey();
}
inline const ::std::string& NewRegResponse::authkey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.AuthKey)
  return authkey_.GetNoArena();
}
inline void NewRegResponse::set_authkey(const ::std::string& value) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.AuthKey)
}
#if LANG_CXX11
inline void NewRegResponse::set_authkey(::std::string&& value) {
  set_has_authkey();
  authkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.AuthKey)
}
#endif
inline void NewRegResponse::set_authkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.AuthKey)
}
inline void NewRegResponse::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.AuthKey)
}
inline ::std::string* NewRegResponse::mutable_authkey() {
  set_has_authkey();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.AuthKey)
  return authkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_authkey() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.AuthKey)
  clear_has_authkey();
  return authkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_authkey(::std::string* authkey) {
  if (authkey != NULL) {
    set_has_authkey();
  } else {
    clear_has_authkey();
  }
  authkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.AuthKey)
}

// optional .micromsg.PluginKeyList PluginKeyList = 22;
inline bool NewRegResponse::has_pluginkeylist() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NewRegResponse::set_has_pluginkeylist() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NewRegResponse::clear_has_pluginkeylist() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NewRegResponse::clear_pluginkeylist() {
  if (pluginkeylist_ != NULL) pluginkeylist_->::micromsg::PluginKeyList::Clear();
  clear_has_pluginkeylist();
}
inline const ::micromsg::PluginKeyList& NewRegResponse::pluginkeylist() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.PluginKeyList)
  return pluginkeylist_ != NULL ? *pluginkeylist_
                         : *::micromsg::PluginKeyList::internal_default_instance();
}
inline ::micromsg::PluginKeyList* NewRegResponse::mutable_pluginkeylist() {
  set_has_pluginkeylist();
  if (pluginkeylist_ == NULL) {
    pluginkeylist_ = new ::micromsg::PluginKeyList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.PluginKeyList)
  return pluginkeylist_;
}
inline ::micromsg::PluginKeyList* NewRegResponse::release_pluginkeylist() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.PluginKeyList)
  clear_has_pluginkeylist();
  ::micromsg::PluginKeyList* temp = pluginkeylist_;
  pluginkeylist_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_pluginkeylist(::micromsg::PluginKeyList* pluginkeylist) {
  delete pluginkeylist_;
  pluginkeylist_ = pluginkeylist;
  if (pluginkeylist) {
    set_has_pluginkeylist();
  } else {
    clear_has_pluginkeylist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.PluginKeyList)
}

// optional string Password = 23;
inline bool NewRegResponse::has_password() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NewRegResponse::set_has_password() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NewRegResponse::clear_has_password() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NewRegResponse::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& NewRegResponse::password() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.Password)
  return password_.GetNoArena();
}
inline void NewRegResponse::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.Password)
}
#if LANG_CXX11
inline void NewRegResponse::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.Password)
}
#endif
inline void NewRegResponse::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.Password)
}
inline void NewRegResponse::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.Password)
}
inline ::std::string* NewRegResponse::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.Password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_password() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.Password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.Password)
}

// optional uint32 ProfileFlag = 24;
inline bool NewRegResponse::has_profileflag() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void NewRegResponse::set_has_profileflag() {
  _has_bits_[0] |= 0x40000000u;
}
inline void NewRegResponse::clear_has_profileflag() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void NewRegResponse::clear_profileflag() {
  profileflag_ = 0u;
  clear_has_profileflag();
}
inline ::google::protobuf::uint32 NewRegResponse::profileflag() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.ProfileFlag)
  return profileflag_;
}
inline void NewRegResponse::set_profileflag(::google::protobuf::uint32 value) {
  set_has_profileflag();
  profileflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.ProfileFlag)
}

// optional .micromsg.HostList NewHostList = 25;
inline bool NewRegResponse::has_newhostlist() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NewRegResponse::set_has_newhostlist() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NewRegResponse::clear_has_newhostlist() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NewRegResponse::clear_newhostlist() {
  if (newhostlist_ != NULL) newhostlist_->::micromsg::HostList::Clear();
  clear_has_newhostlist();
}
inline const ::micromsg::HostList& NewRegResponse::newhostlist() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.NewHostList)
  return newhostlist_ != NULL ? *newhostlist_
                         : *::micromsg::HostList::internal_default_instance();
}
inline ::micromsg::HostList* NewRegResponse::mutable_newhostlist() {
  set_has_newhostlist();
  if (newhostlist_ == NULL) {
    newhostlist_ = new ::micromsg::HostList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.NewHostList)
  return newhostlist_;
}
inline ::micromsg::HostList* NewRegResponse::release_newhostlist() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.NewHostList)
  clear_has_newhostlist();
  ::micromsg::HostList* temp = newhostlist_;
  newhostlist_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_newhostlist(::micromsg::HostList* newhostlist) {
  delete newhostlist_;
  newhostlist_ = newhostlist;
  if (newhostlist) {
    set_has_newhostlist();
  } else {
    clear_has_newhostlist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.NewHostList)
}

// optional string AutoAuthTicket = 26;
inline bool NewRegResponse::has_autoauthticket() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NewRegResponse::set_has_autoauthticket() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NewRegResponse::clear_has_autoauthticket() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NewRegResponse::clear_autoauthticket() {
  autoauthticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_autoauthticket();
}
inline const ::std::string& NewRegResponse::autoauthticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.AutoAuthTicket)
  return autoauthticket_.GetNoArena();
}
inline void NewRegResponse::set_autoauthticket(const ::std::string& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.AutoAuthTicket)
}
#if LANG_CXX11
inline void NewRegResponse::set_autoauthticket(::std::string&& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.AutoAuthTicket)
}
#endif
inline void NewRegResponse::set_autoauthticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.AutoAuthTicket)
}
inline void NewRegResponse::set_autoauthticket(const char* value, size_t size) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.AutoAuthTicket)
}
inline ::std::string* NewRegResponse::mutable_autoauthticket() {
  set_has_autoauthticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.AutoAuthTicket)
  return autoauthticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_autoauthticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.AutoAuthTicket)
  clear_has_autoauthticket();
  return autoauthticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_autoauthticket(::std::string* autoauthticket) {
  if (autoauthticket != NULL) {
    set_has_autoauthticket();
  } else {
    clear_has_autoauthticket();
  }
  autoauthticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), autoauthticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.AutoAuthTicket)
}

// optional .micromsg.CDNDnsInfo DnsInfo = 27;
inline bool NewRegResponse::has_dnsinfo() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NewRegResponse::set_has_dnsinfo() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NewRegResponse::clear_has_dnsinfo() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NewRegResponse::clear_dnsinfo() {
  if (dnsinfo_ != NULL) dnsinfo_->::micromsg::CDNDnsInfo::Clear();
  clear_has_dnsinfo();
}
inline const ::micromsg::CDNDnsInfo& NewRegResponse::dnsinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.DnsInfo)
  return dnsinfo_ != NULL ? *dnsinfo_
                         : *::micromsg::CDNDnsInfo::internal_default_instance();
}
inline ::micromsg::CDNDnsInfo* NewRegResponse::mutable_dnsinfo() {
  set_has_dnsinfo();
  if (dnsinfo_ == NULL) {
    dnsinfo_ = new ::micromsg::CDNDnsInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.DnsInfo)
  return dnsinfo_;
}
inline ::micromsg::CDNDnsInfo* NewRegResponse::release_dnsinfo() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.DnsInfo)
  clear_has_dnsinfo();
  ::micromsg::CDNDnsInfo* temp = dnsinfo_;
  dnsinfo_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_dnsinfo(::micromsg::CDNDnsInfo* dnsinfo) {
  delete dnsinfo_;
  dnsinfo_ = dnsinfo;
  if (dnsinfo) {
    set_has_dnsinfo();
  } else {
    clear_has_dnsinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.DnsInfo)
}

// optional string StepTicket = 28;
inline bool NewRegResponse::has_stepticket() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NewRegResponse::set_has_stepticket() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NewRegResponse::clear_has_stepticket() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NewRegResponse::clear_stepticket() {
  stepticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stepticket();
}
inline const ::std::string& NewRegResponse::stepticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.StepTicket)
  return stepticket_.GetNoArena();
}
inline void NewRegResponse::set_stepticket(const ::std::string& value) {
  set_has_stepticket();
  stepticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.StepTicket)
}
#if LANG_CXX11
inline void NewRegResponse::set_stepticket(::std::string&& value) {
  set_has_stepticket();
  stepticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.StepTicket)
}
#endif
inline void NewRegResponse::set_stepticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_stepticket();
  stepticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.StepTicket)
}
inline void NewRegResponse::set_stepticket(const char* value, size_t size) {
  set_has_stepticket();
  stepticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.StepTicket)
}
inline ::std::string* NewRegResponse::mutable_stepticket() {
  set_has_stepticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.StepTicket)
  return stepticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_stepticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.StepTicket)
  clear_has_stepticket();
  return stepticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_stepticket(::std::string* stepticket) {
  if (stepticket != NULL) {
    set_has_stepticket();
  } else {
    clear_has_stepticket();
  }
  stepticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stepticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.StepTicket)
}

// optional string VerifySignature = 29;
inline bool NewRegResponse::has_verifysignature() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NewRegResponse::set_has_verifysignature() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NewRegResponse::clear_has_verifysignature() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NewRegResponse::clear_verifysignature() {
  verifysignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifysignature();
}
inline const ::std::string& NewRegResponse::verifysignature() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.VerifySignature)
  return verifysignature_.GetNoArena();
}
inline void NewRegResponse::set_verifysignature(const ::std::string& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewRegResponse.VerifySignature)
}
#if LANG_CXX11
inline void NewRegResponse::set_verifysignature(::std::string&& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewRegResponse.VerifySignature)
}
#endif
inline void NewRegResponse::set_verifysignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewRegResponse.VerifySignature)
}
inline void NewRegResponse::set_verifysignature(const char* value, size_t size) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewRegResponse.VerifySignature)
}
inline ::std::string* NewRegResponse::mutable_verifysignature() {
  set_has_verifysignature();
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.VerifySignature)
  return verifysignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewRegResponse::release_verifysignature() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.VerifySignature)
  clear_has_verifysignature();
  return verifysignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewRegResponse::set_allocated_verifysignature(::std::string* verifysignature) {
  if (verifysignature != NULL) {
    set_has_verifysignature();
  } else {
    clear_has_verifysignature();
  }
  verifysignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifysignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.VerifySignature)
}

// optional .micromsg.SKBuiltinBuffer_t VerifyBuff = 30;
inline bool NewRegResponse::has_verifybuff() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NewRegResponse::set_has_verifybuff() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NewRegResponse::clear_has_verifybuff() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NewRegResponse::clear_verifybuff() {
  if (verifybuff_ != NULL) verifybuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_verifybuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewRegResponse::verifybuff() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.VerifyBuff)
  return verifybuff_ != NULL ? *verifybuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewRegResponse::mutable_verifybuff() {
  set_has_verifybuff();
  if (verifybuff_ == NULL) {
    verifybuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.VerifyBuff)
  return verifybuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewRegResponse::release_verifybuff() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.VerifyBuff)
  clear_has_verifybuff();
  ::micromsg::SKBuiltinBuffer_t* temp = verifybuff_;
  verifybuff_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_verifybuff(::micromsg::SKBuiltinBuffer_t* verifybuff) {
  delete verifybuff_;
  verifybuff_ = verifybuff;
  if (verifybuff) {
    set_has_verifybuff();
  } else {
    clear_has_verifybuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.VerifyBuff)
}

// optional .micromsg.ShowStyleKey ShowStyle = 31;
inline bool NewRegResponse::has_showstyle() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NewRegResponse::set_has_showstyle() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NewRegResponse::clear_has_showstyle() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NewRegResponse::clear_showstyle() {
  if (showstyle_ != NULL) showstyle_->::micromsg::ShowStyleKey::Clear();
  clear_has_showstyle();
}
inline const ::micromsg::ShowStyleKey& NewRegResponse::showstyle() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.ShowStyle)
  return showstyle_ != NULL ? *showstyle_
                         : *::micromsg::ShowStyleKey::internal_default_instance();
}
inline ::micromsg::ShowStyleKey* NewRegResponse::mutable_showstyle() {
  set_has_showstyle();
  if (showstyle_ == NULL) {
    showstyle_ = new ::micromsg::ShowStyleKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.ShowStyle)
  return showstyle_;
}
inline ::micromsg::ShowStyleKey* NewRegResponse::release_showstyle() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.ShowStyle)
  clear_has_showstyle();
  ::micromsg::ShowStyleKey* temp = showstyle_;
  showstyle_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle) {
  delete showstyle_;
  showstyle_ = showstyle;
  if (showstyle) {
    set_has_showstyle();
  } else {
    clear_has_showstyle();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.ShowStyle)
}

// optional .micromsg.CDNDnsInfo SnsDnsInfo = 32;
inline bool NewRegResponse::has_snsdnsinfo() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NewRegResponse::set_has_snsdnsinfo() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NewRegResponse::clear_has_snsdnsinfo() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NewRegResponse::clear_snsdnsinfo() {
  if (snsdnsinfo_ != NULL) snsdnsinfo_->::micromsg::CDNDnsInfo::Clear();
  clear_has_snsdnsinfo();
}
inline const ::micromsg::CDNDnsInfo& NewRegResponse::snsdnsinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.SnsDnsInfo)
  return snsdnsinfo_ != NULL ? *snsdnsinfo_
                         : *::micromsg::CDNDnsInfo::internal_default_instance();
}
inline ::micromsg::CDNDnsInfo* NewRegResponse::mutable_snsdnsinfo() {
  set_has_snsdnsinfo();
  if (snsdnsinfo_ == NULL) {
    snsdnsinfo_ = new ::micromsg::CDNDnsInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.SnsDnsInfo)
  return snsdnsinfo_;
}
inline ::micromsg::CDNDnsInfo* NewRegResponse::release_snsdnsinfo() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.SnsDnsInfo)
  clear_has_snsdnsinfo();
  ::micromsg::CDNDnsInfo* temp = snsdnsinfo_;
  snsdnsinfo_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_snsdnsinfo(::micromsg::CDNDnsInfo* snsdnsinfo) {
  delete snsdnsinfo_;
  snsdnsinfo_ = snsdnsinfo;
  if (snsdnsinfo) {
    set_has_snsdnsinfo();
  } else {
    clear_has_snsdnsinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.SnsDnsInfo)
}

// optional .micromsg.CDNDnsInfo AppDnsInfo = 33;
inline bool NewRegResponse::has_appdnsinfo() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NewRegResponse::set_has_appdnsinfo() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NewRegResponse::clear_has_appdnsinfo() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NewRegResponse::clear_appdnsinfo() {
  if (appdnsinfo_ != NULL) appdnsinfo_->::micromsg::CDNDnsInfo::Clear();
  clear_has_appdnsinfo();
}
inline const ::micromsg::CDNDnsInfo& NewRegResponse::appdnsinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.AppDnsInfo)
  return appdnsinfo_ != NULL ? *appdnsinfo_
                         : *::micromsg::CDNDnsInfo::internal_default_instance();
}
inline ::micromsg::CDNDnsInfo* NewRegResponse::mutable_appdnsinfo() {
  set_has_appdnsinfo();
  if (appdnsinfo_ == NULL) {
    appdnsinfo_ = new ::micromsg::CDNDnsInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.AppDnsInfo)
  return appdnsinfo_;
}
inline ::micromsg::CDNDnsInfo* NewRegResponse::release_appdnsinfo() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.AppDnsInfo)
  clear_has_appdnsinfo();
  ::micromsg::CDNDnsInfo* temp = appdnsinfo_;
  appdnsinfo_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_appdnsinfo(::micromsg::CDNDnsInfo* appdnsinfo) {
  delete appdnsinfo_;
  appdnsinfo_ = appdnsinfo;
  if (appdnsinfo) {
    set_has_appdnsinfo();
  } else {
    clear_has_appdnsinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.AppDnsInfo)
}

// optional .micromsg.SecAuthRegKeySect SecAuthRegKeySect = 34;
inline bool NewRegResponse::has_secauthregkeysect() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void NewRegResponse::set_has_secauthregkeysect() {
  _has_bits_[0] |= 0x00800000u;
}
inline void NewRegResponse::clear_has_secauthregkeysect() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void NewRegResponse::clear_secauthregkeysect() {
  if (secauthregkeysect_ != NULL) secauthregkeysect_->::micromsg::SecAuthRegKeySect::Clear();
  clear_has_secauthregkeysect();
}
inline const ::micromsg::SecAuthRegKeySect& NewRegResponse::secauthregkeysect() const {
  // @@protoc_insertion_point(field_get:micromsg.NewRegResponse.SecAuthRegKeySect)
  return secauthregkeysect_ != NULL ? *secauthregkeysect_
                         : *::micromsg::SecAuthRegKeySect::internal_default_instance();
}
inline ::micromsg::SecAuthRegKeySect* NewRegResponse::mutable_secauthregkeysect() {
  set_has_secauthregkeysect();
  if (secauthregkeysect_ == NULL) {
    secauthregkeysect_ = new ::micromsg::SecAuthRegKeySect;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewRegResponse.SecAuthRegKeySect)
  return secauthregkeysect_;
}
inline ::micromsg::SecAuthRegKeySect* NewRegResponse::release_secauthregkeysect() {
  // @@protoc_insertion_point(field_release:micromsg.NewRegResponse.SecAuthRegKeySect)
  clear_has_secauthregkeysect();
  ::micromsg::SecAuthRegKeySect* temp = secauthregkeysect_;
  secauthregkeysect_ = NULL;
  return temp;
}
inline void NewRegResponse::set_allocated_secauthregkeysect(::micromsg::SecAuthRegKeySect* secauthregkeysect) {
  delete secauthregkeysect_;
  secauthregkeysect_ = secauthregkeysect;
  if (secauthregkeysect) {
    set_has_secauthregkeysect();
  } else {
    clear_has_secauthregkeysect();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewRegResponse.SecAuthRegKeySect)
}

// -------------------------------------------------------------------

// GetSuggestAliasRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetSuggestAliasRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetSuggestAliasRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetSuggestAliasRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetSuggestAliasRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetSuggestAliasRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetSuggestAliasRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetSuggestAliasRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetSuggestAliasRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.BaseRequest)
}

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
inline bool GetSuggestAliasRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetSuggestAliasRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetSuggestAliasRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetSuggestAliasRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetSuggestAliasRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetSuggestAliasRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetSuggestAliasRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void GetSuggestAliasRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.RandomEncryKey)
}

// optional string RegBindName = 3;
inline bool GetSuggestAliasRequest::has_regbindname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSuggestAliasRequest::set_has_regbindname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSuggestAliasRequest::clear_has_regbindname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSuggestAliasRequest::clear_regbindname() {
  regbindname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_regbindname();
}
inline const ::std::string& GetSuggestAliasRequest::regbindname() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.RegBindName)
  return regbindname_.GetNoArena();
}
inline void GetSuggestAliasRequest::set_regbindname(const ::std::string& value) {
  set_has_regbindname();
  regbindname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasRequest.RegBindName)
}
#if LANG_CXX11
inline void GetSuggestAliasRequest::set_regbindname(::std::string&& value) {
  set_has_regbindname();
  regbindname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetSuggestAliasRequest.RegBindName)
}
#endif
inline void GetSuggestAliasRequest::set_regbindname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_regbindname();
  regbindname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetSuggestAliasRequest.RegBindName)
}
inline void GetSuggestAliasRequest::set_regbindname(const char* value, size_t size) {
  set_has_regbindname();
  regbindname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetSuggestAliasRequest.RegBindName)
}
inline ::std::string* GetSuggestAliasRequest::mutable_regbindname() {
  set_has_regbindname();
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.RegBindName)
  return regbindname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSuggestAliasRequest::release_regbindname() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.RegBindName)
  clear_has_regbindname();
  return regbindname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSuggestAliasRequest::set_allocated_regbindname(::std::string* regbindname) {
  if (regbindname != NULL) {
    set_has_regbindname();
  } else {
    clear_has_regbindname();
  }
  regbindname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), regbindname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.RegBindName)
}

// optional string RegTicket = 4;
inline bool GetSuggestAliasRequest::has_regticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSuggestAliasRequest::set_has_regticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSuggestAliasRequest::clear_has_regticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSuggestAliasRequest::clear_regticket() {
  regticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_regticket();
}
inline const ::std::string& GetSuggestAliasRequest::regticket() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.RegTicket)
  return regticket_.GetNoArena();
}
inline void GetSuggestAliasRequest::set_regticket(const ::std::string& value) {
  set_has_regticket();
  regticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasRequest.RegTicket)
}
#if LANG_CXX11
inline void GetSuggestAliasRequest::set_regticket(::std::string&& value) {
  set_has_regticket();
  regticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetSuggestAliasRequest.RegTicket)
}
#endif
inline void GetSuggestAliasRequest::set_regticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_regticket();
  regticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetSuggestAliasRequest.RegTicket)
}
inline void GetSuggestAliasRequest::set_regticket(const char* value, size_t size) {
  set_has_regticket();
  regticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetSuggestAliasRequest.RegTicket)
}
inline ::std::string* GetSuggestAliasRequest::mutable_regticket() {
  set_has_regticket();
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.RegTicket)
  return regticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSuggestAliasRequest::release_regticket() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.RegTicket)
  clear_has_regticket();
  return regticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSuggestAliasRequest::set_allocated_regticket(::std::string* regticket) {
  if (regticket != NULL) {
    set_has_regticket();
  } else {
    clear_has_regticket();
  }
  regticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), regticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.RegTicket)
}

// optional string NickName = 5;
inline bool GetSuggestAliasRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSuggestAliasRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSuggestAliasRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSuggestAliasRequest::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& GetSuggestAliasRequest::nickname() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.NickName)
  return nickname_.GetNoArena();
}
inline void GetSuggestAliasRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasRequest.NickName)
}
#if LANG_CXX11
inline void GetSuggestAliasRequest::set_nickname(::std::string&& value) {
  set_has_nickname();
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetSuggestAliasRequest.NickName)
}
#endif
inline void GetSuggestAliasRequest::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetSuggestAliasRequest.NickName)
}
inline void GetSuggestAliasRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetSuggestAliasRequest.NickName)
}
inline ::std::string* GetSuggestAliasRequest::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.NickName)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSuggestAliasRequest::release_nickname() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.NickName)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSuggestAliasRequest::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.NickName)
}

// optional string InputAlias = 6;
inline bool GetSuggestAliasRequest::has_inputalias() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetSuggestAliasRequest::set_has_inputalias() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetSuggestAliasRequest::clear_has_inputalias() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetSuggestAliasRequest::clear_inputalias() {
  inputalias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_inputalias();
}
inline const ::std::string& GetSuggestAliasRequest::inputalias() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.InputAlias)
  return inputalias_.GetNoArena();
}
inline void GetSuggestAliasRequest::set_inputalias(const ::std::string& value) {
  set_has_inputalias();
  inputalias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasRequest.InputAlias)
}
#if LANG_CXX11
inline void GetSuggestAliasRequest::set_inputalias(::std::string&& value) {
  set_has_inputalias();
  inputalias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetSuggestAliasRequest.InputAlias)
}
#endif
inline void GetSuggestAliasRequest::set_inputalias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_inputalias();
  inputalias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetSuggestAliasRequest.InputAlias)
}
inline void GetSuggestAliasRequest::set_inputalias(const char* value, size_t size) {
  set_has_inputalias();
  inputalias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetSuggestAliasRequest.InputAlias)
}
inline ::std::string* GetSuggestAliasRequest::mutable_inputalias() {
  set_has_inputalias();
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.InputAlias)
  return inputalias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSuggestAliasRequest::release_inputalias() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.InputAlias)
  clear_has_inputalias();
  return inputalias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSuggestAliasRequest::set_allocated_inputalias(::std::string* inputalias) {
  if (inputalias != NULL) {
    set_has_inputalias();
  } else {
    clear_has_inputalias();
  }
  inputalias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), inputalias);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.InputAlias)
}

// optional string VerifySignature = 7;
inline bool GetSuggestAliasRequest::has_verifysignature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetSuggestAliasRequest::set_has_verifysignature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetSuggestAliasRequest::clear_has_verifysignature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetSuggestAliasRequest::clear_verifysignature() {
  verifysignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifysignature();
}
inline const ::std::string& GetSuggestAliasRequest::verifysignature() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.VerifySignature)
  return verifysignature_.GetNoArena();
}
inline void GetSuggestAliasRequest::set_verifysignature(const ::std::string& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasRequest.VerifySignature)
}
#if LANG_CXX11
inline void GetSuggestAliasRequest::set_verifysignature(::std::string&& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetSuggestAliasRequest.VerifySignature)
}
#endif
inline void GetSuggestAliasRequest::set_verifysignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetSuggestAliasRequest.VerifySignature)
}
inline void GetSuggestAliasRequest::set_verifysignature(const char* value, size_t size) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetSuggestAliasRequest.VerifySignature)
}
inline ::std::string* GetSuggestAliasRequest::mutable_verifysignature() {
  set_has_verifysignature();
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.VerifySignature)
  return verifysignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSuggestAliasRequest::release_verifysignature() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.VerifySignature)
  clear_has_verifysignature();
  return verifysignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSuggestAliasRequest::set_allocated_verifysignature(::std::string* verifysignature) {
  if (verifysignature != NULL) {
    set_has_verifysignature();
  } else {
    clear_has_verifysignature();
  }
  verifysignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifysignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.VerifySignature)
}

// optional string VerifyContent = 8;
inline bool GetSuggestAliasRequest::has_verifycontent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetSuggestAliasRequest::set_has_verifycontent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetSuggestAliasRequest::clear_has_verifycontent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetSuggestAliasRequest::clear_verifycontent() {
  verifycontent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifycontent();
}
inline const ::std::string& GetSuggestAliasRequest::verifycontent() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.VerifyContent)
  return verifycontent_.GetNoArena();
}
inline void GetSuggestAliasRequest::set_verifycontent(const ::std::string& value) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasRequest.VerifyContent)
}
#if LANG_CXX11
inline void GetSuggestAliasRequest::set_verifycontent(::std::string&& value) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetSuggestAliasRequest.VerifyContent)
}
#endif
inline void GetSuggestAliasRequest::set_verifycontent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetSuggestAliasRequest.VerifyContent)
}
inline void GetSuggestAliasRequest::set_verifycontent(const char* value, size_t size) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetSuggestAliasRequest.VerifyContent)
}
inline ::std::string* GetSuggestAliasRequest::mutable_verifycontent() {
  set_has_verifycontent();
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.VerifyContent)
  return verifycontent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSuggestAliasRequest::release_verifycontent() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.VerifyContent)
  clear_has_verifycontent();
  return verifycontent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSuggestAliasRequest::set_allocated_verifycontent(::std::string* verifycontent) {
  if (verifycontent != NULL) {
    set_has_verifycontent();
  } else {
    clear_has_verifycontent();
  }
  verifycontent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifycontent);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.VerifyContent)
}

// required uint32 RegMode = 9;
inline bool GetSuggestAliasRequest::has_regmode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetSuggestAliasRequest::set_has_regmode() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetSuggestAliasRequest::clear_has_regmode() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetSuggestAliasRequest::clear_regmode() {
  regmode_ = 0u;
  clear_has_regmode();
}
inline ::google::protobuf::uint32 GetSuggestAliasRequest::regmode() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.RegMode)
  return regmode_;
}
inline void GetSuggestAliasRequest::set_regmode(::google::protobuf::uint32 value) {
  set_has_regmode();
  regmode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasRequest.RegMode)
}

// optional string Language = 10;
inline bool GetSuggestAliasRequest::has_language() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetSuggestAliasRequest::set_has_language() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetSuggestAliasRequest::clear_has_language() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetSuggestAliasRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& GetSuggestAliasRequest::language() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.Language)
  return language_.GetNoArena();
}
inline void GetSuggestAliasRequest::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasRequest.Language)
}
#if LANG_CXX11
inline void GetSuggestAliasRequest::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetSuggestAliasRequest.Language)
}
#endif
inline void GetSuggestAliasRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetSuggestAliasRequest.Language)
}
inline void GetSuggestAliasRequest::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetSuggestAliasRequest.Language)
}
inline ::std::string* GetSuggestAliasRequest::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.Language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSuggestAliasRequest::release_language() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.Language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSuggestAliasRequest::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.Language)
}

// optional string ClientSeqID = 11;
inline bool GetSuggestAliasRequest::has_clientseqid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetSuggestAliasRequest::set_has_clientseqid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetSuggestAliasRequest::clear_has_clientseqid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetSuggestAliasRequest::clear_clientseqid() {
  clientseqid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientseqid();
}
inline const ::std::string& GetSuggestAliasRequest::clientseqid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasRequest.ClientSeqID)
  return clientseqid_.GetNoArena();
}
inline void GetSuggestAliasRequest::set_clientseqid(const ::std::string& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasRequest.ClientSeqID)
}
#if LANG_CXX11
inline void GetSuggestAliasRequest::set_clientseqid(::std::string&& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetSuggestAliasRequest.ClientSeqID)
}
#endif
inline void GetSuggestAliasRequest::set_clientseqid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetSuggestAliasRequest.ClientSeqID)
}
inline void GetSuggestAliasRequest::set_clientseqid(const char* value, size_t size) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetSuggestAliasRequest.ClientSeqID)
}
inline ::std::string* GetSuggestAliasRequest::mutable_clientseqid() {
  set_has_clientseqid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasRequest.ClientSeqID)
  return clientseqid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSuggestAliasRequest::release_clientseqid() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasRequest.ClientSeqID)
  clear_has_clientseqid();
  return clientseqid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSuggestAliasRequest::set_allocated_clientseqid(::std::string* clientseqid) {
  if (clientseqid != NULL) {
    set_has_clientseqid();
  } else {
    clear_has_clientseqid();
  }
  clientseqid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientseqid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasRequest.ClientSeqID)
}

// -------------------------------------------------------------------

// GetSuggestAliasResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetSuggestAliasResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSuggestAliasResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSuggestAliasResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSuggestAliasResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetSuggestAliasResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetSuggestAliasResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetSuggestAliasResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetSuggestAliasResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasResponse.BaseResponse)
}

// required uint32 Count = 2;
inline bool GetSuggestAliasResponse::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetSuggestAliasResponse::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetSuggestAliasResponse::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetSuggestAliasResponse::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GetSuggestAliasResponse::count() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasResponse.Count)
  return count_;
}
inline void GetSuggestAliasResponse::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasResponse.Count)
}

// repeated .micromsg.SKBuiltinString_t List = 3;
inline int GetSuggestAliasResponse::list_size() const {
  return list_.size();
}
inline void GetSuggestAliasResponse::clear_list() {
  list_.Clear();
}
inline const ::micromsg::SKBuiltinString_t& GetSuggestAliasResponse::list(int index) const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasResponse.List)
  return list_.Get(index);
}
inline ::micromsg::SKBuiltinString_t* GetSuggestAliasResponse::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasResponse.List)
  return list_.Mutable(index);
}
inline ::micromsg::SKBuiltinString_t* GetSuggestAliasResponse::add_list() {
  // @@protoc_insertion_point(field_add:micromsg.GetSuggestAliasResponse.List)
  return list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t >*
GetSuggestAliasResponse::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:micromsg.GetSuggestAliasResponse.List)
  return &list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::micromsg::SKBuiltinString_t >&
GetSuggestAliasResponse::list() const {
  // @@protoc_insertion_point(field_list:micromsg.GetSuggestAliasResponse.List)
  return list_;
}

// optional string VerifySignature = 4;
inline bool GetSuggestAliasResponse::has_verifysignature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSuggestAliasResponse::set_has_verifysignature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSuggestAliasResponse::clear_has_verifysignature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSuggestAliasResponse::clear_verifysignature() {
  verifysignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifysignature();
}
inline const ::std::string& GetSuggestAliasResponse::verifysignature() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasResponse.VerifySignature)
  return verifysignature_.GetNoArena();
}
inline void GetSuggestAliasResponse::set_verifysignature(const ::std::string& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasResponse.VerifySignature)
}
#if LANG_CXX11
inline void GetSuggestAliasResponse::set_verifysignature(::std::string&& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetSuggestAliasResponse.VerifySignature)
}
#endif
inline void GetSuggestAliasResponse::set_verifysignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetSuggestAliasResponse.VerifySignature)
}
inline void GetSuggestAliasResponse::set_verifysignature(const char* value, size_t size) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetSuggestAliasResponse.VerifySignature)
}
inline ::std::string* GetSuggestAliasResponse::mutable_verifysignature() {
  set_has_verifysignature();
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasResponse.VerifySignature)
  return verifysignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSuggestAliasResponse::release_verifysignature() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasResponse.VerifySignature)
  clear_has_verifysignature();
  return verifysignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSuggestAliasResponse::set_allocated_verifysignature(::std::string* verifysignature) {
  if (verifysignature != NULL) {
    set_has_verifysignature();
  } else {
    clear_has_verifysignature();
  }
  verifysignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifysignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasResponse.VerifySignature)
}

// optional .micromsg.SKBuiltinBuffer_t VerifyBuff = 5;
inline bool GetSuggestAliasResponse::has_verifybuff() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetSuggestAliasResponse::set_has_verifybuff() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetSuggestAliasResponse::clear_has_verifybuff() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetSuggestAliasResponse::clear_verifybuff() {
  if (verifybuff_ != NULL) verifybuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_verifybuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetSuggestAliasResponse::verifybuff() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasResponse.VerifyBuff)
  return verifybuff_ != NULL ? *verifybuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetSuggestAliasResponse::mutable_verifybuff() {
  set_has_verifybuff();
  if (verifybuff_ == NULL) {
    verifybuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetSuggestAliasResponse.VerifyBuff)
  return verifybuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetSuggestAliasResponse::release_verifybuff() {
  // @@protoc_insertion_point(field_release:micromsg.GetSuggestAliasResponse.VerifyBuff)
  clear_has_verifybuff();
  ::micromsg::SKBuiltinBuffer_t* temp = verifybuff_;
  verifybuff_ = NULL;
  return temp;
}
inline void GetSuggestAliasResponse::set_allocated_verifybuff(::micromsg::SKBuiltinBuffer_t* verifybuff) {
  delete verifybuff_;
  verifybuff_ = verifybuff;
  if (verifybuff) {
    set_has_verifybuff();
  } else {
    clear_has_verifybuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetSuggestAliasResponse.VerifyBuff)
}

// optional int32 UserNameRet = 6;
inline bool GetSuggestAliasResponse::has_usernameret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetSuggestAliasResponse::set_has_usernameret() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetSuggestAliasResponse::clear_has_usernameret() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetSuggestAliasResponse::clear_usernameret() {
  usernameret_ = 0;
  clear_has_usernameret();
}
inline ::google::protobuf::int32 GetSuggestAliasResponse::usernameret() const {
  // @@protoc_insertion_point(field_get:micromsg.GetSuggestAliasResponse.UserNameRet)
  return usernameret_;
}
inline void GetSuggestAliasResponse::set_usernameret(::google::protobuf::int32 value) {
  set_has_usernameret();
  usernameret_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetSuggestAliasResponse.UserNameRet)
}

// -------------------------------------------------------------------

// BindOpMobileRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BindOpMobileRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BindOpMobileRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BindOpMobileRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BindOpMobileRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BindOpMobileRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BindOpMobileRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BindOpMobileRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BindOpMobileRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.BaseRequest)
}

// optional string UserName = 2;
inline bool BindOpMobileRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindOpMobileRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindOpMobileRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindOpMobileRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& BindOpMobileRequest::username() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.UserName)
  return username_.GetNoArena();
}
inline void BindOpMobileRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.UserName)
}
#if LANG_CXX11
inline void BindOpMobileRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileRequest.UserName)
}
#endif
inline void BindOpMobileRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileRequest.UserName)
}
inline void BindOpMobileRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileRequest.UserName)
}
inline ::std::string* BindOpMobileRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileRequest::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.UserName)
}

// optional string Mobile = 3;
inline bool BindOpMobileRequest::has_mobile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindOpMobileRequest::set_has_mobile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindOpMobileRequest::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindOpMobileRequest::clear_mobile() {
  mobile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mobile();
}
inline const ::std::string& BindOpMobileRequest::mobile() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.Mobile)
  return mobile_.GetNoArena();
}
inline void BindOpMobileRequest::set_mobile(const ::std::string& value) {
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.Mobile)
}
#if LANG_CXX11
inline void BindOpMobileRequest::set_mobile(::std::string&& value) {
  set_has_mobile();
  mobile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileRequest.Mobile)
}
#endif
inline void BindOpMobileRequest::set_mobile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileRequest.Mobile)
}
inline void BindOpMobileRequest::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileRequest.Mobile)
}
inline ::std::string* BindOpMobileRequest::mutable_mobile() {
  set_has_mobile();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.Mobile)
  return mobile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileRequest::release_mobile() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.Mobile)
  clear_has_mobile();
  return mobile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileRequest::set_allocated_mobile(::std::string* mobile) {
  if (mobile != NULL) {
    set_has_mobile();
  } else {
    clear_has_mobile();
  }
  mobile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mobile);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.Mobile)
}

// required int32 Opcode = 4;
inline bool BindOpMobileRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BindOpMobileRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BindOpMobileRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BindOpMobileRequest::clear_opcode() {
  opcode_ = 0;
  clear_has_opcode();
}
inline ::google::protobuf::int32 BindOpMobileRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.Opcode)
  return opcode_;
}
inline void BindOpMobileRequest::set_opcode(::google::protobuf::int32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.Opcode)
}

// optional string Verifycode = 5;
inline bool BindOpMobileRequest::has_verifycode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindOpMobileRequest::set_has_verifycode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindOpMobileRequest::clear_has_verifycode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindOpMobileRequest::clear_verifycode() {
  verifycode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifycode();
}
inline const ::std::string& BindOpMobileRequest::verifycode() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.Verifycode)
  return verifycode_.GetNoArena();
}
inline void BindOpMobileRequest::set_verifycode(const ::std::string& value) {
  set_has_verifycode();
  verifycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.Verifycode)
}
#if LANG_CXX11
inline void BindOpMobileRequest::set_verifycode(::std::string&& value) {
  set_has_verifycode();
  verifycode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileRequest.Verifycode)
}
#endif
inline void BindOpMobileRequest::set_verifycode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifycode();
  verifycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileRequest.Verifycode)
}
inline void BindOpMobileRequest::set_verifycode(const char* value, size_t size) {
  set_has_verifycode();
  verifycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileRequest.Verifycode)
}
inline ::std::string* BindOpMobileRequest::mutable_verifycode() {
  set_has_verifycode();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.Verifycode)
  return verifycode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileRequest::release_verifycode() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.Verifycode)
  clear_has_verifycode();
  return verifycode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileRequest::set_allocated_verifycode(::std::string* verifycode) {
  if (verifycode != NULL) {
    set_has_verifycode();
  } else {
    clear_has_verifycode();
  }
  verifycode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifycode);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.Verifycode)
}

// optional int32 DialFlag = 6;
inline bool BindOpMobileRequest::has_dialflag() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BindOpMobileRequest::set_has_dialflag() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BindOpMobileRequest::clear_has_dialflag() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BindOpMobileRequest::clear_dialflag() {
  dialflag_ = 0;
  clear_has_dialflag();
}
inline ::google::protobuf::int32 BindOpMobileRequest::dialflag() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.DialFlag)
  return dialflag_;
}
inline void BindOpMobileRequest::set_dialflag(::google::protobuf::int32 value) {
  set_has_dialflag();
  dialflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.DialFlag)
}

// optional string DialLang = 7;
inline bool BindOpMobileRequest::has_diallang() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindOpMobileRequest::set_has_diallang() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindOpMobileRequest::clear_has_diallang() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindOpMobileRequest::clear_diallang() {
  diallang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_diallang();
}
inline const ::std::string& BindOpMobileRequest::diallang() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.DialLang)
  return diallang_.GetNoArena();
}
inline void BindOpMobileRequest::set_diallang(const ::std::string& value) {
  set_has_diallang();
  diallang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.DialLang)
}
#if LANG_CXX11
inline void BindOpMobileRequest::set_diallang(::std::string&& value) {
  set_has_diallang();
  diallang_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileRequest.DialLang)
}
#endif
inline void BindOpMobileRequest::set_diallang(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_diallang();
  diallang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileRequest.DialLang)
}
inline void BindOpMobileRequest::set_diallang(const char* value, size_t size) {
  set_has_diallang();
  diallang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileRequest.DialLang)
}
inline ::std::string* BindOpMobileRequest::mutable_diallang() {
  set_has_diallang();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.DialLang)
  return diallang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileRequest::release_diallang() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.DialLang)
  clear_has_diallang();
  return diallang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileRequest::set_allocated_diallang(::std::string* diallang) {
  if (diallang != NULL) {
    set_has_diallang();
  } else {
    clear_has_diallang();
  }
  diallang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), diallang);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.DialLang)
}

// optional string AuthTicket = 8;
inline bool BindOpMobileRequest::has_authticket() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BindOpMobileRequest::set_has_authticket() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BindOpMobileRequest::clear_has_authticket() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BindOpMobileRequest::clear_authticket() {
  authticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authticket();
}
inline const ::std::string& BindOpMobileRequest::authticket() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.AuthTicket)
  return authticket_.GetNoArena();
}
inline void BindOpMobileRequest::set_authticket(const ::std::string& value) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.AuthTicket)
}
#if LANG_CXX11
inline void BindOpMobileRequest::set_authticket(::std::string&& value) {
  set_has_authticket();
  authticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileRequest.AuthTicket)
}
#endif
inline void BindOpMobileRequest::set_authticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileRequest.AuthTicket)
}
inline void BindOpMobileRequest::set_authticket(const char* value, size_t size) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileRequest.AuthTicket)
}
inline ::std::string* BindOpMobileRequest::mutable_authticket() {
  set_has_authticket();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.AuthTicket)
  return authticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileRequest::release_authticket() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.AuthTicket)
  clear_has_authticket();
  return authticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileRequest::set_allocated_authticket(::std::string* authticket) {
  if (authticket != NULL) {
    set_has_authticket();
  } else {
    clear_has_authticket();
  }
  authticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.AuthTicket)
}

// optional uint32 ForceReg = 9;
inline bool BindOpMobileRequest::has_forcereg() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BindOpMobileRequest::set_has_forcereg() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BindOpMobileRequest::clear_has_forcereg() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BindOpMobileRequest::clear_forcereg() {
  forcereg_ = 0u;
  clear_has_forcereg();
}
inline ::google::protobuf::uint32 BindOpMobileRequest::forcereg() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.ForceReg)
  return forcereg_;
}
inline void BindOpMobileRequest::set_forcereg(::google::protobuf::uint32 value) {
  set_has_forcereg();
  forcereg_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.ForceReg)
}

// optional string SafeDeviceName = 10;
inline bool BindOpMobileRequest::has_safedevicename() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BindOpMobileRequest::set_has_safedevicename() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BindOpMobileRequest::clear_has_safedevicename() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BindOpMobileRequest::clear_safedevicename() {
  safedevicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_safedevicename();
}
inline const ::std::string& BindOpMobileRequest::safedevicename() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.SafeDeviceName)
  return safedevicename_.GetNoArena();
}
inline void BindOpMobileRequest::set_safedevicename(const ::std::string& value) {
  set_has_safedevicename();
  safedevicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.SafeDeviceName)
}
#if LANG_CXX11
inline void BindOpMobileRequest::set_safedevicename(::std::string&& value) {
  set_has_safedevicename();
  safedevicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileRequest.SafeDeviceName)
}
#endif
inline void BindOpMobileRequest::set_safedevicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_safedevicename();
  safedevicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileRequest.SafeDeviceName)
}
inline void BindOpMobileRequest::set_safedevicename(const char* value, size_t size) {
  set_has_safedevicename();
  safedevicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileRequest.SafeDeviceName)
}
inline ::std::string* BindOpMobileRequest::mutable_safedevicename() {
  set_has_safedevicename();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.SafeDeviceName)
  return safedevicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileRequest::release_safedevicename() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.SafeDeviceName)
  clear_has_safedevicename();
  return safedevicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileRequest::set_allocated_safedevicename(::std::string* safedevicename) {
  if (safedevicename != NULL) {
    set_has_safedevicename();
  } else {
    clear_has_safedevicename();
  }
  safedevicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), safedevicename);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.SafeDeviceName)
}

// optional string SafeDeviceType = 11;
inline bool BindOpMobileRequest::has_safedevicetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BindOpMobileRequest::set_has_safedevicetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BindOpMobileRequest::clear_has_safedevicetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BindOpMobileRequest::clear_safedevicetype() {
  safedevicetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_safedevicetype();
}
inline const ::std::string& BindOpMobileRequest::safedevicetype() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.SafeDeviceType)
  return safedevicetype_.GetNoArena();
}
inline void BindOpMobileRequest::set_safedevicetype(const ::std::string& value) {
  set_has_safedevicetype();
  safedevicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.SafeDeviceType)
}
#if LANG_CXX11
inline void BindOpMobileRequest::set_safedevicetype(::std::string&& value) {
  set_has_safedevicetype();
  safedevicetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileRequest.SafeDeviceType)
}
#endif
inline void BindOpMobileRequest::set_safedevicetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_safedevicetype();
  safedevicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileRequest.SafeDeviceType)
}
inline void BindOpMobileRequest::set_safedevicetype(const char* value, size_t size) {
  set_has_safedevicetype();
  safedevicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileRequest.SafeDeviceType)
}
inline ::std::string* BindOpMobileRequest::mutable_safedevicetype() {
  set_has_safedevicetype();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.SafeDeviceType)
  return safedevicetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileRequest::release_safedevicetype() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.SafeDeviceType)
  clear_has_safedevicetype();
  return safedevicetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileRequest::set_allocated_safedevicetype(::std::string* safedevicetype) {
  if (safedevicetype != NULL) {
    set_has_safedevicetype();
  } else {
    clear_has_safedevicetype();
  }
  safedevicetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), safedevicetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.SafeDeviceType)
}

// optional .micromsg.SKBuiltinBuffer_t RandomEncryKey = 12;
inline bool BindOpMobileRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BindOpMobileRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BindOpMobileRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BindOpMobileRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& BindOpMobileRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BindOpMobileRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* BindOpMobileRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void BindOpMobileRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.RandomEncryKey)
}

// optional string Language = 13;
inline bool BindOpMobileRequest::has_language() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BindOpMobileRequest::set_has_language() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BindOpMobileRequest::clear_has_language() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BindOpMobileRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& BindOpMobileRequest::language() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.Language)
  return language_.GetNoArena();
}
inline void BindOpMobileRequest::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.Language)
}
#if LANG_CXX11
inline void BindOpMobileRequest::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileRequest.Language)
}
#endif
inline void BindOpMobileRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileRequest.Language)
}
inline void BindOpMobileRequest::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileRequest.Language)
}
inline ::std::string* BindOpMobileRequest::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.Language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileRequest::release_language() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.Language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileRequest::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.Language)
}

// optional uint32 InputMobileRetrys = 14;
inline bool BindOpMobileRequest::has_inputmobileretrys() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BindOpMobileRequest::set_has_inputmobileretrys() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BindOpMobileRequest::clear_has_inputmobileretrys() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BindOpMobileRequest::clear_inputmobileretrys() {
  inputmobileretrys_ = 0u;
  clear_has_inputmobileretrys();
}
inline ::google::protobuf::uint32 BindOpMobileRequest::inputmobileretrys() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.InputMobileRetrys)
  return inputmobileretrys_;
}
inline void BindOpMobileRequest::set_inputmobileretrys(::google::protobuf::uint32 value) {
  set_has_inputmobileretrys();
  inputmobileretrys_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.InputMobileRetrys)
}

// optional uint32 AdjustRet = 15;
inline bool BindOpMobileRequest::has_adjustret() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BindOpMobileRequest::set_has_adjustret() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BindOpMobileRequest::clear_has_adjustret() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BindOpMobileRequest::clear_adjustret() {
  adjustret_ = 0u;
  clear_has_adjustret();
}
inline ::google::protobuf::uint32 BindOpMobileRequest::adjustret() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.AdjustRet)
  return adjustret_;
}
inline void BindOpMobileRequest::set_adjustret(::google::protobuf::uint32 value) {
  set_has_adjustret();
  adjustret_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.AdjustRet)
}

// optional string ClientSeqID = 16;
inline bool BindOpMobileRequest::has_clientseqid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BindOpMobileRequest::set_has_clientseqid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BindOpMobileRequest::clear_has_clientseqid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BindOpMobileRequest::clear_clientseqid() {
  clientseqid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientseqid();
}
inline const ::std::string& BindOpMobileRequest::clientseqid() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileRequest.ClientSeqID)
  return clientseqid_.GetNoArena();
}
inline void BindOpMobileRequest::set_clientseqid(const ::std::string& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileRequest.ClientSeqID)
}
#if LANG_CXX11
inline void BindOpMobileRequest::set_clientseqid(::std::string&& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileRequest.ClientSeqID)
}
#endif
inline void BindOpMobileRequest::set_clientseqid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileRequest.ClientSeqID)
}
inline void BindOpMobileRequest::set_clientseqid(const char* value, size_t size) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileRequest.ClientSeqID)
}
inline ::std::string* BindOpMobileRequest::mutable_clientseqid() {
  set_has_clientseqid();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileRequest.ClientSeqID)
  return clientseqid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileRequest::release_clientseqid() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileRequest.ClientSeqID)
  clear_has_clientseqid();
  return clientseqid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileRequest::set_allocated_clientseqid(::std::string* clientseqid) {
  if (clientseqid != NULL) {
    set_has_clientseqid();
  } else {
    clear_has_clientseqid();
  }
  clientseqid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientseqid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileRequest.ClientSeqID)
}

// -------------------------------------------------------------------

// BindOpMobileResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BindOpMobileResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BindOpMobileResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BindOpMobileResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BindOpMobileResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BindOpMobileResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BindOpMobileResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BindOpMobileResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BindOpMobileResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.BaseResponse)
}

// optional string ticket = 2;
inline bool BindOpMobileResponse::has_ticket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindOpMobileResponse::set_has_ticket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindOpMobileResponse::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindOpMobileResponse::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& BindOpMobileResponse::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.ticket)
  return ticket_.GetNoArena();
}
inline void BindOpMobileResponse::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.ticket)
}
#if LANG_CXX11
inline void BindOpMobileResponse::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileResponse.ticket)
}
#endif
inline void BindOpMobileResponse::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileResponse.ticket)
}
inline void BindOpMobileResponse::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileResponse.ticket)
}
inline ::std::string* BindOpMobileResponse::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileResponse::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileResponse::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.ticket)
}

// optional string SmsNo = 3;
inline bool BindOpMobileResponse::has_smsno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindOpMobileResponse::set_has_smsno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindOpMobileResponse::clear_has_smsno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindOpMobileResponse::clear_smsno() {
  smsno_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_smsno();
}
inline const ::std::string& BindOpMobileResponse::smsno() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.SmsNo)
  return smsno_.GetNoArena();
}
inline void BindOpMobileResponse::set_smsno(const ::std::string& value) {
  set_has_smsno();
  smsno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.SmsNo)
}
#if LANG_CXX11
inline void BindOpMobileResponse::set_smsno(::std::string&& value) {
  set_has_smsno();
  smsno_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileResponse.SmsNo)
}
#endif
inline void BindOpMobileResponse::set_smsno(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_smsno();
  smsno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileResponse.SmsNo)
}
inline void BindOpMobileResponse::set_smsno(const char* value, size_t size) {
  set_has_smsno();
  smsno_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileResponse.SmsNo)
}
inline ::std::string* BindOpMobileResponse::mutable_smsno() {
  set_has_smsno();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.SmsNo)
  return smsno_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileResponse::release_smsno() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.SmsNo)
  clear_has_smsno();
  return smsno_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileResponse::set_allocated_smsno(::std::string* smsno) {
  if (smsno != NULL) {
    set_has_smsno();
  } else {
    clear_has_smsno();
  }
  smsno_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), smsno);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.SmsNo)
}

// optional uint32 NeedSetPwd = 4;
inline bool BindOpMobileResponse::has_needsetpwd() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BindOpMobileResponse::set_has_needsetpwd() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BindOpMobileResponse::clear_has_needsetpwd() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BindOpMobileResponse::clear_needsetpwd() {
  needsetpwd_ = 0u;
  clear_has_needsetpwd();
}
inline ::google::protobuf::uint32 BindOpMobileResponse::needsetpwd() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.NeedSetPwd)
  return needsetpwd_;
}
inline void BindOpMobileResponse::set_needsetpwd(::google::protobuf::uint32 value) {
  set_has_needsetpwd();
  needsetpwd_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.NeedSetPwd)
}

// optional string Pwd = 5;
inline bool BindOpMobileResponse::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindOpMobileResponse::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindOpMobileResponse::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindOpMobileResponse::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd();
}
inline const ::std::string& BindOpMobileResponse::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.Pwd)
  return pwd_.GetNoArena();
}
inline void BindOpMobileResponse::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.Pwd)
}
#if LANG_CXX11
inline void BindOpMobileResponse::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileResponse.Pwd)
}
#endif
inline void BindOpMobileResponse::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileResponse.Pwd)
}
inline void BindOpMobileResponse::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileResponse.Pwd)
}
inline ::std::string* BindOpMobileResponse::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.Pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileResponse::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.Pwd)
  clear_has_pwd();
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileResponse::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.Pwd)
}

// optional string Username = 6;
inline bool BindOpMobileResponse::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindOpMobileResponse::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindOpMobileResponse::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindOpMobileResponse::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& BindOpMobileResponse::username() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.Username)
  return username_.GetNoArena();
}
inline void BindOpMobileResponse::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.Username)
}
#if LANG_CXX11
inline void BindOpMobileResponse::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileResponse.Username)
}
#endif
inline void BindOpMobileResponse::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileResponse.Username)
}
inline void BindOpMobileResponse::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileResponse.Username)
}
inline ::std::string* BindOpMobileResponse::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.Username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileResponse::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.Username)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileResponse::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.Username)
}

// optional .micromsg.HostList NewHostList = 7;
inline bool BindOpMobileResponse::has_newhostlist() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BindOpMobileResponse::set_has_newhostlist() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BindOpMobileResponse::clear_has_newhostlist() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BindOpMobileResponse::clear_newhostlist() {
  if (newhostlist_ != NULL) newhostlist_->::micromsg::HostList::Clear();
  clear_has_newhostlist();
}
inline const ::micromsg::HostList& BindOpMobileResponse::newhostlist() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.NewHostList)
  return newhostlist_ != NULL ? *newhostlist_
                         : *::micromsg::HostList::internal_default_instance();
}
inline ::micromsg::HostList* BindOpMobileResponse::mutable_newhostlist() {
  set_has_newhostlist();
  if (newhostlist_ == NULL) {
    newhostlist_ = new ::micromsg::HostList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.NewHostList)
  return newhostlist_;
}
inline ::micromsg::HostList* BindOpMobileResponse::release_newhostlist() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.NewHostList)
  clear_has_newhostlist();
  ::micromsg::HostList* temp = newhostlist_;
  newhostlist_ = NULL;
  return temp;
}
inline void BindOpMobileResponse::set_allocated_newhostlist(::micromsg::HostList* newhostlist) {
  delete newhostlist_;
  newhostlist_ = newhostlist;
  if (newhostlist) {
    set_has_newhostlist();
  } else {
    clear_has_newhostlist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.NewHostList)
}

// optional .micromsg.BuiltinIPList BuiltinIPList = 8;
inline bool BindOpMobileResponse::has_builtiniplist() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BindOpMobileResponse::set_has_builtiniplist() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BindOpMobileResponse::clear_has_builtiniplist() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BindOpMobileResponse::clear_builtiniplist() {
  if (builtiniplist_ != NULL) builtiniplist_->::micromsg::BuiltinIPList::Clear();
  clear_has_builtiniplist();
}
inline const ::micromsg::BuiltinIPList& BindOpMobileResponse::builtiniplist() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.BuiltinIPList)
  return builtiniplist_ != NULL ? *builtiniplist_
                         : *::micromsg::BuiltinIPList::internal_default_instance();
}
inline ::micromsg::BuiltinIPList* BindOpMobileResponse::mutable_builtiniplist() {
  set_has_builtiniplist();
  if (builtiniplist_ == NULL) {
    builtiniplist_ = new ::micromsg::BuiltinIPList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.BuiltinIPList)
  return builtiniplist_;
}
inline ::micromsg::BuiltinIPList* BindOpMobileResponse::release_builtiniplist() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.BuiltinIPList)
  clear_has_builtiniplist();
  ::micromsg::BuiltinIPList* temp = builtiniplist_;
  builtiniplist_ = NULL;
  return temp;
}
inline void BindOpMobileResponse::set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist) {
  delete builtiniplist_;
  builtiniplist_ = builtiniplist;
  if (builtiniplist) {
    set_has_builtiniplist();
  } else {
    clear_has_builtiniplist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.BuiltinIPList)
}

// optional .micromsg.NetworkControl NetworkControl = 9;
inline bool BindOpMobileResponse::has_networkcontrol() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BindOpMobileResponse::set_has_networkcontrol() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BindOpMobileResponse::clear_has_networkcontrol() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BindOpMobileResponse::clear_networkcontrol() {
  if (networkcontrol_ != NULL) networkcontrol_->::micromsg::NetworkControl::Clear();
  clear_has_networkcontrol();
}
inline const ::micromsg::NetworkControl& BindOpMobileResponse::networkcontrol() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.NetworkControl)
  return networkcontrol_ != NULL ? *networkcontrol_
                         : *::micromsg::NetworkControl::internal_default_instance();
}
inline ::micromsg::NetworkControl* BindOpMobileResponse::mutable_networkcontrol() {
  set_has_networkcontrol();
  if (networkcontrol_ == NULL) {
    networkcontrol_ = new ::micromsg::NetworkControl;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.NetworkControl)
  return networkcontrol_;
}
inline ::micromsg::NetworkControl* BindOpMobileResponse::release_networkcontrol() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.NetworkControl)
  clear_has_networkcontrol();
  ::micromsg::NetworkControl* temp = networkcontrol_;
  networkcontrol_ = NULL;
  return temp;
}
inline void BindOpMobileResponse::set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol) {
  delete networkcontrol_;
  networkcontrol_ = networkcontrol;
  if (networkcontrol) {
    set_has_networkcontrol();
  } else {
    clear_has_networkcontrol();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.NetworkControl)
}

// optional string AuthTicket = 10;
inline bool BindOpMobileResponse::has_authticket() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BindOpMobileResponse::set_has_authticket() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BindOpMobileResponse::clear_has_authticket() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BindOpMobileResponse::clear_authticket() {
  authticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authticket();
}
inline const ::std::string& BindOpMobileResponse::authticket() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.AuthTicket)
  return authticket_.GetNoArena();
}
inline void BindOpMobileResponse::set_authticket(const ::std::string& value) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.AuthTicket)
}
#if LANG_CXX11
inline void BindOpMobileResponse::set_authticket(::std::string&& value) {
  set_has_authticket();
  authticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileResponse.AuthTicket)
}
#endif
inline void BindOpMobileResponse::set_authticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileResponse.AuthTicket)
}
inline void BindOpMobileResponse::set_authticket(const char* value, size_t size) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileResponse.AuthTicket)
}
inline ::std::string* BindOpMobileResponse::mutable_authticket() {
  set_has_authticket();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.AuthTicket)
  return authticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileResponse::release_authticket() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.AuthTicket)
  clear_has_authticket();
  return authticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileResponse::set_allocated_authticket(::std::string* authticket) {
  if (authticket != NULL) {
    set_has_authticket();
  } else {
    clear_has_authticket();
  }
  authticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.AuthTicket)
}

// optional uint32 SafeDevice = 11;
inline bool BindOpMobileResponse::has_safedevice() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BindOpMobileResponse::set_has_safedevice() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BindOpMobileResponse::clear_has_safedevice() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BindOpMobileResponse::clear_safedevice() {
  safedevice_ = 0u;
  clear_has_safedevice();
}
inline ::google::protobuf::uint32 BindOpMobileResponse::safedevice() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.SafeDevice)
  return safedevice_;
}
inline void BindOpMobileResponse::set_safedevice(::google::protobuf::uint32 value) {
  set_has_safedevice();
  safedevice_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.SafeDevice)
}

// optional string CC = 12;
inline bool BindOpMobileResponse::has_cc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BindOpMobileResponse::set_has_cc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BindOpMobileResponse::clear_has_cc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BindOpMobileResponse::clear_cc() {
  cc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cc();
}
inline const ::std::string& BindOpMobileResponse::cc() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.CC)
  return cc_.GetNoArena();
}
inline void BindOpMobileResponse::set_cc(const ::std::string& value) {
  set_has_cc();
  cc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.CC)
}
#if LANG_CXX11
inline void BindOpMobileResponse::set_cc(::std::string&& value) {
  set_has_cc();
  cc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileResponse.CC)
}
#endif
inline void BindOpMobileResponse::set_cc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cc();
  cc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileResponse.CC)
}
inline void BindOpMobileResponse::set_cc(const char* value, size_t size) {
  set_has_cc();
  cc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileResponse.CC)
}
inline ::std::string* BindOpMobileResponse::mutable_cc() {
  set_has_cc();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.CC)
  return cc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileResponse::release_cc() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.CC)
  clear_has_cc();
  return cc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileResponse::set_allocated_cc(::std::string* cc) {
  if (cc != NULL) {
    set_has_cc();
  } else {
    clear_has_cc();
  }
  cc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cc);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.CC)
}

// optional uint32 ObsoleteItem1 = 13;
inline bool BindOpMobileResponse::has_obsoleteitem1() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BindOpMobileResponse::set_has_obsoleteitem1() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BindOpMobileResponse::clear_has_obsoleteitem1() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BindOpMobileResponse::clear_obsoleteitem1() {
  obsoleteitem1_ = 0u;
  clear_has_obsoleteitem1();
}
inline ::google::protobuf::uint32 BindOpMobileResponse::obsoleteitem1() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.ObsoleteItem1)
  return obsoleteitem1_;
}
inline void BindOpMobileResponse::set_obsoleteitem1(::google::protobuf::uint32 value) {
  set_has_obsoleteitem1();
  obsoleteitem1_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.ObsoleteItem1)
}

// optional .micromsg.SafeDeviceList SafeDeviceList = 14;
inline bool BindOpMobileResponse::has_safedevicelist() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BindOpMobileResponse::set_has_safedevicelist() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BindOpMobileResponse::clear_has_safedevicelist() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BindOpMobileResponse::clear_safedevicelist() {
  if (safedevicelist_ != NULL) safedevicelist_->::micromsg::SafeDeviceList::Clear();
  clear_has_safedevicelist();
}
inline const ::micromsg::SafeDeviceList& BindOpMobileResponse::safedevicelist() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.SafeDeviceList)
  return safedevicelist_ != NULL ? *safedevicelist_
                         : *::micromsg::SafeDeviceList::internal_default_instance();
}
inline ::micromsg::SafeDeviceList* BindOpMobileResponse::mutable_safedevicelist() {
  set_has_safedevicelist();
  if (safedevicelist_ == NULL) {
    safedevicelist_ = new ::micromsg::SafeDeviceList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.SafeDeviceList)
  return safedevicelist_;
}
inline ::micromsg::SafeDeviceList* BindOpMobileResponse::release_safedevicelist() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.SafeDeviceList)
  clear_has_safedevicelist();
  ::micromsg::SafeDeviceList* temp = safedevicelist_;
  safedevicelist_ = NULL;
  return temp;
}
inline void BindOpMobileResponse::set_allocated_safedevicelist(::micromsg::SafeDeviceList* safedevicelist) {
  delete safedevicelist_;
  safedevicelist_ = safedevicelist;
  if (safedevicelist) {
    set_has_safedevicelist();
  } else {
    clear_has_safedevicelist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.SafeDeviceList)
}

// optional string PureMobile = 15;
inline bool BindOpMobileResponse::has_puremobile() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BindOpMobileResponse::set_has_puremobile() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BindOpMobileResponse::clear_has_puremobile() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BindOpMobileResponse::clear_puremobile() {
  puremobile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_puremobile();
}
inline const ::std::string& BindOpMobileResponse::puremobile() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.PureMobile)
  return puremobile_.GetNoArena();
}
inline void BindOpMobileResponse::set_puremobile(const ::std::string& value) {
  set_has_puremobile();
  puremobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.PureMobile)
}
#if LANG_CXX11
inline void BindOpMobileResponse::set_puremobile(::std::string&& value) {
  set_has_puremobile();
  puremobile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileResponse.PureMobile)
}
#endif
inline void BindOpMobileResponse::set_puremobile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_puremobile();
  puremobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileResponse.PureMobile)
}
inline void BindOpMobileResponse::set_puremobile(const char* value, size_t size) {
  set_has_puremobile();
  puremobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileResponse.PureMobile)
}
inline ::std::string* BindOpMobileResponse::mutable_puremobile() {
  set_has_puremobile();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.PureMobile)
  return puremobile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileResponse::release_puremobile() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.PureMobile)
  clear_has_puremobile();
  return puremobile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileResponse::set_allocated_puremobile(::std::string* puremobile) {
  if (puremobile != NULL) {
    set_has_puremobile();
  } else {
    clear_has_puremobile();
  }
  puremobile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), puremobile);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.PureMobile)
}

// optional string FormatedMobile = 16;
inline bool BindOpMobileResponse::has_formatedmobile() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BindOpMobileResponse::set_has_formatedmobile() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BindOpMobileResponse::clear_has_formatedmobile() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BindOpMobileResponse::clear_formatedmobile() {
  formatedmobile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_formatedmobile();
}
inline const ::std::string& BindOpMobileResponse::formatedmobile() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.FormatedMobile)
  return formatedmobile_.GetNoArena();
}
inline void BindOpMobileResponse::set_formatedmobile(const ::std::string& value) {
  set_has_formatedmobile();
  formatedmobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindOpMobileResponse.FormatedMobile)
}
#if LANG_CXX11
inline void BindOpMobileResponse::set_formatedmobile(::std::string&& value) {
  set_has_formatedmobile();
  formatedmobile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindOpMobileResponse.FormatedMobile)
}
#endif
inline void BindOpMobileResponse::set_formatedmobile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_formatedmobile();
  formatedmobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindOpMobileResponse.FormatedMobile)
}
inline void BindOpMobileResponse::set_formatedmobile(const char* value, size_t size) {
  set_has_formatedmobile();
  formatedmobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindOpMobileResponse.FormatedMobile)
}
inline ::std::string* BindOpMobileResponse::mutable_formatedmobile() {
  set_has_formatedmobile();
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.FormatedMobile)
  return formatedmobile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindOpMobileResponse::release_formatedmobile() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.FormatedMobile)
  clear_has_formatedmobile();
  return formatedmobile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindOpMobileResponse::set_allocated_formatedmobile(::std::string* formatedmobile) {
  if (formatedmobile != NULL) {
    set_has_formatedmobile();
  } else {
    clear_has_formatedmobile();
  }
  formatedmobile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), formatedmobile);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.FormatedMobile)
}

// optional .micromsg.ShowStyleKey ShowStyle = 17;
inline bool BindOpMobileResponse::has_showstyle() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BindOpMobileResponse::set_has_showstyle() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BindOpMobileResponse::clear_has_showstyle() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BindOpMobileResponse::clear_showstyle() {
  if (showstyle_ != NULL) showstyle_->::micromsg::ShowStyleKey::Clear();
  clear_has_showstyle();
}
inline const ::micromsg::ShowStyleKey& BindOpMobileResponse::showstyle() const {
  // @@protoc_insertion_point(field_get:micromsg.BindOpMobileResponse.ShowStyle)
  return showstyle_ != NULL ? *showstyle_
                         : *::micromsg::ShowStyleKey::internal_default_instance();
}
inline ::micromsg::ShowStyleKey* BindOpMobileResponse::mutable_showstyle() {
  set_has_showstyle();
  if (showstyle_ == NULL) {
    showstyle_ = new ::micromsg::ShowStyleKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindOpMobileResponse.ShowStyle)
  return showstyle_;
}
inline ::micromsg::ShowStyleKey* BindOpMobileResponse::release_showstyle() {
  // @@protoc_insertion_point(field_release:micromsg.BindOpMobileResponse.ShowStyle)
  clear_has_showstyle();
  ::micromsg::ShowStyleKey* temp = showstyle_;
  showstyle_ = NULL;
  return temp;
}
inline void BindOpMobileResponse::set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle) {
  delete showstyle_;
  showstyle_ = showstyle;
  if (showstyle) {
    set_has_showstyle();
  } else {
    clear_has_showstyle();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindOpMobileResponse.ShowStyle)
}

// -------------------------------------------------------------------

// EmailRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool EmailRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmailRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmailRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmailRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& EmailRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* EmailRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* EmailRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void EmailRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegRequest.BaseRequest)
}

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
inline bool EmailRegRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EmailRegRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EmailRegRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EmailRegRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& EmailRegRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* EmailRegRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* EmailRegRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void EmailRegRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegRequest.RandomEncryKey)
}

// required uint32 Opcode = 3;
inline bool EmailRegRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EmailRegRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EmailRegRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EmailRegRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 EmailRegRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.Opcode)
  return opcode_;
}
inline void EmailRegRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmailRegRequest.Opcode)
}

// optional string Email = 4;
inline bool EmailRegRequest::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmailRegRequest::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmailRegRequest::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmailRegRequest::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_email();
}
inline const ::std::string& EmailRegRequest::email() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.Email)
  return email_.GetNoArena();
}
inline void EmailRegRequest::set_email(const ::std::string& value) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmailRegRequest.Email)
}
#if LANG_CXX11
inline void EmailRegRequest::set_email(::std::string&& value) {
  set_has_email();
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmailRegRequest.Email)
}
#endif
inline void EmailRegRequest::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmailRegRequest.Email)
}
inline void EmailRegRequest::set_email(const char* value, size_t size) {
  set_has_email();
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmailRegRequest.Email)
}
inline ::std::string* EmailRegRequest::mutable_email() {
  set_has_email();
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegRequest.Email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmailRegRequest::release_email() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegRequest.Email)
  clear_has_email();
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmailRegRequest::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    set_has_email();
  } else {
    clear_has_email();
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegRequest.Email)
}

// optional string Language = 5;
inline bool EmailRegRequest::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmailRegRequest::set_has_language() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmailRegRequest::clear_has_language() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmailRegRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& EmailRegRequest::language() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.Language)
  return language_.GetNoArena();
}
inline void EmailRegRequest::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmailRegRequest.Language)
}
#if LANG_CXX11
inline void EmailRegRequest::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmailRegRequest.Language)
}
#endif
inline void EmailRegRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmailRegRequest.Language)
}
inline void EmailRegRequest::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmailRegRequest.Language)
}
inline ::std::string* EmailRegRequest::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegRequest.Language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmailRegRequest::release_language() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegRequest.Language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmailRegRequest::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegRequest.Language)
}

// optional string Pwd = 6;
inline bool EmailRegRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmailRegRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmailRegRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmailRegRequest::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd();
}
inline const ::std::string& EmailRegRequest::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.Pwd)
  return pwd_.GetNoArena();
}
inline void EmailRegRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmailRegRequest.Pwd)
}
#if LANG_CXX11
inline void EmailRegRequest::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmailRegRequest.Pwd)
}
#endif
inline void EmailRegRequest::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmailRegRequest.Pwd)
}
inline void EmailRegRequest::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmailRegRequest.Pwd)
}
inline ::std::string* EmailRegRequest::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegRequest.Pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmailRegRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegRequest.Pwd)
  clear_has_pwd();
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmailRegRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegRequest.Pwd)
}

// optional string VerifyCode = 7;
inline bool EmailRegRequest::has_verifycode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmailRegRequest::set_has_verifycode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmailRegRequest::clear_has_verifycode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmailRegRequest::clear_verifycode() {
  verifycode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifycode();
}
inline const ::std::string& EmailRegRequest::verifycode() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.VerifyCode)
  return verifycode_.GetNoArena();
}
inline void EmailRegRequest::set_verifycode(const ::std::string& value) {
  set_has_verifycode();
  verifycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmailRegRequest.VerifyCode)
}
#if LANG_CXX11
inline void EmailRegRequest::set_verifycode(::std::string&& value) {
  set_has_verifycode();
  verifycode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmailRegRequest.VerifyCode)
}
#endif
inline void EmailRegRequest::set_verifycode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifycode();
  verifycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmailRegRequest.VerifyCode)
}
inline void EmailRegRequest::set_verifycode(const char* value, size_t size) {
  set_has_verifycode();
  verifycode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmailRegRequest.VerifyCode)
}
inline ::std::string* EmailRegRequest::mutable_verifycode() {
  set_has_verifycode();
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegRequest.VerifyCode)
  return verifycode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmailRegRequest::release_verifycode() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegRequest.VerifyCode)
  clear_has_verifycode();
  return verifycode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmailRegRequest::set_allocated_verifycode(::std::string* verifycode) {
  if (verifycode != NULL) {
    set_has_verifycode();
  } else {
    clear_has_verifycode();
  }
  verifycode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifycode);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegRequest.VerifyCode)
}

// optional string ClientSeqID = 8;
inline bool EmailRegRequest::has_clientseqid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmailRegRequest::set_has_clientseqid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmailRegRequest::clear_has_clientseqid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmailRegRequest::clear_clientseqid() {
  clientseqid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientseqid();
}
inline const ::std::string& EmailRegRequest::clientseqid() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.ClientSeqID)
  return clientseqid_.GetNoArena();
}
inline void EmailRegRequest::set_clientseqid(const ::std::string& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmailRegRequest.ClientSeqID)
}
#if LANG_CXX11
inline void EmailRegRequest::set_clientseqid(::std::string&& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmailRegRequest.ClientSeqID)
}
#endif
inline void EmailRegRequest::set_clientseqid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmailRegRequest.ClientSeqID)
}
inline void EmailRegRequest::set_clientseqid(const char* value, size_t size) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmailRegRequest.ClientSeqID)
}
inline ::std::string* EmailRegRequest::mutable_clientseqid() {
  set_has_clientseqid();
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegRequest.ClientSeqID)
  return clientseqid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmailRegRequest::release_clientseqid() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegRequest.ClientSeqID)
  clear_has_clientseqid();
  return clientseqid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmailRegRequest::set_allocated_clientseqid(::std::string* clientseqid) {
  if (clientseqid != NULL) {
    set_has_clientseqid();
  } else {
    clear_has_clientseqid();
  }
  clientseqid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientseqid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegRequest.ClientSeqID)
}

// optional string RealCountry = 9;
inline bool EmailRegRequest::has_realcountry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmailRegRequest::set_has_realcountry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmailRegRequest::clear_has_realcountry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmailRegRequest::clear_realcountry() {
  realcountry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_realcountry();
}
inline const ::std::string& EmailRegRequest::realcountry() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.RealCountry)
  return realcountry_.GetNoArena();
}
inline void EmailRegRequest::set_realcountry(const ::std::string& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmailRegRequest.RealCountry)
}
#if LANG_CXX11
inline void EmailRegRequest::set_realcountry(::std::string&& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmailRegRequest.RealCountry)
}
#endif
inline void EmailRegRequest::set_realcountry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmailRegRequest.RealCountry)
}
inline void EmailRegRequest::set_realcountry(const char* value, size_t size) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmailRegRequest.RealCountry)
}
inline ::std::string* EmailRegRequest::mutable_realcountry() {
  set_has_realcountry();
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegRequest.RealCountry)
  return realcountry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmailRegRequest::release_realcountry() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegRequest.RealCountry)
  clear_has_realcountry();
  return realcountry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmailRegRequest::set_allocated_realcountry(::std::string* realcountry) {
  if (realcountry != NULL) {
    set_has_realcountry();
  } else {
    clear_has_realcountry();
  }
  realcountry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), realcountry);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegRequest.RealCountry)
}

// optional uint32 VerifyScene = 10;
inline bool EmailRegRequest::has_verifyscene() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EmailRegRequest::set_has_verifyscene() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EmailRegRequest::clear_has_verifyscene() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EmailRegRequest::clear_verifyscene() {
  verifyscene_ = 0u;
  clear_has_verifyscene();
}
inline ::google::protobuf::uint32 EmailRegRequest::verifyscene() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegRequest.VerifyScene)
  return verifyscene_;
}
inline void EmailRegRequest::set_verifyscene(::google::protobuf::uint32 value) {
  set_has_verifyscene();
  verifyscene_ = value;
  // @@protoc_insertion_point(field_set:micromsg.EmailRegRequest.VerifyScene)
}

// -------------------------------------------------------------------

// EmailRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool EmailRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmailRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmailRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmailRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& EmailRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* EmailRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* EmailRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void EmailRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegResponse.BaseResponse)
}

// optional string Ticket = 2;
inline bool EmailRegResponse::has_ticket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmailRegResponse::set_has_ticket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmailRegResponse::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmailRegResponse::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& EmailRegResponse::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegResponse.Ticket)
  return ticket_.GetNoArena();
}
inline void EmailRegResponse::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.EmailRegResponse.Ticket)
}
#if LANG_CXX11
inline void EmailRegResponse::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.EmailRegResponse.Ticket)
}
#endif
inline void EmailRegResponse::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.EmailRegResponse.Ticket)
}
inline void EmailRegResponse::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.EmailRegResponse.Ticket)
}
inline ::std::string* EmailRegResponse::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegResponse.Ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EmailRegResponse::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegResponse.Ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EmailRegResponse::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegResponse.Ticket)
}

// optional .micromsg.BuiltinIPList BuiltinIPList = 3;
inline bool EmailRegResponse::has_builtiniplist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmailRegResponse::set_has_builtiniplist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmailRegResponse::clear_has_builtiniplist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmailRegResponse::clear_builtiniplist() {
  if (builtiniplist_ != NULL) builtiniplist_->::micromsg::BuiltinIPList::Clear();
  clear_has_builtiniplist();
}
inline const ::micromsg::BuiltinIPList& EmailRegResponse::builtiniplist() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegResponse.BuiltinIPList)
  return builtiniplist_ != NULL ? *builtiniplist_
                         : *::micromsg::BuiltinIPList::internal_default_instance();
}
inline ::micromsg::BuiltinIPList* EmailRegResponse::mutable_builtiniplist() {
  set_has_builtiniplist();
  if (builtiniplist_ == NULL) {
    builtiniplist_ = new ::micromsg::BuiltinIPList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegResponse.BuiltinIPList)
  return builtiniplist_;
}
inline ::micromsg::BuiltinIPList* EmailRegResponse::release_builtiniplist() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegResponse.BuiltinIPList)
  clear_has_builtiniplist();
  ::micromsg::BuiltinIPList* temp = builtiniplist_;
  builtiniplist_ = NULL;
  return temp;
}
inline void EmailRegResponse::set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist) {
  delete builtiniplist_;
  builtiniplist_ = builtiniplist;
  if (builtiniplist) {
    set_has_builtiniplist();
  } else {
    clear_has_builtiniplist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegResponse.BuiltinIPList)
}

// optional .micromsg.HostList NewHostList = 4;
inline bool EmailRegResponse::has_newhostlist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmailRegResponse::set_has_newhostlist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmailRegResponse::clear_has_newhostlist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmailRegResponse::clear_newhostlist() {
  if (newhostlist_ != NULL) newhostlist_->::micromsg::HostList::Clear();
  clear_has_newhostlist();
}
inline const ::micromsg::HostList& EmailRegResponse::newhostlist() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegResponse.NewHostList)
  return newhostlist_ != NULL ? *newhostlist_
                         : *::micromsg::HostList::internal_default_instance();
}
inline ::micromsg::HostList* EmailRegResponse::mutable_newhostlist() {
  set_has_newhostlist();
  if (newhostlist_ == NULL) {
    newhostlist_ = new ::micromsg::HostList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegResponse.NewHostList)
  return newhostlist_;
}
inline ::micromsg::HostList* EmailRegResponse::release_newhostlist() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegResponse.NewHostList)
  clear_has_newhostlist();
  ::micromsg::HostList* temp = newhostlist_;
  newhostlist_ = NULL;
  return temp;
}
inline void EmailRegResponse::set_allocated_newhostlist(::micromsg::HostList* newhostlist) {
  delete newhostlist_;
  newhostlist_ = newhostlist;
  if (newhostlist) {
    set_has_newhostlist();
  } else {
    clear_has_newhostlist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegResponse.NewHostList)
}

// optional .micromsg.ShowStyleKey ShowStyle = 5;
inline bool EmailRegResponse::has_showstyle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmailRegResponse::set_has_showstyle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmailRegResponse::clear_has_showstyle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmailRegResponse::clear_showstyle() {
  if (showstyle_ != NULL) showstyle_->::micromsg::ShowStyleKey::Clear();
  clear_has_showstyle();
}
inline const ::micromsg::ShowStyleKey& EmailRegResponse::showstyle() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegResponse.ShowStyle)
  return showstyle_ != NULL ? *showstyle_
                         : *::micromsg::ShowStyleKey::internal_default_instance();
}
inline ::micromsg::ShowStyleKey* EmailRegResponse::mutable_showstyle() {
  set_has_showstyle();
  if (showstyle_ == NULL) {
    showstyle_ = new ::micromsg::ShowStyleKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegResponse.ShowStyle)
  return showstyle_;
}
inline ::micromsg::ShowStyleKey* EmailRegResponse::release_showstyle() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegResponse.ShowStyle)
  clear_has_showstyle();
  ::micromsg::ShowStyleKey* temp = showstyle_;
  showstyle_ = NULL;
  return temp;
}
inline void EmailRegResponse::set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle) {
  delete showstyle_;
  showstyle_ = showstyle;
  if (showstyle) {
    set_has_showstyle();
  } else {
    clear_has_showstyle();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegResponse.ShowStyle)
}

// optional .micromsg.NetworkControl NetworkControl = 6;
inline bool EmailRegResponse::has_networkcontrol() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmailRegResponse::set_has_networkcontrol() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmailRegResponse::clear_has_networkcontrol() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmailRegResponse::clear_networkcontrol() {
  if (networkcontrol_ != NULL) networkcontrol_->::micromsg::NetworkControl::Clear();
  clear_has_networkcontrol();
}
inline const ::micromsg::NetworkControl& EmailRegResponse::networkcontrol() const {
  // @@protoc_insertion_point(field_get:micromsg.EmailRegResponse.NetworkControl)
  return networkcontrol_ != NULL ? *networkcontrol_
                         : *::micromsg::NetworkControl::internal_default_instance();
}
inline ::micromsg::NetworkControl* EmailRegResponse::mutable_networkcontrol() {
  set_has_networkcontrol();
  if (networkcontrol_ == NULL) {
    networkcontrol_ = new ::micromsg::NetworkControl;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.EmailRegResponse.NetworkControl)
  return networkcontrol_;
}
inline ::micromsg::NetworkControl* EmailRegResponse::release_networkcontrol() {
  // @@protoc_insertion_point(field_release:micromsg.EmailRegResponse.NetworkControl)
  clear_has_networkcontrol();
  ::micromsg::NetworkControl* temp = networkcontrol_;
  networkcontrol_ = NULL;
  return temp;
}
inline void EmailRegResponse::set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol) {
  delete networkcontrol_;
  networkcontrol_ = networkcontrol;
  if (networkcontrol) {
    set_has_networkcontrol();
  } else {
    clear_has_networkcontrol();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.EmailRegResponse.NetworkControl)
}

// -------------------------------------------------------------------

// SetEmailPwdRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool SetEmailPwdRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetEmailPwdRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetEmailPwdRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetEmailPwdRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& SetEmailPwdRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.SetEmailPwdRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* SetEmailPwdRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.SetEmailPwdRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* SetEmailPwdRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.SetEmailPwdRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void SetEmailPwdRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetEmailPwdRequest.BaseRequest)
}

// optional string Pwd = 2;
inline bool SetEmailPwdRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetEmailPwdRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetEmailPwdRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetEmailPwdRequest::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd();
}
inline const ::std::string& SetEmailPwdRequest::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.SetEmailPwdRequest.Pwd)
  return pwd_.GetNoArena();
}
inline void SetEmailPwdRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.SetEmailPwdRequest.Pwd)
}
#if LANG_CXX11
inline void SetEmailPwdRequest::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.SetEmailPwdRequest.Pwd)
}
#endif
inline void SetEmailPwdRequest::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.SetEmailPwdRequest.Pwd)
}
inline void SetEmailPwdRequest::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.SetEmailPwdRequest.Pwd)
}
inline ::std::string* SetEmailPwdRequest::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:micromsg.SetEmailPwdRequest.Pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetEmailPwdRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.SetEmailPwdRequest.Pwd)
  clear_has_pwd();
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetEmailPwdRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetEmailPwdRequest.Pwd)
}

// optional string Ticket = 3;
inline bool SetEmailPwdRequest::has_ticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetEmailPwdRequest::set_has_ticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetEmailPwdRequest::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetEmailPwdRequest::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& SetEmailPwdRequest::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.SetEmailPwdRequest.Ticket)
  return ticket_.GetNoArena();
}
inline void SetEmailPwdRequest::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.SetEmailPwdRequest.Ticket)
}
#if LANG_CXX11
inline void SetEmailPwdRequest::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.SetEmailPwdRequest.Ticket)
}
#endif
inline void SetEmailPwdRequest::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.SetEmailPwdRequest.Ticket)
}
inline void SetEmailPwdRequest::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.SetEmailPwdRequest.Ticket)
}
inline ::std::string* SetEmailPwdRequest::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.SetEmailPwdRequest.Ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetEmailPwdRequest::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.SetEmailPwdRequest.Ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetEmailPwdRequest::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetEmailPwdRequest.Ticket)
}

// -------------------------------------------------------------------

// SetEmailPwdResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool SetEmailPwdResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetEmailPwdResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetEmailPwdResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetEmailPwdResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& SetEmailPwdResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.SetEmailPwdResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* SetEmailPwdResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.SetEmailPwdResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* SetEmailPwdResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.SetEmailPwdResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void SetEmailPwdResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetEmailPwdResponse.BaseResponse)
}

// -------------------------------------------------------------------

// UpdateSafeDeviceRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool UpdateSafeDeviceRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateSafeDeviceRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateSafeDeviceRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateSafeDeviceRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& UpdateSafeDeviceRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.UpdateSafeDeviceRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* UpdateSafeDeviceRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UpdateSafeDeviceRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* UpdateSafeDeviceRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.UpdateSafeDeviceRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void UpdateSafeDeviceRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UpdateSafeDeviceRequest.BaseRequest)
}

// optional string Uuid = 2;
inline bool UpdateSafeDeviceRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSafeDeviceRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSafeDeviceRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSafeDeviceRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& UpdateSafeDeviceRequest::uuid() const {
  // @@protoc_insertion_point(field_get:micromsg.UpdateSafeDeviceRequest.Uuid)
  return uuid_.GetNoArena();
}
inline void UpdateSafeDeviceRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.UpdateSafeDeviceRequest.Uuid)
}
#if LANG_CXX11
inline void UpdateSafeDeviceRequest::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.UpdateSafeDeviceRequest.Uuid)
}
#endif
inline void UpdateSafeDeviceRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.UpdateSafeDeviceRequest.Uuid)
}
inline void UpdateSafeDeviceRequest::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.UpdateSafeDeviceRequest.Uuid)
}
inline ::std::string* UpdateSafeDeviceRequest::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:micromsg.UpdateSafeDeviceRequest.Uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateSafeDeviceRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:micromsg.UpdateSafeDeviceRequest.Uuid)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateSafeDeviceRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.UpdateSafeDeviceRequest.Uuid)
}

// optional string Name = 3;
inline bool UpdateSafeDeviceRequest::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateSafeDeviceRequest::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateSafeDeviceRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateSafeDeviceRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& UpdateSafeDeviceRequest::name() const {
  // @@protoc_insertion_point(field_get:micromsg.UpdateSafeDeviceRequest.Name)
  return name_.GetNoArena();
}
inline void UpdateSafeDeviceRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.UpdateSafeDeviceRequest.Name)
}
#if LANG_CXX11
inline void UpdateSafeDeviceRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.UpdateSafeDeviceRequest.Name)
}
#endif
inline void UpdateSafeDeviceRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.UpdateSafeDeviceRequest.Name)
}
inline void UpdateSafeDeviceRequest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.UpdateSafeDeviceRequest.Name)
}
inline ::std::string* UpdateSafeDeviceRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:micromsg.UpdateSafeDeviceRequest.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateSafeDeviceRequest::release_name() {
  // @@protoc_insertion_point(field_release:micromsg.UpdateSafeDeviceRequest.Name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateSafeDeviceRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:micromsg.UpdateSafeDeviceRequest.Name)
}

// optional string DeviceType = 4;
inline bool UpdateSafeDeviceRequest::has_devicetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateSafeDeviceRequest::set_has_devicetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateSafeDeviceRequest::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateSafeDeviceRequest::clear_devicetype() {
  devicetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicetype();
}
inline const ::std::string& UpdateSafeDeviceRequest::devicetype() const {
  // @@protoc_insertion_point(field_get:micromsg.UpdateSafeDeviceRequest.DeviceType)
  return devicetype_.GetNoArena();
}
inline void UpdateSafeDeviceRequest::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.UpdateSafeDeviceRequest.DeviceType)
}
#if LANG_CXX11
inline void UpdateSafeDeviceRequest::set_devicetype(::std::string&& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.UpdateSafeDeviceRequest.DeviceType)
}
#endif
inline void UpdateSafeDeviceRequest::set_devicetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.UpdateSafeDeviceRequest.DeviceType)
}
inline void UpdateSafeDeviceRequest::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.UpdateSafeDeviceRequest.DeviceType)
}
inline ::std::string* UpdateSafeDeviceRequest::mutable_devicetype() {
  set_has_devicetype();
  // @@protoc_insertion_point(field_mutable:micromsg.UpdateSafeDeviceRequest.DeviceType)
  return devicetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateSafeDeviceRequest::release_devicetype() {
  // @@protoc_insertion_point(field_release:micromsg.UpdateSafeDeviceRequest.DeviceType)
  clear_has_devicetype();
  return devicetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateSafeDeviceRequest::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype != NULL) {
    set_has_devicetype();
  } else {
    clear_has_devicetype();
  }
  devicetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.UpdateSafeDeviceRequest.DeviceType)
}

// -------------------------------------------------------------------

// UpdateSafeDeviceResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool UpdateSafeDeviceResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateSafeDeviceResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateSafeDeviceResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateSafeDeviceResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& UpdateSafeDeviceResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.UpdateSafeDeviceResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* UpdateSafeDeviceResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UpdateSafeDeviceResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* UpdateSafeDeviceResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.UpdateSafeDeviceResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void UpdateSafeDeviceResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UpdateSafeDeviceResponse.BaseResponse)
}

// optional uint32 SafeDevice = 2;
inline bool UpdateSafeDeviceResponse::has_safedevice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateSafeDeviceResponse::set_has_safedevice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateSafeDeviceResponse::clear_has_safedevice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateSafeDeviceResponse::clear_safedevice() {
  safedevice_ = 0u;
  clear_has_safedevice();
}
inline ::google::protobuf::uint32 UpdateSafeDeviceResponse::safedevice() const {
  // @@protoc_insertion_point(field_get:micromsg.UpdateSafeDeviceResponse.SafeDevice)
  return safedevice_;
}
inline void UpdateSafeDeviceResponse::set_safedevice(::google::protobuf::uint32 value) {
  set_has_safedevice();
  safedevice_ = value;
  // @@protoc_insertion_point(field_set:micromsg.UpdateSafeDeviceResponse.SafeDevice)
}

// -------------------------------------------------------------------

// DelSafeDeviceRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool DelSafeDeviceRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelSafeDeviceRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelSafeDeviceRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelSafeDeviceRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& DelSafeDeviceRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.DelSafeDeviceRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* DelSafeDeviceRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.DelSafeDeviceRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* DelSafeDeviceRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.DelSafeDeviceRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void DelSafeDeviceRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.DelSafeDeviceRequest.BaseRequest)
}

// optional string Uuid = 2;
inline bool DelSafeDeviceRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelSafeDeviceRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelSafeDeviceRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelSafeDeviceRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& DelSafeDeviceRequest::uuid() const {
  // @@protoc_insertion_point(field_get:micromsg.DelSafeDeviceRequest.Uuid)
  return uuid_.GetNoArena();
}
inline void DelSafeDeviceRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.DelSafeDeviceRequest.Uuid)
}
#if LANG_CXX11
inline void DelSafeDeviceRequest::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.DelSafeDeviceRequest.Uuid)
}
#endif
inline void DelSafeDeviceRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.DelSafeDeviceRequest.Uuid)
}
inline void DelSafeDeviceRequest::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.DelSafeDeviceRequest.Uuid)
}
inline ::std::string* DelSafeDeviceRequest::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:micromsg.DelSafeDeviceRequest.Uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DelSafeDeviceRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:micromsg.DelSafeDeviceRequest.Uuid)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DelSafeDeviceRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.DelSafeDeviceRequest.Uuid)
}

// -------------------------------------------------------------------

// DelSafeDeviceResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool DelSafeDeviceResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelSafeDeviceResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DelSafeDeviceResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DelSafeDeviceResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& DelSafeDeviceResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.DelSafeDeviceResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* DelSafeDeviceResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.DelSafeDeviceResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* DelSafeDeviceResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.DelSafeDeviceResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void DelSafeDeviceResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.DelSafeDeviceResponse.BaseResponse)
}

// optional uint32 SafeDevice = 2;
inline bool DelSafeDeviceResponse::has_safedevice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelSafeDeviceResponse::set_has_safedevice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DelSafeDeviceResponse::clear_has_safedevice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DelSafeDeviceResponse::clear_safedevice() {
  safedevice_ = 0u;
  clear_has_safedevice();
}
inline ::google::protobuf::uint32 DelSafeDeviceResponse::safedevice() const {
  // @@protoc_insertion_point(field_get:micromsg.DelSafeDeviceResponse.SafeDevice)
  return safedevice_;
}
inline void DelSafeDeviceResponse::set_safedevice(::google::protobuf::uint32 value) {
  set_has_safedevice();
  safedevice_ = value;
  // @@protoc_insertion_point(field_set:micromsg.DelSafeDeviceResponse.SafeDevice)
}

// -------------------------------------------------------------------

// BindSafeMobileRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BindSafeMobileRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindSafeMobileRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindSafeMobileRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindSafeMobileRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BindSafeMobileRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BindSafeMobileRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BindSafeMobileRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindSafeMobileRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BindSafeMobileRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BindSafeMobileRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BindSafeMobileRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindSafeMobileRequest.BaseRequest)
}

// optional string Mobile = 2;
inline bool BindSafeMobileRequest::has_mobile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindSafeMobileRequest::set_has_mobile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindSafeMobileRequest::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindSafeMobileRequest::clear_mobile() {
  mobile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mobile();
}
inline const ::std::string& BindSafeMobileRequest::mobile() const {
  // @@protoc_insertion_point(field_get:micromsg.BindSafeMobileRequest.Mobile)
  return mobile_.GetNoArena();
}
inline void BindSafeMobileRequest::set_mobile(const ::std::string& value) {
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindSafeMobileRequest.Mobile)
}
#if LANG_CXX11
inline void BindSafeMobileRequest::set_mobile(::std::string&& value) {
  set_has_mobile();
  mobile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindSafeMobileRequest.Mobile)
}
#endif
inline void BindSafeMobileRequest::set_mobile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindSafeMobileRequest.Mobile)
}
inline void BindSafeMobileRequest::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindSafeMobileRequest.Mobile)
}
inline ::std::string* BindSafeMobileRequest::mutable_mobile() {
  set_has_mobile();
  // @@protoc_insertion_point(field_mutable:micromsg.BindSafeMobileRequest.Mobile)
  return mobile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindSafeMobileRequest::release_mobile() {
  // @@protoc_insertion_point(field_release:micromsg.BindSafeMobileRequest.Mobile)
  clear_has_mobile();
  return mobile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindSafeMobileRequest::set_allocated_mobile(::std::string* mobile) {
  if (mobile != NULL) {
    set_has_mobile();
  } else {
    clear_has_mobile();
  }
  mobile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mobile);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindSafeMobileRequest.Mobile)
}

// required int32 Opcode = 3;
inline bool BindSafeMobileRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindSafeMobileRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindSafeMobileRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindSafeMobileRequest::clear_opcode() {
  opcode_ = 0;
  clear_has_opcode();
}
inline ::google::protobuf::int32 BindSafeMobileRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.BindSafeMobileRequest.Opcode)
  return opcode_;
}
inline void BindSafeMobileRequest::set_opcode(::google::protobuf::int32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindSafeMobileRequest.Opcode)
}

// -------------------------------------------------------------------

// BindSafeMobileResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BindSafeMobileResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindSafeMobileResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindSafeMobileResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindSafeMobileResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BindSafeMobileResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BindSafeMobileResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BindSafeMobileResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindSafeMobileResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BindSafeMobileResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BindSafeMobileResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BindSafeMobileResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindSafeMobileResponse.BaseResponse)
}

// -------------------------------------------------------------------

// BindQQRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BindQQRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BindQQRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BindQQRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BindQQRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BindQQRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BindQQRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BindQQRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BindQQRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.BaseRequest)
}

// required uint32 QQ = 2;
inline bool BindQQRequest::has_qq() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BindQQRequest::set_has_qq() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BindQQRequest::clear_has_qq() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BindQQRequest::clear_qq() {
  qq_ = 0u;
  clear_has_qq();
}
inline ::google::protobuf::uint32 BindQQRequest::qq() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.QQ)
  return qq_;
}
inline void BindQQRequest::set_qq(::google::protobuf::uint32 value) {
  set_has_qq();
  qq_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindQQRequest.QQ)
}

// optional string Pwd = 3;
inline bool BindQQRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindQQRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindQQRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindQQRequest::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd();
}
inline const ::std::string& BindQQRequest::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.Pwd)
  return pwd_.GetNoArena();
}
inline void BindQQRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindQQRequest.Pwd)
}
#if LANG_CXX11
inline void BindQQRequest::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindQQRequest.Pwd)
}
#endif
inline void BindQQRequest::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindQQRequest.Pwd)
}
inline void BindQQRequest::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindQQRequest.Pwd)
}
inline ::std::string* BindQQRequest::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.Pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindQQRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.Pwd)
  clear_has_pwd();
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindQQRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.Pwd)
}

// optional string Pwd2 = 4;
inline bool BindQQRequest::has_pwd2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindQQRequest::set_has_pwd2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindQQRequest::clear_has_pwd2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindQQRequest::clear_pwd2() {
  pwd2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd2();
}
inline const ::std::string& BindQQRequest::pwd2() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.Pwd2)
  return pwd2_.GetNoArena();
}
inline void BindQQRequest::set_pwd2(const ::std::string& value) {
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindQQRequest.Pwd2)
}
#if LANG_CXX11
inline void BindQQRequest::set_pwd2(::std::string&& value) {
  set_has_pwd2();
  pwd2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindQQRequest.Pwd2)
}
#endif
inline void BindQQRequest::set_pwd2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindQQRequest.Pwd2)
}
inline void BindQQRequest::set_pwd2(const char* value, size_t size) {
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindQQRequest.Pwd2)
}
inline ::std::string* BindQQRequest::mutable_pwd2() {
  set_has_pwd2();
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.Pwd2)
  return pwd2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindQQRequest::release_pwd2() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.Pwd2)
  clear_has_pwd2();
  return pwd2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindQQRequest::set_allocated_pwd2(::std::string* pwd2) {
  if (pwd2 != NULL) {
    set_has_pwd2();
  } else {
    clear_has_pwd2();
  }
  pwd2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd2);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.Pwd2)
}

// optional string ImgSid = 5;
inline bool BindQQRequest::has_imgsid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindQQRequest::set_has_imgsid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindQQRequest::clear_has_imgsid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindQQRequest::clear_imgsid() {
  imgsid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgsid();
}
inline const ::std::string& BindQQRequest::imgsid() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.ImgSid)
  return imgsid_.GetNoArena();
}
inline void BindQQRequest::set_imgsid(const ::std::string& value) {
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindQQRequest.ImgSid)
}
#if LANG_CXX11
inline void BindQQRequest::set_imgsid(::std::string&& value) {
  set_has_imgsid();
  imgsid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindQQRequest.ImgSid)
}
#endif
inline void BindQQRequest::set_imgsid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindQQRequest.ImgSid)
}
inline void BindQQRequest::set_imgsid(const char* value, size_t size) {
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindQQRequest.ImgSid)
}
inline ::std::string* BindQQRequest::mutable_imgsid() {
  set_has_imgsid();
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.ImgSid)
  return imgsid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindQQRequest::release_imgsid() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.ImgSid)
  clear_has_imgsid();
  return imgsid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindQQRequest::set_allocated_imgsid(::std::string* imgsid) {
  if (imgsid != NULL) {
    set_has_imgsid();
  } else {
    clear_has_imgsid();
  }
  imgsid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgsid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.ImgSid)
}

// optional string ImgCode = 6;
inline bool BindQQRequest::has_imgcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindQQRequest::set_has_imgcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindQQRequest::clear_has_imgcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindQQRequest::clear_imgcode() {
  imgcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgcode();
}
inline const ::std::string& BindQQRequest::imgcode() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.ImgCode)
  return imgcode_.GetNoArena();
}
inline void BindQQRequest::set_imgcode(const ::std::string& value) {
  set_has_imgcode();
  imgcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindQQRequest.ImgCode)
}
#if LANG_CXX11
inline void BindQQRequest::set_imgcode(::std::string&& value) {
  set_has_imgcode();
  imgcode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindQQRequest.ImgCode)
}
#endif
inline void BindQQRequest::set_imgcode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgcode();
  imgcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindQQRequest.ImgCode)
}
inline void BindQQRequest::set_imgcode(const char* value, size_t size) {
  set_has_imgcode();
  imgcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindQQRequest.ImgCode)
}
inline ::std::string* BindQQRequest::mutable_imgcode() {
  set_has_imgcode();
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.ImgCode)
  return imgcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindQQRequest::release_imgcode() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.ImgCode)
  clear_has_imgcode();
  return imgcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindQQRequest::set_allocated_imgcode(::std::string* imgcode) {
  if (imgcode != NULL) {
    set_has_imgcode();
  } else {
    clear_has_imgcode();
  }
  imgcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgcode);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.ImgCode)
}

// required uint32 OPCode = 7;
inline bool BindQQRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BindQQRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BindQQRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BindQQRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 BindQQRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.OPCode)
  return opcode_;
}
inline void BindQQRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindQQRequest.OPCode)
}

// optional .micromsg.SKBuiltinString_t ImgEncryptKey = 8;
inline bool BindQQRequest::has_imgencryptkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BindQQRequest::set_has_imgencryptkey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BindQQRequest::clear_has_imgencryptkey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BindQQRequest::clear_imgencryptkey() {
  if (imgencryptkey_ != NULL) imgencryptkey_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgencryptkey();
}
inline const ::micromsg::SKBuiltinString_t& BindQQRequest::imgencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.ImgEncryptKey)
  return imgencryptkey_ != NULL ? *imgencryptkey_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* BindQQRequest::mutable_imgencryptkey() {
  set_has_imgencryptkey();
  if (imgencryptkey_ == NULL) {
    imgencryptkey_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.ImgEncryptKey)
  return imgencryptkey_;
}
inline ::micromsg::SKBuiltinString_t* BindQQRequest::release_imgencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.ImgEncryptKey)
  clear_has_imgencryptkey();
  ::micromsg::SKBuiltinString_t* temp = imgencryptkey_;
  imgencryptkey_ = NULL;
  return temp;
}
inline void BindQQRequest::set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey) {
  delete imgencryptkey_;
  imgencryptkey_ = imgencryptkey;
  if (imgencryptkey) {
    set_has_imgencryptkey();
  } else {
    clear_has_imgencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.ImgEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t KSid = 9;
inline bool BindQQRequest::has_ksid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BindQQRequest::set_has_ksid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BindQQRequest::clear_has_ksid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BindQQRequest::clear_ksid() {
  if (ksid_ != NULL) ksid_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_ksid();
}
inline const ::micromsg::SKBuiltinBuffer_t& BindQQRequest::ksid() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.KSid)
  return ksid_ != NULL ? *ksid_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQRequest::mutable_ksid() {
  set_has_ksid();
  if (ksid_ == NULL) {
    ksid_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.KSid)
  return ksid_;
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQRequest::release_ksid() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.KSid)
  clear_has_ksid();
  ::micromsg::SKBuiltinBuffer_t* temp = ksid_;
  ksid_ = NULL;
  return temp;
}
inline void BindQQRequest::set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid) {
  delete ksid_;
  ksid_ = ksid;
  if (ksid) {
    set_has_ksid();
  } else {
    clear_has_ksid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.KSid)
}

// optional uint32 SetAsMainAcct = 10;
inline bool BindQQRequest::has_setasmainacct() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BindQQRequest::set_has_setasmainacct() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BindQQRequest::clear_has_setasmainacct() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BindQQRequest::clear_setasmainacct() {
  setasmainacct_ = 0u;
  clear_has_setasmainacct();
}
inline ::google::protobuf::uint32 BindQQRequest::setasmainacct() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.SetAsMainAcct)
  return setasmainacct_;
}
inline void BindQQRequest::set_setasmainacct(::google::protobuf::uint32 value) {
  set_has_setasmainacct();
  setasmainacct_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindQQRequest.SetAsMainAcct)
}

// optional string SafeDeviceName = 11;
inline bool BindQQRequest::has_safedevicename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BindQQRequest::set_has_safedevicename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BindQQRequest::clear_has_safedevicename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BindQQRequest::clear_safedevicename() {
  safedevicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_safedevicename();
}
inline const ::std::string& BindQQRequest::safedevicename() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.SafeDeviceName)
  return safedevicename_.GetNoArena();
}
inline void BindQQRequest::set_safedevicename(const ::std::string& value) {
  set_has_safedevicename();
  safedevicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindQQRequest.SafeDeviceName)
}
#if LANG_CXX11
inline void BindQQRequest::set_safedevicename(::std::string&& value) {
  set_has_safedevicename();
  safedevicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindQQRequest.SafeDeviceName)
}
#endif
inline void BindQQRequest::set_safedevicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_safedevicename();
  safedevicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindQQRequest.SafeDeviceName)
}
inline void BindQQRequest::set_safedevicename(const char* value, size_t size) {
  set_has_safedevicename();
  safedevicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindQQRequest.SafeDeviceName)
}
inline ::std::string* BindQQRequest::mutable_safedevicename() {
  set_has_safedevicename();
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.SafeDeviceName)
  return safedevicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindQQRequest::release_safedevicename() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.SafeDeviceName)
  clear_has_safedevicename();
  return safedevicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindQQRequest::set_allocated_safedevicename(::std::string* safedevicename) {
  if (safedevicename != NULL) {
    set_has_safedevicename();
  } else {
    clear_has_safedevicename();
  }
  safedevicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), safedevicename);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.SafeDeviceName)
}

// optional string SafeDeviceType = 12;
inline bool BindQQRequest::has_safedevicetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BindQQRequest::set_has_safedevicetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BindQQRequest::clear_has_safedevicetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BindQQRequest::clear_safedevicetype() {
  safedevicetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_safedevicetype();
}
inline const ::std::string& BindQQRequest::safedevicetype() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.SafeDeviceType)
  return safedevicetype_.GetNoArena();
}
inline void BindQQRequest::set_safedevicetype(const ::std::string& value) {
  set_has_safedevicetype();
  safedevicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindQQRequest.SafeDeviceType)
}
#if LANG_CXX11
inline void BindQQRequest::set_safedevicetype(::std::string&& value) {
  set_has_safedevicetype();
  safedevicetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindQQRequest.SafeDeviceType)
}
#endif
inline void BindQQRequest::set_safedevicetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_safedevicetype();
  safedevicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindQQRequest.SafeDeviceType)
}
inline void BindQQRequest::set_safedevicetype(const char* value, size_t size) {
  set_has_safedevicetype();
  safedevicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindQQRequest.SafeDeviceType)
}
inline ::std::string* BindQQRequest::mutable_safedevicetype() {
  set_has_safedevicetype();
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.SafeDeviceType)
  return safedevicetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindQQRequest::release_safedevicetype() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.SafeDeviceType)
  clear_has_safedevicetype();
  return safedevicetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindQQRequest::set_allocated_safedevicetype(::std::string* safedevicetype) {
  if (safedevicetype != NULL) {
    set_has_safedevicetype();
  } else {
    clear_has_safedevicetype();
  }
  safedevicetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), safedevicetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.SafeDeviceType)
}

// optional .micromsg.SKBuiltinBuffer_t WTLoginReqBuff = 13;
inline bool BindQQRequest::has_wtloginreqbuff() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BindQQRequest::set_has_wtloginreqbuff() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BindQQRequest::clear_has_wtloginreqbuff() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BindQQRequest::clear_wtloginreqbuff() {
  if (wtloginreqbuff_ != NULL) wtloginreqbuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_wtloginreqbuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& BindQQRequest::wtloginreqbuff() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQRequest.WTLoginReqBuff)
  return wtloginreqbuff_ != NULL ? *wtloginreqbuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQRequest::mutable_wtloginreqbuff() {
  set_has_wtloginreqbuff();
  if (wtloginreqbuff_ == NULL) {
    wtloginreqbuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQRequest.WTLoginReqBuff)
  return wtloginreqbuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQRequest::release_wtloginreqbuff() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQRequest.WTLoginReqBuff)
  clear_has_wtloginreqbuff();
  ::micromsg::SKBuiltinBuffer_t* temp = wtloginreqbuff_;
  wtloginreqbuff_ = NULL;
  return temp;
}
inline void BindQQRequest::set_allocated_wtloginreqbuff(::micromsg::SKBuiltinBuffer_t* wtloginreqbuff) {
  delete wtloginreqbuff_;
  wtloginreqbuff_ = wtloginreqbuff;
  if (wtloginreqbuff) {
    set_has_wtloginreqbuff();
  } else {
    clear_has_wtloginreqbuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQRequest.WTLoginReqBuff)
}

// -------------------------------------------------------------------

// BindQQResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BindQQResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindQQResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindQQResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindQQResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BindQQResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BindQQResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BindQQResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BindQQResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.BaseResponse)
}

// optional string ImgSid = 2;
inline bool BindQQResponse::has_imgsid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindQQResponse::set_has_imgsid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindQQResponse::clear_has_imgsid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindQQResponse::clear_imgsid() {
  imgsid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgsid();
}
inline const ::std::string& BindQQResponse::imgsid() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.ImgSid)
  return imgsid_.GetNoArena();
}
inline void BindQQResponse::set_imgsid(const ::std::string& value) {
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindQQResponse.ImgSid)
}
#if LANG_CXX11
inline void BindQQResponse::set_imgsid(::std::string&& value) {
  set_has_imgsid();
  imgsid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindQQResponse.ImgSid)
}
#endif
inline void BindQQResponse::set_imgsid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindQQResponse.ImgSid)
}
inline void BindQQResponse::set_imgsid(const char* value, size_t size) {
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindQQResponse.ImgSid)
}
inline ::std::string* BindQQResponse::mutable_imgsid() {
  set_has_imgsid();
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.ImgSid)
  return imgsid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindQQResponse::release_imgsid() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.ImgSid)
  clear_has_imgsid();
  return imgsid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindQQResponse::set_allocated_imgsid(::std::string* imgsid) {
  if (imgsid != NULL) {
    set_has_imgsid();
  } else {
    clear_has_imgsid();
  }
  imgsid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgsid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.ImgSid)
}

// required .micromsg.SKBuiltinBuffer_t ImgBuf = 3;
inline bool BindQQResponse::has_imgbuf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BindQQResponse::set_has_imgbuf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BindQQResponse::clear_has_imgbuf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BindQQResponse::clear_imgbuf() {
  if (imgbuf_ != NULL) imgbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_imgbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& BindQQResponse::imgbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.ImgBuf)
  return imgbuf_ != NULL ? *imgbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQResponse::mutable_imgbuf() {
  set_has_imgbuf();
  if (imgbuf_ == NULL) {
    imgbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.ImgBuf)
  return imgbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQResponse::release_imgbuf() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.ImgBuf)
  clear_has_imgbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = imgbuf_;
  imgbuf_ = NULL;
  return temp;
}
inline void BindQQResponse::set_allocated_imgbuf(::micromsg::SKBuiltinBuffer_t* imgbuf) {
  delete imgbuf_;
  imgbuf_ = imgbuf;
  if (imgbuf) {
    set_has_imgbuf();
  } else {
    clear_has_imgbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.ImgBuf)
}

// optional uint32 PushMailStatus = 4;
inline bool BindQQResponse::has_pushmailstatus() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BindQQResponse::set_has_pushmailstatus() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BindQQResponse::clear_has_pushmailstatus() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BindQQResponse::clear_pushmailstatus() {
  pushmailstatus_ = 0u;
  clear_has_pushmailstatus();
}
inline ::google::protobuf::uint32 BindQQResponse::pushmailstatus() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.PushMailStatus)
  return pushmailstatus_;
}
inline void BindQQResponse::set_pushmailstatus(::google::protobuf::uint32 value) {
  set_has_pushmailstatus();
  pushmailstatus_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindQQResponse.PushMailStatus)
}

// optional uint32 PrivateMsgStatus = 5;
inline bool BindQQResponse::has_privatemsgstatus() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BindQQResponse::set_has_privatemsgstatus() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BindQQResponse::clear_has_privatemsgstatus() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BindQQResponse::clear_privatemsgstatus() {
  privatemsgstatus_ = 0u;
  clear_has_privatemsgstatus();
}
inline ::google::protobuf::uint32 BindQQResponse::privatemsgstatus() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.PrivateMsgStatus)
  return privatemsgstatus_;
}
inline void BindQQResponse::set_privatemsgstatus(::google::protobuf::uint32 value) {
  set_has_privatemsgstatus();
  privatemsgstatus_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindQQResponse.PrivateMsgStatus)
}

// optional string MicroBlogName = 6;
inline bool BindQQResponse::has_microblogname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindQQResponse::set_has_microblogname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindQQResponse::clear_has_microblogname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindQQResponse::clear_microblogname() {
  microblogname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_microblogname();
}
inline const ::std::string& BindQQResponse::microblogname() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.MicroBlogName)
  return microblogname_.GetNoArena();
}
inline void BindQQResponse::set_microblogname(const ::std::string& value) {
  set_has_microblogname();
  microblogname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindQQResponse.MicroBlogName)
}
#if LANG_CXX11
inline void BindQQResponse::set_microblogname(::std::string&& value) {
  set_has_microblogname();
  microblogname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindQQResponse.MicroBlogName)
}
#endif
inline void BindQQResponse::set_microblogname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_microblogname();
  microblogname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindQQResponse.MicroBlogName)
}
inline void BindQQResponse::set_microblogname(const char* value, size_t size) {
  set_has_microblogname();
  microblogname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindQQResponse.MicroBlogName)
}
inline ::std::string* BindQQResponse::mutable_microblogname() {
  set_has_microblogname();
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.MicroBlogName)
  return microblogname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindQQResponse::release_microblogname() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.MicroBlogName)
  clear_has_microblogname();
  return microblogname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindQQResponse::set_allocated_microblogname(::std::string* microblogname) {
  if (microblogname != NULL) {
    set_has_microblogname();
  } else {
    clear_has_microblogname();
  }
  microblogname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), microblogname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.MicroBlogName)
}

// optional uint32 Status = 7;
inline bool BindQQResponse::has_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BindQQResponse::set_has_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BindQQResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BindQQResponse::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 BindQQResponse::status() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.Status)
  return status_;
}
inline void BindQQResponse::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindQQResponse.Status)
}

// optional string QQMailSkey = 8;
inline bool BindQQResponse::has_qqmailskey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindQQResponse::set_has_qqmailskey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindQQResponse::clear_has_qqmailskey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindQQResponse::clear_qqmailskey() {
  qqmailskey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_qqmailskey();
}
inline const ::std::string& BindQQResponse::qqmailskey() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.QQMailSkey)
  return qqmailskey_.GetNoArena();
}
inline void BindQQResponse::set_qqmailskey(const ::std::string& value) {
  set_has_qqmailskey();
  qqmailskey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindQQResponse.QQMailSkey)
}
#if LANG_CXX11
inline void BindQQResponse::set_qqmailskey(::std::string&& value) {
  set_has_qqmailskey();
  qqmailskey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindQQResponse.QQMailSkey)
}
#endif
inline void BindQQResponse::set_qqmailskey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_qqmailskey();
  qqmailskey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindQQResponse.QQMailSkey)
}
inline void BindQQResponse::set_qqmailskey(const char* value, size_t size) {
  set_has_qqmailskey();
  qqmailskey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindQQResponse.QQMailSkey)
}
inline ::std::string* BindQQResponse::mutable_qqmailskey() {
  set_has_qqmailskey();
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.QQMailSkey)
  return qqmailskey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindQQResponse::release_qqmailskey() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.QQMailSkey)
  clear_has_qqmailskey();
  return qqmailskey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindQQResponse::set_allocated_qqmailskey(::std::string* qqmailskey) {
  if (qqmailskey != NULL) {
    set_has_qqmailskey();
  } else {
    clear_has_qqmailskey();
  }
  qqmailskey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qqmailskey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.QQMailSkey)
}

// optional .micromsg.SKBuiltinString_t ImgEncryptKey = 9;
inline bool BindQQResponse::has_imgencryptkey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BindQQResponse::set_has_imgencryptkey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BindQQResponse::clear_has_imgencryptkey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BindQQResponse::clear_imgencryptkey() {
  if (imgencryptkey_ != NULL) imgencryptkey_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgencryptkey();
}
inline const ::micromsg::SKBuiltinString_t& BindQQResponse::imgencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.ImgEncryptKey)
  return imgencryptkey_ != NULL ? *imgencryptkey_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* BindQQResponse::mutable_imgencryptkey() {
  set_has_imgencryptkey();
  if (imgencryptkey_ == NULL) {
    imgencryptkey_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.ImgEncryptKey)
  return imgencryptkey_;
}
inline ::micromsg::SKBuiltinString_t* BindQQResponse::release_imgencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.ImgEncryptKey)
  clear_has_imgencryptkey();
  ::micromsg::SKBuiltinString_t* temp = imgencryptkey_;
  imgencryptkey_ = NULL;
  return temp;
}
inline void BindQQResponse::set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey) {
  delete imgencryptkey_;
  imgencryptkey_ = imgencryptkey;
  if (imgencryptkey) {
    set_has_imgencryptkey();
  } else {
    clear_has_imgencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.ImgEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t A2Key = 10;
inline bool BindQQResponse::has_a2key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BindQQResponse::set_has_a2key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BindQQResponse::clear_has_a2key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BindQQResponse::clear_a2key() {
  if (a2key_ != NULL) a2key_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_a2key();
}
inline const ::micromsg::SKBuiltinBuffer_t& BindQQResponse::a2key() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.A2Key)
  return a2key_ != NULL ? *a2key_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQResponse::mutable_a2key() {
  set_has_a2key();
  if (a2key_ == NULL) {
    a2key_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.A2Key)
  return a2key_;
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQResponse::release_a2key() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.A2Key)
  clear_has_a2key();
  ::micromsg::SKBuiltinBuffer_t* temp = a2key_;
  a2key_ = NULL;
  return temp;
}
inline void BindQQResponse::set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key) {
  delete a2key_;
  a2key_ = a2key;
  if (a2key) {
    set_has_a2key();
  } else {
    clear_has_a2key();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.A2Key)
}

// optional .micromsg.SKBuiltinBuffer_t KSid = 11;
inline bool BindQQResponse::has_ksid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BindQQResponse::set_has_ksid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BindQQResponse::clear_has_ksid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BindQQResponse::clear_ksid() {
  if (ksid_ != NULL) ksid_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_ksid();
}
inline const ::micromsg::SKBuiltinBuffer_t& BindQQResponse::ksid() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.KSid)
  return ksid_ != NULL ? *ksid_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQResponse::mutable_ksid() {
  set_has_ksid();
  if (ksid_ == NULL) {
    ksid_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.KSid)
  return ksid_;
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQResponse::release_ksid() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.KSid)
  clear_has_ksid();
  ::micromsg::SKBuiltinBuffer_t* temp = ksid_;
  ksid_ = NULL;
  return temp;
}
inline void BindQQResponse::set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid) {
  delete ksid_;
  ksid_ = ksid;
  if (ksid) {
    set_has_ksid();
  } else {
    clear_has_ksid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.KSid)
}

// optional .micromsg.SafeDeviceList SafeDeviceList = 12;
inline bool BindQQResponse::has_safedevicelist() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BindQQResponse::set_has_safedevicelist() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BindQQResponse::clear_has_safedevicelist() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BindQQResponse::clear_safedevicelist() {
  if (safedevicelist_ != NULL) safedevicelist_->::micromsg::SafeDeviceList::Clear();
  clear_has_safedevicelist();
}
inline const ::micromsg::SafeDeviceList& BindQQResponse::safedevicelist() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.SafeDeviceList)
  return safedevicelist_ != NULL ? *safedevicelist_
                         : *::micromsg::SafeDeviceList::internal_default_instance();
}
inline ::micromsg::SafeDeviceList* BindQQResponse::mutable_safedevicelist() {
  set_has_safedevicelist();
  if (safedevicelist_ == NULL) {
    safedevicelist_ = new ::micromsg::SafeDeviceList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.SafeDeviceList)
  return safedevicelist_;
}
inline ::micromsg::SafeDeviceList* BindQQResponse::release_safedevicelist() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.SafeDeviceList)
  clear_has_safedevicelist();
  ::micromsg::SafeDeviceList* temp = safedevicelist_;
  safedevicelist_ = NULL;
  return temp;
}
inline void BindQQResponse::set_allocated_safedevicelist(::micromsg::SafeDeviceList* safedevicelist) {
  delete safedevicelist_;
  safedevicelist_ = safedevicelist;
  if (safedevicelist) {
    set_has_safedevicelist();
  } else {
    clear_has_safedevicelist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.SafeDeviceList)
}

// optional uint32 SafeDevice = 13;
inline bool BindQQResponse::has_safedevice() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BindQQResponse::set_has_safedevice() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BindQQResponse::clear_has_safedevice() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BindQQResponse::clear_safedevice() {
  safedevice_ = 0u;
  clear_has_safedevice();
}
inline ::google::protobuf::uint32 BindQQResponse::safedevice() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.SafeDevice)
  return safedevice_;
}
inline void BindQQResponse::set_safedevice(::google::protobuf::uint32 value) {
  set_has_safedevice();
  safedevice_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindQQResponse.SafeDevice)
}

// optional .micromsg.SKBuiltinBuffer_t WTLoginRspBuff = 14;
inline bool BindQQResponse::has_wtloginrspbuff() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BindQQResponse::set_has_wtloginrspbuff() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BindQQResponse::clear_has_wtloginrspbuff() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BindQQResponse::clear_wtloginrspbuff() {
  if (wtloginrspbuff_ != NULL) wtloginrspbuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_wtloginrspbuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& BindQQResponse::wtloginrspbuff() const {
  // @@protoc_insertion_point(field_get:micromsg.BindQQResponse.WTLoginRspBuff)
  return wtloginrspbuff_ != NULL ? *wtloginrspbuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQResponse::mutable_wtloginrspbuff() {
  set_has_wtloginrspbuff();
  if (wtloginrspbuff_ == NULL) {
    wtloginrspbuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindQQResponse.WTLoginRspBuff)
  return wtloginrspbuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* BindQQResponse::release_wtloginrspbuff() {
  // @@protoc_insertion_point(field_release:micromsg.BindQQResponse.WTLoginRspBuff)
  clear_has_wtloginrspbuff();
  ::micromsg::SKBuiltinBuffer_t* temp = wtloginrspbuff_;
  wtloginrspbuff_ = NULL;
  return temp;
}
inline void BindQQResponse::set_allocated_wtloginrspbuff(::micromsg::SKBuiltinBuffer_t* wtloginrspbuff) {
  delete wtloginrspbuff_;
  wtloginrspbuff_ = wtloginrspbuff;
  if (wtloginrspbuff) {
    set_has_wtloginrspbuff();
  } else {
    clear_has_wtloginrspbuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindQQResponse.WTLoginRspBuff)
}

// -------------------------------------------------------------------

// ResetPwdRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool ResetPwdRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetPwdRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetPwdRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetPwdRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& ResetPwdRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetPwdRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* ResetPwdRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ResetPwdRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* ResetPwdRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.ResetPwdRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void ResetPwdRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ResetPwdRequest.BaseRequest)
}

// required uint32 OpCode = 2;
inline bool ResetPwdRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResetPwdRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResetPwdRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResetPwdRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 ResetPwdRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetPwdRequest.OpCode)
  return opcode_;
}
inline void ResetPwdRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ResetPwdRequest.OpCode)
}

// optional string Pwd = 3;
inline bool ResetPwdRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetPwdRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetPwdRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetPwdRequest::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd();
}
inline const ::std::string& ResetPwdRequest::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetPwdRequest.Pwd)
  return pwd_.GetNoArena();
}
inline void ResetPwdRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ResetPwdRequest.Pwd)
}
#if LANG_CXX11
inline void ResetPwdRequest::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ResetPwdRequest.Pwd)
}
#endif
inline void ResetPwdRequest::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ResetPwdRequest.Pwd)
}
inline void ResetPwdRequest::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ResetPwdRequest.Pwd)
}
inline ::std::string* ResetPwdRequest::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:micromsg.ResetPwdRequest.Pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResetPwdRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.ResetPwdRequest.Pwd)
  clear_has_pwd();
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResetPwdRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ResetPwdRequest.Pwd)
}

// -------------------------------------------------------------------

// ResetPwdResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool ResetPwdResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetPwdResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetPwdResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetPwdResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& ResetPwdResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetPwdResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* ResetPwdResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ResetPwdResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* ResetPwdResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.ResetPwdResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void ResetPwdResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ResetPwdResponse.BaseResponse)
}

// optional string Url = 2;
inline bool ResetPwdResponse::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetPwdResponse::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetPwdResponse::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetPwdResponse::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ResetPwdResponse::url() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetPwdResponse.Url)
  return url_.GetNoArena();
}
inline void ResetPwdResponse::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ResetPwdResponse.Url)
}
#if LANG_CXX11
inline void ResetPwdResponse::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ResetPwdResponse.Url)
}
#endif
inline void ResetPwdResponse::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ResetPwdResponse.Url)
}
inline void ResetPwdResponse::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ResetPwdResponse.Url)
}
inline ::std::string* ResetPwdResponse::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:micromsg.ResetPwdResponse.Url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResetPwdResponse::release_url() {
  // @@protoc_insertion_point(field_release:micromsg.ResetPwdResponse.Url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResetPwdResponse::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ResetPwdResponse.Url)
}

// -------------------------------------------------------------------

// UnBindQQRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool UnBindQQRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnBindQQRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnBindQQRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnBindQQRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& UnBindQQRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.UnBindQQRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* UnBindQQRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UnBindQQRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* UnBindQQRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.UnBindQQRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void UnBindQQRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UnBindQQRequest.BaseRequest)
}

// optional string Ticket = 2;
inline bool UnBindQQRequest::has_ticket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnBindQQRequest::set_has_ticket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnBindQQRequest::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnBindQQRequest::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& UnBindQQRequest::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.UnBindQQRequest.Ticket)
  return ticket_.GetNoArena();
}
inline void UnBindQQRequest::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.UnBindQQRequest.Ticket)
}
#if LANG_CXX11
inline void UnBindQQRequest::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.UnBindQQRequest.Ticket)
}
#endif
inline void UnBindQQRequest::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.UnBindQQRequest.Ticket)
}
inline void UnBindQQRequest::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.UnBindQQRequest.Ticket)
}
inline ::std::string* UnBindQQRequest::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.UnBindQQRequest.Ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnBindQQRequest::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.UnBindQQRequest.Ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnBindQQRequest::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.UnBindQQRequest.Ticket)
}

// -------------------------------------------------------------------

// UnBindQQResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool UnBindQQResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnBindQQResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnBindQQResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnBindQQResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& UnBindQQResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.UnBindQQResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* UnBindQQResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UnBindQQResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* UnBindQQResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.UnBindQQResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void UnBindQQResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UnBindQQResponse.BaseResponse)
}

// -------------------------------------------------------------------

// CheckUnBindRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool CheckUnBindRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckUnBindRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckUnBindRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckUnBindRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& CheckUnBindRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckUnBindRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* CheckUnBindRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.CheckUnBindRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* CheckUnBindRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.CheckUnBindRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void CheckUnBindRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.CheckUnBindRequest.BaseRequest)
}

// required int32 BindType = 2;
inline bool CheckUnBindRequest::has_bindtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckUnBindRequest::set_has_bindtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckUnBindRequest::clear_has_bindtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckUnBindRequest::clear_bindtype() {
  bindtype_ = 0;
  clear_has_bindtype();
}
inline ::google::protobuf::int32 CheckUnBindRequest::bindtype() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckUnBindRequest.BindType)
  return bindtype_;
}
inline void CheckUnBindRequest::set_bindtype(::google::protobuf::int32 value) {
  set_has_bindtype();
  bindtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.CheckUnBindRequest.BindType)
}

// -------------------------------------------------------------------

// CheckUnBindResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool CheckUnBindResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckUnBindResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckUnBindResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckUnBindResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& CheckUnBindResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckUnBindResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* CheckUnBindResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.CheckUnBindResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* CheckUnBindResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.CheckUnBindResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void CheckUnBindResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.CheckUnBindResponse.BaseResponse)
}

// optional string RandomPasswd = 2;
inline bool CheckUnBindResponse::has_randompasswd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckUnBindResponse::set_has_randompasswd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckUnBindResponse::clear_has_randompasswd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckUnBindResponse::clear_randompasswd() {
  randompasswd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_randompasswd();
}
inline const ::std::string& CheckUnBindResponse::randompasswd() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckUnBindResponse.RandomPasswd)
  return randompasswd_.GetNoArena();
}
inline void CheckUnBindResponse::set_randompasswd(const ::std::string& value) {
  set_has_randompasswd();
  randompasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.CheckUnBindResponse.RandomPasswd)
}
#if LANG_CXX11
inline void CheckUnBindResponse::set_randompasswd(::std::string&& value) {
  set_has_randompasswd();
  randompasswd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.CheckUnBindResponse.RandomPasswd)
}
#endif
inline void CheckUnBindResponse::set_randompasswd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_randompasswd();
  randompasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.CheckUnBindResponse.RandomPasswd)
}
inline void CheckUnBindResponse::set_randompasswd(const char* value, size_t size) {
  set_has_randompasswd();
  randompasswd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.CheckUnBindResponse.RandomPasswd)
}
inline ::std::string* CheckUnBindResponse::mutable_randompasswd() {
  set_has_randompasswd();
  // @@protoc_insertion_point(field_mutable:micromsg.CheckUnBindResponse.RandomPasswd)
  return randompasswd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckUnBindResponse::release_randompasswd() {
  // @@protoc_insertion_point(field_release:micromsg.CheckUnBindResponse.RandomPasswd)
  clear_has_randompasswd();
  return randompasswd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckUnBindResponse::set_allocated_randompasswd(::std::string* randompasswd) {
  if (randompasswd != NULL) {
    set_has_randompasswd();
  } else {
    clear_has_randompasswd();
  }
  randompasswd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), randompasswd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.CheckUnBindResponse.RandomPasswd)
}

// optional string CanUnbindNotice = 3;
inline bool CheckUnBindResponse::has_canunbindnotice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckUnBindResponse::set_has_canunbindnotice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckUnBindResponse::clear_has_canunbindnotice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckUnBindResponse::clear_canunbindnotice() {
  canunbindnotice_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_canunbindnotice();
}
inline const ::std::string& CheckUnBindResponse::canunbindnotice() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckUnBindResponse.CanUnbindNotice)
  return canunbindnotice_.GetNoArena();
}
inline void CheckUnBindResponse::set_canunbindnotice(const ::std::string& value) {
  set_has_canunbindnotice();
  canunbindnotice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.CheckUnBindResponse.CanUnbindNotice)
}
#if LANG_CXX11
inline void CheckUnBindResponse::set_canunbindnotice(::std::string&& value) {
  set_has_canunbindnotice();
  canunbindnotice_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.CheckUnBindResponse.CanUnbindNotice)
}
#endif
inline void CheckUnBindResponse::set_canunbindnotice(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_canunbindnotice();
  canunbindnotice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.CheckUnBindResponse.CanUnbindNotice)
}
inline void CheckUnBindResponse::set_canunbindnotice(const char* value, size_t size) {
  set_has_canunbindnotice();
  canunbindnotice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.CheckUnBindResponse.CanUnbindNotice)
}
inline ::std::string* CheckUnBindResponse::mutable_canunbindnotice() {
  set_has_canunbindnotice();
  // @@protoc_insertion_point(field_mutable:micromsg.CheckUnBindResponse.CanUnbindNotice)
  return canunbindnotice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckUnBindResponse::release_canunbindnotice() {
  // @@protoc_insertion_point(field_release:micromsg.CheckUnBindResponse.CanUnbindNotice)
  clear_has_canunbindnotice();
  return canunbindnotice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckUnBindResponse::set_allocated_canunbindnotice(::std::string* canunbindnotice) {
  if (canunbindnotice != NULL) {
    set_has_canunbindnotice();
  } else {
    clear_has_canunbindnotice();
  }
  canunbindnotice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), canunbindnotice);
  // @@protoc_insertion_point(field_set_allocated:micromsg.CheckUnBindResponse.CanUnbindNotice)
}

// -------------------------------------------------------------------

// FaceBookAuthRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool FaceBookAuthRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FaceBookAuthRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FaceBookAuthRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FaceBookAuthRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& FaceBookAuthRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.FaceBookAuthRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* FaceBookAuthRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.FaceBookAuthRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* FaceBookAuthRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.FaceBookAuthRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void FaceBookAuthRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.FaceBookAuthRequest.BaseRequest)
}

// required uint32 OpType = 2;
inline bool FaceBookAuthRequest::has_optype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FaceBookAuthRequest::set_has_optype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FaceBookAuthRequest::clear_has_optype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FaceBookAuthRequest::clear_optype() {
  optype_ = 0u;
  clear_has_optype();
}
inline ::google::protobuf::uint32 FaceBookAuthRequest::optype() const {
  // @@protoc_insertion_point(field_get:micromsg.FaceBookAuthRequest.OpType)
  return optype_;
}
inline void FaceBookAuthRequest::set_optype(::google::protobuf::uint32 value) {
  set_has_optype();
  optype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.FaceBookAuthRequest.OpType)
}

// optional string AccessToken = 3;
inline bool FaceBookAuthRequest::has_accesstoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaceBookAuthRequest::set_has_accesstoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaceBookAuthRequest::clear_has_accesstoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaceBookAuthRequest::clear_accesstoken() {
  accesstoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_accesstoken();
}
inline const ::std::string& FaceBookAuthRequest::accesstoken() const {
  // @@protoc_insertion_point(field_get:micromsg.FaceBookAuthRequest.AccessToken)
  return accesstoken_.GetNoArena();
}
inline void FaceBookAuthRequest::set_accesstoken(const ::std::string& value) {
  set_has_accesstoken();
  accesstoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.FaceBookAuthRequest.AccessToken)
}
#if LANG_CXX11
inline void FaceBookAuthRequest::set_accesstoken(::std::string&& value) {
  set_has_accesstoken();
  accesstoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.FaceBookAuthRequest.AccessToken)
}
#endif
inline void FaceBookAuthRequest::set_accesstoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_accesstoken();
  accesstoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.FaceBookAuthRequest.AccessToken)
}
inline void FaceBookAuthRequest::set_accesstoken(const char* value, size_t size) {
  set_has_accesstoken();
  accesstoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.FaceBookAuthRequest.AccessToken)
}
inline ::std::string* FaceBookAuthRequest::mutable_accesstoken() {
  set_has_accesstoken();
  // @@protoc_insertion_point(field_mutable:micromsg.FaceBookAuthRequest.AccessToken)
  return accesstoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceBookAuthRequest::release_accesstoken() {
  // @@protoc_insertion_point(field_release:micromsg.FaceBookAuthRequest.AccessToken)
  clear_has_accesstoken();
  return accesstoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceBookAuthRequest::set_allocated_accesstoken(::std::string* accesstoken) {
  if (accesstoken != NULL) {
    set_has_accesstoken();
  } else {
    clear_has_accesstoken();
  }
  accesstoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), accesstoken);
  // @@protoc_insertion_point(field_set_allocated:micromsg.FaceBookAuthRequest.AccessToken)
}

// optional string RandomEncryKey = 4;
inline bool FaceBookAuthRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaceBookAuthRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaceBookAuthRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaceBookAuthRequest::clear_randomencrykey() {
  randomencrykey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_randomencrykey();
}
inline const ::std::string& FaceBookAuthRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.FaceBookAuthRequest.RandomEncryKey)
  return randomencrykey_.GetNoArena();
}
inline void FaceBookAuthRequest::set_randomencrykey(const ::std::string& value) {
  set_has_randomencrykey();
  randomencrykey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.FaceBookAuthRequest.RandomEncryKey)
}
#if LANG_CXX11
inline void FaceBookAuthRequest::set_randomencrykey(::std::string&& value) {
  set_has_randomencrykey();
  randomencrykey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.FaceBookAuthRequest.RandomEncryKey)
}
#endif
inline void FaceBookAuthRequest::set_randomencrykey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_randomencrykey();
  randomencrykey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.FaceBookAuthRequest.RandomEncryKey)
}
inline void FaceBookAuthRequest::set_randomencrykey(const char* value, size_t size) {
  set_has_randomencrykey();
  randomencrykey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.FaceBookAuthRequest.RandomEncryKey)
}
inline ::std::string* FaceBookAuthRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  // @@protoc_insertion_point(field_mutable:micromsg.FaceBookAuthRequest.RandomEncryKey)
  return randomencrykey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceBookAuthRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.FaceBookAuthRequest.RandomEncryKey)
  clear_has_randomencrykey();
  return randomencrykey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceBookAuthRequest::set_allocated_randomencrykey(::std::string* randomencrykey) {
  if (randomencrykey != NULL) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  randomencrykey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), randomencrykey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.FaceBookAuthRequest.RandomEncryKey)
}

// -------------------------------------------------------------------

// FaceBookAuthResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool FaceBookAuthResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaceBookAuthResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaceBookAuthResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaceBookAuthResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& FaceBookAuthResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.FaceBookAuthResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* FaceBookAuthResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.FaceBookAuthResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* FaceBookAuthResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.FaceBookAuthResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void FaceBookAuthResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.FaceBookAuthResponse.BaseResponse)
}

// required uint64 FBUserID = 2;
inline bool FaceBookAuthResponse::has_fbuserid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FaceBookAuthResponse::set_has_fbuserid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FaceBookAuthResponse::clear_has_fbuserid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FaceBookAuthResponse::clear_fbuserid() {
  fbuserid_ = GOOGLE_ULONGLONG(0);
  clear_has_fbuserid();
}
inline ::google::protobuf::uint64 FaceBookAuthResponse::fbuserid() const {
  // @@protoc_insertion_point(field_get:micromsg.FaceBookAuthResponse.FBUserID)
  return fbuserid_;
}
inline void FaceBookAuthResponse::set_fbuserid(::google::protobuf::uint64 value) {
  set_has_fbuserid();
  fbuserid_ = value;
  // @@protoc_insertion_point(field_set:micromsg.FaceBookAuthResponse.FBUserID)
}

// optional string FBUserName = 3;
inline bool FaceBookAuthResponse::has_fbusername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaceBookAuthResponse::set_has_fbusername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaceBookAuthResponse::clear_has_fbusername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaceBookAuthResponse::clear_fbusername() {
  fbusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fbusername();
}
inline const ::std::string& FaceBookAuthResponse::fbusername() const {
  // @@protoc_insertion_point(field_get:micromsg.FaceBookAuthResponse.FBUserName)
  return fbusername_.GetNoArena();
}
inline void FaceBookAuthResponse::set_fbusername(const ::std::string& value) {
  set_has_fbusername();
  fbusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.FaceBookAuthResponse.FBUserName)
}
#if LANG_CXX11
inline void FaceBookAuthResponse::set_fbusername(::std::string&& value) {
  set_has_fbusername();
  fbusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.FaceBookAuthResponse.FBUserName)
}
#endif
inline void FaceBookAuthResponse::set_fbusername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fbusername();
  fbusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.FaceBookAuthResponse.FBUserName)
}
inline void FaceBookAuthResponse::set_fbusername(const char* value, size_t size) {
  set_has_fbusername();
  fbusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.FaceBookAuthResponse.FBUserName)
}
inline ::std::string* FaceBookAuthResponse::mutable_fbusername() {
  set_has_fbusername();
  // @@protoc_insertion_point(field_mutable:micromsg.FaceBookAuthResponse.FBUserName)
  return fbusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FaceBookAuthResponse::release_fbusername() {
  // @@protoc_insertion_point(field_release:micromsg.FaceBookAuthResponse.FBUserName)
  clear_has_fbusername();
  return fbusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FaceBookAuthResponse::set_allocated_fbusername(::std::string* fbusername) {
  if (fbusername != NULL) {
    set_has_fbusername();
  } else {
    clear_has_fbusername();
  }
  fbusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fbusername);
  // @@protoc_insertion_point(field_set_allocated:micromsg.FaceBookAuthResponse.FBUserName)
}

// -------------------------------------------------------------------

// RegEquipmentRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool RegEquipmentRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegEquipmentRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegEquipmentRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegEquipmentRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& RegEquipmentRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* RegEquipmentRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* RegEquipmentRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void RegEquipmentRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentRequest.BaseRequest)
}

// required uint32 Type = 2;
inline bool RegEquipmentRequest::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegEquipmentRequest::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RegEquipmentRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RegEquipmentRequest::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 RegEquipmentRequest::type() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.Type)
  return type_;
}
inline void RegEquipmentRequest::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.Type)
}

// optional string SerialNumber = 3;
inline bool RegEquipmentRequest::has_serialnumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegEquipmentRequest::set_has_serialnumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegEquipmentRequest::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegEquipmentRequest::clear_serialnumber() {
  serialnumber_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serialnumber();
}
inline const ::std::string& RegEquipmentRequest::serialnumber() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.SerialNumber)
  return serialnumber_.GetNoArena();
}
inline void RegEquipmentRequest::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  serialnumber_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.SerialNumber)
}
#if LANG_CXX11
inline void RegEquipmentRequest::set_serialnumber(::std::string&& value) {
  set_has_serialnumber();
  serialnumber_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentRequest.SerialNumber)
}
#endif
inline void RegEquipmentRequest::set_serialnumber(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serialnumber();
  serialnumber_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentRequest.SerialNumber)
}
inline void RegEquipmentRequest::set_serialnumber(const char* value, size_t size) {
  set_has_serialnumber();
  serialnumber_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentRequest.SerialNumber)
}
inline ::std::string* RegEquipmentRequest::mutable_serialnumber() {
  set_has_serialnumber();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentRequest.SerialNumber)
  return serialnumber_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentRequest::release_serialnumber() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentRequest.SerialNumber)
  clear_has_serialnumber();
  return serialnumber_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentRequest::set_allocated_serialnumber(::std::string* serialnumber) {
  if (serialnumber != NULL) {
    set_has_serialnumber();
  } else {
    clear_has_serialnumber();
  }
  serialnumber_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serialnumber);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentRequest.SerialNumber)
}

// optional string IMEI = 4;
inline bool RegEquipmentRequest::has_imei() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegEquipmentRequest::set_has_imei() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegEquipmentRequest::clear_has_imei() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegEquipmentRequest::clear_imei() {
  imei_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imei();
}
inline const ::std::string& RegEquipmentRequest::imei() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.IMEI)
  return imei_.GetNoArena();
}
inline void RegEquipmentRequest::set_imei(const ::std::string& value) {
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.IMEI)
}
#if LANG_CXX11
inline void RegEquipmentRequest::set_imei(::std::string&& value) {
  set_has_imei();
  imei_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentRequest.IMEI)
}
#endif
inline void RegEquipmentRequest::set_imei(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentRequest.IMEI)
}
inline void RegEquipmentRequest::set_imei(const char* value, size_t size) {
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentRequest.IMEI)
}
inline ::std::string* RegEquipmentRequest::mutable_imei() {
  set_has_imei();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentRequest.IMEI)
  return imei_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentRequest::release_imei() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentRequest.IMEI)
  clear_has_imei();
  return imei_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentRequest::set_allocated_imei(::std::string* imei) {
  if (imei != NULL) {
    set_has_imei();
  } else {
    clear_has_imei();
  }
  imei_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imei);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentRequest.IMEI)
}

// optional string MAC = 5;
inline bool RegEquipmentRequest::has_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegEquipmentRequest::set_has_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegEquipmentRequest::clear_has_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegEquipmentRequest::clear_mac() {
  mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mac();
}
inline const ::std::string& RegEquipmentRequest::mac() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.MAC)
  return mac_.GetNoArena();
}
inline void RegEquipmentRequest::set_mac(const ::std::string& value) {
  set_has_mac();
  mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.MAC)
}
#if LANG_CXX11
inline void RegEquipmentRequest::set_mac(::std::string&& value) {
  set_has_mac();
  mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentRequest.MAC)
}
#endif
inline void RegEquipmentRequest::set_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mac();
  mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentRequest.MAC)
}
inline void RegEquipmentRequest::set_mac(const char* value, size_t size) {
  set_has_mac();
  mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentRequest.MAC)
}
inline ::std::string* RegEquipmentRequest::mutable_mac() {
  set_has_mac();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentRequest.MAC)
  return mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentRequest::release_mac() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentRequest.MAC)
  clear_has_mac();
  return mac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentRequest::set_allocated_mac(::std::string* mac) {
  if (mac != NULL) {
    set_has_mac();
  } else {
    clear_has_mac();
  }
  mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentRequest.MAC)
}

// optional string NickName = 6;
inline bool RegEquipmentRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegEquipmentRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegEquipmentRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegEquipmentRequest::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& RegEquipmentRequest::nickname() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.NickName)
  return nickname_.GetNoArena();
}
inline void RegEquipmentRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.NickName)
}
#if LANG_CXX11
inline void RegEquipmentRequest::set_nickname(::std::string&& value) {
  set_has_nickname();
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentRequest.NickName)
}
#endif
inline void RegEquipmentRequest::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentRequest.NickName)
}
inline void RegEquipmentRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentRequest.NickName)
}
inline ::std::string* RegEquipmentRequest::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentRequest.NickName)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentRequest::release_nickname() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentRequest.NickName)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentRequest::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentRequest.NickName)
}

// required uint32 BuiltinIPSeq = 7;
inline bool RegEquipmentRequest::has_builtinipseq() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RegEquipmentRequest::set_has_builtinipseq() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RegEquipmentRequest::clear_has_builtinipseq() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RegEquipmentRequest::clear_builtinipseq() {
  builtinipseq_ = 0u;
  clear_has_builtinipseq();
}
inline ::google::protobuf::uint32 RegEquipmentRequest::builtinipseq() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.BuiltinIPSeq)
  return builtinipseq_;
}
inline void RegEquipmentRequest::set_builtinipseq(::google::protobuf::uint32 value) {
  set_has_builtinipseq();
  builtinipseq_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.BuiltinIPSeq)
}

// required uint32 DLSrc = 8;
inline bool RegEquipmentRequest::has_dlsrc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RegEquipmentRequest::set_has_dlsrc() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RegEquipmentRequest::clear_has_dlsrc() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RegEquipmentRequest::clear_dlsrc() {
  dlsrc_ = 0u;
  clear_has_dlsrc();
}
inline ::google::protobuf::uint32 RegEquipmentRequest::dlsrc() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.DLSrc)
  return dlsrc_;
}
inline void RegEquipmentRequest::set_dlsrc(::google::protobuf::uint32 value) {
  set_has_dlsrc();
  dlsrc_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.DLSrc)
}

// required uint32 RegMode = 9;
inline bool RegEquipmentRequest::has_regmode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RegEquipmentRequest::set_has_regmode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RegEquipmentRequest::clear_has_regmode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RegEquipmentRequest::clear_regmode() {
  regmode_ = 0u;
  clear_has_regmode();
}
inline ::google::protobuf::uint32 RegEquipmentRequest::regmode() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.RegMode)
  return regmode_;
}
inline void RegEquipmentRequest::set_regmode(::google::protobuf::uint32 value) {
  set_has_regmode();
  regmode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.RegMode)
}

// optional string TimeZone = 10;
inline bool RegEquipmentRequest::has_timezone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegEquipmentRequest::set_has_timezone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegEquipmentRequest::clear_has_timezone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegEquipmentRequest::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timezone();
}
inline const ::std::string& RegEquipmentRequest::timezone() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.TimeZone)
  return timezone_.GetNoArena();
}
inline void RegEquipmentRequest::set_timezone(const ::std::string& value) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.TimeZone)
}
#if LANG_CXX11
inline void RegEquipmentRequest::set_timezone(::std::string&& value) {
  set_has_timezone();
  timezone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentRequest.TimeZone)
}
#endif
inline void RegEquipmentRequest::set_timezone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentRequest.TimeZone)
}
inline void RegEquipmentRequest::set_timezone(const char* value, size_t size) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentRequest.TimeZone)
}
inline ::std::string* RegEquipmentRequest::mutable_timezone() {
  set_has_timezone();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentRequest.TimeZone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentRequest::release_timezone() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentRequest.TimeZone)
  clear_has_timezone();
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentRequest::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    set_has_timezone();
  } else {
    clear_has_timezone();
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentRequest.TimeZone)
}

// optional string Language = 11;
inline bool RegEquipmentRequest::has_language() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegEquipmentRequest::set_has_language() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegEquipmentRequest::clear_has_language() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegEquipmentRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& RegEquipmentRequest::language() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.Language)
  return language_.GetNoArena();
}
inline void RegEquipmentRequest::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.Language)
}
#if LANG_CXX11
inline void RegEquipmentRequest::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentRequest.Language)
}
#endif
inline void RegEquipmentRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentRequest.Language)
}
inline void RegEquipmentRequest::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentRequest.Language)
}
inline ::std::string* RegEquipmentRequest::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentRequest.Language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentRequest::release_language() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentRequest.Language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentRequest::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentRequest.Language)
}

// required uint32 ForceReg = 12;
inline bool RegEquipmentRequest::has_forcereg() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RegEquipmentRequest::set_has_forcereg() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RegEquipmentRequest::clear_has_forcereg() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RegEquipmentRequest::clear_forcereg() {
  forcereg_ = 0u;
  clear_has_forcereg();
}
inline ::google::protobuf::uint32 RegEquipmentRequest::forcereg() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.ForceReg)
  return forcereg_;
}
inline void RegEquipmentRequest::set_forcereg(::google::protobuf::uint32 value) {
  set_has_forcereg();
  forcereg_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.ForceReg)
}

// optional string RealCountry = 13;
inline bool RegEquipmentRequest::has_realcountry() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegEquipmentRequest::set_has_realcountry() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegEquipmentRequest::clear_has_realcountry() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegEquipmentRequest::clear_realcountry() {
  realcountry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_realcountry();
}
inline const ::std::string& RegEquipmentRequest::realcountry() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.RealCountry)
  return realcountry_.GetNoArena();
}
inline void RegEquipmentRequest::set_realcountry(const ::std::string& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentRequest.RealCountry)
}
#if LANG_CXX11
inline void RegEquipmentRequest::set_realcountry(::std::string&& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentRequest.RealCountry)
}
#endif
inline void RegEquipmentRequest::set_realcountry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentRequest.RealCountry)
}
inline void RegEquipmentRequest::set_realcountry(const char* value, size_t size) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentRequest.RealCountry)
}
inline ::std::string* RegEquipmentRequest::mutable_realcountry() {
  set_has_realcountry();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentRequest.RealCountry)
  return realcountry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentRequest::release_realcountry() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentRequest.RealCountry)
  clear_has_realcountry();
  return realcountry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentRequest::set_allocated_realcountry(::std::string* realcountry) {
  if (realcountry != NULL) {
    set_has_realcountry();
  } else {
    clear_has_realcountry();
  }
  realcountry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), realcountry);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentRequest.RealCountry)
}

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 14;
inline bool RegEquipmentRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegEquipmentRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RegEquipmentRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RegEquipmentRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& RegEquipmentRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* RegEquipmentRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* RegEquipmentRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void RegEquipmentRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentRequest.RandomEncryKey)
}

// -------------------------------------------------------------------

// RegEquipmentResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool RegEquipmentResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RegEquipmentResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RegEquipmentResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RegEquipmentResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& RegEquipmentResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* RegEquipmentResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* RegEquipmentResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void RegEquipmentResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.BaseResponse)
}

// required uint32 Uin = 2;
inline bool RegEquipmentResponse::has_uin() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RegEquipmentResponse::set_has_uin() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RegEquipmentResponse::clear_has_uin() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RegEquipmentResponse::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 RegEquipmentResponse::uin() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.Uin)
  return uin_;
}
inline void RegEquipmentResponse::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.Uin)
}

// optional string SessionKey = 3;
inline bool RegEquipmentResponse::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegEquipmentResponse::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegEquipmentResponse::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegEquipmentResponse::clear_sessionkey() {
  sessionkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionkey();
}
inline const ::std::string& RegEquipmentResponse::sessionkey() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.SessionKey)
  return sessionkey_.GetNoArena();
}
inline void RegEquipmentResponse::set_sessionkey(const ::std::string& value) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.SessionKey)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_sessionkey(::std::string&& value) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.SessionKey)
}
#endif
inline void RegEquipmentResponse::set_sessionkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.SessionKey)
}
inline void RegEquipmentResponse::set_sessionkey(const char* value, size_t size) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.SessionKey)
}
inline ::std::string* RegEquipmentResponse::mutable_sessionkey() {
  set_has_sessionkey();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.SessionKey)
  return sessionkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_sessionkey() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.SessionKey)
  clear_has_sessionkey();
  return sessionkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_sessionkey(::std::string* sessionkey) {
  if (sessionkey != NULL) {
    set_has_sessionkey();
  } else {
    clear_has_sessionkey();
  }
  sessionkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.SessionKey)
}

// optional string OfficialUserName = 4;
inline bool RegEquipmentResponse::has_officialusername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegEquipmentResponse::set_has_officialusername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegEquipmentResponse::clear_has_officialusername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegEquipmentResponse::clear_officialusername() {
  officialusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_officialusername();
}
inline const ::std::string& RegEquipmentResponse::officialusername() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.OfficialUserName)
  return officialusername_.GetNoArena();
}
inline void RegEquipmentResponse::set_officialusername(const ::std::string& value) {
  set_has_officialusername();
  officialusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.OfficialUserName)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_officialusername(::std::string&& value) {
  set_has_officialusername();
  officialusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.OfficialUserName)
}
#endif
inline void RegEquipmentResponse::set_officialusername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_officialusername();
  officialusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.OfficialUserName)
}
inline void RegEquipmentResponse::set_officialusername(const char* value, size_t size) {
  set_has_officialusername();
  officialusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.OfficialUserName)
}
inline ::std::string* RegEquipmentResponse::mutable_officialusername() {
  set_has_officialusername();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.OfficialUserName)
  return officialusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_officialusername() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.OfficialUserName)
  clear_has_officialusername();
  return officialusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_officialusername(::std::string* officialusername) {
  if (officialusername != NULL) {
    set_has_officialusername();
  } else {
    clear_has_officialusername();
  }
  officialusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), officialusername);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.OfficialUserName)
}

// optional string OfficialNickName = 5;
inline bool RegEquipmentResponse::has_officialnickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegEquipmentResponse::set_has_officialnickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegEquipmentResponse::clear_has_officialnickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegEquipmentResponse::clear_officialnickname() {
  officialnickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_officialnickname();
}
inline const ::std::string& RegEquipmentResponse::officialnickname() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.OfficialNickName)
  return officialnickname_.GetNoArena();
}
inline void RegEquipmentResponse::set_officialnickname(const ::std::string& value) {
  set_has_officialnickname();
  officialnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.OfficialNickName)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_officialnickname(::std::string&& value) {
  set_has_officialnickname();
  officialnickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.OfficialNickName)
}
#endif
inline void RegEquipmentResponse::set_officialnickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_officialnickname();
  officialnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.OfficialNickName)
}
inline void RegEquipmentResponse::set_officialnickname(const char* value, size_t size) {
  set_has_officialnickname();
  officialnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.OfficialNickName)
}
inline ::std::string* RegEquipmentResponse::mutable_officialnickname() {
  set_has_officialnickname();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.OfficialNickName)
  return officialnickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_officialnickname() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.OfficialNickName)
  clear_has_officialnickname();
  return officialnickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_officialnickname(::std::string* officialnickname) {
  if (officialnickname != NULL) {
    set_has_officialnickname();
  } else {
    clear_has_officialnickname();
  }
  officialnickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), officialnickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.OfficialNickName)
}

// optional string QQMicroBlogUserName = 6;
inline bool RegEquipmentResponse::has_qqmicroblogusername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegEquipmentResponse::set_has_qqmicroblogusername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegEquipmentResponse::clear_has_qqmicroblogusername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegEquipmentResponse::clear_qqmicroblogusername() {
  qqmicroblogusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_qqmicroblogusername();
}
inline const ::std::string& RegEquipmentResponse::qqmicroblogusername() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.QQMicroBlogUserName)
  return qqmicroblogusername_.GetNoArena();
}
inline void RegEquipmentResponse::set_qqmicroblogusername(const ::std::string& value) {
  set_has_qqmicroblogusername();
  qqmicroblogusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.QQMicroBlogUserName)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_qqmicroblogusername(::std::string&& value) {
  set_has_qqmicroblogusername();
  qqmicroblogusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.QQMicroBlogUserName)
}
#endif
inline void RegEquipmentResponse::set_qqmicroblogusername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_qqmicroblogusername();
  qqmicroblogusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.QQMicroBlogUserName)
}
inline void RegEquipmentResponse::set_qqmicroblogusername(const char* value, size_t size) {
  set_has_qqmicroblogusername();
  qqmicroblogusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.QQMicroBlogUserName)
}
inline ::std::string* RegEquipmentResponse::mutable_qqmicroblogusername() {
  set_has_qqmicroblogusername();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.QQMicroBlogUserName)
  return qqmicroblogusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_qqmicroblogusername() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.QQMicroBlogUserName)
  clear_has_qqmicroblogusername();
  return qqmicroblogusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_qqmicroblogusername(::std::string* qqmicroblogusername) {
  if (qqmicroblogusername != NULL) {
    set_has_qqmicroblogusername();
  } else {
    clear_has_qqmicroblogusername();
  }
  qqmicroblogusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), qqmicroblogusername);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.QQMicroBlogUserName)
}

// optional string BindEmail = 7;
inline bool RegEquipmentResponse::has_bindemail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegEquipmentResponse::set_has_bindemail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegEquipmentResponse::clear_has_bindemail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegEquipmentResponse::clear_bindemail() {
  bindemail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bindemail();
}
inline const ::std::string& RegEquipmentResponse::bindemail() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.BindEmail)
  return bindemail_.GetNoArena();
}
inline void RegEquipmentResponse::set_bindemail(const ::std::string& value) {
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.BindEmail)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_bindemail(::std::string&& value) {
  set_has_bindemail();
  bindemail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.BindEmail)
}
#endif
inline void RegEquipmentResponse::set_bindemail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.BindEmail)
}
inline void RegEquipmentResponse::set_bindemail(const char* value, size_t size) {
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.BindEmail)
}
inline ::std::string* RegEquipmentResponse::mutable_bindemail() {
  set_has_bindemail();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.BindEmail)
  return bindemail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_bindemail() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.BindEmail)
  clear_has_bindemail();
  return bindemail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_bindemail(::std::string* bindemail) {
  if (bindemail != NULL) {
    set_has_bindemail();
  } else {
    clear_has_bindemail();
  }
  bindemail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bindemail);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.BindEmail)
}

// required uint32 PushMailStatus = 8;
inline bool RegEquipmentResponse::has_pushmailstatus() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RegEquipmentResponse::set_has_pushmailstatus() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RegEquipmentResponse::clear_has_pushmailstatus() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RegEquipmentResponse::clear_pushmailstatus() {
  pushmailstatus_ = 0u;
  clear_has_pushmailstatus();
}
inline ::google::protobuf::uint32 RegEquipmentResponse::pushmailstatus() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.PushMailStatus)
  return pushmailstatus_;
}
inline void RegEquipmentResponse::set_pushmailstatus(::google::protobuf::uint32 value) {
  set_has_pushmailstatus();
  pushmailstatus_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.PushMailStatus)
}

// required uint32 SendCardBitFlag = 9;
inline bool RegEquipmentResponse::has_sendcardbitflag() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RegEquipmentResponse::set_has_sendcardbitflag() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RegEquipmentResponse::clear_has_sendcardbitflag() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RegEquipmentResponse::clear_sendcardbitflag() {
  sendcardbitflag_ = 0u;
  clear_has_sendcardbitflag();
}
inline ::google::protobuf::uint32 RegEquipmentResponse::sendcardbitflag() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.SendCardBitFlag)
  return sendcardbitflag_;
}
inline void RegEquipmentResponse::set_sendcardbitflag(::google::protobuf::uint32 value) {
  set_has_sendcardbitflag();
  sendcardbitflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.SendCardBitFlag)
}

// optional string PushMailSettingTicket = 10;
inline bool RegEquipmentResponse::has_pushmailsettingticket() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegEquipmentResponse::set_has_pushmailsettingticket() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RegEquipmentResponse::clear_has_pushmailsettingticket() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RegEquipmentResponse::clear_pushmailsettingticket() {
  pushmailsettingticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pushmailsettingticket();
}
inline const ::std::string& RegEquipmentResponse::pushmailsettingticket() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.PushMailSettingTicket)
  return pushmailsettingticket_.GetNoArena();
}
inline void RegEquipmentResponse::set_pushmailsettingticket(const ::std::string& value) {
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.PushMailSettingTicket)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_pushmailsettingticket(::std::string&& value) {
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.PushMailSettingTicket)
}
#endif
inline void RegEquipmentResponse::set_pushmailsettingticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.PushMailSettingTicket)
}
inline void RegEquipmentResponse::set_pushmailsettingticket(const char* value, size_t size) {
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.PushMailSettingTicket)
}
inline ::std::string* RegEquipmentResponse::mutable_pushmailsettingticket() {
  set_has_pushmailsettingticket();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.PushMailSettingTicket)
  return pushmailsettingticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_pushmailsettingticket() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.PushMailSettingTicket)
  clear_has_pushmailsettingticket();
  return pushmailsettingticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_pushmailsettingticket(::std::string* pushmailsettingticket) {
  if (pushmailsettingticket != NULL) {
    set_has_pushmailsettingticket();
  } else {
    clear_has_pushmailsettingticket();
  }
  pushmailsettingticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pushmailsettingticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.PushMailSettingTicket)
}

// required .micromsg.BuiltinIPList BuiltinIPList = 14;
inline bool RegEquipmentResponse::has_builtiniplist() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RegEquipmentResponse::set_has_builtiniplist() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RegEquipmentResponse::clear_has_builtiniplist() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RegEquipmentResponse::clear_builtiniplist() {
  if (builtiniplist_ != NULL) builtiniplist_->::micromsg::BuiltinIPList::Clear();
  clear_has_builtiniplist();
}
inline const ::micromsg::BuiltinIPList& RegEquipmentResponse::builtiniplist() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.BuiltinIPList)
  return builtiniplist_ != NULL ? *builtiniplist_
                         : *::micromsg::BuiltinIPList::internal_default_instance();
}
inline ::micromsg::BuiltinIPList* RegEquipmentResponse::mutable_builtiniplist() {
  set_has_builtiniplist();
  if (builtiniplist_ == NULL) {
    builtiniplist_ = new ::micromsg::BuiltinIPList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.BuiltinIPList)
  return builtiniplist_;
}
inline ::micromsg::BuiltinIPList* RegEquipmentResponse::release_builtiniplist() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.BuiltinIPList)
  clear_has_builtiniplist();
  ::micromsg::BuiltinIPList* temp = builtiniplist_;
  builtiniplist_ = NULL;
  return temp;
}
inline void RegEquipmentResponse::set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist) {
  delete builtiniplist_;
  builtiniplist_ = builtiniplist;
  if (builtiniplist) {
    set_has_builtiniplist();
  } else {
    clear_has_builtiniplist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.BuiltinIPList)
}

// optional string FSURL = 15;
inline bool RegEquipmentResponse::has_fsurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegEquipmentResponse::set_has_fsurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RegEquipmentResponse::clear_has_fsurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RegEquipmentResponse::clear_fsurl() {
  fsurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fsurl();
}
inline const ::std::string& RegEquipmentResponse::fsurl() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.FSURL)
  return fsurl_.GetNoArena();
}
inline void RegEquipmentResponse::set_fsurl(const ::std::string& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.FSURL)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_fsurl(::std::string&& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.FSURL)
}
#endif
inline void RegEquipmentResponse::set_fsurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.FSURL)
}
inline void RegEquipmentResponse::set_fsurl(const char* value, size_t size) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.FSURL)
}
inline ::std::string* RegEquipmentResponse::mutable_fsurl() {
  set_has_fsurl();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.FSURL)
  return fsurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_fsurl() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.FSURL)
  clear_has_fsurl();
  return fsurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_fsurl(::std::string* fsurl) {
  if (fsurl != NULL) {
    set_has_fsurl();
  } else {
    clear_has_fsurl();
  }
  fsurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fsurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.FSURL)
}

// optional string UserName = 16;
inline bool RegEquipmentResponse::has_username() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegEquipmentResponse::set_has_username() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RegEquipmentResponse::clear_has_username() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RegEquipmentResponse::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& RegEquipmentResponse::username() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.UserName)
  return username_.GetNoArena();
}
inline void RegEquipmentResponse::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.UserName)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.UserName)
}
#endif
inline void RegEquipmentResponse::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.UserName)
}
inline void RegEquipmentResponse::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.UserName)
}
inline ::std::string* RegEquipmentResponse::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.UserName)
}

// required uint32 Status = 17;
inline bool RegEquipmentResponse::has_status() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RegEquipmentResponse::set_has_status() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RegEquipmentResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RegEquipmentResponse::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 RegEquipmentResponse::status() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.Status)
  return status_;
}
inline void RegEquipmentResponse::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.Status)
}

// required .micromsg.NetworkControl NetworkControl = 18;
inline bool RegEquipmentResponse::has_networkcontrol() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RegEquipmentResponse::set_has_networkcontrol() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RegEquipmentResponse::clear_has_networkcontrol() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RegEquipmentResponse::clear_networkcontrol() {
  if (networkcontrol_ != NULL) networkcontrol_->::micromsg::NetworkControl::Clear();
  clear_has_networkcontrol();
}
inline const ::micromsg::NetworkControl& RegEquipmentResponse::networkcontrol() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.NetworkControl)
  return networkcontrol_ != NULL ? *networkcontrol_
                         : *::micromsg::NetworkControl::internal_default_instance();
}
inline ::micromsg::NetworkControl* RegEquipmentResponse::mutable_networkcontrol() {
  set_has_networkcontrol();
  if (networkcontrol_ == NULL) {
    networkcontrol_ = new ::micromsg::NetworkControl;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.NetworkControl)
  return networkcontrol_;
}
inline ::micromsg::NetworkControl* RegEquipmentResponse::release_networkcontrol() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.NetworkControl)
  clear_has_networkcontrol();
  ::micromsg::NetworkControl* temp = networkcontrol_;
  networkcontrol_ = NULL;
  return temp;
}
inline void RegEquipmentResponse::set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol) {
  delete networkcontrol_;
  networkcontrol_ = networkcontrol;
  if (networkcontrol) {
    set_has_networkcontrol();
  } else {
    clear_has_networkcontrol();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.NetworkControl)
}

// required uint32 ReturnFlag = 19;
inline bool RegEquipmentResponse::has_returnflag() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RegEquipmentResponse::set_has_returnflag() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RegEquipmentResponse::clear_has_returnflag() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RegEquipmentResponse::clear_returnflag() {
  returnflag_ = 0u;
  clear_has_returnflag();
}
inline ::google::protobuf::uint32 RegEquipmentResponse::returnflag() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.ReturnFlag)
  return returnflag_;
}
inline void RegEquipmentResponse::set_returnflag(::google::protobuf::uint32 value) {
  set_has_returnflag();
  returnflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.ReturnFlag)
}

// required uint32 RegType = 20;
inline bool RegEquipmentResponse::has_regtype() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RegEquipmentResponse::set_has_regtype() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RegEquipmentResponse::clear_has_regtype() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RegEquipmentResponse::clear_regtype() {
  regtype_ = 0u;
  clear_has_regtype();
}
inline ::google::protobuf::uint32 RegEquipmentResponse::regtype() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.RegType)
  return regtype_;
}
inline void RegEquipmentResponse::set_regtype(::google::protobuf::uint32 value) {
  set_has_regtype();
  regtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.RegType)
}

// optional string AuthKey = 21;
inline bool RegEquipmentResponse::has_authkey() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegEquipmentResponse::set_has_authkey() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RegEquipmentResponse::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RegEquipmentResponse::clear_authkey() {
  authkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authkey();
}
inline const ::std::string& RegEquipmentResponse::authkey() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.AuthKey)
  return authkey_.GetNoArena();
}
inline void RegEquipmentResponse::set_authkey(const ::std::string& value) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.AuthKey)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_authkey(::std::string&& value) {
  set_has_authkey();
  authkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.AuthKey)
}
#endif
inline void RegEquipmentResponse::set_authkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.AuthKey)
}
inline void RegEquipmentResponse::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.AuthKey)
}
inline ::std::string* RegEquipmentResponse::mutable_authkey() {
  set_has_authkey();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.AuthKey)
  return authkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_authkey() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.AuthKey)
  clear_has_authkey();
  return authkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_authkey(::std::string* authkey) {
  if (authkey != NULL) {
    set_has_authkey();
  } else {
    clear_has_authkey();
  }
  authkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.AuthKey)
}

// required .micromsg.PluginKeyList PluginKeyList = 22;
inline bool RegEquipmentResponse::has_pluginkeylist() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RegEquipmentResponse::set_has_pluginkeylist() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RegEquipmentResponse::clear_has_pluginkeylist() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RegEquipmentResponse::clear_pluginkeylist() {
  if (pluginkeylist_ != NULL) pluginkeylist_->::micromsg::PluginKeyList::Clear();
  clear_has_pluginkeylist();
}
inline const ::micromsg::PluginKeyList& RegEquipmentResponse::pluginkeylist() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.PluginKeyList)
  return pluginkeylist_ != NULL ? *pluginkeylist_
                         : *::micromsg::PluginKeyList::internal_default_instance();
}
inline ::micromsg::PluginKeyList* RegEquipmentResponse::mutable_pluginkeylist() {
  set_has_pluginkeylist();
  if (pluginkeylist_ == NULL) {
    pluginkeylist_ = new ::micromsg::PluginKeyList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.PluginKeyList)
  return pluginkeylist_;
}
inline ::micromsg::PluginKeyList* RegEquipmentResponse::release_pluginkeylist() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.PluginKeyList)
  clear_has_pluginkeylist();
  ::micromsg::PluginKeyList* temp = pluginkeylist_;
  pluginkeylist_ = NULL;
  return temp;
}
inline void RegEquipmentResponse::set_allocated_pluginkeylist(::micromsg::PluginKeyList* pluginkeylist) {
  delete pluginkeylist_;
  pluginkeylist_ = pluginkeylist;
  if (pluginkeylist) {
    set_has_pluginkeylist();
  } else {
    clear_has_pluginkeylist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.PluginKeyList)
}

// optional string Password = 23;
inline bool RegEquipmentResponse::has_password() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegEquipmentResponse::set_has_password() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RegEquipmentResponse::clear_has_password() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RegEquipmentResponse::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& RegEquipmentResponse::password() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.Password)
  return password_.GetNoArena();
}
inline void RegEquipmentResponse::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.Password)
}
#if LANG_CXX11
inline void RegEquipmentResponse::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RegEquipmentResponse.Password)
}
#endif
inline void RegEquipmentResponse::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RegEquipmentResponse.Password)
}
inline void RegEquipmentResponse::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RegEquipmentResponse.Password)
}
inline ::std::string* RegEquipmentResponse::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.Password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegEquipmentResponse::release_password() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.Password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegEquipmentResponse::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.Password)
}

// required uint32 ProfileFlag = 24;
inline bool RegEquipmentResponse::has_profileflag() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RegEquipmentResponse::set_has_profileflag() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RegEquipmentResponse::clear_has_profileflag() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RegEquipmentResponse::clear_profileflag() {
  profileflag_ = 0u;
  clear_has_profileflag();
}
inline ::google::protobuf::uint32 RegEquipmentResponse::profileflag() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.ProfileFlag)
  return profileflag_;
}
inline void RegEquipmentResponse::set_profileflag(::google::protobuf::uint32 value) {
  set_has_profileflag();
  profileflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegEquipmentResponse.ProfileFlag)
}

// required .micromsg.HostList NewHostList = 25;
inline bool RegEquipmentResponse::has_newhostlist() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RegEquipmentResponse::set_has_newhostlist() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RegEquipmentResponse::clear_has_newhostlist() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RegEquipmentResponse::clear_newhostlist() {
  if (newhostlist_ != NULL) newhostlist_->::micromsg::HostList::Clear();
  clear_has_newhostlist();
}
inline const ::micromsg::HostList& RegEquipmentResponse::newhostlist() const {
  // @@protoc_insertion_point(field_get:micromsg.RegEquipmentResponse.NewHostList)
  return newhostlist_ != NULL ? *newhostlist_
                         : *::micromsg::HostList::internal_default_instance();
}
inline ::micromsg::HostList* RegEquipmentResponse::mutable_newhostlist() {
  set_has_newhostlist();
  if (newhostlist_ == NULL) {
    newhostlist_ = new ::micromsg::HostList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegEquipmentResponse.NewHostList)
  return newhostlist_;
}
inline ::micromsg::HostList* RegEquipmentResponse::release_newhostlist() {
  // @@protoc_insertion_point(field_release:micromsg.RegEquipmentResponse.NewHostList)
  clear_has_newhostlist();
  ::micromsg::HostList* temp = newhostlist_;
  newhostlist_ = NULL;
  return temp;
}
inline void RegEquipmentResponse::set_allocated_newhostlist(::micromsg::HostList* newhostlist) {
  delete newhostlist_;
  newhostlist_ = newhostlist;
  if (newhostlist) {
    set_has_newhostlist();
  } else {
    clear_has_newhostlist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegEquipmentResponse.NewHostList)
}

// -------------------------------------------------------------------

// ResetEquipmentRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool ResetEquipmentRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetEquipmentRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetEquipmentRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetEquipmentRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& ResetEquipmentRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetEquipmentRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* ResetEquipmentRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ResetEquipmentRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* ResetEquipmentRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.ResetEquipmentRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void ResetEquipmentRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ResetEquipmentRequest.BaseRequest)
}

// -------------------------------------------------------------------

// ResetEquipmentResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool ResetEquipmentResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetEquipmentResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetEquipmentResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetEquipmentResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& ResetEquipmentResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetEquipmentResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* ResetEquipmentResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ResetEquipmentResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* ResetEquipmentResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.ResetEquipmentResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void ResetEquipmentResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ResetEquipmentResponse.BaseResponse)
}

// -------------------------------------------------------------------

// SetPwdRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool SetPwdRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetPwdRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetPwdRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetPwdRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& SetPwdRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.SetPwdRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* SetPwdRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.SetPwdRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* SetPwdRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.SetPwdRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void SetPwdRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetPwdRequest.BaseRequest)
}

// optional string Password = 2;
inline bool SetPwdRequest::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPwdRequest::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPwdRequest::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPwdRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& SetPwdRequest::password() const {
  // @@protoc_insertion_point(field_get:micromsg.SetPwdRequest.Password)
  return password_.GetNoArena();
}
inline void SetPwdRequest::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.SetPwdRequest.Password)
}
#if LANG_CXX11
inline void SetPwdRequest::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.SetPwdRequest.Password)
}
#endif
inline void SetPwdRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.SetPwdRequest.Password)
}
inline void SetPwdRequest::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.SetPwdRequest.Password)
}
inline ::std::string* SetPwdRequest::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:micromsg.SetPwdRequest.Password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetPwdRequest::release_password() {
  // @@protoc_insertion_point(field_release:micromsg.SetPwdRequest.Password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetPwdRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetPwdRequest.Password)
}

// optional string Ticket = 3;
inline bool SetPwdRequest::has_ticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetPwdRequest::set_has_ticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetPwdRequest::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetPwdRequest::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& SetPwdRequest::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.SetPwdRequest.Ticket)
  return ticket_.GetNoArena();
}
inline void SetPwdRequest::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.SetPwdRequest.Ticket)
}
#if LANG_CXX11
inline void SetPwdRequest::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.SetPwdRequest.Ticket)
}
#endif
inline void SetPwdRequest::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.SetPwdRequest.Ticket)
}
inline void SetPwdRequest::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.SetPwdRequest.Ticket)
}
inline ::std::string* SetPwdRequest::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.SetPwdRequest.Ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetPwdRequest::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.SetPwdRequest.Ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetPwdRequest::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetPwdRequest.Ticket)
}

// optional .micromsg.SKBuiltinBuffer_t AutoAuthKey = 4;
inline bool SetPwdRequest::has_autoauthkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetPwdRequest::set_has_autoauthkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetPwdRequest::clear_has_autoauthkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetPwdRequest::clear_autoauthkey() {
  if (autoauthkey_ != NULL) autoauthkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_autoauthkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& SetPwdRequest::autoauthkey() const {
  // @@protoc_insertion_point(field_get:micromsg.SetPwdRequest.AutoAuthKey)
  return autoauthkey_ != NULL ? *autoauthkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* SetPwdRequest::mutable_autoauthkey() {
  set_has_autoauthkey();
  if (autoauthkey_ == NULL) {
    autoauthkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.SetPwdRequest.AutoAuthKey)
  return autoauthkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* SetPwdRequest::release_autoauthkey() {
  // @@protoc_insertion_point(field_release:micromsg.SetPwdRequest.AutoAuthKey)
  clear_has_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* temp = autoauthkey_;
  autoauthkey_ = NULL;
  return temp;
}
inline void SetPwdRequest::set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey) {
  delete autoauthkey_;
  autoauthkey_ = autoauthkey;
  if (autoauthkey) {
    set_has_autoauthkey();
  } else {
    clear_has_autoauthkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetPwdRequest.AutoAuthKey)
}

// -------------------------------------------------------------------

// SetPwdResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool SetPwdResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetPwdResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetPwdResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetPwdResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& SetPwdResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.SetPwdResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* SetPwdResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.SetPwdResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* SetPwdResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.SetPwdResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void SetPwdResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetPwdResponse.BaseResponse)
}

// optional .micromsg.SKBuiltinBuffer_t AutoAuthKey = 2;
inline bool SetPwdResponse::has_autoauthkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetPwdResponse::set_has_autoauthkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetPwdResponse::clear_has_autoauthkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetPwdResponse::clear_autoauthkey() {
  if (autoauthkey_ != NULL) autoauthkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_autoauthkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& SetPwdResponse::autoauthkey() const {
  // @@protoc_insertion_point(field_get:micromsg.SetPwdResponse.AutoAuthKey)
  return autoauthkey_ != NULL ? *autoauthkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* SetPwdResponse::mutable_autoauthkey() {
  set_has_autoauthkey();
  if (autoauthkey_ == NULL) {
    autoauthkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.SetPwdResponse.AutoAuthKey)
  return autoauthkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* SetPwdResponse::release_autoauthkey() {
  // @@protoc_insertion_point(field_release:micromsg.SetPwdResponse.AutoAuthKey)
  clear_has_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* temp = autoauthkey_;
  autoauthkey_ = NULL;
  return temp;
}
inline void SetPwdResponse::set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey) {
  delete autoauthkey_;
  autoauthkey_ = autoauthkey;
  if (autoauthkey) {
    set_has_autoauthkey();
  } else {
    clear_has_autoauthkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.SetPwdResponse.AutoAuthKey)
}

// -------------------------------------------------------------------

// QueryHasPswdRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool QueryHasPswdRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryHasPswdRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryHasPswdRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryHasPswdRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& QueryHasPswdRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.QueryHasPswdRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* QueryHasPswdRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.QueryHasPswdRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* QueryHasPswdRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.QueryHasPswdRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void QueryHasPswdRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.QueryHasPswdRequest.BaseRequest)
}

// required int32 Scene = 2;
inline bool QueryHasPswdRequest::has_scene() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QueryHasPswdRequest::set_has_scene() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QueryHasPswdRequest::clear_has_scene() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QueryHasPswdRequest::clear_scene() {
  scene_ = 0;
  clear_has_scene();
}
inline ::google::protobuf::int32 QueryHasPswdRequest::scene() const {
  // @@protoc_insertion_point(field_get:micromsg.QueryHasPswdRequest.Scene)
  return scene_;
}
inline void QueryHasPswdRequest::set_scene(::google::protobuf::int32 value) {
  set_has_scene();
  scene_ = value;
  // @@protoc_insertion_point(field_set:micromsg.QueryHasPswdRequest.Scene)
}

// -------------------------------------------------------------------

// QueryHasPswdResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool QueryHasPswdResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryHasPswdResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryHasPswdResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryHasPswdResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& QueryHasPswdResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.QueryHasPswdResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* QueryHasPswdResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.QueryHasPswdResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* QueryHasPswdResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.QueryHasPswdResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void QueryHasPswdResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.QueryHasPswdResponse.BaseResponse)
}

// -------------------------------------------------------------------

// VerifyPswdRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool VerifyPswdRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyPswdRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyPswdRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyPswdRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& VerifyPswdRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* VerifyPswdRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* VerifyPswdRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void VerifyPswdRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdRequest.BaseRequest)
}

// required uint32 OpCode = 2;
inline bool VerifyPswdRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VerifyPswdRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VerifyPswdRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VerifyPswdRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 VerifyPswdRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.OpCode)
  return opcode_;
}
inline void VerifyPswdRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.VerifyPswdRequest.OpCode)
}

// optional string Pwd1 = 3;
inline bool VerifyPswdRequest::has_pwd1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyPswdRequest::set_has_pwd1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyPswdRequest::clear_has_pwd1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyPswdRequest::clear_pwd1() {
  pwd1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd1();
}
inline const ::std::string& VerifyPswdRequest::pwd1() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.Pwd1)
  return pwd1_.GetNoArena();
}
inline void VerifyPswdRequest::set_pwd1(const ::std::string& value) {
  set_has_pwd1();
  pwd1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPswdRequest.Pwd1)
}
#if LANG_CXX11
inline void VerifyPswdRequest::set_pwd1(::std::string&& value) {
  set_has_pwd1();
  pwd1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPswdRequest.Pwd1)
}
#endif
inline void VerifyPswdRequest::set_pwd1(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd1();
  pwd1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPswdRequest.Pwd1)
}
inline void VerifyPswdRequest::set_pwd1(const char* value, size_t size) {
  set_has_pwd1();
  pwd1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPswdRequest.Pwd1)
}
inline ::std::string* VerifyPswdRequest::mutable_pwd1() {
  set_has_pwd1();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdRequest.Pwd1)
  return pwd1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPswdRequest::release_pwd1() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdRequest.Pwd1)
  clear_has_pwd1();
  return pwd1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPswdRequest::set_allocated_pwd1(::std::string* pwd1) {
  if (pwd1 != NULL) {
    set_has_pwd1();
  } else {
    clear_has_pwd1();
  }
  pwd1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd1);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdRequest.Pwd1)
}

// optional string Pwd2 = 4;
inline bool VerifyPswdRequest::has_pwd2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyPswdRequest::set_has_pwd2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyPswdRequest::clear_has_pwd2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyPswdRequest::clear_pwd2() {
  pwd2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd2();
}
inline const ::std::string& VerifyPswdRequest::pwd2() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.Pwd2)
  return pwd2_.GetNoArena();
}
inline void VerifyPswdRequest::set_pwd2(const ::std::string& value) {
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPswdRequest.Pwd2)
}
#if LANG_CXX11
inline void VerifyPswdRequest::set_pwd2(::std::string&& value) {
  set_has_pwd2();
  pwd2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPswdRequest.Pwd2)
}
#endif
inline void VerifyPswdRequest::set_pwd2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPswdRequest.Pwd2)
}
inline void VerifyPswdRequest::set_pwd2(const char* value, size_t size) {
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPswdRequest.Pwd2)
}
inline ::std::string* VerifyPswdRequest::mutable_pwd2() {
  set_has_pwd2();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdRequest.Pwd2)
  return pwd2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPswdRequest::release_pwd2() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdRequest.Pwd2)
  clear_has_pwd2();
  return pwd2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPswdRequest::set_allocated_pwd2(::std::string* pwd2) {
  if (pwd2 != NULL) {
    set_has_pwd2();
  } else {
    clear_has_pwd2();
  }
  pwd2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd2);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdRequest.Pwd2)
}

// optional .micromsg.SKBuiltinString_t ImgSid = 5;
inline bool VerifyPswdRequest::has_imgsid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyPswdRequest::set_has_imgsid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VerifyPswdRequest::clear_has_imgsid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VerifyPswdRequest::clear_imgsid() {
  if (imgsid_ != NULL) imgsid_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgsid();
}
inline const ::micromsg::SKBuiltinString_t& VerifyPswdRequest::imgsid() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.ImgSid)
  return imgsid_ != NULL ? *imgsid_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdRequest::mutable_imgsid() {
  set_has_imgsid();
  if (imgsid_ == NULL) {
    imgsid_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdRequest.ImgSid)
  return imgsid_;
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdRequest::release_imgsid() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdRequest.ImgSid)
  clear_has_imgsid();
  ::micromsg::SKBuiltinString_t* temp = imgsid_;
  imgsid_ = NULL;
  return temp;
}
inline void VerifyPswdRequest::set_allocated_imgsid(::micromsg::SKBuiltinString_t* imgsid) {
  delete imgsid_;
  imgsid_ = imgsid;
  if (imgsid) {
    set_has_imgsid();
  } else {
    clear_has_imgsid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdRequest.ImgSid)
}

// optional .micromsg.SKBuiltinString_t ImgCode = 6;
inline bool VerifyPswdRequest::has_imgcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VerifyPswdRequest::set_has_imgcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VerifyPswdRequest::clear_has_imgcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VerifyPswdRequest::clear_imgcode() {
  if (imgcode_ != NULL) imgcode_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgcode();
}
inline const ::micromsg::SKBuiltinString_t& VerifyPswdRequest::imgcode() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.ImgCode)
  return imgcode_ != NULL ? *imgcode_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdRequest::mutable_imgcode() {
  set_has_imgcode();
  if (imgcode_ == NULL) {
    imgcode_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdRequest.ImgCode)
  return imgcode_;
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdRequest::release_imgcode() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdRequest.ImgCode)
  clear_has_imgcode();
  ::micromsg::SKBuiltinString_t* temp = imgcode_;
  imgcode_ = NULL;
  return temp;
}
inline void VerifyPswdRequest::set_allocated_imgcode(::micromsg::SKBuiltinString_t* imgcode) {
  delete imgcode_;
  imgcode_ = imgcode;
  if (imgcode) {
    set_has_imgcode();
  } else {
    clear_has_imgcode();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdRequest.ImgCode)
}

// optional .micromsg.SKBuiltinString_t ImgEncryptKey = 7;
inline bool VerifyPswdRequest::has_imgencryptkey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VerifyPswdRequest::set_has_imgencryptkey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VerifyPswdRequest::clear_has_imgencryptkey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VerifyPswdRequest::clear_imgencryptkey() {
  if (imgencryptkey_ != NULL) imgencryptkey_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgencryptkey();
}
inline const ::micromsg::SKBuiltinString_t& VerifyPswdRequest::imgencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.ImgEncryptKey)
  return imgencryptkey_ != NULL ? *imgencryptkey_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdRequest::mutable_imgencryptkey() {
  set_has_imgencryptkey();
  if (imgencryptkey_ == NULL) {
    imgencryptkey_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdRequest.ImgEncryptKey)
  return imgencryptkey_;
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdRequest::release_imgencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdRequest.ImgEncryptKey)
  clear_has_imgencryptkey();
  ::micromsg::SKBuiltinString_t* temp = imgencryptkey_;
  imgencryptkey_ = NULL;
  return temp;
}
inline void VerifyPswdRequest::set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey) {
  delete imgencryptkey_;
  imgencryptkey_ = imgencryptkey;
  if (imgencryptkey) {
    set_has_imgencryptkey();
  } else {
    clear_has_imgencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdRequest.ImgEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t KSid = 8;
inline bool VerifyPswdRequest::has_ksid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VerifyPswdRequest::set_has_ksid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VerifyPswdRequest::clear_has_ksid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VerifyPswdRequest::clear_ksid() {
  if (ksid_ != NULL) ksid_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_ksid();
}
inline const ::micromsg::SKBuiltinBuffer_t& VerifyPswdRequest::ksid() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.KSid)
  return ksid_ != NULL ? *ksid_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdRequest::mutable_ksid() {
  set_has_ksid();
  if (ksid_ == NULL) {
    ksid_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdRequest.KSid)
  return ksid_;
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdRequest::release_ksid() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdRequest.KSid)
  clear_has_ksid();
  ::micromsg::SKBuiltinBuffer_t* temp = ksid_;
  ksid_ = NULL;
  return temp;
}
inline void VerifyPswdRequest::set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid) {
  delete ksid_;
  ksid_ = ksid;
  if (ksid) {
    set_has_ksid();
  } else {
    clear_has_ksid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdRequest.KSid)
}

// optional uint32 Scence = 9;
inline bool VerifyPswdRequest::has_scence() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VerifyPswdRequest::set_has_scence() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VerifyPswdRequest::clear_has_scence() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VerifyPswdRequest::clear_scence() {
  scence_ = 0u;
  clear_has_scence();
}
inline ::google::protobuf::uint32 VerifyPswdRequest::scence() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.Scence)
  return scence_;
}
inline void VerifyPswdRequest::set_scence(::google::protobuf::uint32 value) {
  set_has_scence();
  scence_ = value;
  // @@protoc_insertion_point(field_set:micromsg.VerifyPswdRequest.Scence)
}

// optional .micromsg.SKBuiltinBuffer_t WTLoginReqBuff = 10;
inline bool VerifyPswdRequest::has_wtloginreqbuff() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VerifyPswdRequest::set_has_wtloginreqbuff() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VerifyPswdRequest::clear_has_wtloginreqbuff() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VerifyPswdRequest::clear_wtloginreqbuff() {
  if (wtloginreqbuff_ != NULL) wtloginreqbuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_wtloginreqbuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& VerifyPswdRequest::wtloginreqbuff() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdRequest.WTLoginReqBuff)
  return wtloginreqbuff_ != NULL ? *wtloginreqbuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdRequest::mutable_wtloginreqbuff() {
  set_has_wtloginreqbuff();
  if (wtloginreqbuff_ == NULL) {
    wtloginreqbuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdRequest.WTLoginReqBuff)
  return wtloginreqbuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdRequest::release_wtloginreqbuff() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdRequest.WTLoginReqBuff)
  clear_has_wtloginreqbuff();
  ::micromsg::SKBuiltinBuffer_t* temp = wtloginreqbuff_;
  wtloginreqbuff_ = NULL;
  return temp;
}
inline void VerifyPswdRequest::set_allocated_wtloginreqbuff(::micromsg::SKBuiltinBuffer_t* wtloginreqbuff) {
  delete wtloginreqbuff_;
  wtloginreqbuff_ = wtloginreqbuff;
  if (wtloginreqbuff) {
    set_has_wtloginreqbuff();
  } else {
    clear_has_wtloginreqbuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdRequest.WTLoginReqBuff)
}

// -------------------------------------------------------------------

// VerifyPswdResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool VerifyPswdResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyPswdResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyPswdResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyPswdResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& VerifyPswdResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* VerifyPswdResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* VerifyPswdResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void VerifyPswdResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdResponse.BaseResponse)
}

// required .micromsg.SKBuiltinString_t ImgSid = 2;
inline bool VerifyPswdResponse::has_imgsid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VerifyPswdResponse::set_has_imgsid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VerifyPswdResponse::clear_has_imgsid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VerifyPswdResponse::clear_imgsid() {
  if (imgsid_ != NULL) imgsid_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgsid();
}
inline const ::micromsg::SKBuiltinString_t& VerifyPswdResponse::imgsid() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdResponse.ImgSid)
  return imgsid_ != NULL ? *imgsid_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdResponse::mutable_imgsid() {
  set_has_imgsid();
  if (imgsid_ == NULL) {
    imgsid_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdResponse.ImgSid)
  return imgsid_;
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdResponse::release_imgsid() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdResponse.ImgSid)
  clear_has_imgsid();
  ::micromsg::SKBuiltinString_t* temp = imgsid_;
  imgsid_ = NULL;
  return temp;
}
inline void VerifyPswdResponse::set_allocated_imgsid(::micromsg::SKBuiltinString_t* imgsid) {
  delete imgsid_;
  imgsid_ = imgsid;
  if (imgsid) {
    set_has_imgsid();
  } else {
    clear_has_imgsid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdResponse.ImgSid)
}

// required .micromsg.SKBuiltinBuffer_t ImgBuf = 3;
inline bool VerifyPswdResponse::has_imgbuf() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VerifyPswdResponse::set_has_imgbuf() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VerifyPswdResponse::clear_has_imgbuf() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VerifyPswdResponse::clear_imgbuf() {
  if (imgbuf_ != NULL) imgbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_imgbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& VerifyPswdResponse::imgbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdResponse.ImgBuf)
  return imgbuf_ != NULL ? *imgbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdResponse::mutable_imgbuf() {
  set_has_imgbuf();
  if (imgbuf_ == NULL) {
    imgbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdResponse.ImgBuf)
  return imgbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdResponse::release_imgbuf() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdResponse.ImgBuf)
  clear_has_imgbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = imgbuf_;
  imgbuf_ = NULL;
  return temp;
}
inline void VerifyPswdResponse::set_allocated_imgbuf(::micromsg::SKBuiltinBuffer_t* imgbuf) {
  delete imgbuf_;
  imgbuf_ = imgbuf;
  if (imgbuf) {
    set_has_imgbuf();
  } else {
    clear_has_imgbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdResponse.ImgBuf)
}

// optional string Ticket = 4;
inline bool VerifyPswdResponse::has_ticket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyPswdResponse::set_has_ticket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyPswdResponse::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyPswdResponse::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& VerifyPswdResponse::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdResponse.Ticket)
  return ticket_.GetNoArena();
}
inline void VerifyPswdResponse::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPswdResponse.Ticket)
}
#if LANG_CXX11
inline void VerifyPswdResponse::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPswdResponse.Ticket)
}
#endif
inline void VerifyPswdResponse::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPswdResponse.Ticket)
}
inline void VerifyPswdResponse::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPswdResponse.Ticket)
}
inline ::std::string* VerifyPswdResponse::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdResponse.Ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPswdResponse::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdResponse.Ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPswdResponse::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdResponse.Ticket)
}

// optional .micromsg.SKBuiltinString_t ImgEncryptKey = 5;
inline bool VerifyPswdResponse::has_imgencryptkey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VerifyPswdResponse::set_has_imgencryptkey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VerifyPswdResponse::clear_has_imgencryptkey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VerifyPswdResponse::clear_imgencryptkey() {
  if (imgencryptkey_ != NULL) imgencryptkey_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgencryptkey();
}
inline const ::micromsg::SKBuiltinString_t& VerifyPswdResponse::imgencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdResponse.ImgEncryptKey)
  return imgencryptkey_ != NULL ? *imgencryptkey_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdResponse::mutable_imgencryptkey() {
  set_has_imgencryptkey();
  if (imgencryptkey_ == NULL) {
    imgencryptkey_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdResponse.ImgEncryptKey)
  return imgencryptkey_;
}
inline ::micromsg::SKBuiltinString_t* VerifyPswdResponse::release_imgencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdResponse.ImgEncryptKey)
  clear_has_imgencryptkey();
  ::micromsg::SKBuiltinString_t* temp = imgencryptkey_;
  imgencryptkey_ = NULL;
  return temp;
}
inline void VerifyPswdResponse::set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey) {
  delete imgencryptkey_;
  imgencryptkey_ = imgencryptkey;
  if (imgencryptkey) {
    set_has_imgencryptkey();
  } else {
    clear_has_imgencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdResponse.ImgEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t A2Key = 6;
inline bool VerifyPswdResponse::has_a2key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VerifyPswdResponse::set_has_a2key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VerifyPswdResponse::clear_has_a2key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VerifyPswdResponse::clear_a2key() {
  if (a2key_ != NULL) a2key_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_a2key();
}
inline const ::micromsg::SKBuiltinBuffer_t& VerifyPswdResponse::a2key() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdResponse.A2Key)
  return a2key_ != NULL ? *a2key_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdResponse::mutable_a2key() {
  set_has_a2key();
  if (a2key_ == NULL) {
    a2key_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdResponse.A2Key)
  return a2key_;
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdResponse::release_a2key() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdResponse.A2Key)
  clear_has_a2key();
  ::micromsg::SKBuiltinBuffer_t* temp = a2key_;
  a2key_ = NULL;
  return temp;
}
inline void VerifyPswdResponse::set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key) {
  delete a2key_;
  a2key_ = a2key;
  if (a2key) {
    set_has_a2key();
  } else {
    clear_has_a2key();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdResponse.A2Key)
}

// optional .micromsg.SKBuiltinBuffer_t KSid = 7;
inline bool VerifyPswdResponse::has_ksid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VerifyPswdResponse::set_has_ksid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VerifyPswdResponse::clear_has_ksid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VerifyPswdResponse::clear_ksid() {
  if (ksid_ != NULL) ksid_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_ksid();
}
inline const ::micromsg::SKBuiltinBuffer_t& VerifyPswdResponse::ksid() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdResponse.KSid)
  return ksid_ != NULL ? *ksid_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdResponse::mutable_ksid() {
  set_has_ksid();
  if (ksid_ == NULL) {
    ksid_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdResponse.KSid)
  return ksid_;
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdResponse::release_ksid() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdResponse.KSid)
  clear_has_ksid();
  ::micromsg::SKBuiltinBuffer_t* temp = ksid_;
  ksid_ = NULL;
  return temp;
}
inline void VerifyPswdResponse::set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid) {
  delete ksid_;
  ksid_ = ksid;
  if (ksid) {
    set_has_ksid();
  } else {
    clear_has_ksid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdResponse.KSid)
}

// optional string AuthKey = 8;
inline bool VerifyPswdResponse::has_authkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyPswdResponse::set_has_authkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyPswdResponse::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyPswdResponse::clear_authkey() {
  authkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authkey();
}
inline const ::std::string& VerifyPswdResponse::authkey() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdResponse.AuthKey)
  return authkey_.GetNoArena();
}
inline void VerifyPswdResponse::set_authkey(const ::std::string& value) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.VerifyPswdResponse.AuthKey)
}
#if LANG_CXX11
inline void VerifyPswdResponse::set_authkey(::std::string&& value) {
  set_has_authkey();
  authkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.VerifyPswdResponse.AuthKey)
}
#endif
inline void VerifyPswdResponse::set_authkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.VerifyPswdResponse.AuthKey)
}
inline void VerifyPswdResponse::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.VerifyPswdResponse.AuthKey)
}
inline ::std::string* VerifyPswdResponse::mutable_authkey() {
  set_has_authkey();
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdResponse.AuthKey)
  return authkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VerifyPswdResponse::release_authkey() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdResponse.AuthKey)
  clear_has_authkey();
  return authkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VerifyPswdResponse::set_allocated_authkey(::std::string* authkey) {
  if (authkey != NULL) {
    set_has_authkey();
  } else {
    clear_has_authkey();
  }
  authkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdResponse.AuthKey)
}

// optional .micromsg.SKBuiltinBuffer_t WTLoginRspBuff = 9;
inline bool VerifyPswdResponse::has_wtloginrspbuff() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VerifyPswdResponse::set_has_wtloginrspbuff() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VerifyPswdResponse::clear_has_wtloginrspbuff() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VerifyPswdResponse::clear_wtloginrspbuff() {
  if (wtloginrspbuff_ != NULL) wtloginrspbuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_wtloginrspbuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& VerifyPswdResponse::wtloginrspbuff() const {
  // @@protoc_insertion_point(field_get:micromsg.VerifyPswdResponse.WTLoginRspBuff)
  return wtloginrspbuff_ != NULL ? *wtloginrspbuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdResponse::mutable_wtloginrspbuff() {
  set_has_wtloginrspbuff();
  if (wtloginrspbuff_ == NULL) {
    wtloginrspbuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.VerifyPswdResponse.WTLoginRspBuff)
  return wtloginrspbuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* VerifyPswdResponse::release_wtloginrspbuff() {
  // @@protoc_insertion_point(field_release:micromsg.VerifyPswdResponse.WTLoginRspBuff)
  clear_has_wtloginrspbuff();
  ::micromsg::SKBuiltinBuffer_t* temp = wtloginrspbuff_;
  wtloginrspbuff_ = NULL;
  return temp;
}
inline void VerifyPswdResponse::set_allocated_wtloginrspbuff(::micromsg::SKBuiltinBuffer_t* wtloginrspbuff) {
  delete wtloginrspbuff_;
  wtloginrspbuff_ = wtloginrspbuff;
  if (wtloginrspbuff) {
    set_has_wtloginrspbuff();
  } else {
    clear_has_wtloginrspbuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.VerifyPswdResponse.WTLoginRspBuff)
}

// -------------------------------------------------------------------

// ResetPawInfo

// required uint32 CreateTime = 1;
inline bool ResetPawInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetPawInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetPawInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetPawInfo::clear_createtime() {
  createtime_ = 0u;
  clear_has_createtime();
}
inline ::google::protobuf::uint32 ResetPawInfo::createtime() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetPawInfo.CreateTime)
  return createtime_;
}
inline void ResetPawInfo::set_createtime(::google::protobuf::uint32 value) {
  set_has_createtime();
  createtime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ResetPawInfo.CreateTime)
}

// required uint32 IsReset = 2;
inline bool ResetPawInfo::has_isreset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetPawInfo::set_has_isreset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetPawInfo::clear_has_isreset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetPawInfo::clear_isreset() {
  isreset_ = 0u;
  clear_has_isreset();
}
inline ::google::protobuf::uint32 ResetPawInfo::isreset() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetPawInfo.IsReset)
  return isreset_;
}
inline void ResetPawInfo::set_isreset(::google::protobuf::uint32 value) {
  set_has_isreset();
  isreset_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ResetPawInfo.IsReset)
}

// required uint32 ID = 3;
inline bool ResetPawInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResetPawInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResetPawInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResetPawInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ResetPawInfo::id() const {
  // @@protoc_insertion_point(field_get:micromsg.ResetPawInfo.ID)
  return id_;
}
inline void ResetPawInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ResetPawInfo.ID)
}

// -------------------------------------------------------------------

// ApplyResetPawRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool ApplyResetPawRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyResetPawRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyResetPawRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyResetPawRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& ApplyResetPawRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.ApplyResetPawRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* ApplyResetPawRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ApplyResetPawRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* ApplyResetPawRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.ApplyResetPawRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void ApplyResetPawRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ApplyResetPawRequest.BaseRequest)
}

// required int32 Type = 2;
inline bool ApplyResetPawRequest::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyResetPawRequest::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyResetPawRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyResetPawRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ApplyResetPawRequest::type() const {
  // @@protoc_insertion_point(field_get:micromsg.ApplyResetPawRequest.Type)
  return type_;
}
inline void ApplyResetPawRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ApplyResetPawRequest.Type)
}

// optional string ResetInfo = 3;
inline bool ApplyResetPawRequest::has_resetinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyResetPawRequest::set_has_resetinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyResetPawRequest::clear_has_resetinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyResetPawRequest::clear_resetinfo() {
  resetinfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_resetinfo();
}
inline const ::std::string& ApplyResetPawRequest::resetinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.ApplyResetPawRequest.ResetInfo)
  return resetinfo_.GetNoArena();
}
inline void ApplyResetPawRequest::set_resetinfo(const ::std::string& value) {
  set_has_resetinfo();
  resetinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ApplyResetPawRequest.ResetInfo)
}
#if LANG_CXX11
inline void ApplyResetPawRequest::set_resetinfo(::std::string&& value) {
  set_has_resetinfo();
  resetinfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ApplyResetPawRequest.ResetInfo)
}
#endif
inline void ApplyResetPawRequest::set_resetinfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_resetinfo();
  resetinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ApplyResetPawRequest.ResetInfo)
}
inline void ApplyResetPawRequest::set_resetinfo(const char* value, size_t size) {
  set_has_resetinfo();
  resetinfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ApplyResetPawRequest.ResetInfo)
}
inline ::std::string* ApplyResetPawRequest::mutable_resetinfo() {
  set_has_resetinfo();
  // @@protoc_insertion_point(field_mutable:micromsg.ApplyResetPawRequest.ResetInfo)
  return resetinfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyResetPawRequest::release_resetinfo() {
  // @@protoc_insertion_point(field_release:micromsg.ApplyResetPawRequest.ResetInfo)
  clear_has_resetinfo();
  return resetinfo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyResetPawRequest::set_allocated_resetinfo(::std::string* resetinfo) {
  if (resetinfo != NULL) {
    set_has_resetinfo();
  } else {
    clear_has_resetinfo();
  }
  resetinfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resetinfo);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ApplyResetPawRequest.ResetInfo)
}

// optional uint32 GetMethod = 4;
inline bool ApplyResetPawRequest::has_getmethod() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyResetPawRequest::set_has_getmethod() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyResetPawRequest::clear_has_getmethod() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyResetPawRequest::clear_getmethod() {
  getmethod_ = 0u;
  clear_has_getmethod();
}
inline ::google::protobuf::uint32 ApplyResetPawRequest::getmethod() const {
  // @@protoc_insertion_point(field_get:micromsg.ApplyResetPawRequest.GetMethod)
  return getmethod_;
}
inline void ApplyResetPawRequest::set_getmethod(::google::protobuf::uint32 value) {
  set_has_getmethod();
  getmethod_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ApplyResetPawRequest.GetMethod)
}

// optional .micromsg.SKBuiltinBuffer_t RandomEncryKey = 5;
inline bool ApplyResetPawRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyResetPawRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyResetPawRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyResetPawRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& ApplyResetPawRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.ApplyResetPawRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* ApplyResetPawRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ApplyResetPawRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* ApplyResetPawRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.ApplyResetPawRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void ApplyResetPawRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ApplyResetPawRequest.RandomEncryKey)
}

// -------------------------------------------------------------------

// ApplyResetPawResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool ApplyResetPawResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyResetPawResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyResetPawResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyResetPawResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& ApplyResetPawResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.ApplyResetPawResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* ApplyResetPawResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ApplyResetPawResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* ApplyResetPawResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.ApplyResetPawResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void ApplyResetPawResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ApplyResetPawResponse.BaseResponse)
}

// -------------------------------------------------------------------

// GetWeiBoURLReq

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetWeiBoURLReq::has_baserequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetWeiBoURLReq::set_has_baserequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetWeiBoURLReq::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetWeiBoURLReq::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetWeiBoURLReq::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetWeiBoURLReq.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetWeiBoURLReq::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetWeiBoURLReq.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetWeiBoURLReq::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetWeiBoURLReq.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetWeiBoURLReq::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetWeiBoURLReq.BaseRequest)
}

// required .micromsg.SKBuiltinBuffer_t A2Key = 2;
inline bool GetWeiBoURLReq::has_a2key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetWeiBoURLReq::set_has_a2key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetWeiBoURLReq::clear_has_a2key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetWeiBoURLReq::clear_a2key() {
  if (a2key_ != NULL) a2key_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_a2key();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetWeiBoURLReq::a2key() const {
  // @@protoc_insertion_point(field_get:micromsg.GetWeiBoURLReq.A2Key)
  return a2key_ != NULL ? *a2key_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetWeiBoURLReq::mutable_a2key() {
  set_has_a2key();
  if (a2key_ == NULL) {
    a2key_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetWeiBoURLReq.A2Key)
  return a2key_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetWeiBoURLReq::release_a2key() {
  // @@protoc_insertion_point(field_release:micromsg.GetWeiBoURLReq.A2Key)
  clear_has_a2key();
  ::micromsg::SKBuiltinBuffer_t* temp = a2key_;
  a2key_ = NULL;
  return temp;
}
inline void GetWeiBoURLReq::set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key) {
  delete a2key_;
  a2key_ = a2key;
  if (a2key) {
    set_has_a2key();
  } else {
    clear_has_a2key();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetWeiBoURLReq.A2Key)
}

// optional string UserName = 3;
inline bool GetWeiBoURLReq::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetWeiBoURLReq::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetWeiBoURLReq::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetWeiBoURLReq::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& GetWeiBoURLReq::username() const {
  // @@protoc_insertion_point(field_get:micromsg.GetWeiBoURLReq.UserName)
  return username_.GetNoArena();
}
inline void GetWeiBoURLReq::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetWeiBoURLReq.UserName)
}
#if LANG_CXX11
inline void GetWeiBoURLReq::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetWeiBoURLReq.UserName)
}
#endif
inline void GetWeiBoURLReq::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetWeiBoURLReq.UserName)
}
inline void GetWeiBoURLReq::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetWeiBoURLReq.UserName)
}
inline ::std::string* GetWeiBoURLReq::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.GetWeiBoURLReq.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetWeiBoURLReq::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.GetWeiBoURLReq.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetWeiBoURLReq::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetWeiBoURLReq.UserName)
}

// optional uint32 Scene = 4;
inline bool GetWeiBoURLReq::has_scene() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetWeiBoURLReq::set_has_scene() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetWeiBoURLReq::clear_has_scene() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetWeiBoURLReq::clear_scene() {
  scene_ = 0u;
  clear_has_scene();
}
inline ::google::protobuf::uint32 GetWeiBoURLReq::scene() const {
  // @@protoc_insertion_point(field_get:micromsg.GetWeiBoURLReq.Scene)
  return scene_;
}
inline void GetWeiBoURLReq::set_scene(::google::protobuf::uint32 value) {
  set_has_scene();
  scene_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetWeiBoURLReq.Scene)
}

// optional string BlogUserName = 5;
inline bool GetWeiBoURLReq::has_blogusername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetWeiBoURLReq::set_has_blogusername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetWeiBoURLReq::clear_has_blogusername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetWeiBoURLReq::clear_blogusername() {
  blogusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_blogusername();
}
inline const ::std::string& GetWeiBoURLReq::blogusername() const {
  // @@protoc_insertion_point(field_get:micromsg.GetWeiBoURLReq.BlogUserName)
  return blogusername_.GetNoArena();
}
inline void GetWeiBoURLReq::set_blogusername(const ::std::string& value) {
  set_has_blogusername();
  blogusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetWeiBoURLReq.BlogUserName)
}
#if LANG_CXX11
inline void GetWeiBoURLReq::set_blogusername(::std::string&& value) {
  set_has_blogusername();
  blogusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetWeiBoURLReq.BlogUserName)
}
#endif
inline void GetWeiBoURLReq::set_blogusername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_blogusername();
  blogusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetWeiBoURLReq.BlogUserName)
}
inline void GetWeiBoURLReq::set_blogusername(const char* value, size_t size) {
  set_has_blogusername();
  blogusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetWeiBoURLReq.BlogUserName)
}
inline ::std::string* GetWeiBoURLReq::mutable_blogusername() {
  set_has_blogusername();
  // @@protoc_insertion_point(field_mutable:micromsg.GetWeiBoURLReq.BlogUserName)
  return blogusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetWeiBoURLReq::release_blogusername() {
  // @@protoc_insertion_point(field_release:micromsg.GetWeiBoURLReq.BlogUserName)
  clear_has_blogusername();
  return blogusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetWeiBoURLReq::set_allocated_blogusername(::std::string* blogusername) {
  if (blogusername != NULL) {
    set_has_blogusername();
  } else {
    clear_has_blogusername();
  }
  blogusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), blogusername);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetWeiBoURLReq.BlogUserName)
}

// optional .micromsg.SKBuiltinBuffer_t A2KeyNew = 6;
inline bool GetWeiBoURLReq::has_a2keynew() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetWeiBoURLReq::set_has_a2keynew() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetWeiBoURLReq::clear_has_a2keynew() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetWeiBoURLReq::clear_a2keynew() {
  if (a2keynew_ != NULL) a2keynew_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_a2keynew();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetWeiBoURLReq::a2keynew() const {
  // @@protoc_insertion_point(field_get:micromsg.GetWeiBoURLReq.A2KeyNew)
  return a2keynew_ != NULL ? *a2keynew_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetWeiBoURLReq::mutable_a2keynew() {
  set_has_a2keynew();
  if (a2keynew_ == NULL) {
    a2keynew_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetWeiBoURLReq.A2KeyNew)
  return a2keynew_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetWeiBoURLReq::release_a2keynew() {
  // @@protoc_insertion_point(field_release:micromsg.GetWeiBoURLReq.A2KeyNew)
  clear_has_a2keynew();
  ::micromsg::SKBuiltinBuffer_t* temp = a2keynew_;
  a2keynew_ = NULL;
  return temp;
}
inline void GetWeiBoURLReq::set_allocated_a2keynew(::micromsg::SKBuiltinBuffer_t* a2keynew) {
  delete a2keynew_;
  a2keynew_ = a2keynew;
  if (a2keynew) {
    set_has_a2keynew();
  } else {
    clear_has_a2keynew();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetWeiBoURLReq.A2KeyNew)
}

// -------------------------------------------------------------------

// GetWeiBoURLResp

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetWeiBoURLResp::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetWeiBoURLResp::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetWeiBoURLResp::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetWeiBoURLResp::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetWeiBoURLResp::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetWeiBoURLResp.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetWeiBoURLResp::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetWeiBoURLResp.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetWeiBoURLResp::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetWeiBoURLResp.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetWeiBoURLResp::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetWeiBoURLResp.BaseResponse)
}

// optional string URL = 2;
inline bool GetWeiBoURLResp::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetWeiBoURLResp::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetWeiBoURLResp::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetWeiBoURLResp::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& GetWeiBoURLResp::url() const {
  // @@protoc_insertion_point(field_get:micromsg.GetWeiBoURLResp.URL)
  return url_.GetNoArena();
}
inline void GetWeiBoURLResp::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetWeiBoURLResp.URL)
}
#if LANG_CXX11
inline void GetWeiBoURLResp::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetWeiBoURLResp.URL)
}
#endif
inline void GetWeiBoURLResp::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetWeiBoURLResp.URL)
}
inline void GetWeiBoURLResp::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetWeiBoURLResp.URL)
}
inline ::std::string* GetWeiBoURLResp::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:micromsg.GetWeiBoURLResp.URL)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetWeiBoURLResp::release_url() {
  // @@protoc_insertion_point(field_release:micromsg.GetWeiBoURLResp.URL)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetWeiBoURLResp::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetWeiBoURLResp.URL)
}

// -------------------------------------------------------------------

// GetUserNameRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetUserNameRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetUserNameRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetUserNameRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetUserNameRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetUserNameRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetUserNameRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetUserNameRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetUserNameRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetUserNameRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetUserNameRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetUserNameRequest.BaseRequest)
}

// required uint32 BindUin = 2;
inline bool GetUserNameRequest::has_binduin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetUserNameRequest::set_has_binduin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetUserNameRequest::clear_has_binduin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetUserNameRequest::clear_binduin() {
  binduin_ = 0u;
  clear_has_binduin();
}
inline ::google::protobuf::uint32 GetUserNameRequest::binduin() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameRequest.BindUin)
  return binduin_;
}
inline void GetUserNameRequest::set_binduin(::google::protobuf::uint32 value) {
  set_has_binduin();
  binduin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetUserNameRequest.BindUin)
}

// optional string NickName = 3;
inline bool GetUserNameRequest::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserNameRequest::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserNameRequest::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserNameRequest::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& GetUserNameRequest::nickname() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameRequest.NickName)
  return nickname_.GetNoArena();
}
inline void GetUserNameRequest::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetUserNameRequest.NickName)
}
#if LANG_CXX11
inline void GetUserNameRequest::set_nickname(::std::string&& value) {
  set_has_nickname();
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetUserNameRequest.NickName)
}
#endif
inline void GetUserNameRequest::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetUserNameRequest.NickName)
}
inline void GetUserNameRequest::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetUserNameRequest.NickName)
}
inline ::std::string* GetUserNameRequest::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:micromsg.GetUserNameRequest.NickName)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetUserNameRequest::release_nickname() {
  // @@protoc_insertion_point(field_release:micromsg.GetUserNameRequest.NickName)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserNameRequest::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetUserNameRequest.NickName)
}

// optional string Ticket = 4;
inline bool GetUserNameRequest::has_ticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserNameRequest::set_has_ticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserNameRequest::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserNameRequest::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& GetUserNameRequest::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameRequest.Ticket)
  return ticket_.GetNoArena();
}
inline void GetUserNameRequest::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetUserNameRequest.Ticket)
}
#if LANG_CXX11
inline void GetUserNameRequest::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetUserNameRequest.Ticket)
}
#endif
inline void GetUserNameRequest::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetUserNameRequest.Ticket)
}
inline void GetUserNameRequest::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetUserNameRequest.Ticket)
}
inline ::std::string* GetUserNameRequest::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.GetUserNameRequest.Ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetUserNameRequest::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.GetUserNameRequest.Ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserNameRequest::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetUserNameRequest.Ticket)
}

// optional string Pwd = 5;
inline bool GetUserNameRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserNameRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserNameRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserNameRequest::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd();
}
inline const ::std::string& GetUserNameRequest::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameRequest.Pwd)
  return pwd_.GetNoArena();
}
inline void GetUserNameRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetUserNameRequest.Pwd)
}
#if LANG_CXX11
inline void GetUserNameRequest::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetUserNameRequest.Pwd)
}
#endif
inline void GetUserNameRequest::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetUserNameRequest.Pwd)
}
inline void GetUserNameRequest::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetUserNameRequest.Pwd)
}
inline ::std::string* GetUserNameRequest::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:micromsg.GetUserNameRequest.Pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetUserNameRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.GetUserNameRequest.Pwd)
  clear_has_pwd();
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserNameRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetUserNameRequest.Pwd)
}

// optional string Mobile = 6;
inline bool GetUserNameRequest::has_mobile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUserNameRequest::set_has_mobile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetUserNameRequest::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetUserNameRequest::clear_mobile() {
  mobile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mobile();
}
inline const ::std::string& GetUserNameRequest::mobile() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameRequest.Mobile)
  return mobile_.GetNoArena();
}
inline void GetUserNameRequest::set_mobile(const ::std::string& value) {
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetUserNameRequest.Mobile)
}
#if LANG_CXX11
inline void GetUserNameRequest::set_mobile(::std::string&& value) {
  set_has_mobile();
  mobile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetUserNameRequest.Mobile)
}
#endif
inline void GetUserNameRequest::set_mobile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetUserNameRequest.Mobile)
}
inline void GetUserNameRequest::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  mobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetUserNameRequest.Mobile)
}
inline ::std::string* GetUserNameRequest::mutable_mobile() {
  set_has_mobile();
  // @@protoc_insertion_point(field_mutable:micromsg.GetUserNameRequest.Mobile)
  return mobile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetUserNameRequest::release_mobile() {
  // @@protoc_insertion_point(field_release:micromsg.GetUserNameRequest.Mobile)
  clear_has_mobile();
  return mobile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserNameRequest::set_allocated_mobile(::std::string* mobile) {
  if (mobile != NULL) {
    set_has_mobile();
  } else {
    clear_has_mobile();
  }
  mobile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mobile);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetUserNameRequest.Mobile)
}

// optional uint32 OpCode = 7;
inline bool GetUserNameRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetUserNameRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetUserNameRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetUserNameRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 GetUserNameRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameRequest.OpCode)
  return opcode_;
}
inline void GetUserNameRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetUserNameRequest.OpCode)
}

// -------------------------------------------------------------------

// GetUserNameResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetUserNameResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserNameResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUserNameResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUserNameResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetUserNameResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetUserNameResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetUserNameResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetUserNameResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetUserNameResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetUserNameResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetUserNameResponse.BaseResponse)
}

// optional string UserName = 2;
inline bool GetUserNameResponse::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserNameResponse::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUserNameResponse::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUserNameResponse::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& GetUserNameResponse::username() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameResponse.UserName)
  return username_.GetNoArena();
}
inline void GetUserNameResponse::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetUserNameResponse.UserName)
}
#if LANG_CXX11
inline void GetUserNameResponse::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetUserNameResponse.UserName)
}
#endif
inline void GetUserNameResponse::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetUserNameResponse.UserName)
}
inline void GetUserNameResponse::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetUserNameResponse.UserName)
}
inline ::std::string* GetUserNameResponse::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.GetUserNameResponse.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetUserNameResponse::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.GetUserNameResponse.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserNameResponse::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetUserNameResponse.UserName)
}

// optional string Ticket = 3;
inline bool GetUserNameResponse::has_ticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserNameResponse::set_has_ticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUserNameResponse::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUserNameResponse::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& GetUserNameResponse::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.GetUserNameResponse.Ticket)
  return ticket_.GetNoArena();
}
inline void GetUserNameResponse::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetUserNameResponse.Ticket)
}
#if LANG_CXX11
inline void GetUserNameResponse::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetUserNameResponse.Ticket)
}
#endif
inline void GetUserNameResponse::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetUserNameResponse.Ticket)
}
inline void GetUserNameResponse::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetUserNameResponse.Ticket)
}
inline ::std::string* GetUserNameResponse::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.GetUserNameResponse.Ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetUserNameResponse::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.GetUserNameResponse.Ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserNameResponse::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetUserNameResponse.Ticket)
}

// -------------------------------------------------------------------

// IphoneRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool IphoneRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IphoneRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IphoneRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IphoneRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& IphoneRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* IphoneRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.IphoneRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* IphoneRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.IphoneRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void IphoneRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.IphoneRegRequest.BaseRequest)
}

// optional string Token = 2;
inline bool IphoneRegRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IphoneRegRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IphoneRegRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IphoneRegRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& IphoneRegRequest::token() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneRegRequest.Token)
  return token_.GetNoArena();
}
inline void IphoneRegRequest::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.IphoneRegRequest.Token)
}
#if LANG_CXX11
inline void IphoneRegRequest::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.IphoneRegRequest.Token)
}
#endif
inline void IphoneRegRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.IphoneRegRequest.Token)
}
inline void IphoneRegRequest::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.IphoneRegRequest.Token)
}
inline ::std::string* IphoneRegRequest::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:micromsg.IphoneRegRequest.Token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IphoneRegRequest::release_token() {
  // @@protoc_insertion_point(field_release:micromsg.IphoneRegRequest.Token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IphoneRegRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:micromsg.IphoneRegRequest.Token)
}

// optional string Sound = 3;
inline bool IphoneRegRequest::has_sound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IphoneRegRequest::set_has_sound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IphoneRegRequest::clear_has_sound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IphoneRegRequest::clear_sound() {
  sound_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sound();
}
inline const ::std::string& IphoneRegRequest::sound() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneRegRequest.Sound)
  return sound_.GetNoArena();
}
inline void IphoneRegRequest::set_sound(const ::std::string& value) {
  set_has_sound();
  sound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.IphoneRegRequest.Sound)
}
#if LANG_CXX11
inline void IphoneRegRequest::set_sound(::std::string&& value) {
  set_has_sound();
  sound_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.IphoneRegRequest.Sound)
}
#endif
inline void IphoneRegRequest::set_sound(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sound();
  sound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.IphoneRegRequest.Sound)
}
inline void IphoneRegRequest::set_sound(const char* value, size_t size) {
  set_has_sound();
  sound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.IphoneRegRequest.Sound)
}
inline ::std::string* IphoneRegRequest::mutable_sound() {
  set_has_sound();
  // @@protoc_insertion_point(field_mutable:micromsg.IphoneRegRequest.Sound)
  return sound_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IphoneRegRequest::release_sound() {
  // @@protoc_insertion_point(field_release:micromsg.IphoneRegRequest.Sound)
  clear_has_sound();
  return sound_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IphoneRegRequest::set_allocated_sound(::std::string* sound) {
  if (sound != NULL) {
    set_has_sound();
  } else {
    clear_has_sound();
  }
  sound_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sound);
  // @@protoc_insertion_point(field_set_allocated:micromsg.IphoneRegRequest.Sound)
}

// optional uint32 Status = 4;
inline bool IphoneRegRequest::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IphoneRegRequest::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IphoneRegRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IphoneRegRequest::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 IphoneRegRequest::status() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneRegRequest.Status)
  return status_;
}
inline void IphoneRegRequest::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:micromsg.IphoneRegRequest.Status)
}

// optional string VoipSound = 5;
inline bool IphoneRegRequest::has_voipsound() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IphoneRegRequest::set_has_voipsound() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IphoneRegRequest::clear_has_voipsound() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IphoneRegRequest::clear_voipsound() {
  voipsound_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_voipsound();
}
inline const ::std::string& IphoneRegRequest::voipsound() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneRegRequest.VoipSound)
  return voipsound_.GetNoArena();
}
inline void IphoneRegRequest::set_voipsound(const ::std::string& value) {
  set_has_voipsound();
  voipsound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.IphoneRegRequest.VoipSound)
}
#if LANG_CXX11
inline void IphoneRegRequest::set_voipsound(::std::string&& value) {
  set_has_voipsound();
  voipsound_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.IphoneRegRequest.VoipSound)
}
#endif
inline void IphoneRegRequest::set_voipsound(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_voipsound();
  voipsound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.IphoneRegRequest.VoipSound)
}
inline void IphoneRegRequest::set_voipsound(const char* value, size_t size) {
  set_has_voipsound();
  voipsound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.IphoneRegRequest.VoipSound)
}
inline ::std::string* IphoneRegRequest::mutable_voipsound() {
  set_has_voipsound();
  // @@protoc_insertion_point(field_mutable:micromsg.IphoneRegRequest.VoipSound)
  return voipsound_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IphoneRegRequest::release_voipsound() {
  // @@protoc_insertion_point(field_release:micromsg.IphoneRegRequest.VoipSound)
  clear_has_voipsound();
  return voipsound_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IphoneRegRequest::set_allocated_voipsound(::std::string* voipsound) {
  if (voipsound != NULL) {
    set_has_voipsound();
  } else {
    clear_has_voipsound();
  }
  voipsound_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), voipsound);
  // @@protoc_insertion_point(field_set_allocated:micromsg.IphoneRegRequest.VoipSound)
}

// optional uint32 TokenCert = 6;
inline bool IphoneRegRequest::has_tokencert() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IphoneRegRequest::set_has_tokencert() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IphoneRegRequest::clear_has_tokencert() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IphoneRegRequest::clear_tokencert() {
  tokencert_ = 0u;
  clear_has_tokencert();
}
inline ::google::protobuf::uint32 IphoneRegRequest::tokencert() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneRegRequest.TokenCert)
  return tokencert_;
}
inline void IphoneRegRequest::set_tokencert(::google::protobuf::uint32 value) {
  set_has_tokencert();
  tokencert_ = value;
  // @@protoc_insertion_point(field_set:micromsg.IphoneRegRequest.TokenCert)
}

// optional uint32 TokenEnv = 7;
inline bool IphoneRegRequest::has_tokenenv() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IphoneRegRequest::set_has_tokenenv() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IphoneRegRequest::clear_has_tokenenv() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IphoneRegRequest::clear_tokenenv() {
  tokenenv_ = 0u;
  clear_has_tokenenv();
}
inline ::google::protobuf::uint32 IphoneRegRequest::tokenenv() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneRegRequest.TokenEnv)
  return tokenenv_;
}
inline void IphoneRegRequest::set_tokenenv(::google::protobuf::uint32 value) {
  set_has_tokenenv();
  tokenenv_ = value;
  // @@protoc_insertion_point(field_set:micromsg.IphoneRegRequest.TokenEnv)
}

// optional uint32 TokenScene = 8;
inline bool IphoneRegRequest::has_tokenscene() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IphoneRegRequest::set_has_tokenscene() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IphoneRegRequest::clear_has_tokenscene() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IphoneRegRequest::clear_tokenscene() {
  tokenscene_ = 0u;
  clear_has_tokenscene();
}
inline ::google::protobuf::uint32 IphoneRegRequest::tokenscene() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneRegRequest.TokenScene)
  return tokenscene_;
}
inline void IphoneRegRequest::set_tokenscene(::google::protobuf::uint32 value) {
  set_has_tokenscene();
  tokenscene_ = value;
  // @@protoc_insertion_point(field_set:micromsg.IphoneRegRequest.TokenScene)
}

// -------------------------------------------------------------------

// IphoneRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool IphoneRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IphoneRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IphoneRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IphoneRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& IphoneRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* IphoneRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.IphoneRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* IphoneRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.IphoneRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void IphoneRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.IphoneRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// IphoneUnRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool IphoneUnRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IphoneUnRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IphoneUnRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IphoneUnRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& IphoneUnRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneUnRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* IphoneUnRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.IphoneUnRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* IphoneUnRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.IphoneUnRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void IphoneUnRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.IphoneUnRegRequest.BaseRequest)
}

// optional string Token = 2;
inline bool IphoneUnRegRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IphoneUnRegRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IphoneUnRegRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IphoneUnRegRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& IphoneUnRegRequest::token() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneUnRegRequest.Token)
  return token_.GetNoArena();
}
inline void IphoneUnRegRequest::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.IphoneUnRegRequest.Token)
}
#if LANG_CXX11
inline void IphoneUnRegRequest::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.IphoneUnRegRequest.Token)
}
#endif
inline void IphoneUnRegRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.IphoneUnRegRequest.Token)
}
inline void IphoneUnRegRequest::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.IphoneUnRegRequest.Token)
}
inline ::std::string* IphoneUnRegRequest::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:micromsg.IphoneUnRegRequest.Token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IphoneUnRegRequest::release_token() {
  // @@protoc_insertion_point(field_release:micromsg.IphoneUnRegRequest.Token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IphoneUnRegRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:micromsg.IphoneUnRegRequest.Token)
}

// -------------------------------------------------------------------

// IphoneUnRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool IphoneUnRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IphoneUnRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IphoneUnRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IphoneUnRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& IphoneUnRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.IphoneUnRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* IphoneUnRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.IphoneUnRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* IphoneUnRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.IphoneUnRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void IphoneUnRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.IphoneUnRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// WinphoneRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool WinphoneRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WinphoneRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WinphoneRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WinphoneRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& WinphoneRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.WinphoneRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* WinphoneRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.WinphoneRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* WinphoneRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.WinphoneRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void WinphoneRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.WinphoneRegRequest.BaseRequest)
}

// optional string Uri = 2;
inline bool WinphoneRegRequest::has_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WinphoneRegRequest::set_has_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WinphoneRegRequest::clear_has_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WinphoneRegRequest::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uri();
}
inline const ::std::string& WinphoneRegRequest::uri() const {
  // @@protoc_insertion_point(field_get:micromsg.WinphoneRegRequest.Uri)
  return uri_.GetNoArena();
}
inline void WinphoneRegRequest::set_uri(const ::std::string& value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WinphoneRegRequest.Uri)
}
#if LANG_CXX11
inline void WinphoneRegRequest::set_uri(::std::string&& value) {
  set_has_uri();
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WinphoneRegRequest.Uri)
}
#endif
inline void WinphoneRegRequest::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WinphoneRegRequest.Uri)
}
inline void WinphoneRegRequest::set_uri(const char* value, size_t size) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WinphoneRegRequest.Uri)
}
inline ::std::string* WinphoneRegRequest::mutable_uri() {
  set_has_uri();
  // @@protoc_insertion_point(field_mutable:micromsg.WinphoneRegRequest.Uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WinphoneRegRequest::release_uri() {
  // @@protoc_insertion_point(field_release:micromsg.WinphoneRegRequest.Uri)
  clear_has_uri();
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WinphoneRegRequest::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    set_has_uri();
  } else {
    clear_has_uri();
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WinphoneRegRequest.Uri)
}

// -------------------------------------------------------------------

// WinphoneRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool WinphoneRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WinphoneRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WinphoneRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WinphoneRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& WinphoneRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.WinphoneRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* WinphoneRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.WinphoneRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* WinphoneRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.WinphoneRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void WinphoneRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.WinphoneRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// WinphoneUnRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool WinphoneUnRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WinphoneUnRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WinphoneUnRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WinphoneUnRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& WinphoneUnRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.WinphoneUnRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* WinphoneUnRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.WinphoneUnRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* WinphoneUnRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.WinphoneUnRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void WinphoneUnRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.WinphoneUnRegRequest.BaseRequest)
}

// optional string Uri = 2;
inline bool WinphoneUnRegRequest::has_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WinphoneUnRegRequest::set_has_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WinphoneUnRegRequest::clear_has_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WinphoneUnRegRequest::clear_uri() {
  uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uri();
}
inline const ::std::string& WinphoneUnRegRequest::uri() const {
  // @@protoc_insertion_point(field_get:micromsg.WinphoneUnRegRequest.Uri)
  return uri_.GetNoArena();
}
inline void WinphoneUnRegRequest::set_uri(const ::std::string& value) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WinphoneUnRegRequest.Uri)
}
#if LANG_CXX11
inline void WinphoneUnRegRequest::set_uri(::std::string&& value) {
  set_has_uri();
  uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WinphoneUnRegRequest.Uri)
}
#endif
inline void WinphoneUnRegRequest::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WinphoneUnRegRequest.Uri)
}
inline void WinphoneUnRegRequest::set_uri(const char* value, size_t size) {
  set_has_uri();
  uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WinphoneUnRegRequest.Uri)
}
inline ::std::string* WinphoneUnRegRequest::mutable_uri() {
  set_has_uri();
  // @@protoc_insertion_point(field_mutable:micromsg.WinphoneUnRegRequest.Uri)
  return uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WinphoneUnRegRequest::release_uri() {
  // @@protoc_insertion_point(field_release:micromsg.WinphoneUnRegRequest.Uri)
  clear_has_uri();
  return uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WinphoneUnRegRequest::set_allocated_uri(::std::string* uri) {
  if (uri != NULL) {
    set_has_uri();
  } else {
    clear_has_uri();
  }
  uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WinphoneUnRegRequest.Uri)
}

// -------------------------------------------------------------------

// WinphoneUnRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool WinphoneUnRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WinphoneUnRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WinphoneUnRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WinphoneUnRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& WinphoneUnRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.WinphoneUnRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* WinphoneUnRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.WinphoneUnRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* WinphoneUnRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.WinphoneUnRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void WinphoneUnRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.WinphoneUnRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// AshaRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool AshaRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AshaRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AshaRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AshaRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& AshaRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.AshaRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* AshaRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AshaRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* AshaRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.AshaRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void AshaRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AshaRegRequest.BaseRequest)
}

// optional string Nid = 2;
inline bool AshaRegRequest::has_nid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AshaRegRequest::set_has_nid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AshaRegRequest::clear_has_nid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AshaRegRequest::clear_nid() {
  nid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nid();
}
inline const ::std::string& AshaRegRequest::nid() const {
  // @@protoc_insertion_point(field_get:micromsg.AshaRegRequest.Nid)
  return nid_.GetNoArena();
}
inline void AshaRegRequest::set_nid(const ::std::string& value) {
  set_has_nid();
  nid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AshaRegRequest.Nid)
}
#if LANG_CXX11
inline void AshaRegRequest::set_nid(::std::string&& value) {
  set_has_nid();
  nid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AshaRegRequest.Nid)
}
#endif
inline void AshaRegRequest::set_nid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nid();
  nid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AshaRegRequest.Nid)
}
inline void AshaRegRequest::set_nid(const char* value, size_t size) {
  set_has_nid();
  nid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AshaRegRequest.Nid)
}
inline ::std::string* AshaRegRequest::mutable_nid() {
  set_has_nid();
  // @@protoc_insertion_point(field_mutable:micromsg.AshaRegRequest.Nid)
  return nid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AshaRegRequest::release_nid() {
  // @@protoc_insertion_point(field_release:micromsg.AshaRegRequest.Nid)
  clear_has_nid();
  return nid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AshaRegRequest::set_allocated_nid(::std::string* nid) {
  if (nid != NULL) {
    set_has_nid();
  } else {
    clear_has_nid();
  }
  nid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AshaRegRequest.Nid)
}

// -------------------------------------------------------------------

// AshaRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool AshaRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AshaRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AshaRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AshaRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& AshaRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.AshaRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* AshaRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AshaRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* AshaRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.AshaRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void AshaRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AshaRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// AshaUnRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool AshaUnRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AshaUnRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AshaUnRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AshaUnRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& AshaUnRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.AshaUnRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* AshaUnRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AshaUnRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* AshaUnRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.AshaUnRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void AshaUnRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AshaUnRegRequest.BaseRequest)
}

// optional string Nid = 2;
inline bool AshaUnRegRequest::has_nid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AshaUnRegRequest::set_has_nid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AshaUnRegRequest::clear_has_nid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AshaUnRegRequest::clear_nid() {
  nid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nid();
}
inline const ::std::string& AshaUnRegRequest::nid() const {
  // @@protoc_insertion_point(field_get:micromsg.AshaUnRegRequest.Nid)
  return nid_.GetNoArena();
}
inline void AshaUnRegRequest::set_nid(const ::std::string& value) {
  set_has_nid();
  nid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AshaUnRegRequest.Nid)
}
#if LANG_CXX11
inline void AshaUnRegRequest::set_nid(::std::string&& value) {
  set_has_nid();
  nid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AshaUnRegRequest.Nid)
}
#endif
inline void AshaUnRegRequest::set_nid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nid();
  nid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AshaUnRegRequest.Nid)
}
inline void AshaUnRegRequest::set_nid(const char* value, size_t size) {
  set_has_nid();
  nid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AshaUnRegRequest.Nid)
}
inline ::std::string* AshaUnRegRequest::mutable_nid() {
  set_has_nid();
  // @@protoc_insertion_point(field_mutable:micromsg.AshaUnRegRequest.Nid)
  return nid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AshaUnRegRequest::release_nid() {
  // @@protoc_insertion_point(field_release:micromsg.AshaUnRegRequest.Nid)
  clear_has_nid();
  return nid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AshaUnRegRequest::set_allocated_nid(::std::string* nid) {
  if (nid != NULL) {
    set_has_nid();
  } else {
    clear_has_nid();
  }
  nid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AshaUnRegRequest.Nid)
}

// -------------------------------------------------------------------

// AshaUnRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool AshaUnRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AshaUnRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AshaUnRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AshaUnRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& AshaUnRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.AshaUnRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* AshaUnRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AshaUnRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* AshaUnRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.AshaUnRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void AshaUnRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AshaUnRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// BlackBerryRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BlackBerryRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlackBerryRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlackBerryRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlackBerryRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BlackBerryRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BlackBerryRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BlackBerryRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlackBerryRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BlackBerryRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BlackBerryRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BlackBerryRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlackBerryRegRequest.BaseRequest)
}

// optional string Pin = 2;
inline bool BlackBerryRegRequest::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlackBerryRegRequest::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlackBerryRegRequest::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlackBerryRegRequest::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pin();
}
inline const ::std::string& BlackBerryRegRequest::pin() const {
  // @@protoc_insertion_point(field_get:micromsg.BlackBerryRegRequest.Pin)
  return pin_.GetNoArena();
}
inline void BlackBerryRegRequest::set_pin(const ::std::string& value) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlackBerryRegRequest.Pin)
}
#if LANG_CXX11
inline void BlackBerryRegRequest::set_pin(::std::string&& value) {
  set_has_pin();
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlackBerryRegRequest.Pin)
}
#endif
inline void BlackBerryRegRequest::set_pin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlackBerryRegRequest.Pin)
}
inline void BlackBerryRegRequest::set_pin(const char* value, size_t size) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlackBerryRegRequest.Pin)
}
inline ::std::string* BlackBerryRegRequest::mutable_pin() {
  set_has_pin();
  // @@protoc_insertion_point(field_mutable:micromsg.BlackBerryRegRequest.Pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlackBerryRegRequest::release_pin() {
  // @@protoc_insertion_point(field_release:micromsg.BlackBerryRegRequest.Pin)
  clear_has_pin();
  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlackBerryRegRequest::set_allocated_pin(::std::string* pin) {
  if (pin != NULL) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlackBerryRegRequest.Pin)
}

// required uint32 Port = 3;
inline bool BlackBerryRegRequest::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlackBerryRegRequest::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlackBerryRegRequest::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlackBerryRegRequest::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 BlackBerryRegRequest::port() const {
  // @@protoc_insertion_point(field_get:micromsg.BlackBerryRegRequest.Port)
  return port_;
}
inline void BlackBerryRegRequest::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BlackBerryRegRequest.Port)
}

// -------------------------------------------------------------------

// BlackBerryRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BlackBerryRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlackBerryRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlackBerryRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlackBerryRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BlackBerryRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BlackBerryRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BlackBerryRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlackBerryRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BlackBerryRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BlackBerryRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BlackBerryRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlackBerryRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// BlackBerryUnRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BlackBerryUnRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlackBerryUnRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlackBerryUnRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlackBerryUnRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BlackBerryUnRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BlackBerryUnRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BlackBerryUnRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlackBerryUnRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BlackBerryUnRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BlackBerryUnRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BlackBerryUnRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlackBerryUnRegRequest.BaseRequest)
}

// optional string Pin = 2;
inline bool BlackBerryUnRegRequest::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlackBerryUnRegRequest::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlackBerryUnRegRequest::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlackBerryUnRegRequest::clear_pin() {
  pin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pin();
}
inline const ::std::string& BlackBerryUnRegRequest::pin() const {
  // @@protoc_insertion_point(field_get:micromsg.BlackBerryUnRegRequest.Pin)
  return pin_.GetNoArena();
}
inline void BlackBerryUnRegRequest::set_pin(const ::std::string& value) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlackBerryUnRegRequest.Pin)
}
#if LANG_CXX11
inline void BlackBerryUnRegRequest::set_pin(::std::string&& value) {
  set_has_pin();
  pin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlackBerryUnRegRequest.Pin)
}
#endif
inline void BlackBerryUnRegRequest::set_pin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlackBerryUnRegRequest.Pin)
}
inline void BlackBerryUnRegRequest::set_pin(const char* value, size_t size) {
  set_has_pin();
  pin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlackBerryUnRegRequest.Pin)
}
inline ::std::string* BlackBerryUnRegRequest::mutable_pin() {
  set_has_pin();
  // @@protoc_insertion_point(field_mutable:micromsg.BlackBerryUnRegRequest.Pin)
  return pin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlackBerryUnRegRequest::release_pin() {
  // @@protoc_insertion_point(field_release:micromsg.BlackBerryUnRegRequest.Pin)
  clear_has_pin();
  return pin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlackBerryUnRegRequest::set_allocated_pin(::std::string* pin) {
  if (pin != NULL) {
    set_has_pin();
  } else {
    clear_has_pin();
  }
  pin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pin);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlackBerryUnRegRequest.Pin)
}

// -------------------------------------------------------------------

// BlackBerryUnRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BlackBerryUnRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlackBerryUnRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlackBerryUnRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlackBerryUnRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BlackBerryUnRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BlackBerryUnRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BlackBerryUnRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlackBerryUnRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BlackBerryUnRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BlackBerryUnRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BlackBerryUnRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlackBerryUnRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// AndroidGCMRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool AndroidGCMRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AndroidGCMRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AndroidGCMRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AndroidGCMRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& AndroidGCMRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.AndroidGCMRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* AndroidGCMRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AndroidGCMRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* AndroidGCMRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.AndroidGCMRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void AndroidGCMRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AndroidGCMRegRequest.BaseRequest)
}

// optional string Token = 2;
inline bool AndroidGCMRegRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidGCMRegRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AndroidGCMRegRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AndroidGCMRegRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& AndroidGCMRegRequest::token() const {
  // @@protoc_insertion_point(field_get:micromsg.AndroidGCMRegRequest.Token)
  return token_.GetNoArena();
}
inline void AndroidGCMRegRequest::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AndroidGCMRegRequest.Token)
}
#if LANG_CXX11
inline void AndroidGCMRegRequest::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AndroidGCMRegRequest.Token)
}
#endif
inline void AndroidGCMRegRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AndroidGCMRegRequest.Token)
}
inline void AndroidGCMRegRequest::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AndroidGCMRegRequest.Token)
}
inline ::std::string* AndroidGCMRegRequest::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:micromsg.AndroidGCMRegRequest.Token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AndroidGCMRegRequest::release_token() {
  // @@protoc_insertion_point(field_release:micromsg.AndroidGCMRegRequest.Token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidGCMRegRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AndroidGCMRegRequest.Token)
}

// -------------------------------------------------------------------

// AndroidGCMRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool AndroidGCMRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidGCMRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AndroidGCMRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AndroidGCMRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& AndroidGCMRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.AndroidGCMRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* AndroidGCMRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AndroidGCMRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* AndroidGCMRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.AndroidGCMRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void AndroidGCMRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AndroidGCMRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// AndroidGCMUnRegRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool AndroidGCMUnRegRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AndroidGCMUnRegRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AndroidGCMUnRegRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AndroidGCMUnRegRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& AndroidGCMUnRegRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.AndroidGCMUnRegRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* AndroidGCMUnRegRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AndroidGCMUnRegRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* AndroidGCMUnRegRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.AndroidGCMUnRegRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void AndroidGCMUnRegRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AndroidGCMUnRegRequest.BaseRequest)
}

// optional string Token = 2;
inline bool AndroidGCMUnRegRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidGCMUnRegRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AndroidGCMUnRegRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AndroidGCMUnRegRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& AndroidGCMUnRegRequest::token() const {
  // @@protoc_insertion_point(field_get:micromsg.AndroidGCMUnRegRequest.Token)
  return token_.GetNoArena();
}
inline void AndroidGCMUnRegRequest::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AndroidGCMUnRegRequest.Token)
}
#if LANG_CXX11
inline void AndroidGCMUnRegRequest::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AndroidGCMUnRegRequest.Token)
}
#endif
inline void AndroidGCMUnRegRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AndroidGCMUnRegRequest.Token)
}
inline void AndroidGCMUnRegRequest::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AndroidGCMUnRegRequest.Token)
}
inline ::std::string* AndroidGCMUnRegRequest::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:micromsg.AndroidGCMUnRegRequest.Token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AndroidGCMUnRegRequest::release_token() {
  // @@protoc_insertion_point(field_release:micromsg.AndroidGCMUnRegRequest.Token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AndroidGCMUnRegRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AndroidGCMUnRegRequest.Token)
}

// -------------------------------------------------------------------

// AndroidGCMUnRegResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool AndroidGCMUnRegResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidGCMUnRegResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AndroidGCMUnRegResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AndroidGCMUnRegResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& AndroidGCMUnRegResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.AndroidGCMUnRegResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* AndroidGCMUnRegResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AndroidGCMUnRegResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* AndroidGCMUnRegResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.AndroidGCMUnRegResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void AndroidGCMUnRegResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AndroidGCMUnRegResponse.BaseResponse)
}

// -------------------------------------------------------------------

// RSACert

// optional string KeyN = 1;
inline bool RSACert::has_keyn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RSACert::set_has_keyn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RSACert::clear_has_keyn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RSACert::clear_keyn() {
  keyn_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keyn();
}
inline const ::std::string& RSACert::keyn() const {
  // @@protoc_insertion_point(field_get:micromsg.RSACert.KeyN)
  return keyn_.GetNoArena();
}
inline void RSACert::set_keyn(const ::std::string& value) {
  set_has_keyn();
  keyn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RSACert.KeyN)
}
#if LANG_CXX11
inline void RSACert::set_keyn(::std::string&& value) {
  set_has_keyn();
  keyn_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RSACert.KeyN)
}
#endif
inline void RSACert::set_keyn(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keyn();
  keyn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RSACert.KeyN)
}
inline void RSACert::set_keyn(const char* value, size_t size) {
  set_has_keyn();
  keyn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RSACert.KeyN)
}
inline ::std::string* RSACert::mutable_keyn() {
  set_has_keyn();
  // @@protoc_insertion_point(field_mutable:micromsg.RSACert.KeyN)
  return keyn_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSACert::release_keyn() {
  // @@protoc_insertion_point(field_release:micromsg.RSACert.KeyN)
  clear_has_keyn();
  return keyn_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSACert::set_allocated_keyn(::std::string* keyn) {
  if (keyn != NULL) {
    set_has_keyn();
  } else {
    clear_has_keyn();
  }
  keyn_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keyn);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RSACert.KeyN)
}

// optional string KeyE = 2;
inline bool RSACert::has_keye() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RSACert::set_has_keye() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RSACert::clear_has_keye() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RSACert::clear_keye() {
  keye_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_keye();
}
inline const ::std::string& RSACert::keye() const {
  // @@protoc_insertion_point(field_get:micromsg.RSACert.KeyE)
  return keye_.GetNoArena();
}
inline void RSACert::set_keye(const ::std::string& value) {
  set_has_keye();
  keye_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.RSACert.KeyE)
}
#if LANG_CXX11
inline void RSACert::set_keye(::std::string&& value) {
  set_has_keye();
  keye_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.RSACert.KeyE)
}
#endif
inline void RSACert::set_keye(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_keye();
  keye_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.RSACert.KeyE)
}
inline void RSACert::set_keye(const char* value, size_t size) {
  set_has_keye();
  keye_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.RSACert.KeyE)
}
inline ::std::string* RSACert::mutable_keye() {
  set_has_keye();
  // @@protoc_insertion_point(field_mutable:micromsg.RSACert.KeyE)
  return keye_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSACert::release_keye() {
  // @@protoc_insertion_point(field_release:micromsg.RSACert.KeyE)
  clear_has_keye();
  return keye_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSACert::set_allocated_keye(::std::string* keye) {
  if (keye != NULL) {
    set_has_keye();
  } else {
    clear_has_keye();
  }
  keye_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), keye);
  // @@protoc_insertion_point(field_set_allocated:micromsg.RSACert.KeyE)
}

// -------------------------------------------------------------------

// GetCertRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetCertRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCertRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCertRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCertRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetCertRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetCertRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetCertRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetCertRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetCertRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetCertRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetCertRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetCertRequest.BaseRequest)
}

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
inline bool GetCertRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCertRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCertRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCertRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetCertRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.GetCertRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetCertRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetCertRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetCertRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.GetCertRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void GetCertRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetCertRequest.RandomEncryKey)
}

// required uint32 CurrentCertVersion = 3;
inline bool GetCertRequest::has_currentcertversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetCertRequest::set_has_currentcertversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetCertRequest::clear_has_currentcertversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetCertRequest::clear_currentcertversion() {
  currentcertversion_ = 0u;
  clear_has_currentcertversion();
}
inline ::google::protobuf::uint32 GetCertRequest::currentcertversion() const {
  // @@protoc_insertion_point(field_get:micromsg.GetCertRequest.CurrentCertVersion)
  return currentcertversion_;
}
inline void GetCertRequest::set_currentcertversion(::google::protobuf::uint32 value) {
  set_has_currentcertversion();
  currentcertversion_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetCertRequest.CurrentCertVersion)
}

// -------------------------------------------------------------------

// GetCertResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetCertResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCertResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCertResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCertResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetCertResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetCertResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetCertResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetCertResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetCertResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetCertResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetCertResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetCertResponse.BaseResponse)
}

// required .micromsg.RSACert CertValue = 2;
inline bool GetCertResponse::has_certvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCertResponse::set_has_certvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCertResponse::clear_has_certvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCertResponse::clear_certvalue() {
  if (certvalue_ != NULL) certvalue_->::micromsg::RSACert::Clear();
  clear_has_certvalue();
}
inline const ::micromsg::RSACert& GetCertResponse::certvalue() const {
  // @@protoc_insertion_point(field_get:micromsg.GetCertResponse.CertValue)
  return certvalue_ != NULL ? *certvalue_
                         : *::micromsg::RSACert::internal_default_instance();
}
inline ::micromsg::RSACert* GetCertResponse::mutable_certvalue() {
  set_has_certvalue();
  if (certvalue_ == NULL) {
    certvalue_ = new ::micromsg::RSACert;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetCertResponse.CertValue)
  return certvalue_;
}
inline ::micromsg::RSACert* GetCertResponse::release_certvalue() {
  // @@protoc_insertion_point(field_release:micromsg.GetCertResponse.CertValue)
  clear_has_certvalue();
  ::micromsg::RSACert* temp = certvalue_;
  certvalue_ = NULL;
  return temp;
}
inline void GetCertResponse::set_allocated_certvalue(::micromsg::RSACert* certvalue) {
  delete certvalue_;
  certvalue_ = certvalue;
  if (certvalue) {
    set_has_certvalue();
  } else {
    clear_has_certvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetCertResponse.CertValue)
}

// required uint32 CertVersion = 3;
inline bool GetCertResponse::has_certversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetCertResponse::set_has_certversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetCertResponse::clear_has_certversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetCertResponse::clear_certversion() {
  certversion_ = 0u;
  clear_has_certversion();
}
inline ::google::protobuf::uint32 GetCertResponse::certversion() const {
  // @@protoc_insertion_point(field_get:micromsg.GetCertResponse.CertVersion)
  return certversion_;
}
inline void GetCertResponse::set_certversion(::google::protobuf::uint32 value) {
  set_has_certversion();
  certversion_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetCertResponse.CertVersion)
}

// -------------------------------------------------------------------

// NewAuthRsaReqData

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 1;
inline bool NewAuthRsaReqData::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewAuthRsaReqData::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewAuthRsaReqData::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewAuthRsaReqData::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthRsaReqData::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRsaReqData.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRsaReqData::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRsaReqData.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRsaReqData::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRsaReqData.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void NewAuthRsaReqData::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRsaReqData.RandomEncryKey)
}

// -------------------------------------------------------------------

// NewAuthRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool NewAuthRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NewAuthRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NewAuthRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NewAuthRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& NewAuthRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* NewAuthRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* NewAuthRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.BaseRequest)
}

// required .micromsg.SKBuiltinString_t UserName = 2;
inline bool NewAuthRequest::has_username() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void NewAuthRequest::set_has_username() {
  _has_bits_[0] |= 0x00800000u;
}
inline void NewAuthRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void NewAuthRequest::clear_username() {
  if (username_ != NULL) username_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_username();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthRequest::username() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.UserName)
  return username_ != NULL ? *username_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::mutable_username() {
  set_has_username();
  if (username_ == NULL) {
    username_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.UserName)
  return username_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.UserName)
  clear_has_username();
  ::micromsg::SKBuiltinString_t* temp = username_;
  username_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_username(::micromsg::SKBuiltinString_t* username) {
  delete username_;
  username_ = username;
  if (username) {
    set_has_username();
  } else {
    clear_has_username();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.UserName)
}

// required .micromsg.SKBuiltinString_t Pwd = 3;
inline bool NewAuthRequest::has_pwd() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void NewAuthRequest::set_has_pwd() {
  _has_bits_[0] |= 0x01000000u;
}
inline void NewAuthRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void NewAuthRequest::clear_pwd() {
  if (pwd_ != NULL) pwd_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_pwd();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthRequest::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.Pwd)
  return pwd_ != NULL ? *pwd_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == NULL) {
    pwd_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.Pwd)
  return pwd_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.Pwd)
  clear_has_pwd();
  ::micromsg::SKBuiltinString_t* temp = pwd_;
  pwd_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_pwd(::micromsg::SKBuiltinString_t* pwd) {
  delete pwd_;
  pwd_ = pwd;
  if (pwd) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.Pwd)
}

// required .micromsg.SKBuiltinString_t ImgSid = 4;
inline bool NewAuthRequest::has_imgsid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void NewAuthRequest::set_has_imgsid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void NewAuthRequest::clear_has_imgsid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void NewAuthRequest::clear_imgsid() {
  if (imgsid_ != NULL) imgsid_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgsid();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthRequest::imgsid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.ImgSid)
  return imgsid_ != NULL ? *imgsid_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::mutable_imgsid() {
  set_has_imgsid();
  if (imgsid_ == NULL) {
    imgsid_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.ImgSid)
  return imgsid_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::release_imgsid() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.ImgSid)
  clear_has_imgsid();
  ::micromsg::SKBuiltinString_t* temp = imgsid_;
  imgsid_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_imgsid(::micromsg::SKBuiltinString_t* imgsid) {
  delete imgsid_;
  imgsid_ = imgsid;
  if (imgsid) {
    set_has_imgsid();
  } else {
    clear_has_imgsid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.ImgSid)
}

// required .micromsg.SKBuiltinString_t ImgCode = 5;
inline bool NewAuthRequest::has_imgcode() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void NewAuthRequest::set_has_imgcode() {
  _has_bits_[0] |= 0x04000000u;
}
inline void NewAuthRequest::clear_has_imgcode() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void NewAuthRequest::clear_imgcode() {
  if (imgcode_ != NULL) imgcode_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgcode();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthRequest::imgcode() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.ImgCode)
  return imgcode_ != NULL ? *imgcode_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::mutable_imgcode() {
  set_has_imgcode();
  if (imgcode_ == NULL) {
    imgcode_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.ImgCode)
  return imgcode_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::release_imgcode() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.ImgCode)
  clear_has_imgcode();
  ::micromsg::SKBuiltinString_t* temp = imgcode_;
  imgcode_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_imgcode(::micromsg::SKBuiltinString_t* imgcode) {
  delete imgcode_;
  imgcode_ = imgcode;
  if (imgcode) {
    set_has_imgcode();
  } else {
    clear_has_imgcode();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.ImgCode)
}

// optional string Pwd2 = 6;
inline bool NewAuthRequest::has_pwd2() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewAuthRequest::set_has_pwd2() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewAuthRequest::clear_has_pwd2() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewAuthRequest::clear_pwd2() {
  pwd2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd2();
}
inline const ::std::string& NewAuthRequest::pwd2() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.Pwd2)
  return pwd2_.GetNoArena();
}
inline void NewAuthRequest::set_pwd2(const ::std::string& value) {
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.Pwd2)
}
#if LANG_CXX11
inline void NewAuthRequest::set_pwd2(::std::string&& value) {
  set_has_pwd2();
  pwd2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.Pwd2)
}
#endif
inline void NewAuthRequest::set_pwd2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.Pwd2)
}
inline void NewAuthRequest::set_pwd2(const char* value, size_t size) {
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.Pwd2)
}
inline ::std::string* NewAuthRequest::mutable_pwd2() {
  set_has_pwd2();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.Pwd2)
  return pwd2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_pwd2() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.Pwd2)
  clear_has_pwd2();
  return pwd2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_pwd2(::std::string* pwd2) {
  if (pwd2 != NULL) {
    set_has_pwd2();
  } else {
    clear_has_pwd2();
  }
  pwd2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd2);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.Pwd2)
}

// optional uint32 BuiltinIPSeq = 7;
inline bool NewAuthRequest::has_builtinipseq() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void NewAuthRequest::set_has_builtinipseq() {
  _has_bits_[1] |= 0x00000002u;
}
inline void NewAuthRequest::clear_has_builtinipseq() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void NewAuthRequest::clear_builtinipseq() {
  builtinipseq_ = 0u;
  clear_has_builtinipseq();
}
inline ::google::protobuf::uint32 NewAuthRequest::builtinipseq() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.BuiltinIPSeq)
  return builtinipseq_;
}
inline void NewAuthRequest::set_builtinipseq(::google::protobuf::uint32 value) {
  set_has_builtinipseq();
  builtinipseq_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.BuiltinIPSeq)
}

// optional string extPwd = 8;
inline bool NewAuthRequest::has_extpwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewAuthRequest::set_has_extpwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewAuthRequest::clear_has_extpwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewAuthRequest::clear_extpwd() {
  extpwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extpwd();
}
inline const ::std::string& NewAuthRequest::extpwd() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.extPwd)
  return extpwd_.GetNoArena();
}
inline void NewAuthRequest::set_extpwd(const ::std::string& value) {
  set_has_extpwd();
  extpwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.extPwd)
}
#if LANG_CXX11
inline void NewAuthRequest::set_extpwd(::std::string&& value) {
  set_has_extpwd();
  extpwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.extPwd)
}
#endif
inline void NewAuthRequest::set_extpwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extpwd();
  extpwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.extPwd)
}
inline void NewAuthRequest::set_extpwd(const char* value, size_t size) {
  set_has_extpwd();
  extpwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.extPwd)
}
inline ::std::string* NewAuthRequest::mutable_extpwd() {
  set_has_extpwd();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.extPwd)
  return extpwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_extpwd() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.extPwd)
  clear_has_extpwd();
  return extpwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_extpwd(::std::string* extpwd) {
  if (extpwd != NULL) {
    set_has_extpwd();
  } else {
    clear_has_extpwd();
  }
  extpwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extpwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.extPwd)
}

// optional string extPwd2 = 9;
inline bool NewAuthRequest::has_extpwd2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewAuthRequest::set_has_extpwd2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewAuthRequest::clear_has_extpwd2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewAuthRequest::clear_extpwd2() {
  extpwd2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extpwd2();
}
inline const ::std::string& NewAuthRequest::extpwd2() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.extPwd2)
  return extpwd2_.GetNoArena();
}
inline void NewAuthRequest::set_extpwd2(const ::std::string& value) {
  set_has_extpwd2();
  extpwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.extPwd2)
}
#if LANG_CXX11
inline void NewAuthRequest::set_extpwd2(::std::string&& value) {
  set_has_extpwd2();
  extpwd2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.extPwd2)
}
#endif
inline void NewAuthRequest::set_extpwd2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extpwd2();
  extpwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.extPwd2)
}
inline void NewAuthRequest::set_extpwd2(const char* value, size_t size) {
  set_has_extpwd2();
  extpwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.extPwd2)
}
inline ::std::string* NewAuthRequest::mutable_extpwd2() {
  set_has_extpwd2();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.extPwd2)
  return extpwd2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_extpwd2() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.extPwd2)
  clear_has_extpwd2();
  return extpwd2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_extpwd2(::std::string* extpwd2) {
  if (extpwd2 != NULL) {
    set_has_extpwd2();
  } else {
    clear_has_extpwd2();
  }
  extpwd2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extpwd2);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.extPwd2)
}

// optional string TimeZone = 10;
inline bool NewAuthRequest::has_timezone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewAuthRequest::set_has_timezone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewAuthRequest::clear_has_timezone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewAuthRequest::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timezone();
}
inline const ::std::string& NewAuthRequest::timezone() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.TimeZone)
  return timezone_.GetNoArena();
}
inline void NewAuthRequest::set_timezone(const ::std::string& value) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.TimeZone)
}
#if LANG_CXX11
inline void NewAuthRequest::set_timezone(::std::string&& value) {
  set_has_timezone();
  timezone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.TimeZone)
}
#endif
inline void NewAuthRequest::set_timezone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.TimeZone)
}
inline void NewAuthRequest::set_timezone(const char* value, size_t size) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.TimeZone)
}
inline ::std::string* NewAuthRequest::mutable_timezone() {
  set_has_timezone();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.TimeZone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_timezone() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.TimeZone)
  clear_has_timezone();
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    set_has_timezone();
  } else {
    clear_has_timezone();
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.TimeZone)
}

// optional string Language = 11;
inline bool NewAuthRequest::has_language() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewAuthRequest::set_has_language() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewAuthRequest::clear_has_language() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewAuthRequest::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& NewAuthRequest::language() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.Language)
  return language_.GetNoArena();
}
inline void NewAuthRequest::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.Language)
}
#if LANG_CXX11
inline void NewAuthRequest::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.Language)
}
#endif
inline void NewAuthRequest::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.Language)
}
inline void NewAuthRequest::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.Language)
}
inline ::std::string* NewAuthRequest::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.Language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_language() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.Language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.Language)
}

// optional string IMEI = 12;
inline bool NewAuthRequest::has_imei() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewAuthRequest::set_has_imei() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewAuthRequest::clear_has_imei() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewAuthRequest::clear_imei() {
  imei_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imei();
}
inline const ::std::string& NewAuthRequest::imei() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.IMEI)
  return imei_.GetNoArena();
}
inline void NewAuthRequest::set_imei(const ::std::string& value) {
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.IMEI)
}
#if LANG_CXX11
inline void NewAuthRequest::set_imei(::std::string&& value) {
  set_has_imei();
  imei_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.IMEI)
}
#endif
inline void NewAuthRequest::set_imei(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.IMEI)
}
inline void NewAuthRequest::set_imei(const char* value, size_t size) {
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.IMEI)
}
inline ::std::string* NewAuthRequest::mutable_imei() {
  set_has_imei();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.IMEI)
  return imei_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_imei() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.IMEI)
  clear_has_imei();
  return imei_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_imei(::std::string* imei) {
  if (imei != NULL) {
    set_has_imei();
  } else {
    clear_has_imei();
  }
  imei_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imei);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.IMEI)
}

// optional int32 Channel = 13;
inline bool NewAuthRequest::has_channel() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void NewAuthRequest::set_has_channel() {
  _has_bits_[1] |= 0x00000004u;
}
inline void NewAuthRequest::clear_has_channel() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void NewAuthRequest::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 NewAuthRequest::channel() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.Channel)
  return channel_;
}
inline void NewAuthRequest::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.Channel)
}

// optional string IPhoneVer = 14;
inline bool NewAuthRequest::has_iphonever() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewAuthRequest::set_has_iphonever() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewAuthRequest::clear_has_iphonever() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewAuthRequest::clear_iphonever() {
  iphonever_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iphonever();
}
inline const ::std::string& NewAuthRequest::iphonever() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.IPhoneVer)
  return iphonever_.GetNoArena();
}
inline void NewAuthRequest::set_iphonever(const ::std::string& value) {
  set_has_iphonever();
  iphonever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.IPhoneVer)
}
#if LANG_CXX11
inline void NewAuthRequest::set_iphonever(::std::string&& value) {
  set_has_iphonever();
  iphonever_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.IPhoneVer)
}
#endif
inline void NewAuthRequest::set_iphonever(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iphonever();
  iphonever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.IPhoneVer)
}
inline void NewAuthRequest::set_iphonever(const char* value, size_t size) {
  set_has_iphonever();
  iphonever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.IPhoneVer)
}
inline ::std::string* NewAuthRequest::mutable_iphonever() {
  set_has_iphonever();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.IPhoneVer)
  return iphonever_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_iphonever() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.IPhoneVer)
  clear_has_iphonever();
  return iphonever_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_iphonever(::std::string* iphonever) {
  if (iphonever != NULL) {
    set_has_iphonever();
  } else {
    clear_has_iphonever();
  }
  iphonever_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iphonever);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.IPhoneVer)
}

// optional .micromsg.SKBuiltinString_t ImgEncryptKey = 15;
inline bool NewAuthRequest::has_imgencryptkey() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void NewAuthRequest::set_has_imgencryptkey() {
  _has_bits_[0] |= 0x08000000u;
}
inline void NewAuthRequest::clear_has_imgencryptkey() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void NewAuthRequest::clear_imgencryptkey() {
  if (imgencryptkey_ != NULL) imgencryptkey_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgencryptkey();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthRequest::imgencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.ImgEncryptKey)
  return imgencryptkey_ != NULL ? *imgencryptkey_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::mutable_imgencryptkey() {
  set_has_imgencryptkey();
  if (imgencryptkey_ == NULL) {
    imgencryptkey_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.ImgEncryptKey)
  return imgencryptkey_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthRequest::release_imgencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.ImgEncryptKey)
  clear_has_imgencryptkey();
  ::micromsg::SKBuiltinString_t* temp = imgencryptkey_;
  imgencryptkey_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey) {
  delete imgencryptkey_;
  imgencryptkey_ = imgencryptkey;
  if (imgencryptkey) {
    set_has_imgencryptkey();
  } else {
    clear_has_imgencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.ImgEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t KSid = 16;
inline bool NewAuthRequest::has_ksid() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void NewAuthRequest::set_has_ksid() {
  _has_bits_[0] |= 0x10000000u;
}
inline void NewAuthRequest::clear_has_ksid() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void NewAuthRequest::clear_ksid() {
  if (ksid_ != NULL) ksid_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_ksid();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthRequest::ksid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.KSid)
  return ksid_ != NULL ? *ksid_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::mutable_ksid() {
  set_has_ksid();
  if (ksid_ == NULL) {
    ksid_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.KSid)
  return ksid_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::release_ksid() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.KSid)
  clear_has_ksid();
  ::micromsg::SKBuiltinBuffer_t* temp = ksid_;
  ksid_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid) {
  delete ksid_;
  ksid_ = ksid;
  if (ksid) {
    set_has_ksid();
  } else {
    clear_has_ksid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.KSid)
}

// optional uint32 TimeStamp = 17;
inline bool NewAuthRequest::has_timestamp() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void NewAuthRequest::set_has_timestamp() {
  _has_bits_[1] |= 0x00000008u;
}
inline void NewAuthRequest::clear_has_timestamp() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void NewAuthRequest::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 NewAuthRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.TimeStamp)
  return timestamp_;
}
inline void NewAuthRequest::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.TimeStamp)
}

// optional string DeviceBrand = 18;
inline bool NewAuthRequest::has_devicebrand() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NewAuthRequest::set_has_devicebrand() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NewAuthRequest::clear_has_devicebrand() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NewAuthRequest::clear_devicebrand() {
  devicebrand_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicebrand();
}
inline const ::std::string& NewAuthRequest::devicebrand() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.DeviceBrand)
  return devicebrand_.GetNoArena();
}
inline void NewAuthRequest::set_devicebrand(const ::std::string& value) {
  set_has_devicebrand();
  devicebrand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.DeviceBrand)
}
#if LANG_CXX11
inline void NewAuthRequest::set_devicebrand(::std::string&& value) {
  set_has_devicebrand();
  devicebrand_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.DeviceBrand)
}
#endif
inline void NewAuthRequest::set_devicebrand(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicebrand();
  devicebrand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.DeviceBrand)
}
inline void NewAuthRequest::set_devicebrand(const char* value, size_t size) {
  set_has_devicebrand();
  devicebrand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.DeviceBrand)
}
inline ::std::string* NewAuthRequest::mutable_devicebrand() {
  set_has_devicebrand();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.DeviceBrand)
  return devicebrand_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_devicebrand() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.DeviceBrand)
  clear_has_devicebrand();
  return devicebrand_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_devicebrand(::std::string* devicebrand) {
  if (devicebrand != NULL) {
    set_has_devicebrand();
  } else {
    clear_has_devicebrand();
  }
  devicebrand_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicebrand);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.DeviceBrand)
}

// optional string DeviceModel = 19;
inline bool NewAuthRequest::has_devicemodel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NewAuthRequest::set_has_devicemodel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NewAuthRequest::clear_has_devicemodel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NewAuthRequest::clear_devicemodel() {
  devicemodel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicemodel();
}
inline const ::std::string& NewAuthRequest::devicemodel() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.DeviceModel)
  return devicemodel_.GetNoArena();
}
inline void NewAuthRequest::set_devicemodel(const ::std::string& value) {
  set_has_devicemodel();
  devicemodel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.DeviceModel)
}
#if LANG_CXX11
inline void NewAuthRequest::set_devicemodel(::std::string&& value) {
  set_has_devicemodel();
  devicemodel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.DeviceModel)
}
#endif
inline void NewAuthRequest::set_devicemodel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicemodel();
  devicemodel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.DeviceModel)
}
inline void NewAuthRequest::set_devicemodel(const char* value, size_t size) {
  set_has_devicemodel();
  devicemodel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.DeviceModel)
}
inline ::std::string* NewAuthRequest::mutable_devicemodel() {
  set_has_devicemodel();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.DeviceModel)
  return devicemodel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_devicemodel() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.DeviceModel)
  clear_has_devicemodel();
  return devicemodel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_devicemodel(::std::string* devicemodel) {
  if (devicemodel != NULL) {
    set_has_devicemodel();
  } else {
    clear_has_devicemodel();
  }
  devicemodel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicemodel);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.DeviceModel)
}

// optional string OSType = 20;
inline bool NewAuthRequest::has_ostype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NewAuthRequest::set_has_ostype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NewAuthRequest::clear_has_ostype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NewAuthRequest::clear_ostype() {
  ostype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ostype();
}
inline const ::std::string& NewAuthRequest::ostype() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.OSType)
  return ostype_.GetNoArena();
}
inline void NewAuthRequest::set_ostype(const ::std::string& value) {
  set_has_ostype();
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.OSType)
}
#if LANG_CXX11
inline void NewAuthRequest::set_ostype(::std::string&& value) {
  set_has_ostype();
  ostype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.OSType)
}
#endif
inline void NewAuthRequest::set_ostype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ostype();
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.OSType)
}
inline void NewAuthRequest::set_ostype(const char* value, size_t size) {
  set_has_ostype();
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.OSType)
}
inline ::std::string* NewAuthRequest::mutable_ostype() {
  set_has_ostype();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.OSType)
  return ostype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_ostype() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.OSType)
  clear_has_ostype();
  return ostype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_ostype(::std::string* ostype) {
  if (ostype != NULL) {
    set_has_ostype();
  } else {
    clear_has_ostype();
  }
  ostype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ostype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.OSType)
}

// optional string DeviceType = 21;
inline bool NewAuthRequest::has_devicetype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NewAuthRequest::set_has_devicetype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NewAuthRequest::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NewAuthRequest::clear_devicetype() {
  devicetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicetype();
}
inline const ::std::string& NewAuthRequest::devicetype() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.DeviceType)
  return devicetype_.GetNoArena();
}
inline void NewAuthRequest::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.DeviceType)
}
#if LANG_CXX11
inline void NewAuthRequest::set_devicetype(::std::string&& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.DeviceType)
}
#endif
inline void NewAuthRequest::set_devicetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.DeviceType)
}
inline void NewAuthRequest::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.DeviceType)
}
inline ::std::string* NewAuthRequest::mutable_devicetype() {
  set_has_devicetype();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.DeviceType)
  return devicetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_devicetype() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.DeviceType)
  clear_has_devicetype();
  return devicetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype != NULL) {
    set_has_devicetype();
  } else {
    clear_has_devicetype();
  }
  devicetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.DeviceType)
}

// optional string SoftType = 22;
inline bool NewAuthRequest::has_softtype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NewAuthRequest::set_has_softtype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NewAuthRequest::clear_has_softtype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NewAuthRequest::clear_softtype() {
  softtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_softtype();
}
inline const ::std::string& NewAuthRequest::softtype() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.SoftType)
  return softtype_.GetNoArena();
}
inline void NewAuthRequest::set_softtype(const ::std::string& value) {
  set_has_softtype();
  softtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.SoftType)
}
#if LANG_CXX11
inline void NewAuthRequest::set_softtype(::std::string&& value) {
  set_has_softtype();
  softtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.SoftType)
}
#endif
inline void NewAuthRequest::set_softtype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_softtype();
  softtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.SoftType)
}
inline void NewAuthRequest::set_softtype(const char* value, size_t size) {
  set_has_softtype();
  softtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.SoftType)
}
inline ::std::string* NewAuthRequest::mutable_softtype() {
  set_has_softtype();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.SoftType)
  return softtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_softtype() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.SoftType)
  clear_has_softtype();
  return softtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_softtype(::std::string* softtype) {
  if (softtype != NULL) {
    set_has_softtype();
  } else {
    clear_has_softtype();
  }
  softtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), softtype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.SoftType)
}

// optional string AuthTicket = 23;
inline bool NewAuthRequest::has_authticket() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NewAuthRequest::set_has_authticket() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NewAuthRequest::clear_has_authticket() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NewAuthRequest::clear_authticket() {
  authticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authticket();
}
inline const ::std::string& NewAuthRequest::authticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.AuthTicket)
  return authticket_.GetNoArena();
}
inline void NewAuthRequest::set_authticket(const ::std::string& value) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.AuthTicket)
}
#if LANG_CXX11
inline void NewAuthRequest::set_authticket(::std::string&& value) {
  set_has_authticket();
  authticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.AuthTicket)
}
#endif
inline void NewAuthRequest::set_authticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.AuthTicket)
}
inline void NewAuthRequest::set_authticket(const char* value, size_t size) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.AuthTicket)
}
inline ::std::string* NewAuthRequest::mutable_authticket() {
  set_has_authticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.AuthTicket)
  return authticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_authticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.AuthTicket)
  clear_has_authticket();
  return authticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_authticket(::std::string* authticket) {
  if (authticket != NULL) {
    set_has_authticket();
  } else {
    clear_has_authticket();
  }
  authticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.AuthTicket)
}

// optional string RealCountry = 24;
inline bool NewAuthRequest::has_realcountry() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NewAuthRequest::set_has_realcountry() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NewAuthRequest::clear_has_realcountry() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NewAuthRequest::clear_realcountry() {
  realcountry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_realcountry();
}
inline const ::std::string& NewAuthRequest::realcountry() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.RealCountry)
  return realcountry_.GetNoArena();
}
inline void NewAuthRequest::set_realcountry(const ::std::string& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.RealCountry)
}
#if LANG_CXX11
inline void NewAuthRequest::set_realcountry(::std::string&& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.RealCountry)
}
#endif
inline void NewAuthRequest::set_realcountry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.RealCountry)
}
inline void NewAuthRequest::set_realcountry(const char* value, size_t size) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.RealCountry)
}
inline ::std::string* NewAuthRequest::mutable_realcountry() {
  set_has_realcountry();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.RealCountry)
  return realcountry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_realcountry() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.RealCountry)
  clear_has_realcountry();
  return realcountry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_realcountry(::std::string* realcountry) {
  if (realcountry != NULL) {
    set_has_realcountry();
  } else {
    clear_has_realcountry();
  }
  realcountry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), realcountry);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.RealCountry)
}

// optional string Signature = 25;
inline bool NewAuthRequest::has_signature() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NewAuthRequest::set_has_signature() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NewAuthRequest::clear_has_signature() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NewAuthRequest::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& NewAuthRequest::signature() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.Signature)
  return signature_.GetNoArena();
}
inline void NewAuthRequest::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.Signature)
}
#if LANG_CXX11
inline void NewAuthRequest::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.Signature)
}
#endif
inline void NewAuthRequest::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.Signature)
}
inline void NewAuthRequest::set_signature(const char* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.Signature)
}
inline ::std::string* NewAuthRequest::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.Signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_signature() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.Signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.Signature)
}

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 26;
inline bool NewAuthRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void NewAuthRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x20000000u;
}
inline void NewAuthRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void NewAuthRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.RandomEncryKey)
}

// optional string AutoAuthTicket = 27;
inline bool NewAuthRequest::has_autoauthticket() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NewAuthRequest::set_has_autoauthticket() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NewAuthRequest::clear_has_autoauthticket() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NewAuthRequest::clear_autoauthticket() {
  autoauthticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_autoauthticket();
}
inline const ::std::string& NewAuthRequest::autoauthticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.AutoAuthTicket)
  return autoauthticket_.GetNoArena();
}
inline void NewAuthRequest::set_autoauthticket(const ::std::string& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.AutoAuthTicket)
}
#if LANG_CXX11
inline void NewAuthRequest::set_autoauthticket(::std::string&& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.AutoAuthTicket)
}
#endif
inline void NewAuthRequest::set_autoauthticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.AutoAuthTicket)
}
inline void NewAuthRequest::set_autoauthticket(const char* value, size_t size) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.AutoAuthTicket)
}
inline ::std::string* NewAuthRequest::mutable_autoauthticket() {
  set_has_autoauthticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.AutoAuthTicket)
  return autoauthticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_autoauthticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.AutoAuthTicket)
  clear_has_autoauthticket();
  return autoauthticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_autoauthticket(::std::string* autoauthticket) {
  if (autoauthticket != NULL) {
    set_has_autoauthticket();
  } else {
    clear_has_autoauthticket();
  }
  autoauthticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), autoauthticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.AutoAuthTicket)
}

// optional string DeviceName = 28;
inline bool NewAuthRequest::has_devicename() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NewAuthRequest::set_has_devicename() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NewAuthRequest::clear_has_devicename() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NewAuthRequest::clear_devicename() {
  devicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicename();
}
inline const ::std::string& NewAuthRequest::devicename() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.DeviceName)
  return devicename_.GetNoArena();
}
inline void NewAuthRequest::set_devicename(const ::std::string& value) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.DeviceName)
}
#if LANG_CXX11
inline void NewAuthRequest::set_devicename(::std::string&& value) {
  set_has_devicename();
  devicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.DeviceName)
}
#endif
inline void NewAuthRequest::set_devicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.DeviceName)
}
inline void NewAuthRequest::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.DeviceName)
}
inline ::std::string* NewAuthRequest::mutable_devicename() {
  set_has_devicename();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.DeviceName)
  return devicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_devicename() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.DeviceName)
  clear_has_devicename();
  return devicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_devicename(::std::string* devicename) {
  if (devicename != NULL) {
    set_has_devicename();
  } else {
    clear_has_devicename();
  }
  devicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicename);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.DeviceName)
}

// optional .micromsg.SKBuiltinBuffer_t WTLoginReqBuff = 29;
inline bool NewAuthRequest::has_wtloginreqbuff() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void NewAuthRequest::set_has_wtloginreqbuff() {
  _has_bits_[0] |= 0x40000000u;
}
inline void NewAuthRequest::clear_has_wtloginreqbuff() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void NewAuthRequest::clear_wtloginreqbuff() {
  if (wtloginreqbuff_ != NULL) wtloginreqbuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_wtloginreqbuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthRequest::wtloginreqbuff() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.WTLoginReqBuff)
  return wtloginreqbuff_ != NULL ? *wtloginreqbuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::mutable_wtloginreqbuff() {
  set_has_wtloginreqbuff();
  if (wtloginreqbuff_ == NULL) {
    wtloginreqbuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.WTLoginReqBuff)
  return wtloginreqbuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::release_wtloginreqbuff() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.WTLoginReqBuff)
  clear_has_wtloginreqbuff();
  ::micromsg::SKBuiltinBuffer_t* temp = wtloginreqbuff_;
  wtloginreqbuff_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_wtloginreqbuff(::micromsg::SKBuiltinBuffer_t* wtloginreqbuff) {
  delete wtloginreqbuff_;
  wtloginreqbuff_ = wtloginreqbuff;
  if (wtloginreqbuff) {
    set_has_wtloginreqbuff();
  } else {
    clear_has_wtloginreqbuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.WTLoginReqBuff)
}

// optional uint32 InputType = 30;
inline bool NewAuthRequest::has_inputtype() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void NewAuthRequest::set_has_inputtype() {
  _has_bits_[1] |= 0x00000010u;
}
inline void NewAuthRequest::clear_has_inputtype() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void NewAuthRequest::clear_inputtype() {
  inputtype_ = 0u;
  clear_has_inputtype();
}
inline ::google::protobuf::uint32 NewAuthRequest::inputtype() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.InputType)
  return inputtype_;
}
inline void NewAuthRequest::set_inputtype(::google::protobuf::uint32 value) {
  set_has_inputtype();
  inputtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.InputType)
}

// optional string ClientSeqID = 31;
inline bool NewAuthRequest::has_clientseqid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NewAuthRequest::set_has_clientseqid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NewAuthRequest::clear_has_clientseqid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NewAuthRequest::clear_clientseqid() {
  clientseqid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientseqid();
}
inline const ::std::string& NewAuthRequest::clientseqid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.ClientSeqID)
  return clientseqid_.GetNoArena();
}
inline void NewAuthRequest::set_clientseqid(const ::std::string& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.ClientSeqID)
}
#if LANG_CXX11
inline void NewAuthRequest::set_clientseqid(::std::string&& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.ClientSeqID)
}
#endif
inline void NewAuthRequest::set_clientseqid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.ClientSeqID)
}
inline void NewAuthRequest::set_clientseqid(const char* value, size_t size) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.ClientSeqID)
}
inline ::std::string* NewAuthRequest::mutable_clientseqid() {
  set_has_clientseqid();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.ClientSeqID)
  return clientseqid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_clientseqid() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.ClientSeqID)
  clear_has_clientseqid();
  return clientseqid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_clientseqid(::std::string* clientseqid) {
  if (clientseqid != NULL) {
    set_has_clientseqid();
  } else {
    clear_has_clientseqid();
  }
  clientseqid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientseqid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.ClientSeqID)
}

// optional string BundleID = 32;
inline bool NewAuthRequest::has_bundleid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NewAuthRequest::set_has_bundleid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NewAuthRequest::clear_has_bundleid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NewAuthRequest::clear_bundleid() {
  bundleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bundleid();
}
inline const ::std::string& NewAuthRequest::bundleid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.BundleID)
  return bundleid_.GetNoArena();
}
inline void NewAuthRequest::set_bundleid(const ::std::string& value) {
  set_has_bundleid();
  bundleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.BundleID)
}
#if LANG_CXX11
inline void NewAuthRequest::set_bundleid(::std::string&& value) {
  set_has_bundleid();
  bundleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.BundleID)
}
#endif
inline void NewAuthRequest::set_bundleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bundleid();
  bundleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.BundleID)
}
inline void NewAuthRequest::set_bundleid(const char* value, size_t size) {
  set_has_bundleid();
  bundleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.BundleID)
}
inline ::std::string* NewAuthRequest::mutable_bundleid() {
  set_has_bundleid();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.BundleID)
  return bundleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_bundleid() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.BundleID)
  clear_has_bundleid();
  return bundleid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_bundleid(::std::string* bundleid) {
  if (bundleid != NULL) {
    set_has_bundleid();
  } else {
    clear_has_bundleid();
  }
  bundleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bundleid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.BundleID)
}

// optional string AdSource = 33;
inline bool NewAuthRequest::has_adsource() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NewAuthRequest::set_has_adsource() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NewAuthRequest::clear_has_adsource() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NewAuthRequest::clear_adsource() {
  adsource_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_adsource();
}
inline const ::std::string& NewAuthRequest::adsource() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.AdSource)
  return adsource_.GetNoArena();
}
inline void NewAuthRequest::set_adsource(const ::std::string& value) {
  set_has_adsource();
  adsource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.AdSource)
}
#if LANG_CXX11
inline void NewAuthRequest::set_adsource(::std::string&& value) {
  set_has_adsource();
  adsource_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.AdSource)
}
#endif
inline void NewAuthRequest::set_adsource(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_adsource();
  adsource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.AdSource)
}
inline void NewAuthRequest::set_adsource(const char* value, size_t size) {
  set_has_adsource();
  adsource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.AdSource)
}
inline ::std::string* NewAuthRequest::mutable_adsource() {
  set_has_adsource();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.AdSource)
  return adsource_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_adsource() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.AdSource)
  clear_has_adsource();
  return adsource_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_adsource(::std::string* adsource) {
  if (adsource != NULL) {
    set_has_adsource();
  } else {
    clear_has_adsource();
  }
  adsource_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adsource);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.AdSource)
}

// optional .micromsg.SKBuiltinBuffer_t CliDBEncryptKey = 34;
inline bool NewAuthRequest::has_clidbencryptkey() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void NewAuthRequest::set_has_clidbencryptkey() {
  _has_bits_[0] |= 0x80000000u;
}
inline void NewAuthRequest::clear_has_clidbencryptkey() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void NewAuthRequest::clear_clidbencryptkey() {
  if (clidbencryptkey_ != NULL) clidbencryptkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_clidbencryptkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthRequest::clidbencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.CliDBEncryptKey)
  return clidbencryptkey_ != NULL ? *clidbencryptkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::mutable_clidbencryptkey() {
  set_has_clidbencryptkey();
  if (clidbencryptkey_ == NULL) {
    clidbencryptkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.CliDBEncryptKey)
  return clidbencryptkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::release_clidbencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.CliDBEncryptKey)
  clear_has_clidbencryptkey();
  ::micromsg::SKBuiltinBuffer_t* temp = clidbencryptkey_;
  clidbencryptkey_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_clidbencryptkey(::micromsg::SKBuiltinBuffer_t* clidbencryptkey) {
  delete clidbencryptkey_;
  clidbencryptkey_ = clidbencryptkey;
  if (clidbencryptkey) {
    set_has_clidbencryptkey();
  } else {
    clear_has_clidbencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.CliDBEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t CliDBEncryptInfo = 35;
inline bool NewAuthRequest::has_clidbencryptinfo() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void NewAuthRequest::set_has_clidbencryptinfo() {
  _has_bits_[1] |= 0x00000001u;
}
inline void NewAuthRequest::clear_has_clidbencryptinfo() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void NewAuthRequest::clear_clidbencryptinfo() {
  if (clidbencryptinfo_ != NULL) clidbencryptinfo_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_clidbencryptinfo();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthRequest::clidbencryptinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.CliDBEncryptInfo)
  return clidbencryptinfo_ != NULL ? *clidbencryptinfo_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::mutable_clidbencryptinfo() {
  set_has_clidbencryptinfo();
  if (clidbencryptinfo_ == NULL) {
    clidbencryptinfo_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.CliDBEncryptInfo)
  return clidbencryptinfo_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthRequest::release_clidbencryptinfo() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.CliDBEncryptInfo)
  clear_has_clidbencryptinfo();
  ::micromsg::SKBuiltinBuffer_t* temp = clidbencryptinfo_;
  clidbencryptinfo_ = NULL;
  return temp;
}
inline void NewAuthRequest::set_allocated_clidbencryptinfo(::micromsg::SKBuiltinBuffer_t* clidbencryptinfo) {
  delete clidbencryptinfo_;
  clidbencryptinfo_ = clidbencryptinfo;
  if (clidbencryptinfo) {
    set_has_clidbencryptinfo();
  } else {
    clear_has_clidbencryptinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.CliDBEncryptInfo)
}

// optional string VerifySignature = 36;
inline bool NewAuthRequest::has_verifysignature() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NewAuthRequest::set_has_verifysignature() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NewAuthRequest::clear_has_verifysignature() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NewAuthRequest::clear_verifysignature() {
  verifysignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifysignature();
}
inline const ::std::string& NewAuthRequest::verifysignature() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.VerifySignature)
  return verifysignature_.GetNoArena();
}
inline void NewAuthRequest::set_verifysignature(const ::std::string& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.VerifySignature)
}
#if LANG_CXX11
inline void NewAuthRequest::set_verifysignature(::std::string&& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.VerifySignature)
}
#endif
inline void NewAuthRequest::set_verifysignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.VerifySignature)
}
inline void NewAuthRequest::set_verifysignature(const char* value, size_t size) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.VerifySignature)
}
inline ::std::string* NewAuthRequest::mutable_verifysignature() {
  set_has_verifysignature();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.VerifySignature)
  return verifysignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_verifysignature() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.VerifySignature)
  clear_has_verifysignature();
  return verifysignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_verifysignature(::std::string* verifysignature) {
  if (verifysignature != NULL) {
    set_has_verifysignature();
  } else {
    clear_has_verifysignature();
  }
  verifysignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifysignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.VerifySignature)
}

// optional string VerifyContent = 37;
inline bool NewAuthRequest::has_verifycontent() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NewAuthRequest::set_has_verifycontent() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NewAuthRequest::clear_has_verifycontent() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NewAuthRequest::clear_verifycontent() {
  verifycontent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifycontent();
}
inline const ::std::string& NewAuthRequest::verifycontent() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.VerifyContent)
  return verifycontent_.GetNoArena();
}
inline void NewAuthRequest::set_verifycontent(const ::std::string& value) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.VerifyContent)
}
#if LANG_CXX11
inline void NewAuthRequest::set_verifycontent(::std::string&& value) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthRequest.VerifyContent)
}
#endif
inline void NewAuthRequest::set_verifycontent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthRequest.VerifyContent)
}
inline void NewAuthRequest::set_verifycontent(const char* value, size_t size) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthRequest.VerifyContent)
}
inline ::std::string* NewAuthRequest::mutable_verifycontent() {
  set_has_verifycontent();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthRequest.VerifyContent)
  return verifycontent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthRequest::release_verifycontent() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthRequest.VerifyContent)
  clear_has_verifycontent();
  return verifycontent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthRequest::set_allocated_verifycontent(::std::string* verifycontent) {
  if (verifycontent != NULL) {
    set_has_verifycontent();
  } else {
    clear_has_verifycontent();
  }
  verifycontent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifycontent);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthRequest.VerifyContent)
}

// optional uint32 SessionMode = 38;
inline bool NewAuthRequest::has_sessionmode() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void NewAuthRequest::set_has_sessionmode() {
  _has_bits_[1] |= 0x00000020u;
}
inline void NewAuthRequest::clear_has_sessionmode() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void NewAuthRequest::clear_sessionmode() {
  sessionmode_ = 0u;
  clear_has_sessionmode();
}
inline ::google::protobuf::uint32 NewAuthRequest::sessionmode() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthRequest.SessionMode)
  return sessionmode_;
}
inline void NewAuthRequest::set_sessionmode(::google::protobuf::uint32 value) {
  set_has_sessionmode();
  sessionmode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthRequest.SessionMode)
}

// -------------------------------------------------------------------

// NewAuthResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool NewAuthResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NewAuthResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NewAuthResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NewAuthResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& NewAuthResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* NewAuthResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* NewAuthResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.BaseResponse)
}

// required uint32 Uin = 2;
inline bool NewAuthResponse::has_uin() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void NewAuthResponse::set_has_uin() {
  _has_bits_[1] |= 0x00000200u;
}
inline void NewAuthResponse::clear_has_uin() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void NewAuthResponse::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 NewAuthResponse::uin() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.Uin)
  return uin_;
}
inline void NewAuthResponse::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.Uin)
}

// required .micromsg.SKBuiltinString_t UserName = 3;
inline bool NewAuthResponse::has_username() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NewAuthResponse::set_has_username() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NewAuthResponse::clear_has_username() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NewAuthResponse::clear_username() {
  if (username_ != NULL) username_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_username();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthResponse::username() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.UserName)
  return username_ != NULL ? *username_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::mutable_username() {
  set_has_username();
  if (username_ == NULL) {
    username_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.UserName)
  return username_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.UserName)
  clear_has_username();
  ::micromsg::SKBuiltinString_t* temp = username_;
  username_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_username(::micromsg::SKBuiltinString_t* username) {
  delete username_;
  username_ = username;
  if (username) {
    set_has_username();
  } else {
    clear_has_username();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.UserName)
}

// required .micromsg.SKBuiltinString_t NickName = 4;
inline bool NewAuthResponse::has_nickname() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NewAuthResponse::set_has_nickname() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NewAuthResponse::clear_has_nickname() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NewAuthResponse::clear_nickname() {
  if (nickname_ != NULL) nickname_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_nickname();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthResponse::nickname() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.NickName)
  return nickname_ != NULL ? *nickname_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == NULL) {
    nickname_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.NickName)
  return nickname_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::release_nickname() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.NickName)
  clear_has_nickname();
  ::micromsg::SKBuiltinString_t* temp = nickname_;
  nickname_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_nickname(::micromsg::SKBuiltinString_t* nickname) {
  delete nickname_;
  nickname_ = nickname;
  if (nickname) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.NickName)
}

// required uint32 BindUin = 5;
inline bool NewAuthResponse::has_binduin() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void NewAuthResponse::set_has_binduin() {
  _has_bits_[1] |= 0x00000400u;
}
inline void NewAuthResponse::clear_has_binduin() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void NewAuthResponse::clear_binduin() {
  binduin_ = 0u;
  clear_has_binduin();
}
inline ::google::protobuf::uint32 NewAuthResponse::binduin() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.BindUin)
  return binduin_;
}
inline void NewAuthResponse::set_binduin(::google::protobuf::uint32 value) {
  set_has_binduin();
  binduin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.BindUin)
}

// required .micromsg.SKBuiltinString_t BindEmail = 6;
inline bool NewAuthResponse::has_bindemail() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NewAuthResponse::set_has_bindemail() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NewAuthResponse::clear_has_bindemail() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NewAuthResponse::clear_bindemail() {
  if (bindemail_ != NULL) bindemail_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_bindemail();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthResponse::bindemail() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.BindEmail)
  return bindemail_ != NULL ? *bindemail_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::mutable_bindemail() {
  set_has_bindemail();
  if (bindemail_ == NULL) {
    bindemail_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.BindEmail)
  return bindemail_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::release_bindemail() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.BindEmail)
  clear_has_bindemail();
  ::micromsg::SKBuiltinString_t* temp = bindemail_;
  bindemail_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_bindemail(::micromsg::SKBuiltinString_t* bindemail) {
  delete bindemail_;
  bindemail_ = bindemail;
  if (bindemail) {
    set_has_bindemail();
  } else {
    clear_has_bindemail();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.BindEmail)
}

// required .micromsg.SKBuiltinString_t BindMobile = 7;
inline bool NewAuthResponse::has_bindmobile() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NewAuthResponse::set_has_bindmobile() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NewAuthResponse::clear_has_bindmobile() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NewAuthResponse::clear_bindmobile() {
  if (bindmobile_ != NULL) bindmobile_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_bindmobile();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthResponse::bindmobile() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.BindMobile)
  return bindmobile_ != NULL ? *bindmobile_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::mutable_bindmobile() {
  set_has_bindmobile();
  if (bindmobile_ == NULL) {
    bindmobile_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.BindMobile)
  return bindmobile_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::release_bindmobile() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.BindMobile)
  clear_has_bindmobile();
  ::micromsg::SKBuiltinString_t* temp = bindmobile_;
  bindmobile_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_bindmobile(::micromsg::SKBuiltinString_t* bindmobile) {
  delete bindmobile_;
  bindmobile_ = bindmobile;
  if (bindmobile) {
    set_has_bindmobile();
  } else {
    clear_has_bindmobile();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.BindMobile)
}

// required uint32 Status = 8;
inline bool NewAuthResponse::has_status() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void NewAuthResponse::set_has_status() {
  _has_bits_[1] |= 0x00000800u;
}
inline void NewAuthResponse::clear_has_status() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void NewAuthResponse::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 NewAuthResponse::status() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.Status)
  return status_;
}
inline void NewAuthResponse::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.Status)
}

// optional bytes SessionKey = 9;
inline bool NewAuthResponse::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewAuthResponse::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewAuthResponse::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewAuthResponse::clear_sessionkey() {
  sessionkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sessionkey();
}
inline const ::std::string& NewAuthResponse::sessionkey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.SessionKey)
  return sessionkey_.GetNoArena();
}
inline void NewAuthResponse::set_sessionkey(const ::std::string& value) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.SessionKey)
}
#if LANG_CXX11
inline void NewAuthResponse::set_sessionkey(::std::string&& value) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.SessionKey)
}
#endif
inline void NewAuthResponse::set_sessionkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.SessionKey)
}
inline void NewAuthResponse::set_sessionkey(const void* value, size_t size) {
  set_has_sessionkey();
  sessionkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.SessionKey)
}
inline ::std::string* NewAuthResponse::mutable_sessionkey() {
  set_has_sessionkey();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.SessionKey)
  return sessionkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_sessionkey() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.SessionKey)
  clear_has_sessionkey();
  return sessionkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_sessionkey(::std::string* sessionkey) {
  if (sessionkey != NULL) {
    set_has_sessionkey();
  } else {
    clear_has_sessionkey();
  }
  sessionkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sessionkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.SessionKey)
}

// required .micromsg.SKBuiltinString_t ImgSid = 10;
inline bool NewAuthResponse::has_imgsid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NewAuthResponse::set_has_imgsid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NewAuthResponse::clear_has_imgsid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NewAuthResponse::clear_imgsid() {
  if (imgsid_ != NULL) imgsid_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgsid();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthResponse::imgsid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.ImgSid)
  return imgsid_ != NULL ? *imgsid_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::mutable_imgsid() {
  set_has_imgsid();
  if (imgsid_ == NULL) {
    imgsid_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.ImgSid)
  return imgsid_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::release_imgsid() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.ImgSid)
  clear_has_imgsid();
  ::micromsg::SKBuiltinString_t* temp = imgsid_;
  imgsid_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_imgsid(::micromsg::SKBuiltinString_t* imgsid) {
  delete imgsid_;
  imgsid_ = imgsid;
  if (imgsid) {
    set_has_imgsid();
  } else {
    clear_has_imgsid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.ImgSid)
}

// required .micromsg.SKBuiltinBuffer_t ImgBuf = 11;
inline bool NewAuthResponse::has_imgbuf() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NewAuthResponse::set_has_imgbuf() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NewAuthResponse::clear_has_imgbuf() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NewAuthResponse::clear_imgbuf() {
  if (imgbuf_ != NULL) imgbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_imgbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthResponse::imgbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.ImgBuf)
  return imgbuf_ != NULL ? *imgbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::mutable_imgbuf() {
  set_has_imgbuf();
  if (imgbuf_ == NULL) {
    imgbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.ImgBuf)
  return imgbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::release_imgbuf() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.ImgBuf)
  clear_has_imgbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = imgbuf_;
  imgbuf_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_imgbuf(::micromsg::SKBuiltinBuffer_t* imgbuf) {
  delete imgbuf_;
  imgbuf_ = imgbuf;
  if (imgbuf) {
    set_has_imgbuf();
  } else {
    clear_has_imgbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.ImgBuf)
}

// required .micromsg.SKBuiltinString_t OfficialUserName = 12;
inline bool NewAuthResponse::has_officialusername() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void NewAuthResponse::set_has_officialusername() {
  _has_bits_[0] |= 0x00800000u;
}
inline void NewAuthResponse::clear_has_officialusername() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void NewAuthResponse::clear_officialusername() {
  if (officialusername_ != NULL) officialusername_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_officialusername();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthResponse::officialusername() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.OfficialUserName)
  return officialusername_ != NULL ? *officialusername_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::mutable_officialusername() {
  set_has_officialusername();
  if (officialusername_ == NULL) {
    officialusername_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.OfficialUserName)
  return officialusername_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::release_officialusername() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.OfficialUserName)
  clear_has_officialusername();
  ::micromsg::SKBuiltinString_t* temp = officialusername_;
  officialusername_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_officialusername(::micromsg::SKBuiltinString_t* officialusername) {
  delete officialusername_;
  officialusername_ = officialusername;
  if (officialusername) {
    set_has_officialusername();
  } else {
    clear_has_officialusername();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.OfficialUserName)
}

// required .micromsg.SKBuiltinString_t OfficialNickName = 13;
inline bool NewAuthResponse::has_officialnickname() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void NewAuthResponse::set_has_officialnickname() {
  _has_bits_[0] |= 0x01000000u;
}
inline void NewAuthResponse::clear_has_officialnickname() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void NewAuthResponse::clear_officialnickname() {
  if (officialnickname_ != NULL) officialnickname_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_officialnickname();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthResponse::officialnickname() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.OfficialNickName)
  return officialnickname_ != NULL ? *officialnickname_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::mutable_officialnickname() {
  set_has_officialnickname();
  if (officialnickname_ == NULL) {
    officialnickname_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.OfficialNickName)
  return officialnickname_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::release_officialnickname() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.OfficialNickName)
  clear_has_officialnickname();
  ::micromsg::SKBuiltinString_t* temp = officialnickname_;
  officialnickname_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_officialnickname(::micromsg::SKBuiltinString_t* officialnickname) {
  delete officialnickname_;
  officialnickname_ = officialnickname;
  if (officialnickname) {
    set_has_officialnickname();
  } else {
    clear_has_officialnickname();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.OfficialNickName)
}

// optional .micromsg.SKBuiltinString_t QQMicroBlogUserName = 14;
inline bool NewAuthResponse::has_qqmicroblogusername() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void NewAuthResponse::set_has_qqmicroblogusername() {
  _has_bits_[0] |= 0x02000000u;
}
inline void NewAuthResponse::clear_has_qqmicroblogusername() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void NewAuthResponse::clear_qqmicroblogusername() {
  if (qqmicroblogusername_ != NULL) qqmicroblogusername_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_qqmicroblogusername();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthResponse::qqmicroblogusername() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.QQMicroBlogUserName)
  return qqmicroblogusername_ != NULL ? *qqmicroblogusername_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::mutable_qqmicroblogusername() {
  set_has_qqmicroblogusername();
  if (qqmicroblogusername_ == NULL) {
    qqmicroblogusername_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.QQMicroBlogUserName)
  return qqmicroblogusername_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::release_qqmicroblogusername() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.QQMicroBlogUserName)
  clear_has_qqmicroblogusername();
  ::micromsg::SKBuiltinString_t* temp = qqmicroblogusername_;
  qqmicroblogusername_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_qqmicroblogusername(::micromsg::SKBuiltinString_t* qqmicroblogusername) {
  delete qqmicroblogusername_;
  qqmicroblogusername_ = qqmicroblogusername;
  if (qqmicroblogusername) {
    set_has_qqmicroblogusername();
  } else {
    clear_has_qqmicroblogusername();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.QQMicroBlogUserName)
}

// optional uint32 QQMicroBlogStatus = 15;
inline bool NewAuthResponse::has_qqmicroblogstatus() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void NewAuthResponse::set_has_qqmicroblogstatus() {
  _has_bits_[1] |= 0x00001000u;
}
inline void NewAuthResponse::clear_has_qqmicroblogstatus() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void NewAuthResponse::clear_qqmicroblogstatus() {
  qqmicroblogstatus_ = 0u;
  clear_has_qqmicroblogstatus();
}
inline ::google::protobuf::uint32 NewAuthResponse::qqmicroblogstatus() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.QQMicroBlogStatus)
  return qqmicroblogstatus_;
}
inline void NewAuthResponse::set_qqmicroblogstatus(::google::protobuf::uint32 value) {
  set_has_qqmicroblogstatus();
  qqmicroblogstatus_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.QQMicroBlogStatus)
}

// optional uint32 NewVersion = 16;
inline bool NewAuthResponse::has_newversion() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void NewAuthResponse::set_has_newversion() {
  _has_bits_[1] |= 0x00002000u;
}
inline void NewAuthResponse::clear_has_newversion() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void NewAuthResponse::clear_newversion() {
  newversion_ = 0u;
  clear_has_newversion();
}
inline ::google::protobuf::uint32 NewAuthResponse::newversion() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.NewVersion)
  return newversion_;
}
inline void NewAuthResponse::set_newversion(::google::protobuf::uint32 value) {
  set_has_newversion();
  newversion_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.NewVersion)
}

// optional string Ticket = 17;
inline bool NewAuthResponse::has_ticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewAuthResponse::set_has_ticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewAuthResponse::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewAuthResponse::clear_ticket() {
  ticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ticket();
}
inline const ::std::string& NewAuthResponse::ticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.Ticket)
  return ticket_.GetNoArena();
}
inline void NewAuthResponse::set_ticket(const ::std::string& value) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.Ticket)
}
#if LANG_CXX11
inline void NewAuthResponse::set_ticket(::std::string&& value) {
  set_has_ticket();
  ticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.Ticket)
}
#endif
inline void NewAuthResponse::set_ticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.Ticket)
}
inline void NewAuthResponse::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  ticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.Ticket)
}
inline ::std::string* NewAuthResponse::mutable_ticket() {
  set_has_ticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.Ticket)
  return ticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_ticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.Ticket)
  clear_has_ticket();
  return ticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_ticket(::std::string* ticket) {
  if (ticket != NULL) {
    set_has_ticket();
  } else {
    clear_has_ticket();
  }
  ticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.Ticket)
}

// optional uint32 PushMailStatus = 18;
inline bool NewAuthResponse::has_pushmailstatus() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void NewAuthResponse::set_has_pushmailstatus() {
  _has_bits_[1] |= 0x00004000u;
}
inline void NewAuthResponse::clear_has_pushmailstatus() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void NewAuthResponse::clear_pushmailstatus() {
  pushmailstatus_ = 0u;
  clear_has_pushmailstatus();
}
inline ::google::protobuf::uint32 NewAuthResponse::pushmailstatus() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.PushMailStatus)
  return pushmailstatus_;
}
inline void NewAuthResponse::set_pushmailstatus(::google::protobuf::uint32 value) {
  set_has_pushmailstatus();
  pushmailstatus_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.PushMailStatus)
}

// optional uint32 SendCardBitFlag = 19;
inline bool NewAuthResponse::has_sendcardbitflag() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void NewAuthResponse::set_has_sendcardbitflag() {
  _has_bits_[1] |= 0x00008000u;
}
inline void NewAuthResponse::clear_has_sendcardbitflag() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void NewAuthResponse::clear_sendcardbitflag() {
  sendcardbitflag_ = 0u;
  clear_has_sendcardbitflag();
}
inline ::google::protobuf::uint32 NewAuthResponse::sendcardbitflag() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.SendCardBitFlag)
  return sendcardbitflag_;
}
inline void NewAuthResponse::set_sendcardbitflag(::google::protobuf::uint32 value) {
  set_has_sendcardbitflag();
  sendcardbitflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.SendCardBitFlag)
}

// optional string PushMailSettingTicket = 20;
inline bool NewAuthResponse::has_pushmailsettingticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewAuthResponse::set_has_pushmailsettingticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewAuthResponse::clear_has_pushmailsettingticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewAuthResponse::clear_pushmailsettingticket() {
  pushmailsettingticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pushmailsettingticket();
}
inline const ::std::string& NewAuthResponse::pushmailsettingticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.PushMailSettingTicket)
  return pushmailsettingticket_.GetNoArena();
}
inline void NewAuthResponse::set_pushmailsettingticket(const ::std::string& value) {
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.PushMailSettingTicket)
}
#if LANG_CXX11
inline void NewAuthResponse::set_pushmailsettingticket(::std::string&& value) {
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.PushMailSettingTicket)
}
#endif
inline void NewAuthResponse::set_pushmailsettingticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.PushMailSettingTicket)
}
inline void NewAuthResponse::set_pushmailsettingticket(const char* value, size_t size) {
  set_has_pushmailsettingticket();
  pushmailsettingticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.PushMailSettingTicket)
}
inline ::std::string* NewAuthResponse::mutable_pushmailsettingticket() {
  set_has_pushmailsettingticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.PushMailSettingTicket)
  return pushmailsettingticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_pushmailsettingticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.PushMailSettingTicket)
  clear_has_pushmailsettingticket();
  return pushmailsettingticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_pushmailsettingticket(::std::string* pushmailsettingticket) {
  if (pushmailsettingticket != NULL) {
    set_has_pushmailsettingticket();
  } else {
    clear_has_pushmailsettingticket();
  }
  pushmailsettingticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pushmailsettingticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.PushMailSettingTicket)
}

// optional .micromsg.BuiltinIPList BuiltinIPList = 21;
inline bool NewAuthResponse::has_builtiniplist() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void NewAuthResponse::set_has_builtiniplist() {
  _has_bits_[0] |= 0x04000000u;
}
inline void NewAuthResponse::clear_has_builtiniplist() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void NewAuthResponse::clear_builtiniplist() {
  if (builtiniplist_ != NULL) builtiniplist_->::micromsg::BuiltinIPList::Clear();
  clear_has_builtiniplist();
}
inline const ::micromsg::BuiltinIPList& NewAuthResponse::builtiniplist() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.BuiltinIPList)
  return builtiniplist_ != NULL ? *builtiniplist_
                         : *::micromsg::BuiltinIPList::internal_default_instance();
}
inline ::micromsg::BuiltinIPList* NewAuthResponse::mutable_builtiniplist() {
  set_has_builtiniplist();
  if (builtiniplist_ == NULL) {
    builtiniplist_ = new ::micromsg::BuiltinIPList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.BuiltinIPList)
  return builtiniplist_;
}
inline ::micromsg::BuiltinIPList* NewAuthResponse::release_builtiniplist() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.BuiltinIPList)
  clear_has_builtiniplist();
  ::micromsg::BuiltinIPList* temp = builtiniplist_;
  builtiniplist_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist) {
  delete builtiniplist_;
  builtiniplist_ = builtiniplist;
  if (builtiniplist) {
    set_has_builtiniplist();
  } else {
    clear_has_builtiniplist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.BuiltinIPList)
}

// optional string FSURL = 22;
inline bool NewAuthResponse::has_fsurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewAuthResponse::set_has_fsurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewAuthResponse::clear_has_fsurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewAuthResponse::clear_fsurl() {
  fsurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fsurl();
}
inline const ::std::string& NewAuthResponse::fsurl() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.FSURL)
  return fsurl_.GetNoArena();
}
inline void NewAuthResponse::set_fsurl(const ::std::string& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.FSURL)
}
#if LANG_CXX11
inline void NewAuthResponse::set_fsurl(::std::string&& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.FSURL)
}
#endif
inline void NewAuthResponse::set_fsurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.FSURL)
}
inline void NewAuthResponse::set_fsurl(const char* value, size_t size) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.FSURL)
}
inline ::std::string* NewAuthResponse::mutable_fsurl() {
  set_has_fsurl();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.FSURL)
  return fsurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_fsurl() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.FSURL)
  clear_has_fsurl();
  return fsurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_fsurl(::std::string* fsurl) {
  if (fsurl != NULL) {
    set_has_fsurl();
  } else {
    clear_has_fsurl();
  }
  fsurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fsurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.FSURL)
}

// optional .micromsg.NetworkControl NetworkControl = 23;
inline bool NewAuthResponse::has_networkcontrol() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void NewAuthResponse::set_has_networkcontrol() {
  _has_bits_[0] |= 0x08000000u;
}
inline void NewAuthResponse::clear_has_networkcontrol() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void NewAuthResponse::clear_networkcontrol() {
  if (networkcontrol_ != NULL) networkcontrol_->::micromsg::NetworkControl::Clear();
  clear_has_networkcontrol();
}
inline const ::micromsg::NetworkControl& NewAuthResponse::networkcontrol() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.NetworkControl)
  return networkcontrol_ != NULL ? *networkcontrol_
                         : *::micromsg::NetworkControl::internal_default_instance();
}
inline ::micromsg::NetworkControl* NewAuthResponse::mutable_networkcontrol() {
  set_has_networkcontrol();
  if (networkcontrol_ == NULL) {
    networkcontrol_ = new ::micromsg::NetworkControl;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.NetworkControl)
  return networkcontrol_;
}
inline ::micromsg::NetworkControl* NewAuthResponse::release_networkcontrol() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.NetworkControl)
  clear_has_networkcontrol();
  ::micromsg::NetworkControl* temp = networkcontrol_;
  networkcontrol_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol) {
  delete networkcontrol_;
  networkcontrol_ = networkcontrol;
  if (networkcontrol) {
    set_has_networkcontrol();
  } else {
    clear_has_networkcontrol();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.NetworkControl)
}

// optional uint32 PluginFlag = 24;
inline bool NewAuthResponse::has_pluginflag() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void NewAuthResponse::set_has_pluginflag() {
  _has_bits_[1] |= 0x00010000u;
}
inline void NewAuthResponse::clear_has_pluginflag() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void NewAuthResponse::clear_pluginflag() {
  pluginflag_ = 0u;
  clear_has_pluginflag();
}
inline ::google::protobuf::uint32 NewAuthResponse::pluginflag() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.PluginFlag)
  return pluginflag_;
}
inline void NewAuthResponse::set_pluginflag(::google::protobuf::uint32 value) {
  set_has_pluginflag();
  pluginflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.PluginFlag)
}

// optional string Alias = 25;
inline bool NewAuthResponse::has_alias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewAuthResponse::set_has_alias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewAuthResponse::clear_has_alias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewAuthResponse::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
inline const ::std::string& NewAuthResponse::alias() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.Alias)
  return alias_.GetNoArena();
}
inline void NewAuthResponse::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.Alias)
}
#if LANG_CXX11
inline void NewAuthResponse::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.Alias)
}
#endif
inline void NewAuthResponse::set_alias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.Alias)
}
inline void NewAuthResponse::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.Alias)
}
inline ::std::string* NewAuthResponse::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.Alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_alias() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.Alias)
  clear_has_alias();
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.Alias)
}

// optional uint32 RegType = 26;
inline bool NewAuthResponse::has_regtype() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void NewAuthResponse::set_has_regtype() {
  _has_bits_[1] |= 0x00020000u;
}
inline void NewAuthResponse::clear_has_regtype() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void NewAuthResponse::clear_regtype() {
  regtype_ = 0u;
  clear_has_regtype();
}
inline ::google::protobuf::uint32 NewAuthResponse::regtype() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.RegType)
  return regtype_;
}
inline void NewAuthResponse::set_regtype(::google::protobuf::uint32 value) {
  set_has_regtype();
  regtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.RegType)
}

// optional string AuthKey = 27;
inline bool NewAuthResponse::has_authkey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewAuthResponse::set_has_authkey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewAuthResponse::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewAuthResponse::clear_authkey() {
  authkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authkey();
}
inline const ::std::string& NewAuthResponse::authkey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.AuthKey)
  return authkey_.GetNoArena();
}
inline void NewAuthResponse::set_authkey(const ::std::string& value) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.AuthKey)
}
#if LANG_CXX11
inline void NewAuthResponse::set_authkey(::std::string&& value) {
  set_has_authkey();
  authkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.AuthKey)
}
#endif
inline void NewAuthResponse::set_authkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.AuthKey)
}
inline void NewAuthResponse::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.AuthKey)
}
inline ::std::string* NewAuthResponse::mutable_authkey() {
  set_has_authkey();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.AuthKey)
  return authkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_authkey() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.AuthKey)
  clear_has_authkey();
  return authkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_authkey(::std::string* authkey) {
  if (authkey != NULL) {
    set_has_authkey();
  } else {
    clear_has_authkey();
  }
  authkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.AuthKey)
}

// optional string Sid = 28;
inline bool NewAuthResponse::has_sid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewAuthResponse::set_has_sid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewAuthResponse::clear_has_sid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewAuthResponse::clear_sid() {
  sid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sid();
}
inline const ::std::string& NewAuthResponse::sid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.Sid)
  return sid_.GetNoArena();
}
inline void NewAuthResponse::set_sid(const ::std::string& value) {
  set_has_sid();
  sid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.Sid)
}
#if LANG_CXX11
inline void NewAuthResponse::set_sid(::std::string&& value) {
  set_has_sid();
  sid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.Sid)
}
#endif
inline void NewAuthResponse::set_sid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sid();
  sid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.Sid)
}
inline void NewAuthResponse::set_sid(const char* value, size_t size) {
  set_has_sid();
  sid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.Sid)
}
inline ::std::string* NewAuthResponse::mutable_sid() {
  set_has_sid();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.Sid)
  return sid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_sid() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.Sid)
  clear_has_sid();
  return sid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_sid(::std::string* sid) {
  if (sid != NULL) {
    set_has_sid();
  } else {
    clear_has_sid();
  }
  sid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.Sid)
}

// optional .micromsg.PluginKeyList PluginKeyList = 29;
inline bool NewAuthResponse::has_pluginkeylist() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void NewAuthResponse::set_has_pluginkeylist() {
  _has_bits_[0] |= 0x10000000u;
}
inline void NewAuthResponse::clear_has_pluginkeylist() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void NewAuthResponse::clear_pluginkeylist() {
  if (pluginkeylist_ != NULL) pluginkeylist_->::micromsg::PluginKeyList::Clear();
  clear_has_pluginkeylist();
}
inline const ::micromsg::PluginKeyList& NewAuthResponse::pluginkeylist() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.PluginKeyList)
  return pluginkeylist_ != NULL ? *pluginkeylist_
                         : *::micromsg::PluginKeyList::internal_default_instance();
}
inline ::micromsg::PluginKeyList* NewAuthResponse::mutable_pluginkeylist() {
  set_has_pluginkeylist();
  if (pluginkeylist_ == NULL) {
    pluginkeylist_ = new ::micromsg::PluginKeyList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.PluginKeyList)
  return pluginkeylist_;
}
inline ::micromsg::PluginKeyList* NewAuthResponse::release_pluginkeylist() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.PluginKeyList)
  clear_has_pluginkeylist();
  ::micromsg::PluginKeyList* temp = pluginkeylist_;
  pluginkeylist_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_pluginkeylist(::micromsg::PluginKeyList* pluginkeylist) {
  delete pluginkeylist_;
  pluginkeylist_ = pluginkeylist;
  if (pluginkeylist) {
    set_has_pluginkeylist();
  } else {
    clear_has_pluginkeylist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.PluginKeyList)
}

// optional .micromsg.SKBuiltinString_t ImgEncryptKey = 30;
inline bool NewAuthResponse::has_imgencryptkey() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void NewAuthResponse::set_has_imgencryptkey() {
  _has_bits_[0] |= 0x20000000u;
}
inline void NewAuthResponse::clear_has_imgencryptkey() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void NewAuthResponse::clear_imgencryptkey() {
  if (imgencryptkey_ != NULL) imgencryptkey_->::micromsg::SKBuiltinString_t::Clear();
  clear_has_imgencryptkey();
}
inline const ::micromsg::SKBuiltinString_t& NewAuthResponse::imgencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.ImgEncryptKey)
  return imgencryptkey_ != NULL ? *imgencryptkey_
                         : *::micromsg::SKBuiltinString_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::mutable_imgencryptkey() {
  set_has_imgencryptkey();
  if (imgencryptkey_ == NULL) {
    imgencryptkey_ = new ::micromsg::SKBuiltinString_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.ImgEncryptKey)
  return imgencryptkey_;
}
inline ::micromsg::SKBuiltinString_t* NewAuthResponse::release_imgencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.ImgEncryptKey)
  clear_has_imgencryptkey();
  ::micromsg::SKBuiltinString_t* temp = imgencryptkey_;
  imgencryptkey_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_imgencryptkey(::micromsg::SKBuiltinString_t* imgencryptkey) {
  delete imgencryptkey_;
  imgencryptkey_ = imgencryptkey;
  if (imgencryptkey) {
    set_has_imgencryptkey();
  } else {
    clear_has_imgencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.ImgEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t A2Key = 31;
inline bool NewAuthResponse::has_a2key() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void NewAuthResponse::set_has_a2key() {
  _has_bits_[0] |= 0x40000000u;
}
inline void NewAuthResponse::clear_has_a2key() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void NewAuthResponse::clear_a2key() {
  if (a2key_ != NULL) a2key_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_a2key();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthResponse::a2key() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.A2Key)
  return a2key_ != NULL ? *a2key_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::mutable_a2key() {
  set_has_a2key();
  if (a2key_ == NULL) {
    a2key_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.A2Key)
  return a2key_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::release_a2key() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.A2Key)
  clear_has_a2key();
  ::micromsg::SKBuiltinBuffer_t* temp = a2key_;
  a2key_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key) {
  delete a2key_;
  a2key_ = a2key;
  if (a2key) {
    set_has_a2key();
  } else {
    clear_has_a2key();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.A2Key)
}

// optional .micromsg.SKBuiltinBuffer_t KSid = 32;
inline bool NewAuthResponse::has_ksid() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void NewAuthResponse::set_has_ksid() {
  _has_bits_[0] |= 0x80000000u;
}
inline void NewAuthResponse::clear_has_ksid() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void NewAuthResponse::clear_ksid() {
  if (ksid_ != NULL) ksid_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_ksid();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthResponse::ksid() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.KSid)
  return ksid_ != NULL ? *ksid_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::mutable_ksid() {
  set_has_ksid();
  if (ksid_ == NULL) {
    ksid_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.KSid)
  return ksid_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::release_ksid() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.KSid)
  clear_has_ksid();
  ::micromsg::SKBuiltinBuffer_t* temp = ksid_;
  ksid_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid) {
  delete ksid_;
  ksid_ = ksid;
  if (ksid) {
    set_has_ksid();
  } else {
    clear_has_ksid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.KSid)
}

// optional uint32 ProfileFlag = 33;
inline bool NewAuthResponse::has_profileflag() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void NewAuthResponse::set_has_profileflag() {
  _has_bits_[1] |= 0x00040000u;
}
inline void NewAuthResponse::clear_has_profileflag() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void NewAuthResponse::clear_profileflag() {
  profileflag_ = 0u;
  clear_has_profileflag();
}
inline ::google::protobuf::uint32 NewAuthResponse::profileflag() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.ProfileFlag)
  return profileflag_;
}
inline void NewAuthResponse::set_profileflag(::google::protobuf::uint32 value) {
  set_has_profileflag();
  profileflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.ProfileFlag)
}

// optional string Password = 34;
inline bool NewAuthResponse::has_password() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NewAuthResponse::set_has_password() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NewAuthResponse::clear_has_password() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NewAuthResponse::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& NewAuthResponse::password() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.Password)
  return password_.GetNoArena();
}
inline void NewAuthResponse::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.Password)
}
#if LANG_CXX11
inline void NewAuthResponse::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.Password)
}
#endif
inline void NewAuthResponse::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.Password)
}
inline void NewAuthResponse::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.Password)
}
inline ::std::string* NewAuthResponse::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.Password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_password() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.Password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.Password)
}

// optional uint32 TimeStamp = 35;
inline bool NewAuthResponse::has_timestamp() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void NewAuthResponse::set_has_timestamp() {
  _has_bits_[1] |= 0x00080000u;
}
inline void NewAuthResponse::clear_has_timestamp() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void NewAuthResponse::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 NewAuthResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.TimeStamp)
  return timestamp_;
}
inline void NewAuthResponse::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.TimeStamp)
}

// optional uint32 IsAutoReg = 36;
inline bool NewAuthResponse::has_isautoreg() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void NewAuthResponse::set_has_isautoreg() {
  _has_bits_[1] |= 0x00100000u;
}
inline void NewAuthResponse::clear_has_isautoreg() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void NewAuthResponse::clear_isautoreg() {
  isautoreg_ = 0u;
  clear_has_isautoreg();
}
inline ::google::protobuf::uint32 NewAuthResponse::isautoreg() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.IsAutoReg)
  return isautoreg_;
}
inline void NewAuthResponse::set_isautoreg(::google::protobuf::uint32 value) {
  set_has_isautoreg();
  isautoreg_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.IsAutoReg)
}

// optional string KickResponse = 37;
inline bool NewAuthResponse::has_kickresponse() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NewAuthResponse::set_has_kickresponse() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NewAuthResponse::clear_has_kickresponse() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NewAuthResponse::clear_kickresponse() {
  kickresponse_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_kickresponse();
}
inline const ::std::string& NewAuthResponse::kickresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.KickResponse)
  return kickresponse_.GetNoArena();
}
inline void NewAuthResponse::set_kickresponse(const ::std::string& value) {
  set_has_kickresponse();
  kickresponse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.KickResponse)
}
#if LANG_CXX11
inline void NewAuthResponse::set_kickresponse(::std::string&& value) {
  set_has_kickresponse();
  kickresponse_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.KickResponse)
}
#endif
inline void NewAuthResponse::set_kickresponse(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_kickresponse();
  kickresponse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.KickResponse)
}
inline void NewAuthResponse::set_kickresponse(const char* value, size_t size) {
  set_has_kickresponse();
  kickresponse_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.KickResponse)
}
inline ::std::string* NewAuthResponse::mutable_kickresponse() {
  set_has_kickresponse();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.KickResponse)
  return kickresponse_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_kickresponse() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.KickResponse)
  clear_has_kickresponse();
  return kickresponse_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_kickresponse(::std::string* kickresponse) {
  if (kickresponse != NULL) {
    set_has_kickresponse();
  } else {
    clear_has_kickresponse();
  }
  kickresponse_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kickresponse);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.KickResponse)
}

// optional string ApplyBetaUrl = 38;
inline bool NewAuthResponse::has_applybetaurl() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NewAuthResponse::set_has_applybetaurl() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NewAuthResponse::clear_has_applybetaurl() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NewAuthResponse::clear_applybetaurl() {
  applybetaurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_applybetaurl();
}
inline const ::std::string& NewAuthResponse::applybetaurl() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.ApplyBetaUrl)
  return applybetaurl_.GetNoArena();
}
inline void NewAuthResponse::set_applybetaurl(const ::std::string& value) {
  set_has_applybetaurl();
  applybetaurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.ApplyBetaUrl)
}
#if LANG_CXX11
inline void NewAuthResponse::set_applybetaurl(::std::string&& value) {
  set_has_applybetaurl();
  applybetaurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.ApplyBetaUrl)
}
#endif
inline void NewAuthResponse::set_applybetaurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_applybetaurl();
  applybetaurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.ApplyBetaUrl)
}
inline void NewAuthResponse::set_applybetaurl(const char* value, size_t size) {
  set_has_applybetaurl();
  applybetaurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.ApplyBetaUrl)
}
inline ::std::string* NewAuthResponse::mutable_applybetaurl() {
  set_has_applybetaurl();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.ApplyBetaUrl)
  return applybetaurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_applybetaurl() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.ApplyBetaUrl)
  clear_has_applybetaurl();
  return applybetaurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_applybetaurl(::std::string* applybetaurl) {
  if (applybetaurl != NULL) {
    set_has_applybetaurl();
  } else {
    clear_has_applybetaurl();
  }
  applybetaurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), applybetaurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.ApplyBetaUrl)
}

// optional string DeviceInfoXml = 39;
inline bool NewAuthResponse::has_deviceinfoxml() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NewAuthResponse::set_has_deviceinfoxml() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NewAuthResponse::clear_has_deviceinfoxml() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NewAuthResponse::clear_deviceinfoxml() {
  deviceinfoxml_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_deviceinfoxml();
}
inline const ::std::string& NewAuthResponse::deviceinfoxml() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.DeviceInfoXml)
  return deviceinfoxml_.GetNoArena();
}
inline void NewAuthResponse::set_deviceinfoxml(const ::std::string& value) {
  set_has_deviceinfoxml();
  deviceinfoxml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.DeviceInfoXml)
}
#if LANG_CXX11
inline void NewAuthResponse::set_deviceinfoxml(::std::string&& value) {
  set_has_deviceinfoxml();
  deviceinfoxml_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.DeviceInfoXml)
}
#endif
inline void NewAuthResponse::set_deviceinfoxml(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_deviceinfoxml();
  deviceinfoxml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.DeviceInfoXml)
}
inline void NewAuthResponse::set_deviceinfoxml(const char* value, size_t size) {
  set_has_deviceinfoxml();
  deviceinfoxml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.DeviceInfoXml)
}
inline ::std::string* NewAuthResponse::mutable_deviceinfoxml() {
  set_has_deviceinfoxml();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.DeviceInfoXml)
  return deviceinfoxml_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_deviceinfoxml() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.DeviceInfoXml)
  clear_has_deviceinfoxml();
  return deviceinfoxml_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_deviceinfoxml(::std::string* deviceinfoxml) {
  if (deviceinfoxml != NULL) {
    set_has_deviceinfoxml();
  } else {
    clear_has_deviceinfoxml();
  }
  deviceinfoxml_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceinfoxml);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.DeviceInfoXml)
}

// optional string SoftConfigXml = 40;
inline bool NewAuthResponse::has_softconfigxml() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NewAuthResponse::set_has_softconfigxml() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NewAuthResponse::clear_has_softconfigxml() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NewAuthResponse::clear_softconfigxml() {
  softconfigxml_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_softconfigxml();
}
inline const ::std::string& NewAuthResponse::softconfigxml() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.SoftConfigXml)
  return softconfigxml_.GetNoArena();
}
inline void NewAuthResponse::set_softconfigxml(const ::std::string& value) {
  set_has_softconfigxml();
  softconfigxml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.SoftConfigXml)
}
#if LANG_CXX11
inline void NewAuthResponse::set_softconfigxml(::std::string&& value) {
  set_has_softconfigxml();
  softconfigxml_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.SoftConfigXml)
}
#endif
inline void NewAuthResponse::set_softconfigxml(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_softconfigxml();
  softconfigxml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.SoftConfigXml)
}
inline void NewAuthResponse::set_softconfigxml(const char* value, size_t size) {
  set_has_softconfigxml();
  softconfigxml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.SoftConfigXml)
}
inline ::std::string* NewAuthResponse::mutable_softconfigxml() {
  set_has_softconfigxml();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.SoftConfigXml)
  return softconfigxml_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_softconfigxml() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.SoftConfigXml)
  clear_has_softconfigxml();
  return softconfigxml_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_softconfigxml(::std::string* softconfigxml) {
  if (softconfigxml != NULL) {
    set_has_softconfigxml();
  } else {
    clear_has_softconfigxml();
  }
  softconfigxml_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), softconfigxml);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.SoftConfigXml)
}

// optional .micromsg.HostList NewHostList = 41;
inline bool NewAuthResponse::has_newhostlist() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void NewAuthResponse::set_has_newhostlist() {
  _has_bits_[1] |= 0x00000001u;
}
inline void NewAuthResponse::clear_has_newhostlist() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void NewAuthResponse::clear_newhostlist() {
  if (newhostlist_ != NULL) newhostlist_->::micromsg::HostList::Clear();
  clear_has_newhostlist();
}
inline const ::micromsg::HostList& NewAuthResponse::newhostlist() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.NewHostList)
  return newhostlist_ != NULL ? *newhostlist_
                         : *::micromsg::HostList::internal_default_instance();
}
inline ::micromsg::HostList* NewAuthResponse::mutable_newhostlist() {
  set_has_newhostlist();
  if (newhostlist_ == NULL) {
    newhostlist_ = new ::micromsg::HostList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.NewHostList)
  return newhostlist_;
}
inline ::micromsg::HostList* NewAuthResponse::release_newhostlist() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.NewHostList)
  clear_has_newhostlist();
  ::micromsg::HostList* temp = newhostlist_;
  newhostlist_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_newhostlist(::micromsg::HostList* newhostlist) {
  delete newhostlist_;
  newhostlist_ = newhostlist;
  if (newhostlist) {
    set_has_newhostlist();
  } else {
    clear_has_newhostlist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.NewHostList)
}

// optional string AuthTicket = 42;
inline bool NewAuthResponse::has_authticket() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NewAuthResponse::set_has_authticket() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NewAuthResponse::clear_has_authticket() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NewAuthResponse::clear_authticket() {
  authticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authticket();
}
inline const ::std::string& NewAuthResponse::authticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.AuthTicket)
  return authticket_.GetNoArena();
}
inline void NewAuthResponse::set_authticket(const ::std::string& value) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.AuthTicket)
}
#if LANG_CXX11
inline void NewAuthResponse::set_authticket(::std::string&& value) {
  set_has_authticket();
  authticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.AuthTicket)
}
#endif
inline void NewAuthResponse::set_authticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.AuthTicket)
}
inline void NewAuthResponse::set_authticket(const char* value, size_t size) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.AuthTicket)
}
inline ::std::string* NewAuthResponse::mutable_authticket() {
  set_has_authticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.AuthTicket)
  return authticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_authticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.AuthTicket)
  clear_has_authticket();
  return authticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_authticket(::std::string* authticket) {
  if (authticket != NULL) {
    set_has_authticket();
  } else {
    clear_has_authticket();
  }
  authticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.AuthTicket)
}

// optional uint32 SafeDevice = 43;
inline bool NewAuthResponse::has_safedevice() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void NewAuthResponse::set_has_safedevice() {
  _has_bits_[1] |= 0x00200000u;
}
inline void NewAuthResponse::clear_has_safedevice() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void NewAuthResponse::clear_safedevice() {
  safedevice_ = 0u;
  clear_has_safedevice();
}
inline ::google::protobuf::uint32 NewAuthResponse::safedevice() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.SafeDevice)
  return safedevice_;
}
inline void NewAuthResponse::set_safedevice(::google::protobuf::uint32 value) {
  set_has_safedevice();
  safedevice_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.SafeDevice)
}

// optional uint32 ObsoleteItem1 = 44;
inline bool NewAuthResponse::has_obsoleteitem1() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void NewAuthResponse::set_has_obsoleteitem1() {
  _has_bits_[1] |= 0x00400000u;
}
inline void NewAuthResponse::clear_has_obsoleteitem1() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void NewAuthResponse::clear_obsoleteitem1() {
  obsoleteitem1_ = 0u;
  clear_has_obsoleteitem1();
}
inline ::google::protobuf::uint32 NewAuthResponse::obsoleteitem1() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.ObsoleteItem1)
  return obsoleteitem1_;
}
inline void NewAuthResponse::set_obsoleteitem1(::google::protobuf::uint32 value) {
  set_has_obsoleteitem1();
  obsoleteitem1_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.ObsoleteItem1)
}

// optional uint32 NeedSetEmailPwd = 45;
inline bool NewAuthResponse::has_needsetemailpwd() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void NewAuthResponse::set_has_needsetemailpwd() {
  _has_bits_[1] |= 0x00800000u;
}
inline void NewAuthResponse::clear_has_needsetemailpwd() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void NewAuthResponse::clear_needsetemailpwd() {
  needsetemailpwd_ = 0u;
  clear_has_needsetemailpwd();
}
inline ::google::protobuf::uint32 NewAuthResponse::needsetemailpwd() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.NeedSetEmailPwd)
  return needsetemailpwd_;
}
inline void NewAuthResponse::set_needsetemailpwd(::google::protobuf::uint32 value) {
  set_has_needsetemailpwd();
  needsetemailpwd_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.NeedSetEmailPwd)
}

// optional string HintMsg = 46;
inline bool NewAuthResponse::has_hintmsg() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NewAuthResponse::set_has_hintmsg() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NewAuthResponse::clear_has_hintmsg() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NewAuthResponse::clear_hintmsg() {
  hintmsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hintmsg();
}
inline const ::std::string& NewAuthResponse::hintmsg() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.HintMsg)
  return hintmsg_.GetNoArena();
}
inline void NewAuthResponse::set_hintmsg(const ::std::string& value) {
  set_has_hintmsg();
  hintmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.HintMsg)
}
#if LANG_CXX11
inline void NewAuthResponse::set_hintmsg(::std::string&& value) {
  set_has_hintmsg();
  hintmsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.HintMsg)
}
#endif
inline void NewAuthResponse::set_hintmsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hintmsg();
  hintmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.HintMsg)
}
inline void NewAuthResponse::set_hintmsg(const char* value, size_t size) {
  set_has_hintmsg();
  hintmsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.HintMsg)
}
inline ::std::string* NewAuthResponse::mutable_hintmsg() {
  set_has_hintmsg();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.HintMsg)
  return hintmsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_hintmsg() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.HintMsg)
  clear_has_hintmsg();
  return hintmsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_hintmsg(::std::string* hintmsg) {
  if (hintmsg != NULL) {
    set_has_hintmsg();
  } else {
    clear_has_hintmsg();
  }
  hintmsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hintmsg);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.HintMsg)
}

// optional string AutoAuthTicket = 47;
inline bool NewAuthResponse::has_autoauthticket() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NewAuthResponse::set_has_autoauthticket() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NewAuthResponse::clear_has_autoauthticket() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NewAuthResponse::clear_autoauthticket() {
  autoauthticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_autoauthticket();
}
inline const ::std::string& NewAuthResponse::autoauthticket() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.AutoAuthTicket)
  return autoauthticket_.GetNoArena();
}
inline void NewAuthResponse::set_autoauthticket(const ::std::string& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.AutoAuthTicket)
}
#if LANG_CXX11
inline void NewAuthResponse::set_autoauthticket(::std::string&& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.AutoAuthTicket)
}
#endif
inline void NewAuthResponse::set_autoauthticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.AutoAuthTicket)
}
inline void NewAuthResponse::set_autoauthticket(const char* value, size_t size) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.AutoAuthTicket)
}
inline ::std::string* NewAuthResponse::mutable_autoauthticket() {
  set_has_autoauthticket();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.AutoAuthTicket)
  return autoauthticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_autoauthticket() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.AutoAuthTicket)
  clear_has_autoauthticket();
  return autoauthticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_autoauthticket(::std::string* autoauthticket) {
  if (autoauthticket != NULL) {
    set_has_autoauthticket();
  } else {
    clear_has_autoauthticket();
  }
  autoauthticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), autoauthticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.AutoAuthTicket)
}

// optional .micromsg.CDNDnsInfo DnsInfo = 48;
inline bool NewAuthResponse::has_dnsinfo() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void NewAuthResponse::set_has_dnsinfo() {
  _has_bits_[1] |= 0x00000002u;
}
inline void NewAuthResponse::clear_has_dnsinfo() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void NewAuthResponse::clear_dnsinfo() {
  if (dnsinfo_ != NULL) dnsinfo_->::micromsg::CDNDnsInfo::Clear();
  clear_has_dnsinfo();
}
inline const ::micromsg::CDNDnsInfo& NewAuthResponse::dnsinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.DnsInfo)
  return dnsinfo_ != NULL ? *dnsinfo_
                         : *::micromsg::CDNDnsInfo::internal_default_instance();
}
inline ::micromsg::CDNDnsInfo* NewAuthResponse::mutable_dnsinfo() {
  set_has_dnsinfo();
  if (dnsinfo_ == NULL) {
    dnsinfo_ = new ::micromsg::CDNDnsInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.DnsInfo)
  return dnsinfo_;
}
inline ::micromsg::CDNDnsInfo* NewAuthResponse::release_dnsinfo() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.DnsInfo)
  clear_has_dnsinfo();
  ::micromsg::CDNDnsInfo* temp = dnsinfo_;
  dnsinfo_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_dnsinfo(::micromsg::CDNDnsInfo* dnsinfo) {
  delete dnsinfo_;
  dnsinfo_ = dnsinfo;
  if (dnsinfo) {
    set_has_dnsinfo();
  } else {
    clear_has_dnsinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.DnsInfo)
}

// optional uint32 NextAuthType = 49;
inline bool NewAuthResponse::has_nextauthtype() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void NewAuthResponse::set_has_nextauthtype() {
  _has_bits_[1] |= 0x01000000u;
}
inline void NewAuthResponse::clear_has_nextauthtype() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void NewAuthResponse::clear_nextauthtype() {
  nextauthtype_ = 0u;
  clear_has_nextauthtype();
}
inline ::google::protobuf::uint32 NewAuthResponse::nextauthtype() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.NextAuthType)
  return nextauthtype_;
}
inline void NewAuthResponse::set_nextauthtype(::google::protobuf::uint32 value) {
  set_has_nextauthtype();
  nextauthtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.NextAuthType)
}

// optional .micromsg.SKBuiltinBuffer_t WTLoginRspBuff = 50;
inline bool NewAuthResponse::has_wtloginrspbuff() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void NewAuthResponse::set_has_wtloginrspbuff() {
  _has_bits_[1] |= 0x00000004u;
}
inline void NewAuthResponse::clear_has_wtloginrspbuff() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void NewAuthResponse::clear_wtloginrspbuff() {
  if (wtloginrspbuff_ != NULL) wtloginrspbuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_wtloginrspbuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthResponse::wtloginrspbuff() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.WTLoginRspBuff)
  return wtloginrspbuff_ != NULL ? *wtloginrspbuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::mutable_wtloginrspbuff() {
  set_has_wtloginrspbuff();
  if (wtloginrspbuff_ == NULL) {
    wtloginrspbuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.WTLoginRspBuff)
  return wtloginrspbuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::release_wtloginrspbuff() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.WTLoginRspBuff)
  clear_has_wtloginrspbuff();
  ::micromsg::SKBuiltinBuffer_t* temp = wtloginrspbuff_;
  wtloginrspbuff_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_wtloginrspbuff(::micromsg::SKBuiltinBuffer_t* wtloginrspbuff) {
  delete wtloginrspbuff_;
  wtloginrspbuff_ = wtloginrspbuff;
  if (wtloginrspbuff) {
    set_has_wtloginrspbuff();
  } else {
    clear_has_wtloginrspbuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.WTLoginRspBuff)
}

// optional .micromsg.ShowStyleKey ShowStyle = 51;
inline bool NewAuthResponse::has_showstyle() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void NewAuthResponse::set_has_showstyle() {
  _has_bits_[1] |= 0x00000008u;
}
inline void NewAuthResponse::clear_has_showstyle() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void NewAuthResponse::clear_showstyle() {
  if (showstyle_ != NULL) showstyle_->::micromsg::ShowStyleKey::Clear();
  clear_has_showstyle();
}
inline const ::micromsg::ShowStyleKey& NewAuthResponse::showstyle() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.ShowStyle)
  return showstyle_ != NULL ? *showstyle_
                         : *::micromsg::ShowStyleKey::internal_default_instance();
}
inline ::micromsg::ShowStyleKey* NewAuthResponse::mutable_showstyle() {
  set_has_showstyle();
  if (showstyle_ == NULL) {
    showstyle_ = new ::micromsg::ShowStyleKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.ShowStyle)
  return showstyle_;
}
inline ::micromsg::ShowStyleKey* NewAuthResponse::release_showstyle() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.ShowStyle)
  clear_has_showstyle();
  ::micromsg::ShowStyleKey* temp = showstyle_;
  showstyle_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle) {
  delete showstyle_;
  showstyle_ = showstyle;
  if (showstyle) {
    set_has_showstyle();
  } else {
    clear_has_showstyle();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.ShowStyle)
}

// optional .micromsg.SKBuiltinBuffer_t CliDBEncryptKey = 52;
inline bool NewAuthResponse::has_clidbencryptkey() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void NewAuthResponse::set_has_clidbencryptkey() {
  _has_bits_[1] |= 0x00000010u;
}
inline void NewAuthResponse::clear_has_clidbencryptkey() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void NewAuthResponse::clear_clidbencryptkey() {
  if (clidbencryptkey_ != NULL) clidbencryptkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_clidbencryptkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthResponse::clidbencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.CliDBEncryptKey)
  return clidbencryptkey_ != NULL ? *clidbencryptkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::mutable_clidbencryptkey() {
  set_has_clidbencryptkey();
  if (clidbencryptkey_ == NULL) {
    clidbencryptkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.CliDBEncryptKey)
  return clidbencryptkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::release_clidbencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.CliDBEncryptKey)
  clear_has_clidbencryptkey();
  ::micromsg::SKBuiltinBuffer_t* temp = clidbencryptkey_;
  clidbencryptkey_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_clidbencryptkey(::micromsg::SKBuiltinBuffer_t* clidbencryptkey) {
  delete clidbencryptkey_;
  clidbencryptkey_ = clidbencryptkey;
  if (clidbencryptkey) {
    set_has_clidbencryptkey();
  } else {
    clear_has_clidbencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.CliDBEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t CliDBEncryptInfo = 53;
inline bool NewAuthResponse::has_clidbencryptinfo() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void NewAuthResponse::set_has_clidbencryptinfo() {
  _has_bits_[1] |= 0x00000020u;
}
inline void NewAuthResponse::clear_has_clidbencryptinfo() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void NewAuthResponse::clear_clidbencryptinfo() {
  if (clidbencryptinfo_ != NULL) clidbencryptinfo_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_clidbencryptinfo();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthResponse::clidbencryptinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.CliDBEncryptInfo)
  return clidbencryptinfo_ != NULL ? *clidbencryptinfo_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::mutable_clidbencryptinfo() {
  set_has_clidbencryptinfo();
  if (clidbencryptinfo_ == NULL) {
    clidbencryptinfo_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.CliDBEncryptInfo)
  return clidbencryptinfo_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::release_clidbencryptinfo() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.CliDBEncryptInfo)
  clear_has_clidbencryptinfo();
  ::micromsg::SKBuiltinBuffer_t* temp = clidbencryptinfo_;
  clidbencryptinfo_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_clidbencryptinfo(::micromsg::SKBuiltinBuffer_t* clidbencryptinfo) {
  delete clidbencryptinfo_;
  clidbencryptinfo_ = clidbencryptinfo;
  if (clidbencryptinfo) {
    set_has_clidbencryptinfo();
  } else {
    clear_has_clidbencryptinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.CliDBEncryptInfo)
}

// optional uint32 Flag = 54;
inline bool NewAuthResponse::has_flag() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void NewAuthResponse::set_has_flag() {
  _has_bits_[1] |= 0x02000000u;
}
inline void NewAuthResponse::clear_has_flag() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void NewAuthResponse::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 NewAuthResponse::flag() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.Flag)
  return flag_;
}
inline void NewAuthResponse::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.Flag)
}

// optional .micromsg.CDNDnsInfo SnsDnsInfo = 55;
inline bool NewAuthResponse::has_snsdnsinfo() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void NewAuthResponse::set_has_snsdnsinfo() {
  _has_bits_[1] |= 0x00000040u;
}
inline void NewAuthResponse::clear_has_snsdnsinfo() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void NewAuthResponse::clear_snsdnsinfo() {
  if (snsdnsinfo_ != NULL) snsdnsinfo_->::micromsg::CDNDnsInfo::Clear();
  clear_has_snsdnsinfo();
}
inline const ::micromsg::CDNDnsInfo& NewAuthResponse::snsdnsinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.SnsDnsInfo)
  return snsdnsinfo_ != NULL ? *snsdnsinfo_
                         : *::micromsg::CDNDnsInfo::internal_default_instance();
}
inline ::micromsg::CDNDnsInfo* NewAuthResponse::mutable_snsdnsinfo() {
  set_has_snsdnsinfo();
  if (snsdnsinfo_ == NULL) {
    snsdnsinfo_ = new ::micromsg::CDNDnsInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.SnsDnsInfo)
  return snsdnsinfo_;
}
inline ::micromsg::CDNDnsInfo* NewAuthResponse::release_snsdnsinfo() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.SnsDnsInfo)
  clear_has_snsdnsinfo();
  ::micromsg::CDNDnsInfo* temp = snsdnsinfo_;
  snsdnsinfo_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_snsdnsinfo(::micromsg::CDNDnsInfo* snsdnsinfo) {
  delete snsdnsinfo_;
  snsdnsinfo_ = snsdnsinfo;
  if (snsdnsinfo) {
    set_has_snsdnsinfo();
  } else {
    clear_has_snsdnsinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.SnsDnsInfo)
}

// optional .micromsg.CDNDnsInfo AppDnsInfo = 56;
inline bool NewAuthResponse::has_appdnsinfo() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void NewAuthResponse::set_has_appdnsinfo() {
  _has_bits_[1] |= 0x00000080u;
}
inline void NewAuthResponse::clear_has_appdnsinfo() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void NewAuthResponse::clear_appdnsinfo() {
  if (appdnsinfo_ != NULL) appdnsinfo_->::micromsg::CDNDnsInfo::Clear();
  clear_has_appdnsinfo();
}
inline const ::micromsg::CDNDnsInfo& NewAuthResponse::appdnsinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.AppDnsInfo)
  return appdnsinfo_ != NULL ? *appdnsinfo_
                         : *::micromsg::CDNDnsInfo::internal_default_instance();
}
inline ::micromsg::CDNDnsInfo* NewAuthResponse::mutable_appdnsinfo() {
  set_has_appdnsinfo();
  if (appdnsinfo_ == NULL) {
    appdnsinfo_ = new ::micromsg::CDNDnsInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.AppDnsInfo)
  return appdnsinfo_;
}
inline ::micromsg::CDNDnsInfo* NewAuthResponse::release_appdnsinfo() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.AppDnsInfo)
  clear_has_appdnsinfo();
  ::micromsg::CDNDnsInfo* temp = appdnsinfo_;
  appdnsinfo_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_appdnsinfo(::micromsg::CDNDnsInfo* appdnsinfo) {
  delete appdnsinfo_;
  appdnsinfo_ = appdnsinfo;
  if (appdnsinfo) {
    set_has_appdnsinfo();
  } else {
    clear_has_appdnsinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.AppDnsInfo)
}

// optional string VerifySignature = 57;
inline bool NewAuthResponse::has_verifysignature() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NewAuthResponse::set_has_verifysignature() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NewAuthResponse::clear_has_verifysignature() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NewAuthResponse::clear_verifysignature() {
  verifysignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifysignature();
}
inline const ::std::string& NewAuthResponse::verifysignature() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.VerifySignature)
  return verifysignature_.GetNoArena();
}
inline void NewAuthResponse::set_verifysignature(const ::std::string& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.NewAuthResponse.VerifySignature)
}
#if LANG_CXX11
inline void NewAuthResponse::set_verifysignature(::std::string&& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.NewAuthResponse.VerifySignature)
}
#endif
inline void NewAuthResponse::set_verifysignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.NewAuthResponse.VerifySignature)
}
inline void NewAuthResponse::set_verifysignature(const char* value, size_t size) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.NewAuthResponse.VerifySignature)
}
inline ::std::string* NewAuthResponse::mutable_verifysignature() {
  set_has_verifysignature();
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.VerifySignature)
  return verifysignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewAuthResponse::release_verifysignature() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.VerifySignature)
  clear_has_verifysignature();
  return verifysignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewAuthResponse::set_allocated_verifysignature(::std::string* verifysignature) {
  if (verifysignature != NULL) {
    set_has_verifysignature();
  } else {
    clear_has_verifysignature();
  }
  verifysignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifysignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.VerifySignature)
}

// optional .micromsg.SKBuiltinBuffer_t VerifyBuff = 58;
inline bool NewAuthResponse::has_verifybuff() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void NewAuthResponse::set_has_verifybuff() {
  _has_bits_[1] |= 0x00000100u;
}
inline void NewAuthResponse::clear_has_verifybuff() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void NewAuthResponse::clear_verifybuff() {
  if (verifybuff_ != NULL) verifybuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_verifybuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& NewAuthResponse::verifybuff() const {
  // @@protoc_insertion_point(field_get:micromsg.NewAuthResponse.VerifyBuff)
  return verifybuff_ != NULL ? *verifybuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::mutable_verifybuff() {
  set_has_verifybuff();
  if (verifybuff_ == NULL) {
    verifybuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NewAuthResponse.VerifyBuff)
  return verifybuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* NewAuthResponse::release_verifybuff() {
  // @@protoc_insertion_point(field_release:micromsg.NewAuthResponse.VerifyBuff)
  clear_has_verifybuff();
  ::micromsg::SKBuiltinBuffer_t* temp = verifybuff_;
  verifybuff_ = NULL;
  return temp;
}
inline void NewAuthResponse::set_allocated_verifybuff(::micromsg::SKBuiltinBuffer_t* verifybuff) {
  delete verifybuff_;
  verifybuff_ = verifybuff;
  if (verifybuff) {
    set_has_verifybuff();
  } else {
    clear_has_verifybuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NewAuthResponse.VerifyBuff)
}

// -------------------------------------------------------------------

// BindGoogleContactRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BindGoogleContactRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindGoogleContactRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindGoogleContactRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindGoogleContactRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BindGoogleContactRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BindGoogleContactRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BindGoogleContactRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindGoogleContactRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BindGoogleContactRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BindGoogleContactRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BindGoogleContactRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindGoogleContactRequest.BaseRequest)
}

// required uint32 Opcode = 2;
inline bool BindGoogleContactRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindGoogleContactRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindGoogleContactRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindGoogleContactRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 BindGoogleContactRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.BindGoogleContactRequest.Opcode)
  return opcode_;
}
inline void BindGoogleContactRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindGoogleContactRequest.Opcode)
}

// optional string GoogleContactName = 3;
inline bool BindGoogleContactRequest::has_googlecontactname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindGoogleContactRequest::set_has_googlecontactname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindGoogleContactRequest::clear_has_googlecontactname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindGoogleContactRequest::clear_googlecontactname() {
  googlecontactname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_googlecontactname();
}
inline const ::std::string& BindGoogleContactRequest::googlecontactname() const {
  // @@protoc_insertion_point(field_get:micromsg.BindGoogleContactRequest.GoogleContactName)
  return googlecontactname_.GetNoArena();
}
inline void BindGoogleContactRequest::set_googlecontactname(const ::std::string& value) {
  set_has_googlecontactname();
  googlecontactname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindGoogleContactRequest.GoogleContactName)
}
#if LANG_CXX11
inline void BindGoogleContactRequest::set_googlecontactname(::std::string&& value) {
  set_has_googlecontactname();
  googlecontactname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindGoogleContactRequest.GoogleContactName)
}
#endif
inline void BindGoogleContactRequest::set_googlecontactname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_googlecontactname();
  googlecontactname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindGoogleContactRequest.GoogleContactName)
}
inline void BindGoogleContactRequest::set_googlecontactname(const char* value, size_t size) {
  set_has_googlecontactname();
  googlecontactname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindGoogleContactRequest.GoogleContactName)
}
inline ::std::string* BindGoogleContactRequest::mutable_googlecontactname() {
  set_has_googlecontactname();
  // @@protoc_insertion_point(field_mutable:micromsg.BindGoogleContactRequest.GoogleContactName)
  return googlecontactname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindGoogleContactRequest::release_googlecontactname() {
  // @@protoc_insertion_point(field_release:micromsg.BindGoogleContactRequest.GoogleContactName)
  clear_has_googlecontactname();
  return googlecontactname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindGoogleContactRequest::set_allocated_googlecontactname(::std::string* googlecontactname) {
  if (googlecontactname != NULL) {
    set_has_googlecontactname();
  } else {
    clear_has_googlecontactname();
  }
  googlecontactname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), googlecontactname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindGoogleContactRequest.GoogleContactName)
}

// required uint32 Force = 4;
inline bool BindGoogleContactRequest::has_force() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindGoogleContactRequest::set_has_force() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindGoogleContactRequest::clear_has_force() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindGoogleContactRequest::clear_force() {
  force_ = 0u;
  clear_has_force();
}
inline ::google::protobuf::uint32 BindGoogleContactRequest::force() const {
  // @@protoc_insertion_point(field_get:micromsg.BindGoogleContactRequest.Force)
  return force_;
}
inline void BindGoogleContactRequest::set_force(::google::protobuf::uint32 value) {
  set_has_force();
  force_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindGoogleContactRequest.Force)
}

// -------------------------------------------------------------------

// BindGoogleContactResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BindGoogleContactResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindGoogleContactResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindGoogleContactResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindGoogleContactResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BindGoogleContactResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BindGoogleContactResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BindGoogleContactResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindGoogleContactResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BindGoogleContactResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BindGoogleContactResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BindGoogleContactResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindGoogleContactResponse.BaseResponse)
}

// -------------------------------------------------------------------

// BindLinkedinContactRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BindLinkedinContactRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BindLinkedinContactRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BindLinkedinContactRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BindLinkedinContactRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BindLinkedinContactRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BindLinkedinContactRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindLinkedinContactRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BindLinkedinContactRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BindLinkedinContactRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BindLinkedinContactRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindLinkedinContactRequest.BaseRequest)
}

// required uint32 Opcode = 2;
inline bool BindLinkedinContactRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BindLinkedinContactRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BindLinkedinContactRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BindLinkedinContactRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 BindLinkedinContactRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.Opcode)
  return opcode_;
}
inline void BindLinkedinContactRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindLinkedinContactRequest.Opcode)
}

// required uint32 Visible = 3;
inline bool BindLinkedinContactRequest::has_visible() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BindLinkedinContactRequest::set_has_visible() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BindLinkedinContactRequest::clear_has_visible() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BindLinkedinContactRequest::clear_visible() {
  visible_ = 0u;
  clear_has_visible();
}
inline ::google::protobuf::uint32 BindLinkedinContactRequest::visible() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.Visible)
  return visible_;
}
inline void BindLinkedinContactRequest::set_visible(::google::protobuf::uint32 value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindLinkedinContactRequest.Visible)
}

// optional string LinkedinMemberID = 4;
inline bool BindLinkedinContactRequest::has_linkedinmemberid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindLinkedinContactRequest::set_has_linkedinmemberid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindLinkedinContactRequest::clear_has_linkedinmemberid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindLinkedinContactRequest::clear_linkedinmemberid() {
  linkedinmemberid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_linkedinmemberid();
}
inline const ::std::string& BindLinkedinContactRequest::linkedinmemberid() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.LinkedinMemberID)
  return linkedinmemberid_.GetNoArena();
}
inline void BindLinkedinContactRequest::set_linkedinmemberid(const ::std::string& value) {
  set_has_linkedinmemberid();
  linkedinmemberid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindLinkedinContactRequest.LinkedinMemberID)
}
#if LANG_CXX11
inline void BindLinkedinContactRequest::set_linkedinmemberid(::std::string&& value) {
  set_has_linkedinmemberid();
  linkedinmemberid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindLinkedinContactRequest.LinkedinMemberID)
}
#endif
inline void BindLinkedinContactRequest::set_linkedinmemberid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_linkedinmemberid();
  linkedinmemberid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindLinkedinContactRequest.LinkedinMemberID)
}
inline void BindLinkedinContactRequest::set_linkedinmemberid(const char* value, size_t size) {
  set_has_linkedinmemberid();
  linkedinmemberid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindLinkedinContactRequest.LinkedinMemberID)
}
inline ::std::string* BindLinkedinContactRequest::mutable_linkedinmemberid() {
  set_has_linkedinmemberid();
  // @@protoc_insertion_point(field_mutable:micromsg.BindLinkedinContactRequest.LinkedinMemberID)
  return linkedinmemberid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindLinkedinContactRequest::release_linkedinmemberid() {
  // @@protoc_insertion_point(field_release:micromsg.BindLinkedinContactRequest.LinkedinMemberID)
  clear_has_linkedinmemberid();
  return linkedinmemberid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindLinkedinContactRequest::set_allocated_linkedinmemberid(::std::string* linkedinmemberid) {
  if (linkedinmemberid != NULL) {
    set_has_linkedinmemberid();
  } else {
    clear_has_linkedinmemberid();
  }
  linkedinmemberid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), linkedinmemberid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindLinkedinContactRequest.LinkedinMemberID)
}

// optional string LinkedinName = 5;
inline bool BindLinkedinContactRequest::has_linkedinname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindLinkedinContactRequest::set_has_linkedinname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindLinkedinContactRequest::clear_has_linkedinname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindLinkedinContactRequest::clear_linkedinname() {
  linkedinname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_linkedinname();
}
inline const ::std::string& BindLinkedinContactRequest::linkedinname() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.LinkedinName)
  return linkedinname_.GetNoArena();
}
inline void BindLinkedinContactRequest::set_linkedinname(const ::std::string& value) {
  set_has_linkedinname();
  linkedinname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindLinkedinContactRequest.LinkedinName)
}
#if LANG_CXX11
inline void BindLinkedinContactRequest::set_linkedinname(::std::string&& value) {
  set_has_linkedinname();
  linkedinname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindLinkedinContactRequest.LinkedinName)
}
#endif
inline void BindLinkedinContactRequest::set_linkedinname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_linkedinname();
  linkedinname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindLinkedinContactRequest.LinkedinName)
}
inline void BindLinkedinContactRequest::set_linkedinname(const char* value, size_t size) {
  set_has_linkedinname();
  linkedinname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindLinkedinContactRequest.LinkedinName)
}
inline ::std::string* BindLinkedinContactRequest::mutable_linkedinname() {
  set_has_linkedinname();
  // @@protoc_insertion_point(field_mutable:micromsg.BindLinkedinContactRequest.LinkedinName)
  return linkedinname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindLinkedinContactRequest::release_linkedinname() {
  // @@protoc_insertion_point(field_release:micromsg.BindLinkedinContactRequest.LinkedinName)
  clear_has_linkedinname();
  return linkedinname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindLinkedinContactRequest::set_allocated_linkedinname(::std::string* linkedinname) {
  if (linkedinname != NULL) {
    set_has_linkedinname();
  } else {
    clear_has_linkedinname();
  }
  linkedinname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), linkedinname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindLinkedinContactRequest.LinkedinName)
}

// optional string LinkedinPublicUrl = 6;
inline bool BindLinkedinContactRequest::has_linkedinpublicurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindLinkedinContactRequest::set_has_linkedinpublicurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindLinkedinContactRequest::clear_has_linkedinpublicurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindLinkedinContactRequest::clear_linkedinpublicurl() {
  linkedinpublicurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_linkedinpublicurl();
}
inline const ::std::string& BindLinkedinContactRequest::linkedinpublicurl() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.LinkedinPublicUrl)
  return linkedinpublicurl_.GetNoArena();
}
inline void BindLinkedinContactRequest::set_linkedinpublicurl(const ::std::string& value) {
  set_has_linkedinpublicurl();
  linkedinpublicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindLinkedinContactRequest.LinkedinPublicUrl)
}
#if LANG_CXX11
inline void BindLinkedinContactRequest::set_linkedinpublicurl(::std::string&& value) {
  set_has_linkedinpublicurl();
  linkedinpublicurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindLinkedinContactRequest.LinkedinPublicUrl)
}
#endif
inline void BindLinkedinContactRequest::set_linkedinpublicurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_linkedinpublicurl();
  linkedinpublicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindLinkedinContactRequest.LinkedinPublicUrl)
}
inline void BindLinkedinContactRequest::set_linkedinpublicurl(const char* value, size_t size) {
  set_has_linkedinpublicurl();
  linkedinpublicurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindLinkedinContactRequest.LinkedinPublicUrl)
}
inline ::std::string* BindLinkedinContactRequest::mutable_linkedinpublicurl() {
  set_has_linkedinpublicurl();
  // @@protoc_insertion_point(field_mutable:micromsg.BindLinkedinContactRequest.LinkedinPublicUrl)
  return linkedinpublicurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindLinkedinContactRequest::release_linkedinpublicurl() {
  // @@protoc_insertion_point(field_release:micromsg.BindLinkedinContactRequest.LinkedinPublicUrl)
  clear_has_linkedinpublicurl();
  return linkedinpublicurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindLinkedinContactRequest::set_allocated_linkedinpublicurl(::std::string* linkedinpublicurl) {
  if (linkedinpublicurl != NULL) {
    set_has_linkedinpublicurl();
  } else {
    clear_has_linkedinpublicurl();
  }
  linkedinpublicurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), linkedinpublicurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindLinkedinContactRequest.LinkedinPublicUrl)
}

// optional string Timestamp = 7;
inline bool BindLinkedinContactRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindLinkedinContactRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindLinkedinContactRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindLinkedinContactRequest::clear_timestamp() {
  timestamp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timestamp();
}
inline const ::std::string& BindLinkedinContactRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.Timestamp)
  return timestamp_.GetNoArena();
}
inline void BindLinkedinContactRequest::set_timestamp(const ::std::string& value) {
  set_has_timestamp();
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindLinkedinContactRequest.Timestamp)
}
#if LANG_CXX11
inline void BindLinkedinContactRequest::set_timestamp(::std::string&& value) {
  set_has_timestamp();
  timestamp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindLinkedinContactRequest.Timestamp)
}
#endif
inline void BindLinkedinContactRequest::set_timestamp(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timestamp();
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindLinkedinContactRequest.Timestamp)
}
inline void BindLinkedinContactRequest::set_timestamp(const char* value, size_t size) {
  set_has_timestamp();
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindLinkedinContactRequest.Timestamp)
}
inline ::std::string* BindLinkedinContactRequest::mutable_timestamp() {
  set_has_timestamp();
  // @@protoc_insertion_point(field_mutable:micromsg.BindLinkedinContactRequest.Timestamp)
  return timestamp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindLinkedinContactRequest::release_timestamp() {
  // @@protoc_insertion_point(field_release:micromsg.BindLinkedinContactRequest.Timestamp)
  clear_has_timestamp();
  return timestamp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindLinkedinContactRequest::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp != NULL) {
    set_has_timestamp();
  } else {
    clear_has_timestamp();
  }
  timestamp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timestamp);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindLinkedinContactRequest.Timestamp)
}

// optional string Nounce = 8;
inline bool BindLinkedinContactRequest::has_nounce() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BindLinkedinContactRequest::set_has_nounce() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BindLinkedinContactRequest::clear_has_nounce() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BindLinkedinContactRequest::clear_nounce() {
  nounce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nounce();
}
inline const ::std::string& BindLinkedinContactRequest::nounce() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.Nounce)
  return nounce_.GetNoArena();
}
inline void BindLinkedinContactRequest::set_nounce(const ::std::string& value) {
  set_has_nounce();
  nounce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindLinkedinContactRequest.Nounce)
}
#if LANG_CXX11
inline void BindLinkedinContactRequest::set_nounce(::std::string&& value) {
  set_has_nounce();
  nounce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindLinkedinContactRequest.Nounce)
}
#endif
inline void BindLinkedinContactRequest::set_nounce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nounce();
  nounce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindLinkedinContactRequest.Nounce)
}
inline void BindLinkedinContactRequest::set_nounce(const char* value, size_t size) {
  set_has_nounce();
  nounce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindLinkedinContactRequest.Nounce)
}
inline ::std::string* BindLinkedinContactRequest::mutable_nounce() {
  set_has_nounce();
  // @@protoc_insertion_point(field_mutable:micromsg.BindLinkedinContactRequest.Nounce)
  return nounce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindLinkedinContactRequest::release_nounce() {
  // @@protoc_insertion_point(field_release:micromsg.BindLinkedinContactRequest.Nounce)
  clear_has_nounce();
  return nounce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindLinkedinContactRequest::set_allocated_nounce(::std::string* nounce) {
  if (nounce != NULL) {
    set_has_nounce();
  } else {
    clear_has_nounce();
  }
  nounce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nounce);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindLinkedinContactRequest.Nounce)
}

// optional string LinkedinSignature = 9;
inline bool BindLinkedinContactRequest::has_linkedinsignature() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BindLinkedinContactRequest::set_has_linkedinsignature() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BindLinkedinContactRequest::clear_has_linkedinsignature() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BindLinkedinContactRequest::clear_linkedinsignature() {
  linkedinsignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_linkedinsignature();
}
inline const ::std::string& BindLinkedinContactRequest::linkedinsignature() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.LinkedinSignature)
  return linkedinsignature_.GetNoArena();
}
inline void BindLinkedinContactRequest::set_linkedinsignature(const ::std::string& value) {
  set_has_linkedinsignature();
  linkedinsignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindLinkedinContactRequest.LinkedinSignature)
}
#if LANG_CXX11
inline void BindLinkedinContactRequest::set_linkedinsignature(::std::string&& value) {
  set_has_linkedinsignature();
  linkedinsignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindLinkedinContactRequest.LinkedinSignature)
}
#endif
inline void BindLinkedinContactRequest::set_linkedinsignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_linkedinsignature();
  linkedinsignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindLinkedinContactRequest.LinkedinSignature)
}
inline void BindLinkedinContactRequest::set_linkedinsignature(const char* value, size_t size) {
  set_has_linkedinsignature();
  linkedinsignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindLinkedinContactRequest.LinkedinSignature)
}
inline ::std::string* BindLinkedinContactRequest::mutable_linkedinsignature() {
  set_has_linkedinsignature();
  // @@protoc_insertion_point(field_mutable:micromsg.BindLinkedinContactRequest.LinkedinSignature)
  return linkedinsignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindLinkedinContactRequest::release_linkedinsignature() {
  // @@protoc_insertion_point(field_release:micromsg.BindLinkedinContactRequest.LinkedinSignature)
  clear_has_linkedinsignature();
  return linkedinsignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindLinkedinContactRequest::set_allocated_linkedinsignature(::std::string* linkedinsignature) {
  if (linkedinsignature != NULL) {
    set_has_linkedinsignature();
  } else {
    clear_has_linkedinsignature();
  }
  linkedinsignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), linkedinsignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindLinkedinContactRequest.LinkedinSignature)
}

// optional string LinkedinReturnSignature = 10;
inline bool BindLinkedinContactRequest::has_linkedinreturnsignature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BindLinkedinContactRequest::set_has_linkedinreturnsignature() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BindLinkedinContactRequest::clear_has_linkedinreturnsignature() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BindLinkedinContactRequest::clear_linkedinreturnsignature() {
  linkedinreturnsignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_linkedinreturnsignature();
}
inline const ::std::string& BindLinkedinContactRequest::linkedinreturnsignature() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactRequest.LinkedinReturnSignature)
  return linkedinreturnsignature_.GetNoArena();
}
inline void BindLinkedinContactRequest::set_linkedinreturnsignature(const ::std::string& value) {
  set_has_linkedinreturnsignature();
  linkedinreturnsignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindLinkedinContactRequest.LinkedinReturnSignature)
}
#if LANG_CXX11
inline void BindLinkedinContactRequest::set_linkedinreturnsignature(::std::string&& value) {
  set_has_linkedinreturnsignature();
  linkedinreturnsignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindLinkedinContactRequest.LinkedinReturnSignature)
}
#endif
inline void BindLinkedinContactRequest::set_linkedinreturnsignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_linkedinreturnsignature();
  linkedinreturnsignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindLinkedinContactRequest.LinkedinReturnSignature)
}
inline void BindLinkedinContactRequest::set_linkedinreturnsignature(const char* value, size_t size) {
  set_has_linkedinreturnsignature();
  linkedinreturnsignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindLinkedinContactRequest.LinkedinReturnSignature)
}
inline ::std::string* BindLinkedinContactRequest::mutable_linkedinreturnsignature() {
  set_has_linkedinreturnsignature();
  // @@protoc_insertion_point(field_mutable:micromsg.BindLinkedinContactRequest.LinkedinReturnSignature)
  return linkedinreturnsignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindLinkedinContactRequest::release_linkedinreturnsignature() {
  // @@protoc_insertion_point(field_release:micromsg.BindLinkedinContactRequest.LinkedinReturnSignature)
  clear_has_linkedinreturnsignature();
  return linkedinreturnsignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindLinkedinContactRequest::set_allocated_linkedinreturnsignature(::std::string* linkedinreturnsignature) {
  if (linkedinreturnsignature != NULL) {
    set_has_linkedinreturnsignature();
  } else {
    clear_has_linkedinreturnsignature();
  }
  linkedinreturnsignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), linkedinreturnsignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindLinkedinContactRequest.LinkedinReturnSignature)
}

// -------------------------------------------------------------------

// BindLinkedinContactResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BindLinkedinContactResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindLinkedinContactResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindLinkedinContactResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindLinkedinContactResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BindLinkedinContactResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BindLinkedinContactResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BindLinkedinContactResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindLinkedinContactResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BindLinkedinContactResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BindLinkedinContactResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BindLinkedinContactResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindLinkedinContactResponse.BaseResponse)
}

// -------------------------------------------------------------------

// UnBindLinkedinContactRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool UnBindLinkedinContactRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnBindLinkedinContactRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnBindLinkedinContactRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnBindLinkedinContactRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& UnBindLinkedinContactRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.UnBindLinkedinContactRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* UnBindLinkedinContactRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UnBindLinkedinContactRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* UnBindLinkedinContactRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.UnBindLinkedinContactRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void UnBindLinkedinContactRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UnBindLinkedinContactRequest.BaseRequest)
}

// required uint32 Opcode = 2;
inline bool UnBindLinkedinContactRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnBindLinkedinContactRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnBindLinkedinContactRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnBindLinkedinContactRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 UnBindLinkedinContactRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.UnBindLinkedinContactRequest.Opcode)
  return opcode_;
}
inline void UnBindLinkedinContactRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.UnBindLinkedinContactRequest.Opcode)
}

// -------------------------------------------------------------------

// UnBindLinkedinContactResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool UnBindLinkedinContactResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnBindLinkedinContactResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnBindLinkedinContactResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnBindLinkedinContactResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& UnBindLinkedinContactResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.UnBindLinkedinContactResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* UnBindLinkedinContactResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UnBindLinkedinContactResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* UnBindLinkedinContactResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.UnBindLinkedinContactResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void UnBindLinkedinContactResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UnBindLinkedinContactResponse.BaseResponse)
}

// -------------------------------------------------------------------

// LoginQRCodeNotify

// optional string UUID = 1;
inline bool LoginQRCodeNotify::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginQRCodeNotify::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginQRCodeNotify::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginQRCodeNotify::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& LoginQRCodeNotify::uuid() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.UUID)
  return uuid_.GetNoArena();
}
inline void LoginQRCodeNotify::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.UUID)
}
#if LANG_CXX11
inline void LoginQRCodeNotify::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LoginQRCodeNotify.UUID)
}
#endif
inline void LoginQRCodeNotify::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LoginQRCodeNotify.UUID)
}
inline void LoginQRCodeNotify::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LoginQRCodeNotify.UUID)
}
inline ::std::string* LoginQRCodeNotify::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:micromsg.LoginQRCodeNotify.UUID)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginQRCodeNotify::release_uuid() {
  // @@protoc_insertion_point(field_release:micromsg.LoginQRCodeNotify.UUID)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginQRCodeNotify::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LoginQRCodeNotify.UUID)
}

// required uint32 Status = 2;
inline bool LoginQRCodeNotify::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginQRCodeNotify::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginQRCodeNotify::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginQRCodeNotify::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 LoginQRCodeNotify::status() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.Status)
  return status_;
}
inline void LoginQRCodeNotify::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.Status)
}

// optional string UserName = 3;
inline bool LoginQRCodeNotify::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginQRCodeNotify::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginQRCodeNotify::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginQRCodeNotify::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& LoginQRCodeNotify::username() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.UserName)
  return username_.GetNoArena();
}
inline void LoginQRCodeNotify::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.UserName)
}
#if LANG_CXX11
inline void LoginQRCodeNotify::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LoginQRCodeNotify.UserName)
}
#endif
inline void LoginQRCodeNotify::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LoginQRCodeNotify.UserName)
}
inline void LoginQRCodeNotify::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LoginQRCodeNotify.UserName)
}
inline ::std::string* LoginQRCodeNotify::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.LoginQRCodeNotify.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginQRCodeNotify::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.LoginQRCodeNotify.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginQRCodeNotify::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LoginQRCodeNotify.UserName)
}

// optional string Pwd = 4;
inline bool LoginQRCodeNotify::has_pwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginQRCodeNotify::set_has_pwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginQRCodeNotify::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginQRCodeNotify::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd();
}
inline const ::std::string& LoginQRCodeNotify::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.Pwd)
  return pwd_.GetNoArena();
}
inline void LoginQRCodeNotify::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.Pwd)
}
#if LANG_CXX11
inline void LoginQRCodeNotify::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LoginQRCodeNotify.Pwd)
}
#endif
inline void LoginQRCodeNotify::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LoginQRCodeNotify.Pwd)
}
inline void LoginQRCodeNotify::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LoginQRCodeNotify.Pwd)
}
inline ::std::string* LoginQRCodeNotify::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:micromsg.LoginQRCodeNotify.Pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginQRCodeNotify::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.LoginQRCodeNotify.Pwd)
  clear_has_pwd();
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginQRCodeNotify::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LoginQRCodeNotify.Pwd)
}

// optional string HeadImgURL = 5;
inline bool LoginQRCodeNotify::has_headimgurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginQRCodeNotify::set_has_headimgurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginQRCodeNotify::clear_has_headimgurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginQRCodeNotify::clear_headimgurl() {
  headimgurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_headimgurl();
}
inline const ::std::string& LoginQRCodeNotify::headimgurl() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.HeadImgURL)
  return headimgurl_.GetNoArena();
}
inline void LoginQRCodeNotify::set_headimgurl(const ::std::string& value) {
  set_has_headimgurl();
  headimgurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.HeadImgURL)
}
#if LANG_CXX11
inline void LoginQRCodeNotify::set_headimgurl(::std::string&& value) {
  set_has_headimgurl();
  headimgurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LoginQRCodeNotify.HeadImgURL)
}
#endif
inline void LoginQRCodeNotify::set_headimgurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_headimgurl();
  headimgurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LoginQRCodeNotify.HeadImgURL)
}
inline void LoginQRCodeNotify::set_headimgurl(const char* value, size_t size) {
  set_has_headimgurl();
  headimgurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LoginQRCodeNotify.HeadImgURL)
}
inline ::std::string* LoginQRCodeNotify::mutable_headimgurl() {
  set_has_headimgurl();
  // @@protoc_insertion_point(field_mutable:micromsg.LoginQRCodeNotify.HeadImgURL)
  return headimgurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginQRCodeNotify::release_headimgurl() {
  // @@protoc_insertion_point(field_release:micromsg.LoginQRCodeNotify.HeadImgURL)
  clear_has_headimgurl();
  return headimgurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginQRCodeNotify::set_allocated_headimgurl(::std::string* headimgurl) {
  if (headimgurl != NULL) {
    set_has_headimgurl();
  } else {
    clear_has_headimgurl();
  }
  headimgurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), headimgurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LoginQRCodeNotify.HeadImgURL)
}

// optional uint32 PushLoginURLExpiredTime = 6;
inline bool LoginQRCodeNotify::has_pushloginurlexpiredtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginQRCodeNotify::set_has_pushloginurlexpiredtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginQRCodeNotify::clear_has_pushloginurlexpiredtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginQRCodeNotify::clear_pushloginurlexpiredtime() {
  pushloginurlexpiredtime_ = 0u;
  clear_has_pushloginurlexpiredtime();
}
inline ::google::protobuf::uint32 LoginQRCodeNotify::pushloginurlexpiredtime() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.PushLoginURLExpiredTime)
  return pushloginurlexpiredtime_;
}
inline void LoginQRCodeNotify::set_pushloginurlexpiredtime(::google::protobuf::uint32 value) {
  set_has_pushloginurlexpiredtime();
  pushloginurlexpiredtime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.PushLoginURLExpiredTime)
}

// optional string NickName = 7;
inline bool LoginQRCodeNotify::has_nickname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginQRCodeNotify::set_has_nickname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginQRCodeNotify::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginQRCodeNotify::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& LoginQRCodeNotify::nickname() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.NickName)
  return nickname_.GetNoArena();
}
inline void LoginQRCodeNotify::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.NickName)
}
#if LANG_CXX11
inline void LoginQRCodeNotify::set_nickname(::std::string&& value) {
  set_has_nickname();
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LoginQRCodeNotify.NickName)
}
#endif
inline void LoginQRCodeNotify::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LoginQRCodeNotify.NickName)
}
inline void LoginQRCodeNotify::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LoginQRCodeNotify.NickName)
}
inline ::std::string* LoginQRCodeNotify::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:micromsg.LoginQRCodeNotify.NickName)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginQRCodeNotify::release_nickname() {
  // @@protoc_insertion_point(field_release:micromsg.LoginQRCodeNotify.NickName)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginQRCodeNotify::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LoginQRCodeNotify.NickName)
}

// optional uint32 ExpiredTime = 8;
inline bool LoginQRCodeNotify::has_expiredtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginQRCodeNotify::set_has_expiredtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginQRCodeNotify::clear_has_expiredtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginQRCodeNotify::clear_expiredtime() {
  expiredtime_ = 0u;
  clear_has_expiredtime();
}
inline ::google::protobuf::uint32 LoginQRCodeNotify::expiredtime() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.ExpiredTime)
  return expiredtime_;
}
inline void LoginQRCodeNotify::set_expiredtime(::google::protobuf::uint32 value) {
  set_has_expiredtime();
  expiredtime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.ExpiredTime)
}

// optional string PairWaitTip = 9;
inline bool LoginQRCodeNotify::has_pairwaittip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginQRCodeNotify::set_has_pairwaittip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginQRCodeNotify::clear_has_pairwaittip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginQRCodeNotify::clear_pairwaittip() {
  pairwaittip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pairwaittip();
}
inline const ::std::string& LoginQRCodeNotify::pairwaittip() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.PairWaitTip)
  return pairwaittip_.GetNoArena();
}
inline void LoginQRCodeNotify::set_pairwaittip(const ::std::string& value) {
  set_has_pairwaittip();
  pairwaittip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.PairWaitTip)
}
#if LANG_CXX11
inline void LoginQRCodeNotify::set_pairwaittip(::std::string&& value) {
  set_has_pairwaittip();
  pairwaittip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LoginQRCodeNotify.PairWaitTip)
}
#endif
inline void LoginQRCodeNotify::set_pairwaittip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pairwaittip();
  pairwaittip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LoginQRCodeNotify.PairWaitTip)
}
inline void LoginQRCodeNotify::set_pairwaittip(const char* value, size_t size) {
  set_has_pairwaittip();
  pairwaittip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LoginQRCodeNotify.PairWaitTip)
}
inline ::std::string* LoginQRCodeNotify::mutable_pairwaittip() {
  set_has_pairwaittip();
  // @@protoc_insertion_point(field_mutable:micromsg.LoginQRCodeNotify.PairWaitTip)
  return pairwaittip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginQRCodeNotify::release_pairwaittip() {
  // @@protoc_insertion_point(field_release:micromsg.LoginQRCodeNotify.PairWaitTip)
  clear_has_pairwaittip();
  return pairwaittip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginQRCodeNotify::set_allocated_pairwaittip(::std::string* pairwaittip) {
  if (pairwaittip != NULL) {
    set_has_pairwaittip();
  } else {
    clear_has_pairwaittip();
  }
  pairwaittip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pairwaittip);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LoginQRCodeNotify.PairWaitTip)
}

// optional uint32 AuthorClientVersion = 10;
inline bool LoginQRCodeNotify::has_authorclientversion() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginQRCodeNotify::set_has_authorclientversion() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginQRCodeNotify::clear_has_authorclientversion() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginQRCodeNotify::clear_authorclientversion() {
  authorclientversion_ = 0u;
  clear_has_authorclientversion();
}
inline ::google::protobuf::uint32 LoginQRCodeNotify::authorclientversion() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.AuthorClientVersion)
  return authorclientversion_;
}
inline void LoginQRCodeNotify::set_authorclientversion(::google::protobuf::uint32 value) {
  set_has_authorclientversion();
  authorclientversion_ = value;
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.AuthorClientVersion)
}

// optional string AuthorDeviceType = 11;
inline bool LoginQRCodeNotify::has_authordevicetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginQRCodeNotify::set_has_authordevicetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginQRCodeNotify::clear_has_authordevicetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginQRCodeNotify::clear_authordevicetype() {
  authordevicetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authordevicetype();
}
inline const ::std::string& LoginQRCodeNotify::authordevicetype() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotify.AuthorDeviceType)
  return authordevicetype_.GetNoArena();
}
inline void LoginQRCodeNotify::set_authordevicetype(const ::std::string& value) {
  set_has_authordevicetype();
  authordevicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotify.AuthorDeviceType)
}
#if LANG_CXX11
inline void LoginQRCodeNotify::set_authordevicetype(::std::string&& value) {
  set_has_authordevicetype();
  authordevicetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LoginQRCodeNotify.AuthorDeviceType)
}
#endif
inline void LoginQRCodeNotify::set_authordevicetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authordevicetype();
  authordevicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LoginQRCodeNotify.AuthorDeviceType)
}
inline void LoginQRCodeNotify::set_authordevicetype(const char* value, size_t size) {
  set_has_authordevicetype();
  authordevicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LoginQRCodeNotify.AuthorDeviceType)
}
inline ::std::string* LoginQRCodeNotify::mutable_authordevicetype() {
  set_has_authordevicetype();
  // @@protoc_insertion_point(field_mutable:micromsg.LoginQRCodeNotify.AuthorDeviceType)
  return authordevicetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginQRCodeNotify::release_authordevicetype() {
  // @@protoc_insertion_point(field_release:micromsg.LoginQRCodeNotify.AuthorDeviceType)
  clear_has_authordevicetype();
  return authordevicetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginQRCodeNotify::set_allocated_authordevicetype(::std::string* authordevicetype) {
  if (authordevicetype != NULL) {
    set_has_authordevicetype();
  } else {
    clear_has_authordevicetype();
  }
  authordevicetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authordevicetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LoginQRCodeNotify.AuthorDeviceType)
}

// -------------------------------------------------------------------

// LoginQRCodeNotifyPkg

// required .micromsg.SKBuiltinBuffer_t NotifyData = 1;
inline bool LoginQRCodeNotifyPkg::has_notifydata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginQRCodeNotifyPkg::set_has_notifydata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginQRCodeNotifyPkg::clear_has_notifydata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginQRCodeNotifyPkg::clear_notifydata() {
  if (notifydata_ != NULL) notifydata_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_notifydata();
}
inline const ::micromsg::SKBuiltinBuffer_t& LoginQRCodeNotifyPkg::notifydata() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotifyPkg.NotifyData)
  return notifydata_ != NULL ? *notifydata_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* LoginQRCodeNotifyPkg::mutable_notifydata() {
  set_has_notifydata();
  if (notifydata_ == NULL) {
    notifydata_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.LoginQRCodeNotifyPkg.NotifyData)
  return notifydata_;
}
inline ::micromsg::SKBuiltinBuffer_t* LoginQRCodeNotifyPkg::release_notifydata() {
  // @@protoc_insertion_point(field_release:micromsg.LoginQRCodeNotifyPkg.NotifyData)
  clear_has_notifydata();
  ::micromsg::SKBuiltinBuffer_t* temp = notifydata_;
  notifydata_ = NULL;
  return temp;
}
inline void LoginQRCodeNotifyPkg::set_allocated_notifydata(::micromsg::SKBuiltinBuffer_t* notifydata) {
  delete notifydata_;
  notifydata_ = notifydata;
  if (notifydata) {
    set_has_notifydata();
  } else {
    clear_has_notifydata();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.LoginQRCodeNotifyPkg.NotifyData)
}

// required uint32 OPCode = 2;
inline bool LoginQRCodeNotifyPkg::has_opcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginQRCodeNotifyPkg::set_has_opcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginQRCodeNotifyPkg::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginQRCodeNotifyPkg::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 LoginQRCodeNotifyPkg::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.LoginQRCodeNotifyPkg.OPCode)
  return opcode_;
}
inline void LoginQRCodeNotifyPkg::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.LoginQRCodeNotifyPkg.OPCode)
}

// -------------------------------------------------------------------

// GetLoginQRCodeRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetLoginQRCodeRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLoginQRCodeRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLoginQRCodeRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLoginQRCodeRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetLoginQRCodeRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetLoginQRCodeRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetLoginQRCodeRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetLoginQRCodeRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeRequest.BaseRequest)
}

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
inline bool GetLoginQRCodeRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetLoginQRCodeRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetLoginQRCodeRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetLoginQRCodeRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetLoginQRCodeRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetLoginQRCodeRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetLoginQRCodeRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void GetLoginQRCodeRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeRequest.RandomEncryKey)
}

// optional uint32 OPCode = 3;
inline bool GetLoginQRCodeRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetLoginQRCodeRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetLoginQRCodeRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetLoginQRCodeRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 GetLoginQRCodeRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeRequest.OPCode)
  return opcode_;
}
inline void GetLoginQRCodeRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetLoginQRCodeRequest.OPCode)
}

// optional string DeviceName = 4;
inline bool GetLoginQRCodeRequest::has_devicename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLoginQRCodeRequest::set_has_devicename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLoginQRCodeRequest::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLoginQRCodeRequest::clear_devicename() {
  devicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicename();
}
inline const ::std::string& GetLoginQRCodeRequest::devicename() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeRequest.DeviceName)
  return devicename_.GetNoArena();
}
inline void GetLoginQRCodeRequest::set_devicename(const ::std::string& value) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetLoginQRCodeRequest.DeviceName)
}
#if LANG_CXX11
inline void GetLoginQRCodeRequest::set_devicename(::std::string&& value) {
  set_has_devicename();
  devicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetLoginQRCodeRequest.DeviceName)
}
#endif
inline void GetLoginQRCodeRequest::set_devicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetLoginQRCodeRequest.DeviceName)
}
inline void GetLoginQRCodeRequest::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetLoginQRCodeRequest.DeviceName)
}
inline ::std::string* GetLoginQRCodeRequest::mutable_devicename() {
  set_has_devicename();
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeRequest.DeviceName)
  return devicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLoginQRCodeRequest::release_devicename() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeRequest.DeviceName)
  clear_has_devicename();
  return devicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLoginQRCodeRequest::set_allocated_devicename(::std::string* devicename) {
  if (devicename != NULL) {
    set_has_devicename();
  } else {
    clear_has_devicename();
  }
  devicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicename);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeRequest.DeviceName)
}

// optional string UserName = 5;
inline bool GetLoginQRCodeRequest::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLoginQRCodeRequest::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLoginQRCodeRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLoginQRCodeRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& GetLoginQRCodeRequest::username() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeRequest.UserName)
  return username_.GetNoArena();
}
inline void GetLoginQRCodeRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetLoginQRCodeRequest.UserName)
}
#if LANG_CXX11
inline void GetLoginQRCodeRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetLoginQRCodeRequest.UserName)
}
#endif
inline void GetLoginQRCodeRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetLoginQRCodeRequest.UserName)
}
inline void GetLoginQRCodeRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetLoginQRCodeRequest.UserName)
}
inline ::std::string* GetLoginQRCodeRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeRequest.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLoginQRCodeRequest::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeRequest.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLoginQRCodeRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeRequest.UserName)
}

// optional uint32 ExtDevLoginType = 6;
inline bool GetLoginQRCodeRequest::has_extdevlogintype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetLoginQRCodeRequest::set_has_extdevlogintype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetLoginQRCodeRequest::clear_has_extdevlogintype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetLoginQRCodeRequest::clear_extdevlogintype() {
  extdevlogintype_ = 0u;
  clear_has_extdevlogintype();
}
inline ::google::protobuf::uint32 GetLoginQRCodeRequest::extdevlogintype() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeRequest.ExtDevLoginType)
  return extdevlogintype_;
}
inline void GetLoginQRCodeRequest::set_extdevlogintype(::google::protobuf::uint32 value) {
  set_has_extdevlogintype();
  extdevlogintype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetLoginQRCodeRequest.ExtDevLoginType)
}

// -------------------------------------------------------------------

// GetLoginQRCodeResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetLoginQRCodeResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLoginQRCodeResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLoginQRCodeResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLoginQRCodeResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetLoginQRCodeResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetLoginQRCodeResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetLoginQRCodeResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetLoginQRCodeResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeResponse.BaseResponse)
}

// required .micromsg.SKBuiltinBuffer_t QRCode = 2;
inline bool GetLoginQRCodeResponse::has_qrcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetLoginQRCodeResponse::set_has_qrcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetLoginQRCodeResponse::clear_has_qrcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetLoginQRCodeResponse::clear_qrcode() {
  if (qrcode_ != NULL) qrcode_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_qrcode();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetLoginQRCodeResponse::qrcode() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeResponse.QRCode)
  return qrcode_ != NULL ? *qrcode_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetLoginQRCodeResponse::mutable_qrcode() {
  set_has_qrcode();
  if (qrcode_ == NULL) {
    qrcode_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeResponse.QRCode)
  return qrcode_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetLoginQRCodeResponse::release_qrcode() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeResponse.QRCode)
  clear_has_qrcode();
  ::micromsg::SKBuiltinBuffer_t* temp = qrcode_;
  qrcode_ = NULL;
  return temp;
}
inline void GetLoginQRCodeResponse::set_allocated_qrcode(::micromsg::SKBuiltinBuffer_t* qrcode) {
  delete qrcode_;
  qrcode_ = qrcode;
  if (qrcode) {
    set_has_qrcode();
  } else {
    clear_has_qrcode();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeResponse.QRCode)
}

// optional string UUID = 3;
inline bool GetLoginQRCodeResponse::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLoginQRCodeResponse::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLoginQRCodeResponse::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLoginQRCodeResponse::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& GetLoginQRCodeResponse::uuid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeResponse.UUID)
  return uuid_.GetNoArena();
}
inline void GetLoginQRCodeResponse::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetLoginQRCodeResponse.UUID)
}
#if LANG_CXX11
inline void GetLoginQRCodeResponse::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetLoginQRCodeResponse.UUID)
}
#endif
inline void GetLoginQRCodeResponse::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetLoginQRCodeResponse.UUID)
}
inline void GetLoginQRCodeResponse::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetLoginQRCodeResponse.UUID)
}
inline ::std::string* GetLoginQRCodeResponse::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeResponse.UUID)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLoginQRCodeResponse::release_uuid() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeResponse.UUID)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLoginQRCodeResponse::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeResponse.UUID)
}

// required uint32 CheckTime = 4;
inline bool GetLoginQRCodeResponse::has_checktime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetLoginQRCodeResponse::set_has_checktime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetLoginQRCodeResponse::clear_has_checktime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetLoginQRCodeResponse::clear_checktime() {
  checktime_ = 0u;
  clear_has_checktime();
}
inline ::google::protobuf::uint32 GetLoginQRCodeResponse::checktime() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeResponse.CheckTime)
  return checktime_;
}
inline void GetLoginQRCodeResponse::set_checktime(::google::protobuf::uint32 value) {
  set_has_checktime();
  checktime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetLoginQRCodeResponse.CheckTime)
}

// required .micromsg.SKBuiltinBuffer_t NotifyKey = 5;
inline bool GetLoginQRCodeResponse::has_notifykey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetLoginQRCodeResponse::set_has_notifykey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetLoginQRCodeResponse::clear_has_notifykey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetLoginQRCodeResponse::clear_notifykey() {
  if (notifykey_ != NULL) notifykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_notifykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetLoginQRCodeResponse::notifykey() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeResponse.NotifyKey)
  return notifykey_ != NULL ? *notifykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetLoginQRCodeResponse::mutable_notifykey() {
  set_has_notifykey();
  if (notifykey_ == NULL) {
    notifykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeResponse.NotifyKey)
  return notifykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetLoginQRCodeResponse::release_notifykey() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeResponse.NotifyKey)
  clear_has_notifykey();
  ::micromsg::SKBuiltinBuffer_t* temp = notifykey_;
  notifykey_ = NULL;
  return temp;
}
inline void GetLoginQRCodeResponse::set_allocated_notifykey(::micromsg::SKBuiltinBuffer_t* notifykey) {
  delete notifykey_;
  notifykey_ = notifykey;
  if (notifykey) {
    set_has_notifykey();
  } else {
    clear_has_notifykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeResponse.NotifyKey)
}

// optional uint32 ExpiredTime = 6;
inline bool GetLoginQRCodeResponse::has_expiredtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetLoginQRCodeResponse::set_has_expiredtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetLoginQRCodeResponse::clear_has_expiredtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetLoginQRCodeResponse::clear_expiredtime() {
  expiredtime_ = 0u;
  clear_has_expiredtime();
}
inline ::google::protobuf::uint32 GetLoginQRCodeResponse::expiredtime() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeResponse.ExpiredTime)
  return expiredtime_;
}
inline void GetLoginQRCodeResponse::set_expiredtime(::google::protobuf::uint32 value) {
  set_has_expiredtime();
  expiredtime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetLoginQRCodeResponse.ExpiredTime)
}

// optional string BlueToothBroadCastUUID = 7;
inline bool GetLoginQRCodeResponse::has_bluetoothbroadcastuuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLoginQRCodeResponse::set_has_bluetoothbroadcastuuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLoginQRCodeResponse::clear_has_bluetoothbroadcastuuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLoginQRCodeResponse::clear_bluetoothbroadcastuuid() {
  bluetoothbroadcastuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetoothbroadcastuuid();
}
inline const ::std::string& GetLoginQRCodeResponse::bluetoothbroadcastuuid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.GetNoArena();
}
inline void GetLoginQRCodeResponse::set_bluetoothbroadcastuuid(const ::std::string& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastUUID)
}
#if LANG_CXX11
inline void GetLoginQRCodeResponse::set_bluetoothbroadcastuuid(::std::string&& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastUUID)
}
#endif
inline void GetLoginQRCodeResponse::set_bluetoothbroadcastuuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastUUID)
}
inline void GetLoginQRCodeResponse::set_bluetoothbroadcastuuid(const char* value, size_t size) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastUUID)
}
inline ::std::string* GetLoginQRCodeResponse::mutable_bluetoothbroadcastuuid() {
  set_has_bluetoothbroadcastuuid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLoginQRCodeResponse::release_bluetoothbroadcastuuid() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastUUID)
  clear_has_bluetoothbroadcastuuid();
  return bluetoothbroadcastuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLoginQRCodeResponse::set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid) {
  if (bluetoothbroadcastuuid != NULL) {
    set_has_bluetoothbroadcastuuid();
  } else {
    clear_has_bluetoothbroadcastuuid();
  }
  bluetoothbroadcastuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetoothbroadcastuuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastUUID)
}

// optional .micromsg.SKBuiltinBuffer_t BlueToothBroadCastContent = 8;
inline bool GetLoginQRCodeResponse::has_bluetoothbroadcastcontent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetLoginQRCodeResponse::set_has_bluetoothbroadcastcontent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetLoginQRCodeResponse::clear_has_bluetoothbroadcastcontent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetLoginQRCodeResponse::clear_bluetoothbroadcastcontent() {
  if (bluetoothbroadcastcontent_ != NULL) bluetoothbroadcastcontent_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_bluetoothbroadcastcontent();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetLoginQRCodeResponse::bluetoothbroadcastcontent() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastContent)
  return bluetoothbroadcastcontent_ != NULL ? *bluetoothbroadcastcontent_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetLoginQRCodeResponse::mutable_bluetoothbroadcastcontent() {
  set_has_bluetoothbroadcastcontent();
  if (bluetoothbroadcastcontent_ == NULL) {
    bluetoothbroadcastcontent_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastContent)
  return bluetoothbroadcastcontent_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetLoginQRCodeResponse::release_bluetoothbroadcastcontent() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastContent)
  clear_has_bluetoothbroadcastcontent();
  ::micromsg::SKBuiltinBuffer_t* temp = bluetoothbroadcastcontent_;
  bluetoothbroadcastcontent_ = NULL;
  return temp;
}
inline void GetLoginQRCodeResponse::set_allocated_bluetoothbroadcastcontent(::micromsg::SKBuiltinBuffer_t* bluetoothbroadcastcontent) {
  delete bluetoothbroadcastcontent_;
  bluetoothbroadcastcontent_ = bluetoothbroadcastcontent;
  if (bluetoothbroadcastcontent) {
    set_has_bluetoothbroadcastcontent();
  } else {
    clear_has_bluetoothbroadcastcontent();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginQRCodeResponse.BlueToothBroadCastContent)
}

// -------------------------------------------------------------------

// CheckLoginQRCodeRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool CheckLoginQRCodeRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckLoginQRCodeRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckLoginQRCodeRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckLoginQRCodeRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& CheckLoginQRCodeRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckLoginQRCodeRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* CheckLoginQRCodeRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.CheckLoginQRCodeRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* CheckLoginQRCodeRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.CheckLoginQRCodeRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void CheckLoginQRCodeRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.CheckLoginQRCodeRequest.BaseRequest)
}

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 2;
inline bool CheckLoginQRCodeRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckLoginQRCodeRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckLoginQRCodeRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckLoginQRCodeRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& CheckLoginQRCodeRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckLoginQRCodeRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* CheckLoginQRCodeRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.CheckLoginQRCodeRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* CheckLoginQRCodeRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.CheckLoginQRCodeRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void CheckLoginQRCodeRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.CheckLoginQRCodeRequest.RandomEncryKey)
}

// optional string UUID = 3;
inline bool CheckLoginQRCodeRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckLoginQRCodeRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckLoginQRCodeRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckLoginQRCodeRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& CheckLoginQRCodeRequest::uuid() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckLoginQRCodeRequest.UUID)
  return uuid_.GetNoArena();
}
inline void CheckLoginQRCodeRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.CheckLoginQRCodeRequest.UUID)
}
#if LANG_CXX11
inline void CheckLoginQRCodeRequest::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.CheckLoginQRCodeRequest.UUID)
}
#endif
inline void CheckLoginQRCodeRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.CheckLoginQRCodeRequest.UUID)
}
inline void CheckLoginQRCodeRequest::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.CheckLoginQRCodeRequest.UUID)
}
inline ::std::string* CheckLoginQRCodeRequest::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:micromsg.CheckLoginQRCodeRequest.UUID)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CheckLoginQRCodeRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:micromsg.CheckLoginQRCodeRequest.UUID)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CheckLoginQRCodeRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.CheckLoginQRCodeRequest.UUID)
}

// required uint32 TimeStamp = 4;
inline bool CheckLoginQRCodeRequest::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckLoginQRCodeRequest::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckLoginQRCodeRequest::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckLoginQRCodeRequest::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CheckLoginQRCodeRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckLoginQRCodeRequest.TimeStamp)
  return timestamp_;
}
inline void CheckLoginQRCodeRequest::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:micromsg.CheckLoginQRCodeRequest.TimeStamp)
}

// optional uint32 OPCode = 5;
inline bool CheckLoginQRCodeRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckLoginQRCodeRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckLoginQRCodeRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckLoginQRCodeRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 CheckLoginQRCodeRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckLoginQRCodeRequest.OPCode)
  return opcode_;
}
inline void CheckLoginQRCodeRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.CheckLoginQRCodeRequest.OPCode)
}

// -------------------------------------------------------------------

// CheckLoginQRCodeResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool CheckLoginQRCodeResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckLoginQRCodeResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckLoginQRCodeResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckLoginQRCodeResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& CheckLoginQRCodeResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckLoginQRCodeResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* CheckLoginQRCodeResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.CheckLoginQRCodeResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* CheckLoginQRCodeResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.CheckLoginQRCodeResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void CheckLoginQRCodeResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.CheckLoginQRCodeResponse.BaseResponse)
}

// optional .micromsg.LoginQRCodeNotifyPkg NotifyPkg = 3;
inline bool CheckLoginQRCodeResponse::has_notifypkg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckLoginQRCodeResponse::set_has_notifypkg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckLoginQRCodeResponse::clear_has_notifypkg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckLoginQRCodeResponse::clear_notifypkg() {
  if (notifypkg_ != NULL) notifypkg_->::micromsg::LoginQRCodeNotifyPkg::Clear();
  clear_has_notifypkg();
}
inline const ::micromsg::LoginQRCodeNotifyPkg& CheckLoginQRCodeResponse::notifypkg() const {
  // @@protoc_insertion_point(field_get:micromsg.CheckLoginQRCodeResponse.NotifyPkg)
  return notifypkg_ != NULL ? *notifypkg_
                         : *::micromsg::LoginQRCodeNotifyPkg::internal_default_instance();
}
inline ::micromsg::LoginQRCodeNotifyPkg* CheckLoginQRCodeResponse::mutable_notifypkg() {
  set_has_notifypkg();
  if (notifypkg_ == NULL) {
    notifypkg_ = new ::micromsg::LoginQRCodeNotifyPkg;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.CheckLoginQRCodeResponse.NotifyPkg)
  return notifypkg_;
}
inline ::micromsg::LoginQRCodeNotifyPkg* CheckLoginQRCodeResponse::release_notifypkg() {
  // @@protoc_insertion_point(field_release:micromsg.CheckLoginQRCodeResponse.NotifyPkg)
  clear_has_notifypkg();
  ::micromsg::LoginQRCodeNotifyPkg* temp = notifypkg_;
  notifypkg_ = NULL;
  return temp;
}
inline void CheckLoginQRCodeResponse::set_allocated_notifypkg(::micromsg::LoginQRCodeNotifyPkg* notifypkg) {
  delete notifypkg_;
  notifypkg_ = notifypkg;
  if (notifypkg) {
    set_has_notifypkg();
  } else {
    clear_has_notifypkg();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.CheckLoginQRCodeResponse.NotifyPkg)
}

// -------------------------------------------------------------------

// GetLoginURLRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetLoginURLRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetLoginURLRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetLoginURLRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetLoginURLRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetLoginURLRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginURLRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetLoginURLRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginURLRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetLoginURLRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginURLRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetLoginURLRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginURLRequest.BaseRequest)
}

// optional string UUID = 2;
inline bool GetLoginURLRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLoginURLRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLoginURLRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLoginURLRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& GetLoginURLRequest::uuid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginURLRequest.UUID)
  return uuid_.GetNoArena();
}
inline void GetLoginURLRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetLoginURLRequest.UUID)
}
#if LANG_CXX11
inline void GetLoginURLRequest::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetLoginURLRequest.UUID)
}
#endif
inline void GetLoginURLRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetLoginURLRequest.UUID)
}
inline void GetLoginURLRequest::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetLoginURLRequest.UUID)
}
inline ::std::string* GetLoginURLRequest::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginURLRequest.UUID)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLoginURLRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginURLRequest.UUID)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLoginURLRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginURLRequest.UUID)
}

// optional bytes FromDeviceID = 3;
inline bool GetLoginURLRequest::has_fromdeviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLoginURLRequest::set_has_fromdeviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLoginURLRequest::clear_has_fromdeviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLoginURLRequest::clear_fromdeviceid() {
  fromdeviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fromdeviceid();
}
inline const ::std::string& GetLoginURLRequest::fromdeviceid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginURLRequest.FromDeviceID)
  return fromdeviceid_.GetNoArena();
}
inline void GetLoginURLRequest::set_fromdeviceid(const ::std::string& value) {
  set_has_fromdeviceid();
  fromdeviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetLoginURLRequest.FromDeviceID)
}
#if LANG_CXX11
inline void GetLoginURLRequest::set_fromdeviceid(::std::string&& value) {
  set_has_fromdeviceid();
  fromdeviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetLoginURLRequest.FromDeviceID)
}
#endif
inline void GetLoginURLRequest::set_fromdeviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fromdeviceid();
  fromdeviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetLoginURLRequest.FromDeviceID)
}
inline void GetLoginURLRequest::set_fromdeviceid(const void* value, size_t size) {
  set_has_fromdeviceid();
  fromdeviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetLoginURLRequest.FromDeviceID)
}
inline ::std::string* GetLoginURLRequest::mutable_fromdeviceid() {
  set_has_fromdeviceid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginURLRequest.FromDeviceID)
  return fromdeviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLoginURLRequest::release_fromdeviceid() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginURLRequest.FromDeviceID)
  clear_has_fromdeviceid();
  return fromdeviceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLoginURLRequest::set_allocated_fromdeviceid(::std::string* fromdeviceid) {
  if (fromdeviceid != NULL) {
    set_has_fromdeviceid();
  } else {
    clear_has_fromdeviceid();
  }
  fromdeviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fromdeviceid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginURLRequest.FromDeviceID)
}

// -------------------------------------------------------------------

// GetLoginURLResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetLoginURLResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLoginURLResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLoginURLResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLoginURLResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetLoginURLResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginURLResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetLoginURLResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginURLResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetLoginURLResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginURLResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetLoginURLResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginURLResponse.BaseResponse)
}

// optional string URL = 2;
inline bool GetLoginURLResponse::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLoginURLResponse::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLoginURLResponse::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLoginURLResponse::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& GetLoginURLResponse::url() const {
  // @@protoc_insertion_point(field_get:micromsg.GetLoginURLResponse.URL)
  return url_.GetNoArena();
}
inline void GetLoginURLResponse::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetLoginURLResponse.URL)
}
#if LANG_CXX11
inline void GetLoginURLResponse::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetLoginURLResponse.URL)
}
#endif
inline void GetLoginURLResponse::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetLoginURLResponse.URL)
}
inline void GetLoginURLResponse::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetLoginURLResponse.URL)
}
inline ::std::string* GetLoginURLResponse::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:micromsg.GetLoginURLResponse.URL)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLoginURLResponse::release_url() {
  // @@protoc_insertion_point(field_release:micromsg.GetLoginURLResponse.URL)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLoginURLResponse::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetLoginURLResponse.URL)
}

// -------------------------------------------------------------------

// PushLoginURLRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool PushLoginURLRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PushLoginURLRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PushLoginURLRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PushLoginURLRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& PushLoginURLRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* PushLoginURLRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* PushLoginURLRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void PushLoginURLRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLRequest.BaseRequest)
}

// optional string UserName = 2;
inline bool PushLoginURLRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushLoginURLRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushLoginURLRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushLoginURLRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& PushLoginURLRequest::username() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLRequest.UserName)
  return username_.GetNoArena();
}
inline void PushLoginURLRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PushLoginURLRequest.UserName)
}
#if LANG_CXX11
inline void PushLoginURLRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PushLoginURLRequest.UserName)
}
#endif
inline void PushLoginURLRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PushLoginURLRequest.UserName)
}
inline void PushLoginURLRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PushLoginURLRequest.UserName)
}
inline ::std::string* PushLoginURLRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLRequest.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushLoginURLRequest::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLRequest.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushLoginURLRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLRequest.UserName)
}

// optional string AutoAuthTicket = 3;
inline bool PushLoginURLRequest::has_autoauthticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushLoginURLRequest::set_has_autoauthticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushLoginURLRequest::clear_has_autoauthticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushLoginURLRequest::clear_autoauthticket() {
  autoauthticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_autoauthticket();
}
inline const ::std::string& PushLoginURLRequest::autoauthticket() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLRequest.AutoAuthTicket)
  return autoauthticket_.GetNoArena();
}
inline void PushLoginURLRequest::set_autoauthticket(const ::std::string& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PushLoginURLRequest.AutoAuthTicket)
}
#if LANG_CXX11
inline void PushLoginURLRequest::set_autoauthticket(::std::string&& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PushLoginURLRequest.AutoAuthTicket)
}
#endif
inline void PushLoginURLRequest::set_autoauthticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PushLoginURLRequest.AutoAuthTicket)
}
inline void PushLoginURLRequest::set_autoauthticket(const char* value, size_t size) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PushLoginURLRequest.AutoAuthTicket)
}
inline ::std::string* PushLoginURLRequest::mutable_autoauthticket() {
  set_has_autoauthticket();
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLRequest.AutoAuthTicket)
  return autoauthticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushLoginURLRequest::release_autoauthticket() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLRequest.AutoAuthTicket)
  clear_has_autoauthticket();
  return autoauthticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushLoginURLRequest::set_allocated_autoauthticket(::std::string* autoauthticket) {
  if (autoauthticket != NULL) {
    set_has_autoauthticket();
  } else {
    clear_has_autoauthticket();
  }
  autoauthticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), autoauthticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLRequest.AutoAuthTicket)
}

// optional string ClientID = 4;
inline bool PushLoginURLRequest::has_clientid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushLoginURLRequest::set_has_clientid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushLoginURLRequest::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushLoginURLRequest::clear_clientid() {
  clientid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientid();
}
inline const ::std::string& PushLoginURLRequest::clientid() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLRequest.ClientID)
  return clientid_.GetNoArena();
}
inline void PushLoginURLRequest::set_clientid(const ::std::string& value) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PushLoginURLRequest.ClientID)
}
#if LANG_CXX11
inline void PushLoginURLRequest::set_clientid(::std::string&& value) {
  set_has_clientid();
  clientid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PushLoginURLRequest.ClientID)
}
#endif
inline void PushLoginURLRequest::set_clientid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PushLoginURLRequest.ClientID)
}
inline void PushLoginURLRequest::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  clientid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PushLoginURLRequest.ClientID)
}
inline ::std::string* PushLoginURLRequest::mutable_clientid() {
  set_has_clientid();
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLRequest.ClientID)
  return clientid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushLoginURLRequest::release_clientid() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLRequest.ClientID)
  clear_has_clientid();
  return clientid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushLoginURLRequest::set_allocated_clientid(::std::string* clientid) {
  if (clientid != NULL) {
    set_has_clientid();
  } else {
    clear_has_clientid();
  }
  clientid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLRequest.ClientID)
}

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 5;
inline bool PushLoginURLRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PushLoginURLRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PushLoginURLRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PushLoginURLRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& PushLoginURLRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* PushLoginURLRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* PushLoginURLRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void PushLoginURLRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLRequest.RandomEncryKey)
}

// required uint32 OPCode = 6;
inline bool PushLoginURLRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PushLoginURLRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PushLoginURLRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PushLoginURLRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 PushLoginURLRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLRequest.OPCode)
  return opcode_;
}
inline void PushLoginURLRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.PushLoginURLRequest.OPCode)
}

// optional string DeviceName = 7;
inline bool PushLoginURLRequest::has_devicename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushLoginURLRequest::set_has_devicename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushLoginURLRequest::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushLoginURLRequest::clear_devicename() {
  devicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicename();
}
inline const ::std::string& PushLoginURLRequest::devicename() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLRequest.DeviceName)
  return devicename_.GetNoArena();
}
inline void PushLoginURLRequest::set_devicename(const ::std::string& value) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PushLoginURLRequest.DeviceName)
}
#if LANG_CXX11
inline void PushLoginURLRequest::set_devicename(::std::string&& value) {
  set_has_devicename();
  devicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PushLoginURLRequest.DeviceName)
}
#endif
inline void PushLoginURLRequest::set_devicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PushLoginURLRequest.DeviceName)
}
inline void PushLoginURLRequest::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PushLoginURLRequest.DeviceName)
}
inline ::std::string* PushLoginURLRequest::mutable_devicename() {
  set_has_devicename();
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLRequest.DeviceName)
  return devicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushLoginURLRequest::release_devicename() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLRequest.DeviceName)
  clear_has_devicename();
  return devicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushLoginURLRequest::set_allocated_devicename(::std::string* devicename) {
  if (devicename != NULL) {
    set_has_devicename();
  } else {
    clear_has_devicename();
  }
  devicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicename);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLRequest.DeviceName)
}

// optional .micromsg.SKBuiltinBuffer_t AutoAuthKey = 8;
inline bool PushLoginURLRequest::has_autoauthkey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PushLoginURLRequest::set_has_autoauthkey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PushLoginURLRequest::clear_has_autoauthkey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PushLoginURLRequest::clear_autoauthkey() {
  if (autoauthkey_ != NULL) autoauthkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_autoauthkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& PushLoginURLRequest::autoauthkey() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLRequest.AutoAuthKey)
  return autoauthkey_ != NULL ? *autoauthkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* PushLoginURLRequest::mutable_autoauthkey() {
  set_has_autoauthkey();
  if (autoauthkey_ == NULL) {
    autoauthkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLRequest.AutoAuthKey)
  return autoauthkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* PushLoginURLRequest::release_autoauthkey() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLRequest.AutoAuthKey)
  clear_has_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* temp = autoauthkey_;
  autoauthkey_ = NULL;
  return temp;
}
inline void PushLoginURLRequest::set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey) {
  delete autoauthkey_;
  autoauthkey_ = autoauthkey;
  if (autoauthkey) {
    set_has_autoauthkey();
  } else {
    clear_has_autoauthkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLRequest.AutoAuthKey)
}

// -------------------------------------------------------------------

// PushLoginURLResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool PushLoginURLResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PushLoginURLResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PushLoginURLResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PushLoginURLResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& PushLoginURLResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* PushLoginURLResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* PushLoginURLResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void PushLoginURLResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLResponse.BaseResponse)
}

// optional string UUID = 2;
inline bool PushLoginURLResponse::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushLoginURLResponse::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushLoginURLResponse::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushLoginURLResponse::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& PushLoginURLResponse::uuid() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLResponse.UUID)
  return uuid_.GetNoArena();
}
inline void PushLoginURLResponse::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PushLoginURLResponse.UUID)
}
#if LANG_CXX11
inline void PushLoginURLResponse::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PushLoginURLResponse.UUID)
}
#endif
inline void PushLoginURLResponse::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PushLoginURLResponse.UUID)
}
inline void PushLoginURLResponse::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PushLoginURLResponse.UUID)
}
inline ::std::string* PushLoginURLResponse::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLResponse.UUID)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushLoginURLResponse::release_uuid() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLResponse.UUID)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushLoginURLResponse::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLResponse.UUID)
}

// required .micromsg.SKBuiltinBuffer_t NotifyKey = 3;
inline bool PushLoginURLResponse::has_notifykey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PushLoginURLResponse::set_has_notifykey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PushLoginURLResponse::clear_has_notifykey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PushLoginURLResponse::clear_notifykey() {
  if (notifykey_ != NULL) notifykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_notifykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& PushLoginURLResponse::notifykey() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLResponse.NotifyKey)
  return notifykey_ != NULL ? *notifykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* PushLoginURLResponse::mutable_notifykey() {
  set_has_notifykey();
  if (notifykey_ == NULL) {
    notifykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLResponse.NotifyKey)
  return notifykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* PushLoginURLResponse::release_notifykey() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLResponse.NotifyKey)
  clear_has_notifykey();
  ::micromsg::SKBuiltinBuffer_t* temp = notifykey_;
  notifykey_ = NULL;
  return temp;
}
inline void PushLoginURLResponse::set_allocated_notifykey(::micromsg::SKBuiltinBuffer_t* notifykey) {
  delete notifykey_;
  notifykey_ = notifykey;
  if (notifykey) {
    set_has_notifykey();
  } else {
    clear_has_notifykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLResponse.NotifyKey)
}

// required uint32 CheckTime = 4;
inline bool PushLoginURLResponse::has_checktime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PushLoginURLResponse::set_has_checktime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PushLoginURLResponse::clear_has_checktime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PushLoginURLResponse::clear_checktime() {
  checktime_ = 0u;
  clear_has_checktime();
}
inline ::google::protobuf::uint32 PushLoginURLResponse::checktime() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLResponse.CheckTime)
  return checktime_;
}
inline void PushLoginURLResponse::set_checktime(::google::protobuf::uint32 value) {
  set_has_checktime();
  checktime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.PushLoginURLResponse.CheckTime)
}

// required uint32 ExpiredTime = 5;
inline bool PushLoginURLResponse::has_expiredtime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PushLoginURLResponse::set_has_expiredtime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PushLoginURLResponse::clear_has_expiredtime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PushLoginURLResponse::clear_expiredtime() {
  expiredtime_ = 0u;
  clear_has_expiredtime();
}
inline ::google::protobuf::uint32 PushLoginURLResponse::expiredtime() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLResponse.ExpiredTime)
  return expiredtime_;
}
inline void PushLoginURLResponse::set_expiredtime(::google::protobuf::uint32 value) {
  set_has_expiredtime();
  expiredtime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.PushLoginURLResponse.ExpiredTime)
}

// optional string BlueToothBroadCastUUID = 6;
inline bool PushLoginURLResponse::has_bluetoothbroadcastuuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushLoginURLResponse::set_has_bluetoothbroadcastuuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushLoginURLResponse::clear_has_bluetoothbroadcastuuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushLoginURLResponse::clear_bluetoothbroadcastuuid() {
  bluetoothbroadcastuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetoothbroadcastuuid();
}
inline const ::std::string& PushLoginURLResponse::bluetoothbroadcastuuid() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLResponse.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.GetNoArena();
}
inline void PushLoginURLResponse::set_bluetoothbroadcastuuid(const ::std::string& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.PushLoginURLResponse.BlueToothBroadCastUUID)
}
#if LANG_CXX11
inline void PushLoginURLResponse::set_bluetoothbroadcastuuid(::std::string&& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.PushLoginURLResponse.BlueToothBroadCastUUID)
}
#endif
inline void PushLoginURLResponse::set_bluetoothbroadcastuuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.PushLoginURLResponse.BlueToothBroadCastUUID)
}
inline void PushLoginURLResponse::set_bluetoothbroadcastuuid(const char* value, size_t size) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.PushLoginURLResponse.BlueToothBroadCastUUID)
}
inline ::std::string* PushLoginURLResponse::mutable_bluetoothbroadcastuuid() {
  set_has_bluetoothbroadcastuuid();
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLResponse.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushLoginURLResponse::release_bluetoothbroadcastuuid() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLResponse.BlueToothBroadCastUUID)
  clear_has_bluetoothbroadcastuuid();
  return bluetoothbroadcastuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushLoginURLResponse::set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid) {
  if (bluetoothbroadcastuuid != NULL) {
    set_has_bluetoothbroadcastuuid();
  } else {
    clear_has_bluetoothbroadcastuuid();
  }
  bluetoothbroadcastuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetoothbroadcastuuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLResponse.BlueToothBroadCastUUID)
}

// optional .micromsg.SKBuiltinBuffer_t BlueToothBroadCastContent = 7;
inline bool PushLoginURLResponse::has_bluetoothbroadcastcontent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PushLoginURLResponse::set_has_bluetoothbroadcastcontent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PushLoginURLResponse::clear_has_bluetoothbroadcastcontent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PushLoginURLResponse::clear_bluetoothbroadcastcontent() {
  if (bluetoothbroadcastcontent_ != NULL) bluetoothbroadcastcontent_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_bluetoothbroadcastcontent();
}
inline const ::micromsg::SKBuiltinBuffer_t& PushLoginURLResponse::bluetoothbroadcastcontent() const {
  // @@protoc_insertion_point(field_get:micromsg.PushLoginURLResponse.BlueToothBroadCastContent)
  return bluetoothbroadcastcontent_ != NULL ? *bluetoothbroadcastcontent_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* PushLoginURLResponse::mutable_bluetoothbroadcastcontent() {
  set_has_bluetoothbroadcastcontent();
  if (bluetoothbroadcastcontent_ == NULL) {
    bluetoothbroadcastcontent_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PushLoginURLResponse.BlueToothBroadCastContent)
  return bluetoothbroadcastcontent_;
}
inline ::micromsg::SKBuiltinBuffer_t* PushLoginURLResponse::release_bluetoothbroadcastcontent() {
  // @@protoc_insertion_point(field_release:micromsg.PushLoginURLResponse.BlueToothBroadCastContent)
  clear_has_bluetoothbroadcastcontent();
  ::micromsg::SKBuiltinBuffer_t* temp = bluetoothbroadcastcontent_;
  bluetoothbroadcastcontent_ = NULL;
  return temp;
}
inline void PushLoginURLResponse::set_allocated_bluetoothbroadcastcontent(::micromsg::SKBuiltinBuffer_t* bluetoothbroadcastcontent) {
  delete bluetoothbroadcastcontent_;
  bluetoothbroadcastcontent_ = bluetoothbroadcastcontent;
  if (bluetoothbroadcastcontent) {
    set_has_bluetoothbroadcastcontent();
  } else {
    clear_has_bluetoothbroadcastcontent();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PushLoginURLResponse.BlueToothBroadCastContent)
}

// -------------------------------------------------------------------

// BlueToothBindLoginRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BlueToothBindLoginRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueToothBindLoginRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueToothBindLoginRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueToothBindLoginRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BlueToothBindLoginRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothBindLoginRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BlueToothBindLoginRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothBindLoginRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BlueToothBindLoginRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothBindLoginRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BlueToothBindLoginRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothBindLoginRequest.BaseRequest)
}

// optional string URL = 2;
inline bool BlueToothBindLoginRequest::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueToothBindLoginRequest::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueToothBindLoginRequest::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueToothBindLoginRequest::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& BlueToothBindLoginRequest::url() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothBindLoginRequest.URL)
  return url_.GetNoArena();
}
inline void BlueToothBindLoginRequest::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothBindLoginRequest.URL)
}
#if LANG_CXX11
inline void BlueToothBindLoginRequest::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothBindLoginRequest.URL)
}
#endif
inline void BlueToothBindLoginRequest::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothBindLoginRequest.URL)
}
inline void BlueToothBindLoginRequest::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothBindLoginRequest.URL)
}
inline ::std::string* BlueToothBindLoginRequest::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothBindLoginRequest.URL)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothBindLoginRequest::release_url() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothBindLoginRequest.URL)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothBindLoginRequest::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothBindLoginRequest.URL)
}

// required uint32 OPCode = 3;
inline bool BlueToothBindLoginRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlueToothBindLoginRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlueToothBindLoginRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlueToothBindLoginRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 BlueToothBindLoginRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothBindLoginRequest.OPCode)
  return opcode_;
}
inline void BlueToothBindLoginRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BlueToothBindLoginRequest.OPCode)
}

// -------------------------------------------------------------------

// BlueToothBindLoginResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BlueToothBindLoginResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlueToothBindLoginResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlueToothBindLoginResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlueToothBindLoginResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BlueToothBindLoginResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothBindLoginResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BlueToothBindLoginResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothBindLoginResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BlueToothBindLoginResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothBindLoginResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BlueToothBindLoginResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothBindLoginResponse.BaseResponse)
}

// optional string DeviceName = 2;
inline bool BlueToothBindLoginResponse::has_devicename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueToothBindLoginResponse::set_has_devicename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueToothBindLoginResponse::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueToothBindLoginResponse::clear_devicename() {
  devicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicename();
}
inline const ::std::string& BlueToothBindLoginResponse::devicename() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothBindLoginResponse.DeviceName)
  return devicename_.GetNoArena();
}
inline void BlueToothBindLoginResponse::set_devicename(const ::std::string& value) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothBindLoginResponse.DeviceName)
}
#if LANG_CXX11
inline void BlueToothBindLoginResponse::set_devicename(::std::string&& value) {
  set_has_devicename();
  devicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothBindLoginResponse.DeviceName)
}
#endif
inline void BlueToothBindLoginResponse::set_devicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothBindLoginResponse.DeviceName)
}
inline void BlueToothBindLoginResponse::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothBindLoginResponse.DeviceName)
}
inline ::std::string* BlueToothBindLoginResponse::mutable_devicename() {
  set_has_devicename();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothBindLoginResponse.DeviceName)
  return devicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothBindLoginResponse::release_devicename() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothBindLoginResponse.DeviceName)
  clear_has_devicename();
  return devicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothBindLoginResponse::set_allocated_devicename(::std::string* devicename) {
  if (devicename != NULL) {
    set_has_devicename();
  } else {
    clear_has_devicename();
  }
  devicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicename);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothBindLoginResponse.DeviceName)
}

// required uint32 ExpiredTime = 3;
inline bool BlueToothBindLoginResponse::has_expiredtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlueToothBindLoginResponse::set_has_expiredtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlueToothBindLoginResponse::clear_has_expiredtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlueToothBindLoginResponse::clear_expiredtime() {
  expiredtime_ = 0u;
  clear_has_expiredtime();
}
inline ::google::protobuf::uint32 BlueToothBindLoginResponse::expiredtime() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothBindLoginResponse.ExpiredTime)
  return expiredtime_;
}
inline void BlueToothBindLoginResponse::set_expiredtime(::google::protobuf::uint32 value) {
  set_has_expiredtime();
  expiredtime_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BlueToothBindLoginResponse.ExpiredTime)
}

// optional string UUID = 4;
inline bool BlueToothBindLoginResponse::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueToothBindLoginResponse::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueToothBindLoginResponse::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueToothBindLoginResponse::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& BlueToothBindLoginResponse::uuid() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothBindLoginResponse.UUID)
  return uuid_.GetNoArena();
}
inline void BlueToothBindLoginResponse::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothBindLoginResponse.UUID)
}
#if LANG_CXX11
inline void BlueToothBindLoginResponse::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothBindLoginResponse.UUID)
}
#endif
inline void BlueToothBindLoginResponse::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothBindLoginResponse.UUID)
}
inline void BlueToothBindLoginResponse::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothBindLoginResponse.UUID)
}
inline ::std::string* BlueToothBindLoginResponse::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothBindLoginResponse.UUID)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothBindLoginResponse::release_uuid() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothBindLoginResponse.UUID)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothBindLoginResponse::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothBindLoginResponse.UUID)
}

// optional string BlueToothBroadCastUUID = 5;
inline bool BlueToothBindLoginResponse::has_bluetoothbroadcastuuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlueToothBindLoginResponse::set_has_bluetoothbroadcastuuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlueToothBindLoginResponse::clear_has_bluetoothbroadcastuuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlueToothBindLoginResponse::clear_bluetoothbroadcastuuid() {
  bluetoothbroadcastuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetoothbroadcastuuid();
}
inline const ::std::string& BlueToothBindLoginResponse::bluetoothbroadcastuuid() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothBindLoginResponse.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.GetNoArena();
}
inline void BlueToothBindLoginResponse::set_bluetoothbroadcastuuid(const ::std::string& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothBindLoginResponse.BlueToothBroadCastUUID)
}
#if LANG_CXX11
inline void BlueToothBindLoginResponse::set_bluetoothbroadcastuuid(::std::string&& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothBindLoginResponse.BlueToothBroadCastUUID)
}
#endif
inline void BlueToothBindLoginResponse::set_bluetoothbroadcastuuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothBindLoginResponse.BlueToothBroadCastUUID)
}
inline void BlueToothBindLoginResponse::set_bluetoothbroadcastuuid(const char* value, size_t size) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothBindLoginResponse.BlueToothBroadCastUUID)
}
inline ::std::string* BlueToothBindLoginResponse::mutable_bluetoothbroadcastuuid() {
  set_has_bluetoothbroadcastuuid();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothBindLoginResponse.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothBindLoginResponse::release_bluetoothbroadcastuuid() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothBindLoginResponse.BlueToothBroadCastUUID)
  clear_has_bluetoothbroadcastuuid();
  return bluetoothbroadcastuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothBindLoginResponse::set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid) {
  if (bluetoothbroadcastuuid != NULL) {
    set_has_bluetoothbroadcastuuid();
  } else {
    clear_has_bluetoothbroadcastuuid();
  }
  bluetoothbroadcastuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetoothbroadcastuuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothBindLoginResponse.BlueToothBroadCastUUID)
}

// -------------------------------------------------------------------

// BlueToothAutoLoginRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BlueToothAutoLoginRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlueToothAutoLoginRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlueToothAutoLoginRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlueToothAutoLoginRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BlueToothAutoLoginRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BlueToothAutoLoginRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BlueToothAutoLoginRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BlueToothAutoLoginRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginRequest.BaseRequest)
}

// optional string UserName = 2;
inline bool BlueToothAutoLoginRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueToothAutoLoginRequest::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueToothAutoLoginRequest::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueToothAutoLoginRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& BlueToothAutoLoginRequest::username() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginRequest.UserName)
  return username_.GetNoArena();
}
inline void BlueToothAutoLoginRequest::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginRequest.UserName)
}
#if LANG_CXX11
inline void BlueToothAutoLoginRequest::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothAutoLoginRequest.UserName)
}
#endif
inline void BlueToothAutoLoginRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothAutoLoginRequest.UserName)
}
inline void BlueToothAutoLoginRequest::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothAutoLoginRequest.UserName)
}
inline ::std::string* BlueToothAutoLoginRequest::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginRequest.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothAutoLoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginRequest.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothAutoLoginRequest::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginRequest.UserName)
}

// optional string UUID = 3;
inline bool BlueToothAutoLoginRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueToothAutoLoginRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueToothAutoLoginRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueToothAutoLoginRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
inline const ::std::string& BlueToothAutoLoginRequest::uuid() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginRequest.UUID)
  return uuid_.GetNoArena();
}
inline void BlueToothAutoLoginRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginRequest.UUID)
}
#if LANG_CXX11
inline void BlueToothAutoLoginRequest::set_uuid(::std::string&& value) {
  set_has_uuid();
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothAutoLoginRequest.UUID)
}
#endif
inline void BlueToothAutoLoginRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothAutoLoginRequest.UUID)
}
inline void BlueToothAutoLoginRequest::set_uuid(const char* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothAutoLoginRequest.UUID)
}
inline ::std::string* BlueToothAutoLoginRequest::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginRequest.UUID)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothAutoLoginRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginRequest.UUID)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothAutoLoginRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginRequest.UUID)
}

// optional string AutoAuthTicket = 4;
inline bool BlueToothAutoLoginRequest::has_autoauthticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlueToothAutoLoginRequest::set_has_autoauthticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlueToothAutoLoginRequest::clear_has_autoauthticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlueToothAutoLoginRequest::clear_autoauthticket() {
  autoauthticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_autoauthticket();
}
inline const ::std::string& BlueToothAutoLoginRequest::autoauthticket() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginRequest.AutoAuthTicket)
  return autoauthticket_.GetNoArena();
}
inline void BlueToothAutoLoginRequest::set_autoauthticket(const ::std::string& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginRequest.AutoAuthTicket)
}
#if LANG_CXX11
inline void BlueToothAutoLoginRequest::set_autoauthticket(::std::string&& value) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothAutoLoginRequest.AutoAuthTicket)
}
#endif
inline void BlueToothAutoLoginRequest::set_autoauthticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothAutoLoginRequest.AutoAuthTicket)
}
inline void BlueToothAutoLoginRequest::set_autoauthticket(const char* value, size_t size) {
  set_has_autoauthticket();
  autoauthticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothAutoLoginRequest.AutoAuthTicket)
}
inline ::std::string* BlueToothAutoLoginRequest::mutable_autoauthticket() {
  set_has_autoauthticket();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginRequest.AutoAuthTicket)
  return autoauthticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothAutoLoginRequest::release_autoauthticket() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginRequest.AutoAuthTicket)
  clear_has_autoauthticket();
  return autoauthticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothAutoLoginRequest::set_allocated_autoauthticket(::std::string* autoauthticket) {
  if (autoauthticket != NULL) {
    set_has_autoauthticket();
  } else {
    clear_has_autoauthticket();
  }
  autoauthticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), autoauthticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginRequest.AutoAuthTicket)
}

// required .micromsg.SKBuiltinBuffer_t LoginInfoData = 5;
inline bool BlueToothAutoLoginRequest::has_logininfodata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlueToothAutoLoginRequest::set_has_logininfodata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlueToothAutoLoginRequest::clear_has_logininfodata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlueToothAutoLoginRequest::clear_logininfodata() {
  if (logininfodata_ != NULL) logininfodata_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_logininfodata();
}
inline const ::micromsg::SKBuiltinBuffer_t& BlueToothAutoLoginRequest::logininfodata() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginRequest.LoginInfoData)
  return logininfodata_ != NULL ? *logininfodata_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BlueToothAutoLoginRequest::mutable_logininfodata() {
  set_has_logininfodata();
  if (logininfodata_ == NULL) {
    logininfodata_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginRequest.LoginInfoData)
  return logininfodata_;
}
inline ::micromsg::SKBuiltinBuffer_t* BlueToothAutoLoginRequest::release_logininfodata() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginRequest.LoginInfoData)
  clear_has_logininfodata();
  ::micromsg::SKBuiltinBuffer_t* temp = logininfodata_;
  logininfodata_ = NULL;
  return temp;
}
inline void BlueToothAutoLoginRequest::set_allocated_logininfodata(::micromsg::SKBuiltinBuffer_t* logininfodata) {
  delete logininfodata_;
  logininfodata_ = logininfodata;
  if (logininfodata) {
    set_has_logininfodata();
  } else {
    clear_has_logininfodata();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginRequest.LoginInfoData)
}

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 6;
inline bool BlueToothAutoLoginRequest::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BlueToothAutoLoginRequest::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BlueToothAutoLoginRequest::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BlueToothAutoLoginRequest::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& BlueToothAutoLoginRequest::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginRequest.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BlueToothAutoLoginRequest::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginRequest.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* BlueToothAutoLoginRequest::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginRequest.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void BlueToothAutoLoginRequest::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginRequest.RandomEncryKey)
}

// optional string BlueToothBroadCastUUID = 7;
inline bool BlueToothAutoLoginRequest::has_bluetoothbroadcastuuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlueToothAutoLoginRequest::set_has_bluetoothbroadcastuuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlueToothAutoLoginRequest::clear_has_bluetoothbroadcastuuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlueToothAutoLoginRequest::clear_bluetoothbroadcastuuid() {
  bluetoothbroadcastuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetoothbroadcastuuid();
}
inline const ::std::string& BlueToothAutoLoginRequest::bluetoothbroadcastuuid() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginRequest.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.GetNoArena();
}
inline void BlueToothAutoLoginRequest::set_bluetoothbroadcastuuid(const ::std::string& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginRequest.BlueToothBroadCastUUID)
}
#if LANG_CXX11
inline void BlueToothAutoLoginRequest::set_bluetoothbroadcastuuid(::std::string&& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothAutoLoginRequest.BlueToothBroadCastUUID)
}
#endif
inline void BlueToothAutoLoginRequest::set_bluetoothbroadcastuuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothAutoLoginRequest.BlueToothBroadCastUUID)
}
inline void BlueToothAutoLoginRequest::set_bluetoothbroadcastuuid(const char* value, size_t size) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothAutoLoginRequest.BlueToothBroadCastUUID)
}
inline ::std::string* BlueToothAutoLoginRequest::mutable_bluetoothbroadcastuuid() {
  set_has_bluetoothbroadcastuuid();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginRequest.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothAutoLoginRequest::release_bluetoothbroadcastuuid() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginRequest.BlueToothBroadCastUUID)
  clear_has_bluetoothbroadcastuuid();
  return bluetoothbroadcastuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothAutoLoginRequest::set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid) {
  if (bluetoothbroadcastuuid != NULL) {
    set_has_bluetoothbroadcastuuid();
  } else {
    clear_has_bluetoothbroadcastuuid();
  }
  bluetoothbroadcastuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetoothbroadcastuuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginRequest.BlueToothBroadCastUUID)
}

// -------------------------------------------------------------------

// BlueToothAutoLoginResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BlueToothAutoLoginResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlueToothAutoLoginResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlueToothAutoLoginResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlueToothAutoLoginResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BlueToothAutoLoginResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BlueToothAutoLoginResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BlueToothAutoLoginResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BlueToothAutoLoginResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginResponse.BaseResponse)
}

// optional string UserName = 2;
inline bool BlueToothAutoLoginResponse::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueToothAutoLoginResponse::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueToothAutoLoginResponse::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueToothAutoLoginResponse::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& BlueToothAutoLoginResponse::username() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginResponse.UserName)
  return username_.GetNoArena();
}
inline void BlueToothAutoLoginResponse::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginResponse.UserName)
}
#if LANG_CXX11
inline void BlueToothAutoLoginResponse::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothAutoLoginResponse.UserName)
}
#endif
inline void BlueToothAutoLoginResponse::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothAutoLoginResponse.UserName)
}
inline void BlueToothAutoLoginResponse::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothAutoLoginResponse.UserName)
}
inline ::std::string* BlueToothAutoLoginResponse::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginResponse.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothAutoLoginResponse::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginResponse.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothAutoLoginResponse::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginResponse.UserName)
}

// optional string Password = 3;
inline bool BlueToothAutoLoginResponse::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueToothAutoLoginResponse::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueToothAutoLoginResponse::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueToothAutoLoginResponse::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& BlueToothAutoLoginResponse::password() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginResponse.Password)
  return password_.GetNoArena();
}
inline void BlueToothAutoLoginResponse::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginResponse.Password)
}
#if LANG_CXX11
inline void BlueToothAutoLoginResponse::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothAutoLoginResponse.Password)
}
#endif
inline void BlueToothAutoLoginResponse::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothAutoLoginResponse.Password)
}
inline void BlueToothAutoLoginResponse::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothAutoLoginResponse.Password)
}
inline ::std::string* BlueToothAutoLoginResponse::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginResponse.Password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothAutoLoginResponse::release_password() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginResponse.Password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothAutoLoginResponse::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginResponse.Password)
}

// -------------------------------------------------------------------

// BlueToothAutoLoginInfoPkg

// required .micromsg.SKBuiltinBuffer_t Salt = 1;
inline bool BlueToothAutoLoginInfoPkg::has_salt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueToothAutoLoginInfoPkg::set_has_salt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueToothAutoLoginInfoPkg::clear_has_salt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueToothAutoLoginInfoPkg::clear_salt() {
  if (salt_ != NULL) salt_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_salt();
}
inline const ::micromsg::SKBuiltinBuffer_t& BlueToothAutoLoginInfoPkg::salt() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginInfoPkg.Salt)
  return salt_ != NULL ? *salt_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BlueToothAutoLoginInfoPkg::mutable_salt() {
  set_has_salt();
  if (salt_ == NULL) {
    salt_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginInfoPkg.Salt)
  return salt_;
}
inline ::micromsg::SKBuiltinBuffer_t* BlueToothAutoLoginInfoPkg::release_salt() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginInfoPkg.Salt)
  clear_has_salt();
  ::micromsg::SKBuiltinBuffer_t* temp = salt_;
  salt_ = NULL;
  return temp;
}
inline void BlueToothAutoLoginInfoPkg::set_allocated_salt(::micromsg::SKBuiltinBuffer_t* salt) {
  delete salt_;
  salt_ = salt;
  if (salt) {
    set_has_salt();
  } else {
    clear_has_salt();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginInfoPkg.Salt)
}

// required .micromsg.SKBuiltinBuffer_t Data = 2;
inline bool BlueToothAutoLoginInfoPkg::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueToothAutoLoginInfoPkg::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueToothAutoLoginInfoPkg::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueToothAutoLoginInfoPkg::clear_data() {
  if (data_ != NULL) data_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_data();
}
inline const ::micromsg::SKBuiltinBuffer_t& BlueToothAutoLoginInfoPkg::data() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginInfoPkg.Data)
  return data_ != NULL ? *data_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BlueToothAutoLoginInfoPkg::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    data_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginInfoPkg.Data)
  return data_;
}
inline ::micromsg::SKBuiltinBuffer_t* BlueToothAutoLoginInfoPkg::release_data() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginInfoPkg.Data)
  clear_has_data();
  ::micromsg::SKBuiltinBuffer_t* temp = data_;
  data_ = NULL;
  return temp;
}
inline void BlueToothAutoLoginInfoPkg::set_allocated_data(::micromsg::SKBuiltinBuffer_t* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginInfoPkg.Data)
}

// -------------------------------------------------------------------

// BlueToothAutoLoginInfo

// required uint32 Uin = 1;
inline bool BlueToothAutoLoginInfo::has_uin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlueToothAutoLoginInfo::set_has_uin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlueToothAutoLoginInfo::clear_has_uin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlueToothAutoLoginInfo::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 BlueToothAutoLoginInfo::uin() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginInfo.Uin)
  return uin_;
}
inline void BlueToothAutoLoginInfo::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginInfo.Uin)
}

// optional string DeviceType = 2;
inline bool BlueToothAutoLoginInfo::has_devicetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueToothAutoLoginInfo::set_has_devicetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueToothAutoLoginInfo::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueToothAutoLoginInfo::clear_devicetype() {
  devicetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicetype();
}
inline const ::std::string& BlueToothAutoLoginInfo::devicetype() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginInfo.DeviceType)
  return devicetype_.GetNoArena();
}
inline void BlueToothAutoLoginInfo::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginInfo.DeviceType)
}
#if LANG_CXX11
inline void BlueToothAutoLoginInfo::set_devicetype(::std::string&& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothAutoLoginInfo.DeviceType)
}
#endif
inline void BlueToothAutoLoginInfo::set_devicetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothAutoLoginInfo.DeviceType)
}
inline void BlueToothAutoLoginInfo::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothAutoLoginInfo.DeviceType)
}
inline ::std::string* BlueToothAutoLoginInfo::mutable_devicetype() {
  set_has_devicetype();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginInfo.DeviceType)
  return devicetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothAutoLoginInfo::release_devicetype() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginInfo.DeviceType)
  clear_has_devicetype();
  return devicetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothAutoLoginInfo::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype != NULL) {
    set_has_devicetype();
  } else {
    clear_has_devicetype();
  }
  devicetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginInfo.DeviceType)
}

// required uint32 ClientVersion = 3;
inline bool BlueToothAutoLoginInfo::has_clientversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlueToothAutoLoginInfo::set_has_clientversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlueToothAutoLoginInfo::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlueToothAutoLoginInfo::clear_clientversion() {
  clientversion_ = 0u;
  clear_has_clientversion();
}
inline ::google::protobuf::uint32 BlueToothAutoLoginInfo::clientversion() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginInfo.ClientVersion)
  return clientversion_;
}
inline void BlueToothAutoLoginInfo::set_clientversion(::google::protobuf::uint32 value) {
  set_has_clientversion();
  clientversion_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginInfo.ClientVersion)
}

// optional bytes DeviceID = 4;
inline bool BlueToothAutoLoginInfo::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueToothAutoLoginInfo::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueToothAutoLoginInfo::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueToothAutoLoginInfo::clear_deviceid() {
  deviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_deviceid();
}
inline const ::std::string& BlueToothAutoLoginInfo::deviceid() const {
  // @@protoc_insertion_point(field_get:micromsg.BlueToothAutoLoginInfo.DeviceID)
  return deviceid_.GetNoArena();
}
inline void BlueToothAutoLoginInfo::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BlueToothAutoLoginInfo.DeviceID)
}
#if LANG_CXX11
inline void BlueToothAutoLoginInfo::set_deviceid(::std::string&& value) {
  set_has_deviceid();
  deviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BlueToothAutoLoginInfo.DeviceID)
}
#endif
inline void BlueToothAutoLoginInfo::set_deviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_deviceid();
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BlueToothAutoLoginInfo.DeviceID)
}
inline void BlueToothAutoLoginInfo::set_deviceid(const void* value, size_t size) {
  set_has_deviceid();
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BlueToothAutoLoginInfo.DeviceID)
}
inline ::std::string* BlueToothAutoLoginInfo::mutable_deviceid() {
  set_has_deviceid();
  // @@protoc_insertion_point(field_mutable:micromsg.BlueToothAutoLoginInfo.DeviceID)
  return deviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlueToothAutoLoginInfo::release_deviceid() {
  // @@protoc_insertion_point(field_release:micromsg.BlueToothAutoLoginInfo.DeviceID)
  clear_has_deviceid();
  return deviceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlueToothAutoLoginInfo::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid != NULL) {
    set_has_deviceid();
  } else {
    clear_has_deviceid();
  }
  deviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BlueToothAutoLoginInfo.DeviceID)
}

// -------------------------------------------------------------------

// BindBlackberryPPIDRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool BindBlackberryPPIDRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BindBlackberryPPIDRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BindBlackberryPPIDRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BindBlackberryPPIDRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& BindBlackberryPPIDRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.BindBlackberryPPIDRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* BindBlackberryPPIDRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindBlackberryPPIDRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* BindBlackberryPPIDRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.BindBlackberryPPIDRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void BindBlackberryPPIDRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindBlackberryPPIDRequest.BaseRequest)
}

// required uint32 Opcode = 2;
inline bool BindBlackberryPPIDRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BindBlackberryPPIDRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BindBlackberryPPIDRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BindBlackberryPPIDRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 BindBlackberryPPIDRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.BindBlackberryPPIDRequest.Opcode)
  return opcode_;
}
inline void BindBlackberryPPIDRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindBlackberryPPIDRequest.Opcode)
}

// optional string BBPPID = 3;
inline bool BindBlackberryPPIDRequest::has_bbppid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindBlackberryPPIDRequest::set_has_bbppid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindBlackberryPPIDRequest::clear_has_bbppid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindBlackberryPPIDRequest::clear_bbppid() {
  bbppid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bbppid();
}
inline const ::std::string& BindBlackberryPPIDRequest::bbppid() const {
  // @@protoc_insertion_point(field_get:micromsg.BindBlackberryPPIDRequest.BBPPID)
  return bbppid_.GetNoArena();
}
inline void BindBlackberryPPIDRequest::set_bbppid(const ::std::string& value) {
  set_has_bbppid();
  bbppid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindBlackberryPPIDRequest.BBPPID)
}
#if LANG_CXX11
inline void BindBlackberryPPIDRequest::set_bbppid(::std::string&& value) {
  set_has_bbppid();
  bbppid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindBlackberryPPIDRequest.BBPPID)
}
#endif
inline void BindBlackberryPPIDRequest::set_bbppid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bbppid();
  bbppid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindBlackberryPPIDRequest.BBPPID)
}
inline void BindBlackberryPPIDRequest::set_bbppid(const char* value, size_t size) {
  set_has_bbppid();
  bbppid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindBlackberryPPIDRequest.BBPPID)
}
inline ::std::string* BindBlackberryPPIDRequest::mutable_bbppid() {
  set_has_bbppid();
  // @@protoc_insertion_point(field_mutable:micromsg.BindBlackberryPPIDRequest.BBPPID)
  return bbppid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindBlackberryPPIDRequest::release_bbppid() {
  // @@protoc_insertion_point(field_release:micromsg.BindBlackberryPPIDRequest.BBPPID)
  clear_has_bbppid();
  return bbppid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindBlackberryPPIDRequest::set_allocated_bbppid(::std::string* bbppid) {
  if (bbppid != NULL) {
    set_has_bbppid();
  } else {
    clear_has_bbppid();
  }
  bbppid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bbppid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindBlackberryPPIDRequest.BBPPID)
}

// optional string BBPIN = 4;
inline bool BindBlackberryPPIDRequest::has_bbpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BindBlackberryPPIDRequest::set_has_bbpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BindBlackberryPPIDRequest::clear_has_bbpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BindBlackberryPPIDRequest::clear_bbpin() {
  bbpin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bbpin();
}
inline const ::std::string& BindBlackberryPPIDRequest::bbpin() const {
  // @@protoc_insertion_point(field_get:micromsg.BindBlackberryPPIDRequest.BBPIN)
  return bbpin_.GetNoArena();
}
inline void BindBlackberryPPIDRequest::set_bbpin(const ::std::string& value) {
  set_has_bbpin();
  bbpin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindBlackberryPPIDRequest.BBPIN)
}
#if LANG_CXX11
inline void BindBlackberryPPIDRequest::set_bbpin(::std::string&& value) {
  set_has_bbpin();
  bbpin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindBlackberryPPIDRequest.BBPIN)
}
#endif
inline void BindBlackberryPPIDRequest::set_bbpin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bbpin();
  bbpin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindBlackberryPPIDRequest.BBPIN)
}
inline void BindBlackberryPPIDRequest::set_bbpin(const char* value, size_t size) {
  set_has_bbpin();
  bbpin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindBlackberryPPIDRequest.BBPIN)
}
inline ::std::string* BindBlackberryPPIDRequest::mutable_bbpin() {
  set_has_bbpin();
  // @@protoc_insertion_point(field_mutable:micromsg.BindBlackberryPPIDRequest.BBPIN)
  return bbpin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindBlackberryPPIDRequest::release_bbpin() {
  // @@protoc_insertion_point(field_release:micromsg.BindBlackberryPPIDRequest.BBPIN)
  clear_has_bbpin();
  return bbpin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindBlackberryPPIDRequest::set_allocated_bbpin(::std::string* bbpin) {
  if (bbpin != NULL) {
    set_has_bbpin();
  } else {
    clear_has_bbpin();
  }
  bbpin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bbpin);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindBlackberryPPIDRequest.BBPIN)
}

// optional string BBMNickName = 5;
inline bool BindBlackberryPPIDRequest::has_bbmnickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BindBlackberryPPIDRequest::set_has_bbmnickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BindBlackberryPPIDRequest::clear_has_bbmnickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BindBlackberryPPIDRequest::clear_bbmnickname() {
  bbmnickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bbmnickname();
}
inline const ::std::string& BindBlackberryPPIDRequest::bbmnickname() const {
  // @@protoc_insertion_point(field_get:micromsg.BindBlackberryPPIDRequest.BBMNickName)
  return bbmnickname_.GetNoArena();
}
inline void BindBlackberryPPIDRequest::set_bbmnickname(const ::std::string& value) {
  set_has_bbmnickname();
  bbmnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BindBlackberryPPIDRequest.BBMNickName)
}
#if LANG_CXX11
inline void BindBlackberryPPIDRequest::set_bbmnickname(::std::string&& value) {
  set_has_bbmnickname();
  bbmnickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BindBlackberryPPIDRequest.BBMNickName)
}
#endif
inline void BindBlackberryPPIDRequest::set_bbmnickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bbmnickname();
  bbmnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BindBlackberryPPIDRequest.BBMNickName)
}
inline void BindBlackberryPPIDRequest::set_bbmnickname(const char* value, size_t size) {
  set_has_bbmnickname();
  bbmnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BindBlackberryPPIDRequest.BBMNickName)
}
inline ::std::string* BindBlackberryPPIDRequest::mutable_bbmnickname() {
  set_has_bbmnickname();
  // @@protoc_insertion_point(field_mutable:micromsg.BindBlackberryPPIDRequest.BBMNickName)
  return bbmnickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BindBlackberryPPIDRequest::release_bbmnickname() {
  // @@protoc_insertion_point(field_release:micromsg.BindBlackberryPPIDRequest.BBMNickName)
  clear_has_bbmnickname();
  return bbmnickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BindBlackberryPPIDRequest::set_allocated_bbmnickname(::std::string* bbmnickname) {
  if (bbmnickname != NULL) {
    set_has_bbmnickname();
  } else {
    clear_has_bbmnickname();
  }
  bbmnickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bbmnickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindBlackberryPPIDRequest.BBMNickName)
}

// required uint32 Force = 6;
inline bool BindBlackberryPPIDRequest::has_force() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BindBlackberryPPIDRequest::set_has_force() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BindBlackberryPPIDRequest::clear_has_force() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BindBlackberryPPIDRequest::clear_force() {
  force_ = 0u;
  clear_has_force();
}
inline ::google::protobuf::uint32 BindBlackberryPPIDRequest::force() const {
  // @@protoc_insertion_point(field_get:micromsg.BindBlackberryPPIDRequest.Force)
  return force_;
}
inline void BindBlackberryPPIDRequest::set_force(::google::protobuf::uint32 value) {
  set_has_force();
  force_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BindBlackberryPPIDRequest.Force)
}

// -------------------------------------------------------------------

// BindBlackberryPPIDResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool BindBlackberryPPIDResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BindBlackberryPPIDResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BindBlackberryPPIDResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BindBlackberryPPIDResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& BindBlackberryPPIDResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.BindBlackberryPPIDResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* BindBlackberryPPIDResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BindBlackberryPPIDResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* BindBlackberryPPIDResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.BindBlackberryPPIDResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void BindBlackberryPPIDResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BindBlackberryPPIDResponse.BaseResponse)
}

// -------------------------------------------------------------------

// LockWebDeviceRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool LockWebDeviceRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LockWebDeviceRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LockWebDeviceRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LockWebDeviceRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& LockWebDeviceRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.LockWebDeviceRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* LockWebDeviceRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.LockWebDeviceRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* LockWebDeviceRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.LockWebDeviceRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void LockWebDeviceRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.LockWebDeviceRequest.BaseRequest)
}

// required uint32 OPCode = 2;
inline bool LockWebDeviceRequest::has_opcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LockWebDeviceRequest::set_has_opcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LockWebDeviceRequest::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LockWebDeviceRequest::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 LockWebDeviceRequest::opcode() const {
  // @@protoc_insertion_point(field_get:micromsg.LockWebDeviceRequest.OPCode)
  return opcode_;
}
inline void LockWebDeviceRequest::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
  // @@protoc_insertion_point(field_set:micromsg.LockWebDeviceRequest.OPCode)
}

// optional string BlueToothBroadCastUUID = 3;
inline bool LockWebDeviceRequest::has_bluetoothbroadcastuuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LockWebDeviceRequest::set_has_bluetoothbroadcastuuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LockWebDeviceRequest::clear_has_bluetoothbroadcastuuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LockWebDeviceRequest::clear_bluetoothbroadcastuuid() {
  bluetoothbroadcastuuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetoothbroadcastuuid();
}
inline const ::std::string& LockWebDeviceRequest::bluetoothbroadcastuuid() const {
  // @@protoc_insertion_point(field_get:micromsg.LockWebDeviceRequest.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.GetNoArena();
}
inline void LockWebDeviceRequest::set_bluetoothbroadcastuuid(const ::std::string& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.LockWebDeviceRequest.BlueToothBroadCastUUID)
}
#if LANG_CXX11
inline void LockWebDeviceRequest::set_bluetoothbroadcastuuid(::std::string&& value) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.LockWebDeviceRequest.BlueToothBroadCastUUID)
}
#endif
inline void LockWebDeviceRequest::set_bluetoothbroadcastuuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.LockWebDeviceRequest.BlueToothBroadCastUUID)
}
inline void LockWebDeviceRequest::set_bluetoothbroadcastuuid(const char* value, size_t size) {
  set_has_bluetoothbroadcastuuid();
  bluetoothbroadcastuuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.LockWebDeviceRequest.BlueToothBroadCastUUID)
}
inline ::std::string* LockWebDeviceRequest::mutable_bluetoothbroadcastuuid() {
  set_has_bluetoothbroadcastuuid();
  // @@protoc_insertion_point(field_mutable:micromsg.LockWebDeviceRequest.BlueToothBroadCastUUID)
  return bluetoothbroadcastuuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockWebDeviceRequest::release_bluetoothbroadcastuuid() {
  // @@protoc_insertion_point(field_release:micromsg.LockWebDeviceRequest.BlueToothBroadCastUUID)
  clear_has_bluetoothbroadcastuuid();
  return bluetoothbroadcastuuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockWebDeviceRequest::set_allocated_bluetoothbroadcastuuid(::std::string* bluetoothbroadcastuuid) {
  if (bluetoothbroadcastuuid != NULL) {
    set_has_bluetoothbroadcastuuid();
  } else {
    clear_has_bluetoothbroadcastuuid();
  }
  bluetoothbroadcastuuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetoothbroadcastuuid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.LockWebDeviceRequest.BlueToothBroadCastUUID)
}

// required .micromsg.SKBuiltinBuffer_t BlueToothBroadCastContent = 4;
inline bool LockWebDeviceRequest::has_bluetoothbroadcastcontent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LockWebDeviceRequest::set_has_bluetoothbroadcastcontent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LockWebDeviceRequest::clear_has_bluetoothbroadcastcontent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LockWebDeviceRequest::clear_bluetoothbroadcastcontent() {
  if (bluetoothbroadcastcontent_ != NULL) bluetoothbroadcastcontent_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_bluetoothbroadcastcontent();
}
inline const ::micromsg::SKBuiltinBuffer_t& LockWebDeviceRequest::bluetoothbroadcastcontent() const {
  // @@protoc_insertion_point(field_get:micromsg.LockWebDeviceRequest.BlueToothBroadCastContent)
  return bluetoothbroadcastcontent_ != NULL ? *bluetoothbroadcastcontent_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* LockWebDeviceRequest::mutable_bluetoothbroadcastcontent() {
  set_has_bluetoothbroadcastcontent();
  if (bluetoothbroadcastcontent_ == NULL) {
    bluetoothbroadcastcontent_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.LockWebDeviceRequest.BlueToothBroadCastContent)
  return bluetoothbroadcastcontent_;
}
inline ::micromsg::SKBuiltinBuffer_t* LockWebDeviceRequest::release_bluetoothbroadcastcontent() {
  // @@protoc_insertion_point(field_release:micromsg.LockWebDeviceRequest.BlueToothBroadCastContent)
  clear_has_bluetoothbroadcastcontent();
  ::micromsg::SKBuiltinBuffer_t* temp = bluetoothbroadcastcontent_;
  bluetoothbroadcastcontent_ = NULL;
  return temp;
}
inline void LockWebDeviceRequest::set_allocated_bluetoothbroadcastcontent(::micromsg::SKBuiltinBuffer_t* bluetoothbroadcastcontent) {
  delete bluetoothbroadcastcontent_;
  bluetoothbroadcastcontent_ = bluetoothbroadcastcontent;
  if (bluetoothbroadcastcontent) {
    set_has_bluetoothbroadcastcontent();
  } else {
    clear_has_bluetoothbroadcastcontent();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.LockWebDeviceRequest.BlueToothBroadCastContent)
}

// -------------------------------------------------------------------

// LockWebDeviceResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool LockWebDeviceResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LockWebDeviceResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LockWebDeviceResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LockWebDeviceResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& LockWebDeviceResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.LockWebDeviceResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* LockWebDeviceResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.LockWebDeviceResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* LockWebDeviceResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.LockWebDeviceResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void LockWebDeviceResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.LockWebDeviceResponse.BaseResponse)
}

// -------------------------------------------------------------------

// GetIosExtensionKeyRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool GetIosExtensionKeyRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetIosExtensionKeyRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetIosExtensionKeyRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetIosExtensionKeyRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& GetIosExtensionKeyRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.GetIosExtensionKeyRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* GetIosExtensionKeyRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetIosExtensionKeyRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* GetIosExtensionKeyRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.GetIosExtensionKeyRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void GetIosExtensionKeyRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetIosExtensionKeyRequest.BaseRequest)
}

// optional uint32 ExtensionSessionType = 2;
inline bool GetIosExtensionKeyRequest::has_extensionsessiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetIosExtensionKeyRequest::set_has_extensionsessiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetIosExtensionKeyRequest::clear_has_extensionsessiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetIosExtensionKeyRequest::clear_extensionsessiontype() {
  extensionsessiontype_ = 0u;
  clear_has_extensionsessiontype();
}
inline ::google::protobuf::uint32 GetIosExtensionKeyRequest::extensionsessiontype() const {
  // @@protoc_insertion_point(field_get:micromsg.GetIosExtensionKeyRequest.ExtensionSessionType)
  return extensionsessiontype_;
}
inline void GetIosExtensionKeyRequest::set_extensionsessiontype(::google::protobuf::uint32 value) {
  set_has_extensionsessiontype();
  extensionsessiontype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.GetIosExtensionKeyRequest.ExtensionSessionType)
}

// optional bytes ExtensionDeviceId = 3;
inline bool GetIosExtensionKeyRequest::has_extensiondeviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetIosExtensionKeyRequest::set_has_extensiondeviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetIosExtensionKeyRequest::clear_has_extensiondeviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetIosExtensionKeyRequest::clear_extensiondeviceid() {
  extensiondeviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extensiondeviceid();
}
inline const ::std::string& GetIosExtensionKeyRequest::extensiondeviceid() const {
  // @@protoc_insertion_point(field_get:micromsg.GetIosExtensionKeyRequest.ExtensionDeviceId)
  return extensiondeviceid_.GetNoArena();
}
inline void GetIosExtensionKeyRequest::set_extensiondeviceid(const ::std::string& value) {
  set_has_extensiondeviceid();
  extensiondeviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.GetIosExtensionKeyRequest.ExtensionDeviceId)
}
#if LANG_CXX11
inline void GetIosExtensionKeyRequest::set_extensiondeviceid(::std::string&& value) {
  set_has_extensiondeviceid();
  extensiondeviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.GetIosExtensionKeyRequest.ExtensionDeviceId)
}
#endif
inline void GetIosExtensionKeyRequest::set_extensiondeviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extensiondeviceid();
  extensiondeviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.GetIosExtensionKeyRequest.ExtensionDeviceId)
}
inline void GetIosExtensionKeyRequest::set_extensiondeviceid(const void* value, size_t size) {
  set_has_extensiondeviceid();
  extensiondeviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.GetIosExtensionKeyRequest.ExtensionDeviceId)
}
inline ::std::string* GetIosExtensionKeyRequest::mutable_extensiondeviceid() {
  set_has_extensiondeviceid();
  // @@protoc_insertion_point(field_mutable:micromsg.GetIosExtensionKeyRequest.ExtensionDeviceId)
  return extensiondeviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetIosExtensionKeyRequest::release_extensiondeviceid() {
  // @@protoc_insertion_point(field_release:micromsg.GetIosExtensionKeyRequest.ExtensionDeviceId)
  clear_has_extensiondeviceid();
  return extensiondeviceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetIosExtensionKeyRequest::set_allocated_extensiondeviceid(::std::string* extensiondeviceid) {
  if (extensiondeviceid != NULL) {
    set_has_extensiondeviceid();
  } else {
    clear_has_extensiondeviceid();
  }
  extensiondeviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extensiondeviceid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetIosExtensionKeyRequest.ExtensionDeviceId)
}

// -------------------------------------------------------------------

// ExtSession

// required uint32 SessionType = 1;
inline bool ExtSession::has_sessiontype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtSession::set_has_sessiontype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtSession::clear_has_sessiontype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtSession::clear_sessiontype() {
  sessiontype_ = 0u;
  clear_has_sessiontype();
}
inline ::google::protobuf::uint32 ExtSession::sessiontype() const {
  // @@protoc_insertion_point(field_get:micromsg.ExtSession.SessionType)
  return sessiontype_;
}
inline void ExtSession::set_sessiontype(::google::protobuf::uint32 value) {
  set_has_sessiontype();
  sessiontype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ExtSession.SessionType)
}

// required .micromsg.SKBuiltinBuffer_t SessionKey = 2;
inline bool ExtSession::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtSession::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtSession::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtSession::clear_sessionkey() {
  if (sessionkey_ != NULL) sessionkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_sessionkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& ExtSession::sessionkey() const {
  // @@protoc_insertion_point(field_get:micromsg.ExtSession.SessionKey)
  return sessionkey_ != NULL ? *sessionkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* ExtSession::mutable_sessionkey() {
  set_has_sessionkey();
  if (sessionkey_ == NULL) {
    sessionkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ExtSession.SessionKey)
  return sessionkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* ExtSession::release_sessionkey() {
  // @@protoc_insertion_point(field_release:micromsg.ExtSession.SessionKey)
  clear_has_sessionkey();
  ::micromsg::SKBuiltinBuffer_t* temp = sessionkey_;
  sessionkey_ = NULL;
  return temp;
}
inline void ExtSession::set_allocated_sessionkey(::micromsg::SKBuiltinBuffer_t* sessionkey) {
  delete sessionkey_;
  sessionkey_ = sessionkey;
  if (sessionkey) {
    set_has_sessionkey();
  } else {
    clear_has_sessionkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ExtSession.SessionKey)
}

// required .micromsg.SKBuiltinBuffer_t ServerId = 3;
inline bool ExtSession::has_serverid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtSession::set_has_serverid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtSession::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtSession::clear_serverid() {
  if (serverid_ != NULL) serverid_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_serverid();
}
inline const ::micromsg::SKBuiltinBuffer_t& ExtSession::serverid() const {
  // @@protoc_insertion_point(field_get:micromsg.ExtSession.ServerId)
  return serverid_ != NULL ? *serverid_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* ExtSession::mutable_serverid() {
  set_has_serverid();
  if (serverid_ == NULL) {
    serverid_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ExtSession.ServerId)
  return serverid_;
}
inline ::micromsg::SKBuiltinBuffer_t* ExtSession::release_serverid() {
  // @@protoc_insertion_point(field_release:micromsg.ExtSession.ServerId)
  clear_has_serverid();
  ::micromsg::SKBuiltinBuffer_t* temp = serverid_;
  serverid_ = NULL;
  return temp;
}
inline void ExtSession::set_allocated_serverid(::micromsg::SKBuiltinBuffer_t* serverid) {
  delete serverid_;
  serverid_ = serverid;
  if (serverid) {
    set_has_serverid();
  } else {
    clear_has_serverid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ExtSession.ServerId)
}

// -------------------------------------------------------------------

// GetIosExtensionKeyResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool GetIosExtensionKeyResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetIosExtensionKeyResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetIosExtensionKeyResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetIosExtensionKeyResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& GetIosExtensionKeyResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.GetIosExtensionKeyResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* GetIosExtensionKeyResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetIosExtensionKeyResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* GetIosExtensionKeyResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.GetIosExtensionKeyResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void GetIosExtensionKeyResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetIosExtensionKeyResponse.BaseResponse)
}

// required .micromsg.SKBuiltinBuffer_t Key = 2;
inline bool GetIosExtensionKeyResponse::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetIosExtensionKeyResponse::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetIosExtensionKeyResponse::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetIosExtensionKeyResponse::clear_key() {
  if (key_ != NULL) key_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_key();
}
inline const ::micromsg::SKBuiltinBuffer_t& GetIosExtensionKeyResponse::key() const {
  // @@protoc_insertion_point(field_get:micromsg.GetIosExtensionKeyResponse.Key)
  return key_ != NULL ? *key_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* GetIosExtensionKeyResponse::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    key_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetIosExtensionKeyResponse.Key)
  return key_;
}
inline ::micromsg::SKBuiltinBuffer_t* GetIosExtensionKeyResponse::release_key() {
  // @@protoc_insertion_point(field_release:micromsg.GetIosExtensionKeyResponse.Key)
  clear_has_key();
  ::micromsg::SKBuiltinBuffer_t* temp = key_;
  key_ = NULL;
  return temp;
}
inline void GetIosExtensionKeyResponse::set_allocated_key(::micromsg::SKBuiltinBuffer_t* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetIosExtensionKeyResponse.Key)
}

// optional .micromsg.ExtSession ExtensionSession = 3;
inline bool GetIosExtensionKeyResponse::has_extensionsession() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetIosExtensionKeyResponse::set_has_extensionsession() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetIosExtensionKeyResponse::clear_has_extensionsession() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetIosExtensionKeyResponse::clear_extensionsession() {
  if (extensionsession_ != NULL) extensionsession_->::micromsg::ExtSession::Clear();
  clear_has_extensionsession();
}
inline const ::micromsg::ExtSession& GetIosExtensionKeyResponse::extensionsession() const {
  // @@protoc_insertion_point(field_get:micromsg.GetIosExtensionKeyResponse.ExtensionSession)
  return extensionsession_ != NULL ? *extensionsession_
                         : *::micromsg::ExtSession::internal_default_instance();
}
inline ::micromsg::ExtSession* GetIosExtensionKeyResponse::mutable_extensionsession() {
  set_has_extensionsession();
  if (extensionsession_ == NULL) {
    extensionsession_ = new ::micromsg::ExtSession;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.GetIosExtensionKeyResponse.ExtensionSession)
  return extensionsession_;
}
inline ::micromsg::ExtSession* GetIosExtensionKeyResponse::release_extensionsession() {
  // @@protoc_insertion_point(field_release:micromsg.GetIosExtensionKeyResponse.ExtensionSession)
  clear_has_extensionsession();
  ::micromsg::ExtSession* temp = extensionsession_;
  extensionsession_ = NULL;
  return temp;
}
inline void GetIosExtensionKeyResponse::set_allocated_extensionsession(::micromsg::ExtSession* extensionsession) {
  delete extensionsession_;
  extensionsession_ = extensionsession;
  if (extensionsession) {
    set_has_extensionsession();
  } else {
    clear_has_extensionsession();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.GetIosExtensionKeyResponse.ExtensionSession)
}

// -------------------------------------------------------------------

// PatternLockBuffer

// optional uint32 uin = 1;
inline bool PatternLockBuffer::has_uin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PatternLockBuffer::set_has_uin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PatternLockBuffer::clear_has_uin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PatternLockBuffer::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 PatternLockBuffer::uin() const {
  // @@protoc_insertion_point(field_get:micromsg.PatternLockBuffer.uin)
  return uin_;
}
inline void PatternLockBuffer::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.PatternLockBuffer.uin)
}

// optional uint32 version = 2;
inline bool PatternLockBuffer::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PatternLockBuffer::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PatternLockBuffer::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PatternLockBuffer::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 PatternLockBuffer::version() const {
  // @@protoc_insertion_point(field_get:micromsg.PatternLockBuffer.version)
  return version_;
}
inline void PatternLockBuffer::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:micromsg.PatternLockBuffer.version)
}

// optional .micromsg.SKBuiltinBuffer_t svrpatternhash = 3;
inline bool PatternLockBuffer::has_svrpatternhash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PatternLockBuffer::set_has_svrpatternhash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PatternLockBuffer::clear_has_svrpatternhash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PatternLockBuffer::clear_svrpatternhash() {
  if (svrpatternhash_ != NULL) svrpatternhash_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_svrpatternhash();
}
inline const ::micromsg::SKBuiltinBuffer_t& PatternLockBuffer::svrpatternhash() const {
  // @@protoc_insertion_point(field_get:micromsg.PatternLockBuffer.svrpatternhash)
  return svrpatternhash_ != NULL ? *svrpatternhash_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* PatternLockBuffer::mutable_svrpatternhash() {
  set_has_svrpatternhash();
  if (svrpatternhash_ == NULL) {
    svrpatternhash_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PatternLockBuffer.svrpatternhash)
  return svrpatternhash_;
}
inline ::micromsg::SKBuiltinBuffer_t* PatternLockBuffer::release_svrpatternhash() {
  // @@protoc_insertion_point(field_release:micromsg.PatternLockBuffer.svrpatternhash)
  clear_has_svrpatternhash();
  ::micromsg::SKBuiltinBuffer_t* temp = svrpatternhash_;
  svrpatternhash_ = NULL;
  return temp;
}
inline void PatternLockBuffer::set_allocated_svrpatternhash(::micromsg::SKBuiltinBuffer_t* svrpatternhash) {
  delete svrpatternhash_;
  svrpatternhash_ = svrpatternhash;
  if (svrpatternhash) {
    set_has_svrpatternhash();
  } else {
    clear_has_svrpatternhash();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PatternLockBuffer.svrpatternhash)
}

// optional uint32 lockstatus = 4;
inline bool PatternLockBuffer::has_lockstatus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PatternLockBuffer::set_has_lockstatus() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PatternLockBuffer::clear_has_lockstatus() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PatternLockBuffer::clear_lockstatus() {
  lockstatus_ = 0u;
  clear_has_lockstatus();
}
inline ::google::protobuf::uint32 PatternLockBuffer::lockstatus() const {
  // @@protoc_insertion_point(field_get:micromsg.PatternLockBuffer.lockstatus)
  return lockstatus_;
}
inline void PatternLockBuffer::set_lockstatus(::google::protobuf::uint32 value) {
  set_has_lockstatus();
  lockstatus_ = value;
  // @@protoc_insertion_point(field_set:micromsg.PatternLockBuffer.lockstatus)
}

// optional .micromsg.SKBuiltinBuffer_t sign = 5;
inline bool PatternLockBuffer::has_sign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PatternLockBuffer::set_has_sign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PatternLockBuffer::clear_has_sign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PatternLockBuffer::clear_sign() {
  if (sign_ != NULL) sign_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_sign();
}
inline const ::micromsg::SKBuiltinBuffer_t& PatternLockBuffer::sign() const {
  // @@protoc_insertion_point(field_get:micromsg.PatternLockBuffer.sign)
  return sign_ != NULL ? *sign_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* PatternLockBuffer::mutable_sign() {
  set_has_sign();
  if (sign_ == NULL) {
    sign_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.PatternLockBuffer.sign)
  return sign_;
}
inline ::micromsg::SKBuiltinBuffer_t* PatternLockBuffer::release_sign() {
  // @@protoc_insertion_point(field_release:micromsg.PatternLockBuffer.sign)
  clear_has_sign();
  ::micromsg::SKBuiltinBuffer_t* temp = sign_;
  sign_ = NULL;
  return temp;
}
inline void PatternLockBuffer::set_allocated_sign(::micromsg::SKBuiltinBuffer_t* sign) {
  delete sign_;
  sign_ = sign;
  if (sign) {
    set_has_sign();
  } else {
    clear_has_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.PatternLockBuffer.sign)
}

// -------------------------------------------------------------------

// RegisterNewPatternLockRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool RegisterNewPatternLockRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterNewPatternLockRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterNewPatternLockRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterNewPatternLockRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& RegisterNewPatternLockRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.RegisterNewPatternLockRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* RegisterNewPatternLockRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegisterNewPatternLockRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* RegisterNewPatternLockRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.RegisterNewPatternLockRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void RegisterNewPatternLockRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegisterNewPatternLockRequest.BaseRequest)
}

// optional .micromsg.SKBuiltinBuffer_t paytoken = 2;
inline bool RegisterNewPatternLockRequest::has_paytoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterNewPatternLockRequest::set_has_paytoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterNewPatternLockRequest::clear_has_paytoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterNewPatternLockRequest::clear_paytoken() {
  if (paytoken_ != NULL) paytoken_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_paytoken();
}
inline const ::micromsg::SKBuiltinBuffer_t& RegisterNewPatternLockRequest::paytoken() const {
  // @@protoc_insertion_point(field_get:micromsg.RegisterNewPatternLockRequest.paytoken)
  return paytoken_ != NULL ? *paytoken_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* RegisterNewPatternLockRequest::mutable_paytoken() {
  set_has_paytoken();
  if (paytoken_ == NULL) {
    paytoken_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegisterNewPatternLockRequest.paytoken)
  return paytoken_;
}
inline ::micromsg::SKBuiltinBuffer_t* RegisterNewPatternLockRequest::release_paytoken() {
  // @@protoc_insertion_point(field_release:micromsg.RegisterNewPatternLockRequest.paytoken)
  clear_has_paytoken();
  ::micromsg::SKBuiltinBuffer_t* temp = paytoken_;
  paytoken_ = NULL;
  return temp;
}
inline void RegisterNewPatternLockRequest::set_allocated_paytoken(::micromsg::SKBuiltinBuffer_t* paytoken) {
  delete paytoken_;
  paytoken_ = paytoken;
  if (paytoken) {
    set_has_paytoken();
  } else {
    clear_has_paytoken();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegisterNewPatternLockRequest.paytoken)
}

// optional .micromsg.SKBuiltinBuffer_t patternhash = 3;
inline bool RegisterNewPatternLockRequest::has_patternhash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterNewPatternLockRequest::set_has_patternhash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterNewPatternLockRequest::clear_has_patternhash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterNewPatternLockRequest::clear_patternhash() {
  if (patternhash_ != NULL) patternhash_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_patternhash();
}
inline const ::micromsg::SKBuiltinBuffer_t& RegisterNewPatternLockRequest::patternhash() const {
  // @@protoc_insertion_point(field_get:micromsg.RegisterNewPatternLockRequest.patternhash)
  return patternhash_ != NULL ? *patternhash_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* RegisterNewPatternLockRequest::mutable_patternhash() {
  set_has_patternhash();
  if (patternhash_ == NULL) {
    patternhash_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegisterNewPatternLockRequest.patternhash)
  return patternhash_;
}
inline ::micromsg::SKBuiltinBuffer_t* RegisterNewPatternLockRequest::release_patternhash() {
  // @@protoc_insertion_point(field_release:micromsg.RegisterNewPatternLockRequest.patternhash)
  clear_has_patternhash();
  ::micromsg::SKBuiltinBuffer_t* temp = patternhash_;
  patternhash_ = NULL;
  return temp;
}
inline void RegisterNewPatternLockRequest::set_allocated_patternhash(::micromsg::SKBuiltinBuffer_t* patternhash) {
  delete patternhash_;
  patternhash_ = patternhash;
  if (patternhash) {
    set_has_patternhash();
  } else {
    clear_has_patternhash();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegisterNewPatternLockRequest.patternhash)
}

// optional uint32 cmd = 4;
inline bool RegisterNewPatternLockRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterNewPatternLockRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterNewPatternLockRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterNewPatternLockRequest::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 RegisterNewPatternLockRequest::cmd() const {
  // @@protoc_insertion_point(field_get:micromsg.RegisterNewPatternLockRequest.cmd)
  return cmd_;
}
inline void RegisterNewPatternLockRequest::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:micromsg.RegisterNewPatternLockRequest.cmd)
}

// -------------------------------------------------------------------

// RegisterNewPatternLockResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool RegisterNewPatternLockResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterNewPatternLockResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterNewPatternLockResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterNewPatternLockResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& RegisterNewPatternLockResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.RegisterNewPatternLockResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* RegisterNewPatternLockResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegisterNewPatternLockResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* RegisterNewPatternLockResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.RegisterNewPatternLockResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void RegisterNewPatternLockResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegisterNewPatternLockResponse.BaseResponse)
}

// optional .micromsg.PatternLockBuffer patternlockbuf = 2;
inline bool RegisterNewPatternLockResponse::has_patternlockbuf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterNewPatternLockResponse::set_has_patternlockbuf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterNewPatternLockResponse::clear_has_patternlockbuf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterNewPatternLockResponse::clear_patternlockbuf() {
  if (patternlockbuf_ != NULL) patternlockbuf_->::micromsg::PatternLockBuffer::Clear();
  clear_has_patternlockbuf();
}
inline const ::micromsg::PatternLockBuffer& RegisterNewPatternLockResponse::patternlockbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.RegisterNewPatternLockResponse.patternlockbuf)
  return patternlockbuf_ != NULL ? *patternlockbuf_
                         : *::micromsg::PatternLockBuffer::internal_default_instance();
}
inline ::micromsg::PatternLockBuffer* RegisterNewPatternLockResponse::mutable_patternlockbuf() {
  set_has_patternlockbuf();
  if (patternlockbuf_ == NULL) {
    patternlockbuf_ = new ::micromsg::PatternLockBuffer;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.RegisterNewPatternLockResponse.patternlockbuf)
  return patternlockbuf_;
}
inline ::micromsg::PatternLockBuffer* RegisterNewPatternLockResponse::release_patternlockbuf() {
  // @@protoc_insertion_point(field_release:micromsg.RegisterNewPatternLockResponse.patternlockbuf)
  clear_has_patternlockbuf();
  ::micromsg::PatternLockBuffer* temp = patternlockbuf_;
  patternlockbuf_ = NULL;
  return temp;
}
inline void RegisterNewPatternLockResponse::set_allocated_patternlockbuf(::micromsg::PatternLockBuffer* patternlockbuf) {
  delete patternlockbuf_;
  patternlockbuf_ = patternlockbuf;
  if (patternlockbuf) {
    set_has_patternlockbuf();
  } else {
    clear_has_patternlockbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.RegisterNewPatternLockResponse.patternlockbuf)
}

// -------------------------------------------------------------------

// OpPatternLockRequest

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool OpPatternLockRequest::has_baserequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpPatternLockRequest::set_has_baserequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpPatternLockRequest::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpPatternLockRequest::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& OpPatternLockRequest::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.OpPatternLockRequest.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* OpPatternLockRequest::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.OpPatternLockRequest.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* OpPatternLockRequest::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.OpPatternLockRequest.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void OpPatternLockRequest::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.OpPatternLockRequest.BaseRequest)
}

// optional uint32 cmd = 2;
inline bool OpPatternLockRequest::has_cmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpPatternLockRequest::set_has_cmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpPatternLockRequest::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpPatternLockRequest::clear_cmd() {
  cmd_ = 0u;
  clear_has_cmd();
}
inline ::google::protobuf::uint32 OpPatternLockRequest::cmd() const {
  // @@protoc_insertion_point(field_get:micromsg.OpPatternLockRequest.cmd)
  return cmd_;
}
inline void OpPatternLockRequest::set_cmd(::google::protobuf::uint32 value) {
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:micromsg.OpPatternLockRequest.cmd)
}

// optional .micromsg.SKBuiltinBuffer_t nowpatternhash = 3;
inline bool OpPatternLockRequest::has_nowpatternhash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpPatternLockRequest::set_has_nowpatternhash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpPatternLockRequest::clear_has_nowpatternhash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpPatternLockRequest::clear_nowpatternhash() {
  if (nowpatternhash_ != NULL) nowpatternhash_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_nowpatternhash();
}
inline const ::micromsg::SKBuiltinBuffer_t& OpPatternLockRequest::nowpatternhash() const {
  // @@protoc_insertion_point(field_get:micromsg.OpPatternLockRequest.nowpatternhash)
  return nowpatternhash_ != NULL ? *nowpatternhash_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* OpPatternLockRequest::mutable_nowpatternhash() {
  set_has_nowpatternhash();
  if (nowpatternhash_ == NULL) {
    nowpatternhash_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.OpPatternLockRequest.nowpatternhash)
  return nowpatternhash_;
}
inline ::micromsg::SKBuiltinBuffer_t* OpPatternLockRequest::release_nowpatternhash() {
  // @@protoc_insertion_point(field_release:micromsg.OpPatternLockRequest.nowpatternhash)
  clear_has_nowpatternhash();
  ::micromsg::SKBuiltinBuffer_t* temp = nowpatternhash_;
  nowpatternhash_ = NULL;
  return temp;
}
inline void OpPatternLockRequest::set_allocated_nowpatternhash(::micromsg::SKBuiltinBuffer_t* nowpatternhash) {
  delete nowpatternhash_;
  nowpatternhash_ = nowpatternhash;
  if (nowpatternhash) {
    set_has_nowpatternhash();
  } else {
    clear_has_nowpatternhash();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.OpPatternLockRequest.nowpatternhash)
}

// optional .micromsg.SKBuiltinBuffer_t newpatternhash = 4;
inline bool OpPatternLockRequest::has_newpatternhash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpPatternLockRequest::set_has_newpatternhash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpPatternLockRequest::clear_has_newpatternhash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpPatternLockRequest::clear_newpatternhash() {
  if (newpatternhash_ != NULL) newpatternhash_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_newpatternhash();
}
inline const ::micromsg::SKBuiltinBuffer_t& OpPatternLockRequest::newpatternhash() const {
  // @@protoc_insertion_point(field_get:micromsg.OpPatternLockRequest.newpatternhash)
  return newpatternhash_ != NULL ? *newpatternhash_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* OpPatternLockRequest::mutable_newpatternhash() {
  set_has_newpatternhash();
  if (newpatternhash_ == NULL) {
    newpatternhash_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.OpPatternLockRequest.newpatternhash)
  return newpatternhash_;
}
inline ::micromsg::SKBuiltinBuffer_t* OpPatternLockRequest::release_newpatternhash() {
  // @@protoc_insertion_point(field_release:micromsg.OpPatternLockRequest.newpatternhash)
  clear_has_newpatternhash();
  ::micromsg::SKBuiltinBuffer_t* temp = newpatternhash_;
  newpatternhash_ = NULL;
  return temp;
}
inline void OpPatternLockRequest::set_allocated_newpatternhash(::micromsg::SKBuiltinBuffer_t* newpatternhash) {
  delete newpatternhash_;
  newpatternhash_ = newpatternhash;
  if (newpatternhash) {
    set_has_newpatternhash();
  } else {
    clear_has_newpatternhash();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.OpPatternLockRequest.newpatternhash)
}

// -------------------------------------------------------------------

// OpPatternLockResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool OpPatternLockResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpPatternLockResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpPatternLockResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpPatternLockResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& OpPatternLockResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.OpPatternLockResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* OpPatternLockResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.OpPatternLockResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* OpPatternLockResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.OpPatternLockResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void OpPatternLockResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.OpPatternLockResponse.BaseResponse)
}

// optional .micromsg.PatternLockBuffer patternlockbuf = 2;
inline bool OpPatternLockResponse::has_patternlockbuf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpPatternLockResponse::set_has_patternlockbuf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpPatternLockResponse::clear_has_patternlockbuf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpPatternLockResponse::clear_patternlockbuf() {
  if (patternlockbuf_ != NULL) patternlockbuf_->::micromsg::PatternLockBuffer::Clear();
  clear_has_patternlockbuf();
}
inline const ::micromsg::PatternLockBuffer& OpPatternLockResponse::patternlockbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.OpPatternLockResponse.patternlockbuf)
  return patternlockbuf_ != NULL ? *patternlockbuf_
                         : *::micromsg::PatternLockBuffer::internal_default_instance();
}
inline ::micromsg::PatternLockBuffer* OpPatternLockResponse::mutable_patternlockbuf() {
  set_has_patternlockbuf();
  if (patternlockbuf_ == NULL) {
    patternlockbuf_ = new ::micromsg::PatternLockBuffer;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.OpPatternLockResponse.patternlockbuf)
  return patternlockbuf_;
}
inline ::micromsg::PatternLockBuffer* OpPatternLockResponse::release_patternlockbuf() {
  // @@protoc_insertion_point(field_release:micromsg.OpPatternLockResponse.patternlockbuf)
  clear_has_patternlockbuf();
  ::micromsg::PatternLockBuffer* temp = patternlockbuf_;
  patternlockbuf_ = NULL;
  return temp;
}
inline void OpPatternLockResponse::set_allocated_patternlockbuf(::micromsg::PatternLockBuffer* patternlockbuf) {
  delete patternlockbuf_;
  patternlockbuf_ = patternlockbuf;
  if (patternlockbuf) {
    set_has_patternlockbuf();
  } else {
    clear_has_patternlockbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.OpPatternLockResponse.patternlockbuf)
}

// -------------------------------------------------------------------

// WTLoginImgReqInfo

// optional string ImgSid = 1;
inline bool WTLoginImgReqInfo::has_imgsid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WTLoginImgReqInfo::set_has_imgsid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WTLoginImgReqInfo::clear_has_imgsid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WTLoginImgReqInfo::clear_imgsid() {
  imgsid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgsid();
}
inline const ::std::string& WTLoginImgReqInfo::imgsid() const {
  // @@protoc_insertion_point(field_get:micromsg.WTLoginImgReqInfo.ImgSid)
  return imgsid_.GetNoArena();
}
inline void WTLoginImgReqInfo::set_imgsid(const ::std::string& value) {
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WTLoginImgReqInfo.ImgSid)
}
#if LANG_CXX11
inline void WTLoginImgReqInfo::set_imgsid(::std::string&& value) {
  set_has_imgsid();
  imgsid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WTLoginImgReqInfo.ImgSid)
}
#endif
inline void WTLoginImgReqInfo::set_imgsid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WTLoginImgReqInfo.ImgSid)
}
inline void WTLoginImgReqInfo::set_imgsid(const char* value, size_t size) {
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WTLoginImgReqInfo.ImgSid)
}
inline ::std::string* WTLoginImgReqInfo::mutable_imgsid() {
  set_has_imgsid();
  // @@protoc_insertion_point(field_mutable:micromsg.WTLoginImgReqInfo.ImgSid)
  return imgsid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WTLoginImgReqInfo::release_imgsid() {
  // @@protoc_insertion_point(field_release:micromsg.WTLoginImgReqInfo.ImgSid)
  clear_has_imgsid();
  return imgsid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WTLoginImgReqInfo::set_allocated_imgsid(::std::string* imgsid) {
  if (imgsid != NULL) {
    set_has_imgsid();
  } else {
    clear_has_imgsid();
  }
  imgsid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgsid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WTLoginImgReqInfo.ImgSid)
}

// optional string ImgCode = 2;
inline bool WTLoginImgReqInfo::has_imgcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WTLoginImgReqInfo::set_has_imgcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WTLoginImgReqInfo::clear_has_imgcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WTLoginImgReqInfo::clear_imgcode() {
  imgcode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgcode();
}
inline const ::std::string& WTLoginImgReqInfo::imgcode() const {
  // @@protoc_insertion_point(field_get:micromsg.WTLoginImgReqInfo.ImgCode)
  return imgcode_.GetNoArena();
}
inline void WTLoginImgReqInfo::set_imgcode(const ::std::string& value) {
  set_has_imgcode();
  imgcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WTLoginImgReqInfo.ImgCode)
}
#if LANG_CXX11
inline void WTLoginImgReqInfo::set_imgcode(::std::string&& value) {
  set_has_imgcode();
  imgcode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WTLoginImgReqInfo.ImgCode)
}
#endif
inline void WTLoginImgReqInfo::set_imgcode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgcode();
  imgcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WTLoginImgReqInfo.ImgCode)
}
inline void WTLoginImgReqInfo::set_imgcode(const char* value, size_t size) {
  set_has_imgcode();
  imgcode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WTLoginImgReqInfo.ImgCode)
}
inline ::std::string* WTLoginImgReqInfo::mutable_imgcode() {
  set_has_imgcode();
  // @@protoc_insertion_point(field_mutable:micromsg.WTLoginImgReqInfo.ImgCode)
  return imgcode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WTLoginImgReqInfo::release_imgcode() {
  // @@protoc_insertion_point(field_release:micromsg.WTLoginImgReqInfo.ImgCode)
  clear_has_imgcode();
  return imgcode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WTLoginImgReqInfo::set_allocated_imgcode(::std::string* imgcode) {
  if (imgcode != NULL) {
    set_has_imgcode();
  } else {
    clear_has_imgcode();
  }
  imgcode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgcode);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WTLoginImgReqInfo.ImgCode)
}

// optional string ImgEncryptKey = 3;
inline bool WTLoginImgReqInfo::has_imgencryptkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WTLoginImgReqInfo::set_has_imgencryptkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WTLoginImgReqInfo::clear_has_imgencryptkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WTLoginImgReqInfo::clear_imgencryptkey() {
  imgencryptkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgencryptkey();
}
inline const ::std::string& WTLoginImgReqInfo::imgencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.WTLoginImgReqInfo.ImgEncryptKey)
  return imgencryptkey_.GetNoArena();
}
inline void WTLoginImgReqInfo::set_imgencryptkey(const ::std::string& value) {
  set_has_imgencryptkey();
  imgencryptkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WTLoginImgReqInfo.ImgEncryptKey)
}
#if LANG_CXX11
inline void WTLoginImgReqInfo::set_imgencryptkey(::std::string&& value) {
  set_has_imgencryptkey();
  imgencryptkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WTLoginImgReqInfo.ImgEncryptKey)
}
#endif
inline void WTLoginImgReqInfo::set_imgencryptkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgencryptkey();
  imgencryptkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WTLoginImgReqInfo.ImgEncryptKey)
}
inline void WTLoginImgReqInfo::set_imgencryptkey(const char* value, size_t size) {
  set_has_imgencryptkey();
  imgencryptkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WTLoginImgReqInfo.ImgEncryptKey)
}
inline ::std::string* WTLoginImgReqInfo::mutable_imgencryptkey() {
  set_has_imgencryptkey();
  // @@protoc_insertion_point(field_mutable:micromsg.WTLoginImgReqInfo.ImgEncryptKey)
  return imgencryptkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WTLoginImgReqInfo::release_imgencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.WTLoginImgReqInfo.ImgEncryptKey)
  clear_has_imgencryptkey();
  return imgencryptkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WTLoginImgReqInfo::set_allocated_imgencryptkey(::std::string* imgencryptkey) {
  if (imgencryptkey != NULL) {
    set_has_imgencryptkey();
  } else {
    clear_has_imgencryptkey();
  }
  imgencryptkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgencryptkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WTLoginImgReqInfo.ImgEncryptKey)
}

// required .micromsg.SKBuiltinBuffer_t KSid = 4;
inline bool WTLoginImgReqInfo::has_ksid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WTLoginImgReqInfo::set_has_ksid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WTLoginImgReqInfo::clear_has_ksid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WTLoginImgReqInfo::clear_ksid() {
  if (ksid_ != NULL) ksid_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_ksid();
}
inline const ::micromsg::SKBuiltinBuffer_t& WTLoginImgReqInfo::ksid() const {
  // @@protoc_insertion_point(field_get:micromsg.WTLoginImgReqInfo.KSid)
  return ksid_ != NULL ? *ksid_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* WTLoginImgReqInfo::mutable_ksid() {
  set_has_ksid();
  if (ksid_ == NULL) {
    ksid_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.WTLoginImgReqInfo.KSid)
  return ksid_;
}
inline ::micromsg::SKBuiltinBuffer_t* WTLoginImgReqInfo::release_ksid() {
  // @@protoc_insertion_point(field_release:micromsg.WTLoginImgReqInfo.KSid)
  clear_has_ksid();
  ::micromsg::SKBuiltinBuffer_t* temp = ksid_;
  ksid_ = NULL;
  return temp;
}
inline void WTLoginImgReqInfo::set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid) {
  delete ksid_;
  ksid_ = ksid;
  if (ksid) {
    set_has_ksid();
  } else {
    clear_has_ksid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.WTLoginImgReqInfo.KSid)
}

// -------------------------------------------------------------------

// WTLoginImgRespInfo

// optional string ImgEncryptKey = 1;
inline bool WTLoginImgRespInfo::has_imgencryptkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WTLoginImgRespInfo::set_has_imgencryptkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WTLoginImgRespInfo::clear_has_imgencryptkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WTLoginImgRespInfo::clear_imgencryptkey() {
  imgencryptkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgencryptkey();
}
inline const ::std::string& WTLoginImgRespInfo::imgencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.WTLoginImgRespInfo.ImgEncryptKey)
  return imgencryptkey_.GetNoArena();
}
inline void WTLoginImgRespInfo::set_imgencryptkey(const ::std::string& value) {
  set_has_imgencryptkey();
  imgencryptkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WTLoginImgRespInfo.ImgEncryptKey)
}
#if LANG_CXX11
inline void WTLoginImgRespInfo::set_imgencryptkey(::std::string&& value) {
  set_has_imgencryptkey();
  imgencryptkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WTLoginImgRespInfo.ImgEncryptKey)
}
#endif
inline void WTLoginImgRespInfo::set_imgencryptkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgencryptkey();
  imgencryptkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WTLoginImgRespInfo.ImgEncryptKey)
}
inline void WTLoginImgRespInfo::set_imgencryptkey(const char* value, size_t size) {
  set_has_imgencryptkey();
  imgencryptkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WTLoginImgRespInfo.ImgEncryptKey)
}
inline ::std::string* WTLoginImgRespInfo::mutable_imgencryptkey() {
  set_has_imgencryptkey();
  // @@protoc_insertion_point(field_mutable:micromsg.WTLoginImgRespInfo.ImgEncryptKey)
  return imgencryptkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WTLoginImgRespInfo::release_imgencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.WTLoginImgRespInfo.ImgEncryptKey)
  clear_has_imgencryptkey();
  return imgencryptkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WTLoginImgRespInfo::set_allocated_imgencryptkey(::std::string* imgencryptkey) {
  if (imgencryptkey != NULL) {
    set_has_imgencryptkey();
  } else {
    clear_has_imgencryptkey();
  }
  imgencryptkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgencryptkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WTLoginImgRespInfo.ImgEncryptKey)
}

// required .micromsg.SKBuiltinBuffer_t KSid = 2;
inline bool WTLoginImgRespInfo::has_ksid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WTLoginImgRespInfo::set_has_ksid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WTLoginImgRespInfo::clear_has_ksid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WTLoginImgRespInfo::clear_ksid() {
  if (ksid_ != NULL) ksid_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_ksid();
}
inline const ::micromsg::SKBuiltinBuffer_t& WTLoginImgRespInfo::ksid() const {
  // @@protoc_insertion_point(field_get:micromsg.WTLoginImgRespInfo.KSid)
  return ksid_ != NULL ? *ksid_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* WTLoginImgRespInfo::mutable_ksid() {
  set_has_ksid();
  if (ksid_ == NULL) {
    ksid_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.WTLoginImgRespInfo.KSid)
  return ksid_;
}
inline ::micromsg::SKBuiltinBuffer_t* WTLoginImgRespInfo::release_ksid() {
  // @@protoc_insertion_point(field_release:micromsg.WTLoginImgRespInfo.KSid)
  clear_has_ksid();
  ::micromsg::SKBuiltinBuffer_t* temp = ksid_;
  ksid_ = NULL;
  return temp;
}
inline void WTLoginImgRespInfo::set_allocated_ksid(::micromsg::SKBuiltinBuffer_t* ksid) {
  delete ksid_;
  ksid_ = ksid;
  if (ksid) {
    set_has_ksid();
  } else {
    clear_has_ksid();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.WTLoginImgRespInfo.KSid)
}

// optional string ImgSid = 3;
inline bool WTLoginImgRespInfo::has_imgsid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WTLoginImgRespInfo::set_has_imgsid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WTLoginImgRespInfo::clear_has_imgsid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WTLoginImgRespInfo::clear_imgsid() {
  imgsid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imgsid();
}
inline const ::std::string& WTLoginImgRespInfo::imgsid() const {
  // @@protoc_insertion_point(field_get:micromsg.WTLoginImgRespInfo.ImgSid)
  return imgsid_.GetNoArena();
}
inline void WTLoginImgRespInfo::set_imgsid(const ::std::string& value) {
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WTLoginImgRespInfo.ImgSid)
}
#if LANG_CXX11
inline void WTLoginImgRespInfo::set_imgsid(::std::string&& value) {
  set_has_imgsid();
  imgsid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WTLoginImgRespInfo.ImgSid)
}
#endif
inline void WTLoginImgRespInfo::set_imgsid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WTLoginImgRespInfo.ImgSid)
}
inline void WTLoginImgRespInfo::set_imgsid(const char* value, size_t size) {
  set_has_imgsid();
  imgsid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WTLoginImgRespInfo.ImgSid)
}
inline ::std::string* WTLoginImgRespInfo::mutable_imgsid() {
  set_has_imgsid();
  // @@protoc_insertion_point(field_mutable:micromsg.WTLoginImgRespInfo.ImgSid)
  return imgsid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WTLoginImgRespInfo::release_imgsid() {
  // @@protoc_insertion_point(field_release:micromsg.WTLoginImgRespInfo.ImgSid)
  clear_has_imgsid();
  return imgsid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WTLoginImgRespInfo::set_allocated_imgsid(::std::string* imgsid) {
  if (imgsid != NULL) {
    set_has_imgsid();
  } else {
    clear_has_imgsid();
  }
  imgsid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imgsid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WTLoginImgRespInfo.ImgSid)
}

// required .micromsg.SKBuiltinBuffer_t ImgBuf = 4;
inline bool WTLoginImgRespInfo::has_imgbuf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WTLoginImgRespInfo::set_has_imgbuf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WTLoginImgRespInfo::clear_has_imgbuf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WTLoginImgRespInfo::clear_imgbuf() {
  if (imgbuf_ != NULL) imgbuf_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_imgbuf();
}
inline const ::micromsg::SKBuiltinBuffer_t& WTLoginImgRespInfo::imgbuf() const {
  // @@protoc_insertion_point(field_get:micromsg.WTLoginImgRespInfo.ImgBuf)
  return imgbuf_ != NULL ? *imgbuf_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* WTLoginImgRespInfo::mutable_imgbuf() {
  set_has_imgbuf();
  if (imgbuf_ == NULL) {
    imgbuf_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.WTLoginImgRespInfo.ImgBuf)
  return imgbuf_;
}
inline ::micromsg::SKBuiltinBuffer_t* WTLoginImgRespInfo::release_imgbuf() {
  // @@protoc_insertion_point(field_release:micromsg.WTLoginImgRespInfo.ImgBuf)
  clear_has_imgbuf();
  ::micromsg::SKBuiltinBuffer_t* temp = imgbuf_;
  imgbuf_ = NULL;
  return temp;
}
inline void WTLoginImgRespInfo::set_allocated_imgbuf(::micromsg::SKBuiltinBuffer_t* imgbuf) {
  delete imgbuf_;
  imgbuf_ = imgbuf;
  if (imgbuf) {
    set_has_imgbuf();
  } else {
    clear_has_imgbuf();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.WTLoginImgRespInfo.ImgBuf)
}

// -------------------------------------------------------------------

// WxVerifyCodeReqInfo

// optional string VerifySignature = 1;
inline bool WxVerifyCodeReqInfo::has_verifysignature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WxVerifyCodeReqInfo::set_has_verifysignature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WxVerifyCodeReqInfo::clear_has_verifysignature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WxVerifyCodeReqInfo::clear_verifysignature() {
  verifysignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifysignature();
}
inline const ::std::string& WxVerifyCodeReqInfo::verifysignature() const {
  // @@protoc_insertion_point(field_get:micromsg.WxVerifyCodeReqInfo.VerifySignature)
  return verifysignature_.GetNoArena();
}
inline void WxVerifyCodeReqInfo::set_verifysignature(const ::std::string& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WxVerifyCodeReqInfo.VerifySignature)
}
#if LANG_CXX11
inline void WxVerifyCodeReqInfo::set_verifysignature(::std::string&& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WxVerifyCodeReqInfo.VerifySignature)
}
#endif
inline void WxVerifyCodeReqInfo::set_verifysignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WxVerifyCodeReqInfo.VerifySignature)
}
inline void WxVerifyCodeReqInfo::set_verifysignature(const char* value, size_t size) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WxVerifyCodeReqInfo.VerifySignature)
}
inline ::std::string* WxVerifyCodeReqInfo::mutable_verifysignature() {
  set_has_verifysignature();
  // @@protoc_insertion_point(field_mutable:micromsg.WxVerifyCodeReqInfo.VerifySignature)
  return verifysignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WxVerifyCodeReqInfo::release_verifysignature() {
  // @@protoc_insertion_point(field_release:micromsg.WxVerifyCodeReqInfo.VerifySignature)
  clear_has_verifysignature();
  return verifysignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WxVerifyCodeReqInfo::set_allocated_verifysignature(::std::string* verifysignature) {
  if (verifysignature != NULL) {
    set_has_verifysignature();
  } else {
    clear_has_verifysignature();
  }
  verifysignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifysignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WxVerifyCodeReqInfo.VerifySignature)
}

// optional string VerifyContent = 2;
inline bool WxVerifyCodeReqInfo::has_verifycontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WxVerifyCodeReqInfo::set_has_verifycontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WxVerifyCodeReqInfo::clear_has_verifycontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WxVerifyCodeReqInfo::clear_verifycontent() {
  verifycontent_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifycontent();
}
inline const ::std::string& WxVerifyCodeReqInfo::verifycontent() const {
  // @@protoc_insertion_point(field_get:micromsg.WxVerifyCodeReqInfo.VerifyContent)
  return verifycontent_.GetNoArena();
}
inline void WxVerifyCodeReqInfo::set_verifycontent(const ::std::string& value) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WxVerifyCodeReqInfo.VerifyContent)
}
#if LANG_CXX11
inline void WxVerifyCodeReqInfo::set_verifycontent(::std::string&& value) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WxVerifyCodeReqInfo.VerifyContent)
}
#endif
inline void WxVerifyCodeReqInfo::set_verifycontent(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WxVerifyCodeReqInfo.VerifyContent)
}
inline void WxVerifyCodeReqInfo::set_verifycontent(const char* value, size_t size) {
  set_has_verifycontent();
  verifycontent_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WxVerifyCodeReqInfo.VerifyContent)
}
inline ::std::string* WxVerifyCodeReqInfo::mutable_verifycontent() {
  set_has_verifycontent();
  // @@protoc_insertion_point(field_mutable:micromsg.WxVerifyCodeReqInfo.VerifyContent)
  return verifycontent_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WxVerifyCodeReqInfo::release_verifycontent() {
  // @@protoc_insertion_point(field_release:micromsg.WxVerifyCodeReqInfo.VerifyContent)
  clear_has_verifycontent();
  return verifycontent_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WxVerifyCodeReqInfo::set_allocated_verifycontent(::std::string* verifycontent) {
  if (verifycontent != NULL) {
    set_has_verifycontent();
  } else {
    clear_has_verifycontent();
  }
  verifycontent_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifycontent);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WxVerifyCodeReqInfo.VerifyContent)
}

// -------------------------------------------------------------------

// WxVerifyCodeRespInfo

// optional string VerifySignature = 1;
inline bool WxVerifyCodeRespInfo::has_verifysignature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WxVerifyCodeRespInfo::set_has_verifysignature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WxVerifyCodeRespInfo::clear_has_verifysignature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WxVerifyCodeRespInfo::clear_verifysignature() {
  verifysignature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verifysignature();
}
inline const ::std::string& WxVerifyCodeRespInfo::verifysignature() const {
  // @@protoc_insertion_point(field_get:micromsg.WxVerifyCodeRespInfo.VerifySignature)
  return verifysignature_.GetNoArena();
}
inline void WxVerifyCodeRespInfo::set_verifysignature(const ::std::string& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.WxVerifyCodeRespInfo.VerifySignature)
}
#if LANG_CXX11
inline void WxVerifyCodeRespInfo::set_verifysignature(::std::string&& value) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.WxVerifyCodeRespInfo.VerifySignature)
}
#endif
inline void WxVerifyCodeRespInfo::set_verifysignature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.WxVerifyCodeRespInfo.VerifySignature)
}
inline void WxVerifyCodeRespInfo::set_verifysignature(const char* value, size_t size) {
  set_has_verifysignature();
  verifysignature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.WxVerifyCodeRespInfo.VerifySignature)
}
inline ::std::string* WxVerifyCodeRespInfo::mutable_verifysignature() {
  set_has_verifysignature();
  // @@protoc_insertion_point(field_mutable:micromsg.WxVerifyCodeRespInfo.VerifySignature)
  return verifysignature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WxVerifyCodeRespInfo::release_verifysignature() {
  // @@protoc_insertion_point(field_release:micromsg.WxVerifyCodeRespInfo.VerifySignature)
  clear_has_verifysignature();
  return verifysignature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WxVerifyCodeRespInfo::set_allocated_verifysignature(::std::string* verifysignature) {
  if (verifysignature != NULL) {
    set_has_verifysignature();
  } else {
    clear_has_verifysignature();
  }
  verifysignature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifysignature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.WxVerifyCodeRespInfo.VerifySignature)
}

// required .micromsg.SKBuiltinBuffer_t VerifyBuff = 2;
inline bool WxVerifyCodeRespInfo::has_verifybuff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WxVerifyCodeRespInfo::set_has_verifybuff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WxVerifyCodeRespInfo::clear_has_verifybuff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WxVerifyCodeRespInfo::clear_verifybuff() {
  if (verifybuff_ != NULL) verifybuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_verifybuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& WxVerifyCodeRespInfo::verifybuff() const {
  // @@protoc_insertion_point(field_get:micromsg.WxVerifyCodeRespInfo.VerifyBuff)
  return verifybuff_ != NULL ? *verifybuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* WxVerifyCodeRespInfo::mutable_verifybuff() {
  set_has_verifybuff();
  if (verifybuff_ == NULL) {
    verifybuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.WxVerifyCodeRespInfo.VerifyBuff)
  return verifybuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* WxVerifyCodeRespInfo::release_verifybuff() {
  // @@protoc_insertion_point(field_release:micromsg.WxVerifyCodeRespInfo.VerifyBuff)
  clear_has_verifybuff();
  ::micromsg::SKBuiltinBuffer_t* temp = verifybuff_;
  verifybuff_ = NULL;
  return temp;
}
inline void WxVerifyCodeRespInfo::set_allocated_verifybuff(::micromsg::SKBuiltinBuffer_t* verifybuff) {
  delete verifybuff_;
  verifybuff_ = verifybuff;
  if (verifybuff) {
    set_has_verifybuff();
  } else {
    clear_has_verifybuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.WxVerifyCodeRespInfo.VerifyBuff)
}

// -------------------------------------------------------------------

// BaseAuthReqInfo

// optional .micromsg.SKBuiltinBuffer_t WTLoginReqBuff = 1;
inline bool BaseAuthReqInfo::has_wtloginreqbuff() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseAuthReqInfo::set_has_wtloginreqbuff() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseAuthReqInfo::clear_has_wtloginreqbuff() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseAuthReqInfo::clear_wtloginreqbuff() {
  if (wtloginreqbuff_ != NULL) wtloginreqbuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_wtloginreqbuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& BaseAuthReqInfo::wtloginreqbuff() const {
  // @@protoc_insertion_point(field_get:micromsg.BaseAuthReqInfo.WTLoginReqBuff)
  return wtloginreqbuff_ != NULL ? *wtloginreqbuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BaseAuthReqInfo::mutable_wtloginreqbuff() {
  set_has_wtloginreqbuff();
  if (wtloginreqbuff_ == NULL) {
    wtloginreqbuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BaseAuthReqInfo.WTLoginReqBuff)
  return wtloginreqbuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* BaseAuthReqInfo::release_wtloginreqbuff() {
  // @@protoc_insertion_point(field_release:micromsg.BaseAuthReqInfo.WTLoginReqBuff)
  clear_has_wtloginreqbuff();
  ::micromsg::SKBuiltinBuffer_t* temp = wtloginreqbuff_;
  wtloginreqbuff_ = NULL;
  return temp;
}
inline void BaseAuthReqInfo::set_allocated_wtloginreqbuff(::micromsg::SKBuiltinBuffer_t* wtloginreqbuff) {
  delete wtloginreqbuff_;
  wtloginreqbuff_ = wtloginreqbuff;
  if (wtloginreqbuff) {
    set_has_wtloginreqbuff();
  } else {
    clear_has_wtloginreqbuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BaseAuthReqInfo.WTLoginReqBuff)
}

// optional .micromsg.WTLoginImgReqInfo WTLoginImgReqInfo = 2;
inline bool BaseAuthReqInfo::has_wtloginimgreqinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BaseAuthReqInfo::set_has_wtloginimgreqinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BaseAuthReqInfo::clear_has_wtloginimgreqinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BaseAuthReqInfo::clear_wtloginimgreqinfo() {
  if (wtloginimgreqinfo_ != NULL) wtloginimgreqinfo_->::micromsg::WTLoginImgReqInfo::Clear();
  clear_has_wtloginimgreqinfo();
}
inline const ::micromsg::WTLoginImgReqInfo& BaseAuthReqInfo::wtloginimgreqinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.BaseAuthReqInfo.WTLoginImgReqInfo)
  return wtloginimgreqinfo_ != NULL ? *wtloginimgreqinfo_
                         : *::micromsg::WTLoginImgReqInfo::internal_default_instance();
}
inline ::micromsg::WTLoginImgReqInfo* BaseAuthReqInfo::mutable_wtloginimgreqinfo() {
  set_has_wtloginimgreqinfo();
  if (wtloginimgreqinfo_ == NULL) {
    wtloginimgreqinfo_ = new ::micromsg::WTLoginImgReqInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BaseAuthReqInfo.WTLoginImgReqInfo)
  return wtloginimgreqinfo_;
}
inline ::micromsg::WTLoginImgReqInfo* BaseAuthReqInfo::release_wtloginimgreqinfo() {
  // @@protoc_insertion_point(field_release:micromsg.BaseAuthReqInfo.WTLoginImgReqInfo)
  clear_has_wtloginimgreqinfo();
  ::micromsg::WTLoginImgReqInfo* temp = wtloginimgreqinfo_;
  wtloginimgreqinfo_ = NULL;
  return temp;
}
inline void BaseAuthReqInfo::set_allocated_wtloginimgreqinfo(::micromsg::WTLoginImgReqInfo* wtloginimgreqinfo) {
  delete wtloginimgreqinfo_;
  wtloginimgreqinfo_ = wtloginimgreqinfo;
  if (wtloginimgreqinfo) {
    set_has_wtloginimgreqinfo();
  } else {
    clear_has_wtloginimgreqinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BaseAuthReqInfo.WTLoginImgReqInfo)
}

// optional .micromsg.WxVerifyCodeReqInfo WxVerifyCodeReqInfo = 3;
inline bool BaseAuthReqInfo::has_wxverifycodereqinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BaseAuthReqInfo::set_has_wxverifycodereqinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BaseAuthReqInfo::clear_has_wxverifycodereqinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BaseAuthReqInfo::clear_wxverifycodereqinfo() {
  if (wxverifycodereqinfo_ != NULL) wxverifycodereqinfo_->::micromsg::WxVerifyCodeReqInfo::Clear();
  clear_has_wxverifycodereqinfo();
}
inline const ::micromsg::WxVerifyCodeReqInfo& BaseAuthReqInfo::wxverifycodereqinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.BaseAuthReqInfo.WxVerifyCodeReqInfo)
  return wxverifycodereqinfo_ != NULL ? *wxverifycodereqinfo_
                         : *::micromsg::WxVerifyCodeReqInfo::internal_default_instance();
}
inline ::micromsg::WxVerifyCodeReqInfo* BaseAuthReqInfo::mutable_wxverifycodereqinfo() {
  set_has_wxverifycodereqinfo();
  if (wxverifycodereqinfo_ == NULL) {
    wxverifycodereqinfo_ = new ::micromsg::WxVerifyCodeReqInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BaseAuthReqInfo.WxVerifyCodeReqInfo)
  return wxverifycodereqinfo_;
}
inline ::micromsg::WxVerifyCodeReqInfo* BaseAuthReqInfo::release_wxverifycodereqinfo() {
  // @@protoc_insertion_point(field_release:micromsg.BaseAuthReqInfo.WxVerifyCodeReqInfo)
  clear_has_wxverifycodereqinfo();
  ::micromsg::WxVerifyCodeReqInfo* temp = wxverifycodereqinfo_;
  wxverifycodereqinfo_ = NULL;
  return temp;
}
inline void BaseAuthReqInfo::set_allocated_wxverifycodereqinfo(::micromsg::WxVerifyCodeReqInfo* wxverifycodereqinfo) {
  delete wxverifycodereqinfo_;
  wxverifycodereqinfo_ = wxverifycodereqinfo;
  if (wxverifycodereqinfo) {
    set_has_wxverifycodereqinfo();
  } else {
    clear_has_wxverifycodereqinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BaseAuthReqInfo.WxVerifyCodeReqInfo)
}

// optional .micromsg.SKBuiltinBuffer_t CliDBEncryptKey = 4;
inline bool BaseAuthReqInfo::has_clidbencryptkey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BaseAuthReqInfo::set_has_clidbencryptkey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BaseAuthReqInfo::clear_has_clidbencryptkey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BaseAuthReqInfo::clear_clidbencryptkey() {
  if (clidbencryptkey_ != NULL) clidbencryptkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_clidbencryptkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& BaseAuthReqInfo::clidbencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.BaseAuthReqInfo.CliDBEncryptKey)
  return clidbencryptkey_ != NULL ? *clidbencryptkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BaseAuthReqInfo::mutable_clidbencryptkey() {
  set_has_clidbencryptkey();
  if (clidbencryptkey_ == NULL) {
    clidbencryptkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BaseAuthReqInfo.CliDBEncryptKey)
  return clidbencryptkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* BaseAuthReqInfo::release_clidbencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.BaseAuthReqInfo.CliDBEncryptKey)
  clear_has_clidbencryptkey();
  ::micromsg::SKBuiltinBuffer_t* temp = clidbencryptkey_;
  clidbencryptkey_ = NULL;
  return temp;
}
inline void BaseAuthReqInfo::set_allocated_clidbencryptkey(::micromsg::SKBuiltinBuffer_t* clidbencryptkey) {
  delete clidbencryptkey_;
  clidbencryptkey_ = clidbencryptkey;
  if (clidbencryptkey) {
    set_has_clidbencryptkey();
  } else {
    clear_has_clidbencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BaseAuthReqInfo.CliDBEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t CliDBEncryptInfo = 5;
inline bool BaseAuthReqInfo::has_clidbencryptinfo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BaseAuthReqInfo::set_has_clidbencryptinfo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BaseAuthReqInfo::clear_has_clidbencryptinfo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BaseAuthReqInfo::clear_clidbencryptinfo() {
  if (clidbencryptinfo_ != NULL) clidbencryptinfo_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_clidbencryptinfo();
}
inline const ::micromsg::SKBuiltinBuffer_t& BaseAuthReqInfo::clidbencryptinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.BaseAuthReqInfo.CliDBEncryptInfo)
  return clidbencryptinfo_ != NULL ? *clidbencryptinfo_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* BaseAuthReqInfo::mutable_clidbencryptinfo() {
  set_has_clidbencryptinfo();
  if (clidbencryptinfo_ == NULL) {
    clidbencryptinfo_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.BaseAuthReqInfo.CliDBEncryptInfo)
  return clidbencryptinfo_;
}
inline ::micromsg::SKBuiltinBuffer_t* BaseAuthReqInfo::release_clidbencryptinfo() {
  // @@protoc_insertion_point(field_release:micromsg.BaseAuthReqInfo.CliDBEncryptInfo)
  clear_has_clidbencryptinfo();
  ::micromsg::SKBuiltinBuffer_t* temp = clidbencryptinfo_;
  clidbencryptinfo_ = NULL;
  return temp;
}
inline void BaseAuthReqInfo::set_allocated_clidbencryptinfo(::micromsg::SKBuiltinBuffer_t* clidbencryptinfo) {
  delete clidbencryptinfo_;
  clidbencryptinfo_ = clidbencryptinfo;
  if (clidbencryptinfo) {
    set_has_clidbencryptinfo();
  } else {
    clear_has_clidbencryptinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.BaseAuthReqInfo.CliDBEncryptInfo)
}

// optional uint32 AuthReqFlag = 6;
inline bool BaseAuthReqInfo::has_authreqflag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BaseAuthReqInfo::set_has_authreqflag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BaseAuthReqInfo::clear_has_authreqflag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BaseAuthReqInfo::clear_authreqflag() {
  authreqflag_ = 0u;
  clear_has_authreqflag();
}
inline ::google::protobuf::uint32 BaseAuthReqInfo::authreqflag() const {
  // @@protoc_insertion_point(field_get:micromsg.BaseAuthReqInfo.AuthReqFlag)
  return authreqflag_;
}
inline void BaseAuthReqInfo::set_authreqflag(::google::protobuf::uint32 value) {
  set_has_authreqflag();
  authreqflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.BaseAuthReqInfo.AuthReqFlag)
}

// optional string AuthTicket = 7;
inline bool BaseAuthReqInfo::has_authticket() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseAuthReqInfo::set_has_authticket() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseAuthReqInfo::clear_has_authticket() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseAuthReqInfo::clear_authticket() {
  authticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authticket();
}
inline const ::std::string& BaseAuthReqInfo::authticket() const {
  // @@protoc_insertion_point(field_get:micromsg.BaseAuthReqInfo.AuthTicket)
  return authticket_.GetNoArena();
}
inline void BaseAuthReqInfo::set_authticket(const ::std::string& value) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.BaseAuthReqInfo.AuthTicket)
}
#if LANG_CXX11
inline void BaseAuthReqInfo::set_authticket(::std::string&& value) {
  set_has_authticket();
  authticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.BaseAuthReqInfo.AuthTicket)
}
#endif
inline void BaseAuthReqInfo::set_authticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.BaseAuthReqInfo.AuthTicket)
}
inline void BaseAuthReqInfo::set_authticket(const char* value, size_t size) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.BaseAuthReqInfo.AuthTicket)
}
inline ::std::string* BaseAuthReqInfo::mutable_authticket() {
  set_has_authticket();
  // @@protoc_insertion_point(field_mutable:micromsg.BaseAuthReqInfo.AuthTicket)
  return authticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BaseAuthReqInfo::release_authticket() {
  // @@protoc_insertion_point(field_release:micromsg.BaseAuthReqInfo.AuthTicket)
  clear_has_authticket();
  return authticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BaseAuthReqInfo::set_allocated_authticket(::std::string* authticket) {
  if (authticket != NULL) {
    set_has_authticket();
  } else {
    clear_has_authticket();
  }
  authticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.BaseAuthReqInfo.AuthTicket)
}

// -------------------------------------------------------------------

// ManualAuthRsaReqData

// required .micromsg.SKBuiltinBuffer_t RandomEncryKey = 1;
inline bool ManualAuthRsaReqData::has_randomencrykey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManualAuthRsaReqData::set_has_randomencrykey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManualAuthRsaReqData::clear_has_randomencrykey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManualAuthRsaReqData::clear_randomencrykey() {
  if (randomencrykey_ != NULL) randomencrykey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_randomencrykey();
}
inline const ::micromsg::SKBuiltinBuffer_t& ManualAuthRsaReqData::randomencrykey() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthRsaReqData.RandomEncryKey)
  return randomencrykey_ != NULL ? *randomencrykey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* ManualAuthRsaReqData::mutable_randomencrykey() {
  set_has_randomencrykey();
  if (randomencrykey_ == NULL) {
    randomencrykey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthRsaReqData.RandomEncryKey)
  return randomencrykey_;
}
inline ::micromsg::SKBuiltinBuffer_t* ManualAuthRsaReqData::release_randomencrykey() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthRsaReqData.RandomEncryKey)
  clear_has_randomencrykey();
  ::micromsg::SKBuiltinBuffer_t* temp = randomencrykey_;
  randomencrykey_ = NULL;
  return temp;
}
inline void ManualAuthRsaReqData::set_allocated_randomencrykey(::micromsg::SKBuiltinBuffer_t* randomencrykey) {
  delete randomencrykey_;
  randomencrykey_ = randomencrykey;
  if (randomencrykey) {
    set_has_randomencrykey();
  } else {
    clear_has_randomencrykey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthRsaReqData.RandomEncryKey)
}

// required .micromsg.ECDHKey CliPubECDHKey = 2;
inline bool ManualAuthRsaReqData::has_clipubecdhkey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ManualAuthRsaReqData::set_has_clipubecdhkey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ManualAuthRsaReqData::clear_has_clipubecdhkey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ManualAuthRsaReqData::clear_clipubecdhkey() {
  if (clipubecdhkey_ != NULL) clipubecdhkey_->::micromsg::ECDHKey::Clear();
  clear_has_clipubecdhkey();
}
inline const ::micromsg::ECDHKey& ManualAuthRsaReqData::clipubecdhkey() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthRsaReqData.CliPubECDHKey)
  return clipubecdhkey_ != NULL ? *clipubecdhkey_
                         : *::micromsg::ECDHKey::internal_default_instance();
}
inline ::micromsg::ECDHKey* ManualAuthRsaReqData::mutable_clipubecdhkey() {
  set_has_clipubecdhkey();
  if (clipubecdhkey_ == NULL) {
    clipubecdhkey_ = new ::micromsg::ECDHKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthRsaReqData.CliPubECDHKey)
  return clipubecdhkey_;
}
inline ::micromsg::ECDHKey* ManualAuthRsaReqData::release_clipubecdhkey() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthRsaReqData.CliPubECDHKey)
  clear_has_clipubecdhkey();
  ::micromsg::ECDHKey* temp = clipubecdhkey_;
  clipubecdhkey_ = NULL;
  return temp;
}
inline void ManualAuthRsaReqData::set_allocated_clipubecdhkey(::micromsg::ECDHKey* clipubecdhkey) {
  delete clipubecdhkey_;
  clipubecdhkey_ = clipubecdhkey;
  if (clipubecdhkey) {
    set_has_clipubecdhkey();
  } else {
    clear_has_clipubecdhkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthRsaReqData.CliPubECDHKey)
}

// optional string UserName = 3;
inline bool ManualAuthRsaReqData::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManualAuthRsaReqData::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManualAuthRsaReqData::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManualAuthRsaReqData::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& ManualAuthRsaReqData::username() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthRsaReqData.UserName)
  return username_.GetNoArena();
}
inline void ManualAuthRsaReqData::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthRsaReqData.UserName)
}
#if LANG_CXX11
inline void ManualAuthRsaReqData::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthRsaReqData.UserName)
}
#endif
inline void ManualAuthRsaReqData::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthRsaReqData.UserName)
}
inline void ManualAuthRsaReqData::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthRsaReqData.UserName)
}
inline ::std::string* ManualAuthRsaReqData::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthRsaReqData.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthRsaReqData::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthRsaReqData.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthRsaReqData::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthRsaReqData.UserName)
}

// optional string Pwd = 4;
inline bool ManualAuthRsaReqData::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManualAuthRsaReqData::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManualAuthRsaReqData::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManualAuthRsaReqData::clear_pwd() {
  pwd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd();
}
inline const ::std::string& ManualAuthRsaReqData::pwd() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthRsaReqData.Pwd)
  return pwd_.GetNoArena();
}
inline void ManualAuthRsaReqData::set_pwd(const ::std::string& value) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthRsaReqData.Pwd)
}
#if LANG_CXX11
inline void ManualAuthRsaReqData::set_pwd(::std::string&& value) {
  set_has_pwd();
  pwd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthRsaReqData.Pwd)
}
#endif
inline void ManualAuthRsaReqData::set_pwd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthRsaReqData.Pwd)
}
inline void ManualAuthRsaReqData::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  pwd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthRsaReqData.Pwd)
}
inline ::std::string* ManualAuthRsaReqData::mutable_pwd() {
  set_has_pwd();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthRsaReqData.Pwd)
  return pwd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthRsaReqData::release_pwd() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthRsaReqData.Pwd)
  clear_has_pwd();
  return pwd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthRsaReqData::set_allocated_pwd(::std::string* pwd) {
  if (pwd != NULL) {
    set_has_pwd();
  } else {
    clear_has_pwd();
  }
  pwd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthRsaReqData.Pwd)
}

// optional string Pwd2 = 5;
inline bool ManualAuthRsaReqData::has_pwd2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManualAuthRsaReqData::set_has_pwd2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManualAuthRsaReqData::clear_has_pwd2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManualAuthRsaReqData::clear_pwd2() {
  pwd2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pwd2();
}
inline const ::std::string& ManualAuthRsaReqData::pwd2() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthRsaReqData.Pwd2)
  return pwd2_.GetNoArena();
}
inline void ManualAuthRsaReqData::set_pwd2(const ::std::string& value) {
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthRsaReqData.Pwd2)
}
#if LANG_CXX11
inline void ManualAuthRsaReqData::set_pwd2(::std::string&& value) {
  set_has_pwd2();
  pwd2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthRsaReqData.Pwd2)
}
#endif
inline void ManualAuthRsaReqData::set_pwd2(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthRsaReqData.Pwd2)
}
inline void ManualAuthRsaReqData::set_pwd2(const char* value, size_t size) {
  set_has_pwd2();
  pwd2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthRsaReqData.Pwd2)
}
inline ::std::string* ManualAuthRsaReqData::mutable_pwd2() {
  set_has_pwd2();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthRsaReqData.Pwd2)
  return pwd2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthRsaReqData::release_pwd2() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthRsaReqData.Pwd2)
  clear_has_pwd2();
  return pwd2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthRsaReqData::set_allocated_pwd2(::std::string* pwd2) {
  if (pwd2 != NULL) {
    set_has_pwd2();
  } else {
    clear_has_pwd2();
  }
  pwd2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pwd2);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthRsaReqData.Pwd2)
}

// -------------------------------------------------------------------

// ManualAuthAesReqData

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool ManualAuthAesReqData::has_baserequest() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ManualAuthAesReqData::set_has_baserequest() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ManualAuthAesReqData::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ManualAuthAesReqData::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& ManualAuthAesReqData::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* ManualAuthAesReqData::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* ManualAuthAesReqData::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void ManualAuthAesReqData::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.BaseRequest)
}

// optional .micromsg.BaseAuthReqInfo BaseReqInfo = 2;
inline bool ManualAuthAesReqData::has_basereqinfo() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ManualAuthAesReqData::set_has_basereqinfo() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ManualAuthAesReqData::clear_has_basereqinfo() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ManualAuthAesReqData::clear_basereqinfo() {
  if (basereqinfo_ != NULL) basereqinfo_->::micromsg::BaseAuthReqInfo::Clear();
  clear_has_basereqinfo();
}
inline const ::micromsg::BaseAuthReqInfo& ManualAuthAesReqData::basereqinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.BaseReqInfo)
  return basereqinfo_ != NULL ? *basereqinfo_
                         : *::micromsg::BaseAuthReqInfo::internal_default_instance();
}
inline ::micromsg::BaseAuthReqInfo* ManualAuthAesReqData::mutable_basereqinfo() {
  set_has_basereqinfo();
  if (basereqinfo_ == NULL) {
    basereqinfo_ = new ::micromsg::BaseAuthReqInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.BaseReqInfo)
  return basereqinfo_;
}
inline ::micromsg::BaseAuthReqInfo* ManualAuthAesReqData::release_basereqinfo() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.BaseReqInfo)
  clear_has_basereqinfo();
  ::micromsg::BaseAuthReqInfo* temp = basereqinfo_;
  basereqinfo_ = NULL;
  return temp;
}
inline void ManualAuthAesReqData::set_allocated_basereqinfo(::micromsg::BaseAuthReqInfo* basereqinfo) {
  delete basereqinfo_;
  basereqinfo_ = basereqinfo;
  if (basereqinfo) {
    set_has_basereqinfo();
  } else {
    clear_has_basereqinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.BaseReqInfo)
}

// optional string IMEI = 3;
inline bool ManualAuthAesReqData::has_imei() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManualAuthAesReqData::set_has_imei() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManualAuthAesReqData::clear_has_imei() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManualAuthAesReqData::clear_imei() {
  imei_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imei();
}
inline const ::std::string& ManualAuthAesReqData::imei() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.IMEI)
  return imei_.GetNoArena();
}
inline void ManualAuthAesReqData::set_imei(const ::std::string& value) {
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.IMEI)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_imei(::std::string&& value) {
  set_has_imei();
  imei_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.IMEI)
}
#endif
inline void ManualAuthAesReqData::set_imei(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.IMEI)
}
inline void ManualAuthAesReqData::set_imei(const char* value, size_t size) {
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.IMEI)
}
inline ::std::string* ManualAuthAesReqData::mutable_imei() {
  set_has_imei();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.IMEI)
  return imei_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_imei() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.IMEI)
  clear_has_imei();
  return imei_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_imei(::std::string* imei) {
  if (imei != NULL) {
    set_has_imei();
  } else {
    clear_has_imei();
  }
  imei_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imei);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.IMEI)
}

// optional string SoftType = 4;
inline bool ManualAuthAesReqData::has_softtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManualAuthAesReqData::set_has_softtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManualAuthAesReqData::clear_has_softtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManualAuthAesReqData::clear_softtype() {
  softtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_softtype();
}
inline const ::std::string& ManualAuthAesReqData::softtype() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.SoftType)
  return softtype_.GetNoArena();
}
inline void ManualAuthAesReqData::set_softtype(const ::std::string& value) {
  set_has_softtype();
  softtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.SoftType)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_softtype(::std::string&& value) {
  set_has_softtype();
  softtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.SoftType)
}
#endif
inline void ManualAuthAesReqData::set_softtype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_softtype();
  softtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.SoftType)
}
inline void ManualAuthAesReqData::set_softtype(const char* value, size_t size) {
  set_has_softtype();
  softtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.SoftType)
}
inline ::std::string* ManualAuthAesReqData::mutable_softtype() {
  set_has_softtype();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.SoftType)
  return softtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_softtype() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.SoftType)
  clear_has_softtype();
  return softtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_softtype(::std::string* softtype) {
  if (softtype != NULL) {
    set_has_softtype();
  } else {
    clear_has_softtype();
  }
  softtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), softtype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.SoftType)
}

// required uint32 BuiltinIPSeq = 5;
inline bool ManualAuthAesReqData::has_builtinipseq() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ManualAuthAesReqData::set_has_builtinipseq() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ManualAuthAesReqData::clear_has_builtinipseq() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ManualAuthAesReqData::clear_builtinipseq() {
  builtinipseq_ = 0u;
  clear_has_builtinipseq();
}
inline ::google::protobuf::uint32 ManualAuthAesReqData::builtinipseq() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.BuiltinIPSeq)
  return builtinipseq_;
}
inline void ManualAuthAesReqData::set_builtinipseq(::google::protobuf::uint32 value) {
  set_has_builtinipseq();
  builtinipseq_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.BuiltinIPSeq)
}

// optional string ClientSeqID = 6;
inline bool ManualAuthAesReqData::has_clientseqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManualAuthAesReqData::set_has_clientseqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManualAuthAesReqData::clear_has_clientseqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManualAuthAesReqData::clear_clientseqid() {
  clientseqid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientseqid();
}
inline const ::std::string& ManualAuthAesReqData::clientseqid() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.ClientSeqID)
  return clientseqid_.GetNoArena();
}
inline void ManualAuthAesReqData::set_clientseqid(const ::std::string& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.ClientSeqID)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_clientseqid(::std::string&& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.ClientSeqID)
}
#endif
inline void ManualAuthAesReqData::set_clientseqid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.ClientSeqID)
}
inline void ManualAuthAesReqData::set_clientseqid(const char* value, size_t size) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.ClientSeqID)
}
inline ::std::string* ManualAuthAesReqData::mutable_clientseqid() {
  set_has_clientseqid();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.ClientSeqID)
  return clientseqid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_clientseqid() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.ClientSeqID)
  clear_has_clientseqid();
  return clientseqid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_clientseqid(::std::string* clientseqid) {
  if (clientseqid != NULL) {
    set_has_clientseqid();
  } else {
    clear_has_clientseqid();
  }
  clientseqid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientseqid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.ClientSeqID)
}

// optional string Signature = 7;
inline bool ManualAuthAesReqData::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ManualAuthAesReqData::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ManualAuthAesReqData::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ManualAuthAesReqData::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& ManualAuthAesReqData::signature() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.Signature)
  return signature_.GetNoArena();
}
inline void ManualAuthAesReqData::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.Signature)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.Signature)
}
#endif
inline void ManualAuthAesReqData::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.Signature)
}
inline void ManualAuthAesReqData::set_signature(const char* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.Signature)
}
inline ::std::string* ManualAuthAesReqData::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.Signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_signature() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.Signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.Signature)
}

// optional string DeviceName = 8;
inline bool ManualAuthAesReqData::has_devicename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ManualAuthAesReqData::set_has_devicename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ManualAuthAesReqData::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ManualAuthAesReqData::clear_devicename() {
  devicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicename();
}
inline const ::std::string& ManualAuthAesReqData::devicename() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.DeviceName)
  return devicename_.GetNoArena();
}
inline void ManualAuthAesReqData::set_devicename(const ::std::string& value) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.DeviceName)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_devicename(::std::string&& value) {
  set_has_devicename();
  devicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.DeviceName)
}
#endif
inline void ManualAuthAesReqData::set_devicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.DeviceName)
}
inline void ManualAuthAesReqData::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.DeviceName)
}
inline ::std::string* ManualAuthAesReqData::mutable_devicename() {
  set_has_devicename();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.DeviceName)
  return devicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_devicename() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.DeviceName)
  clear_has_devicename();
  return devicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_devicename(::std::string* devicename) {
  if (devicename != NULL) {
    set_has_devicename();
  } else {
    clear_has_devicename();
  }
  devicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicename);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.DeviceName)
}

// optional string DeviceType = 9;
inline bool ManualAuthAesReqData::has_devicetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ManualAuthAesReqData::set_has_devicetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ManualAuthAesReqData::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ManualAuthAesReqData::clear_devicetype() {
  devicetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicetype();
}
inline const ::std::string& ManualAuthAesReqData::devicetype() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.DeviceType)
  return devicetype_.GetNoArena();
}
inline void ManualAuthAesReqData::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.DeviceType)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_devicetype(::std::string&& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.DeviceType)
}
#endif
inline void ManualAuthAesReqData::set_devicetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.DeviceType)
}
inline void ManualAuthAesReqData::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.DeviceType)
}
inline ::std::string* ManualAuthAesReqData::mutable_devicetype() {
  set_has_devicetype();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.DeviceType)
  return devicetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_devicetype() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.DeviceType)
  clear_has_devicetype();
  return devicetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype != NULL) {
    set_has_devicetype();
  } else {
    clear_has_devicetype();
  }
  devicetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.DeviceType)
}

// optional string Language = 10;
inline bool ManualAuthAesReqData::has_language() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ManualAuthAesReqData::set_has_language() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ManualAuthAesReqData::clear_has_language() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ManualAuthAesReqData::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& ManualAuthAesReqData::language() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.Language)
  return language_.GetNoArena();
}
inline void ManualAuthAesReqData::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.Language)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.Language)
}
#endif
inline void ManualAuthAesReqData::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.Language)
}
inline void ManualAuthAesReqData::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.Language)
}
inline ::std::string* ManualAuthAesReqData::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.Language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_language() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.Language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.Language)
}

// optional string TimeZone = 11;
inline bool ManualAuthAesReqData::has_timezone() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ManualAuthAesReqData::set_has_timezone() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ManualAuthAesReqData::clear_has_timezone() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ManualAuthAesReqData::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timezone();
}
inline const ::std::string& ManualAuthAesReqData::timezone() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.TimeZone)
  return timezone_.GetNoArena();
}
inline void ManualAuthAesReqData::set_timezone(const ::std::string& value) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.TimeZone)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_timezone(::std::string&& value) {
  set_has_timezone();
  timezone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.TimeZone)
}
#endif
inline void ManualAuthAesReqData::set_timezone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.TimeZone)
}
inline void ManualAuthAesReqData::set_timezone(const char* value, size_t size) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.TimeZone)
}
inline ::std::string* ManualAuthAesReqData::mutable_timezone() {
  set_has_timezone();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.TimeZone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_timezone() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.TimeZone)
  clear_has_timezone();
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    set_has_timezone();
  } else {
    clear_has_timezone();
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.TimeZone)
}

// optional int32 Channel = 13;
inline bool ManualAuthAesReqData::has_channel() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ManualAuthAesReqData::set_has_channel() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ManualAuthAesReqData::clear_has_channel() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ManualAuthAesReqData::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ManualAuthAesReqData::channel() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.Channel)
  return channel_;
}
inline void ManualAuthAesReqData::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.Channel)
}

// optional uint32 TimeStamp = 14;
inline bool ManualAuthAesReqData::has_timestamp() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ManualAuthAesReqData::set_has_timestamp() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ManualAuthAesReqData::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ManualAuthAesReqData::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 ManualAuthAesReqData::timestamp() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.TimeStamp)
  return timestamp_;
}
inline void ManualAuthAesReqData::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.TimeStamp)
}

// optional string DeviceBrand = 15;
inline bool ManualAuthAesReqData::has_devicebrand() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ManualAuthAesReqData::set_has_devicebrand() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ManualAuthAesReqData::clear_has_devicebrand() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ManualAuthAesReqData::clear_devicebrand() {
  devicebrand_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicebrand();
}
inline const ::std::string& ManualAuthAesReqData::devicebrand() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.DeviceBrand)
  return devicebrand_.GetNoArena();
}
inline void ManualAuthAesReqData::set_devicebrand(const ::std::string& value) {
  set_has_devicebrand();
  devicebrand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.DeviceBrand)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_devicebrand(::std::string&& value) {
  set_has_devicebrand();
  devicebrand_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.DeviceBrand)
}
#endif
inline void ManualAuthAesReqData::set_devicebrand(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicebrand();
  devicebrand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.DeviceBrand)
}
inline void ManualAuthAesReqData::set_devicebrand(const char* value, size_t size) {
  set_has_devicebrand();
  devicebrand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.DeviceBrand)
}
inline ::std::string* ManualAuthAesReqData::mutable_devicebrand() {
  set_has_devicebrand();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.DeviceBrand)
  return devicebrand_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_devicebrand() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.DeviceBrand)
  clear_has_devicebrand();
  return devicebrand_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_devicebrand(::std::string* devicebrand) {
  if (devicebrand != NULL) {
    set_has_devicebrand();
  } else {
    clear_has_devicebrand();
  }
  devicebrand_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicebrand);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.DeviceBrand)
}

// optional string DeviceModel = 16;
inline bool ManualAuthAesReqData::has_devicemodel() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ManualAuthAesReqData::set_has_devicemodel() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ManualAuthAesReqData::clear_has_devicemodel() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ManualAuthAesReqData::clear_devicemodel() {
  devicemodel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicemodel();
}
inline const ::std::string& ManualAuthAesReqData::devicemodel() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.DeviceModel)
  return devicemodel_.GetNoArena();
}
inline void ManualAuthAesReqData::set_devicemodel(const ::std::string& value) {
  set_has_devicemodel();
  devicemodel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.DeviceModel)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_devicemodel(::std::string&& value) {
  set_has_devicemodel();
  devicemodel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.DeviceModel)
}
#endif
inline void ManualAuthAesReqData::set_devicemodel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicemodel();
  devicemodel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.DeviceModel)
}
inline void ManualAuthAesReqData::set_devicemodel(const char* value, size_t size) {
  set_has_devicemodel();
  devicemodel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.DeviceModel)
}
inline ::std::string* ManualAuthAesReqData::mutable_devicemodel() {
  set_has_devicemodel();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.DeviceModel)
  return devicemodel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_devicemodel() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.DeviceModel)
  clear_has_devicemodel();
  return devicemodel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_devicemodel(::std::string* devicemodel) {
  if (devicemodel != NULL) {
    set_has_devicemodel();
  } else {
    clear_has_devicemodel();
  }
  devicemodel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicemodel);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.DeviceModel)
}

// optional string OSType = 17;
inline bool ManualAuthAesReqData::has_ostype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ManualAuthAesReqData::set_has_ostype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ManualAuthAesReqData::clear_has_ostype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ManualAuthAesReqData::clear_ostype() {
  ostype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ostype();
}
inline const ::std::string& ManualAuthAesReqData::ostype() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.OSType)
  return ostype_.GetNoArena();
}
inline void ManualAuthAesReqData::set_ostype(const ::std::string& value) {
  set_has_ostype();
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.OSType)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_ostype(::std::string&& value) {
  set_has_ostype();
  ostype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.OSType)
}
#endif
inline void ManualAuthAesReqData::set_ostype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ostype();
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.OSType)
}
inline void ManualAuthAesReqData::set_ostype(const char* value, size_t size) {
  set_has_ostype();
  ostype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.OSType)
}
inline ::std::string* ManualAuthAesReqData::mutable_ostype() {
  set_has_ostype();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.OSType)
  return ostype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_ostype() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.OSType)
  clear_has_ostype();
  return ostype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_ostype(::std::string* ostype) {
  if (ostype != NULL) {
    set_has_ostype();
  } else {
    clear_has_ostype();
  }
  ostype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ostype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.OSType)
}

// optional string RealCountry = 18;
inline bool ManualAuthAesReqData::has_realcountry() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ManualAuthAesReqData::set_has_realcountry() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ManualAuthAesReqData::clear_has_realcountry() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ManualAuthAesReqData::clear_realcountry() {
  realcountry_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_realcountry();
}
inline const ::std::string& ManualAuthAesReqData::realcountry() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.RealCountry)
  return realcountry_.GetNoArena();
}
inline void ManualAuthAesReqData::set_realcountry(const ::std::string& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.RealCountry)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_realcountry(::std::string&& value) {
  set_has_realcountry();
  realcountry_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.RealCountry)
}
#endif
inline void ManualAuthAesReqData::set_realcountry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.RealCountry)
}
inline void ManualAuthAesReqData::set_realcountry(const char* value, size_t size) {
  set_has_realcountry();
  realcountry_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.RealCountry)
}
inline ::std::string* ManualAuthAesReqData::mutable_realcountry() {
  set_has_realcountry();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.RealCountry)
  return realcountry_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_realcountry() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.RealCountry)
  clear_has_realcountry();
  return realcountry_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_realcountry(::std::string* realcountry) {
  if (realcountry != NULL) {
    set_has_realcountry();
  } else {
    clear_has_realcountry();
  }
  realcountry_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), realcountry);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.RealCountry)
}

// optional string BundleID = 19;
inline bool ManualAuthAesReqData::has_bundleid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ManualAuthAesReqData::set_has_bundleid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ManualAuthAesReqData::clear_has_bundleid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ManualAuthAesReqData::clear_bundleid() {
  bundleid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bundleid();
}
inline const ::std::string& ManualAuthAesReqData::bundleid() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.BundleID)
  return bundleid_.GetNoArena();
}
inline void ManualAuthAesReqData::set_bundleid(const ::std::string& value) {
  set_has_bundleid();
  bundleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.BundleID)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_bundleid(::std::string&& value) {
  set_has_bundleid();
  bundleid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.BundleID)
}
#endif
inline void ManualAuthAesReqData::set_bundleid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bundleid();
  bundleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.BundleID)
}
inline void ManualAuthAesReqData::set_bundleid(const char* value, size_t size) {
  set_has_bundleid();
  bundleid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.BundleID)
}
inline ::std::string* ManualAuthAesReqData::mutable_bundleid() {
  set_has_bundleid();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.BundleID)
  return bundleid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_bundleid() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.BundleID)
  clear_has_bundleid();
  return bundleid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_bundleid(::std::string* bundleid) {
  if (bundleid != NULL) {
    set_has_bundleid();
  } else {
    clear_has_bundleid();
  }
  bundleid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bundleid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.BundleID)
}

// optional string AdSource = 20;
inline bool ManualAuthAesReqData::has_adsource() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ManualAuthAesReqData::set_has_adsource() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ManualAuthAesReqData::clear_has_adsource() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ManualAuthAesReqData::clear_adsource() {
  adsource_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_adsource();
}
inline const ::std::string& ManualAuthAesReqData::adsource() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.AdSource)
  return adsource_.GetNoArena();
}
inline void ManualAuthAesReqData::set_adsource(const ::std::string& value) {
  set_has_adsource();
  adsource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.AdSource)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_adsource(::std::string&& value) {
  set_has_adsource();
  adsource_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.AdSource)
}
#endif
inline void ManualAuthAesReqData::set_adsource(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_adsource();
  adsource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.AdSource)
}
inline void ManualAuthAesReqData::set_adsource(const char* value, size_t size) {
  set_has_adsource();
  adsource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.AdSource)
}
inline ::std::string* ManualAuthAesReqData::mutable_adsource() {
  set_has_adsource();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.AdSource)
  return adsource_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_adsource() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.AdSource)
  clear_has_adsource();
  return adsource_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_adsource(::std::string* adsource) {
  if (adsource != NULL) {
    set_has_adsource();
  } else {
    clear_has_adsource();
  }
  adsource_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), adsource);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.AdSource)
}

// optional string IPhoneVer = 21;
inline bool ManualAuthAesReqData::has_iphonever() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ManualAuthAesReqData::set_has_iphonever() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ManualAuthAesReqData::clear_has_iphonever() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ManualAuthAesReqData::clear_iphonever() {
  iphonever_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iphonever();
}
inline const ::std::string& ManualAuthAesReqData::iphonever() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.IPhoneVer)
  return iphonever_.GetNoArena();
}
inline void ManualAuthAesReqData::set_iphonever(const ::std::string& value) {
  set_has_iphonever();
  iphonever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.IPhoneVer)
}
#if LANG_CXX11
inline void ManualAuthAesReqData::set_iphonever(::std::string&& value) {
  set_has_iphonever();
  iphonever_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.ManualAuthAesReqData.IPhoneVer)
}
#endif
inline void ManualAuthAesReqData::set_iphonever(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iphonever();
  iphonever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.ManualAuthAesReqData.IPhoneVer)
}
inline void ManualAuthAesReqData::set_iphonever(const char* value, size_t size) {
  set_has_iphonever();
  iphonever_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.ManualAuthAesReqData.IPhoneVer)
}
inline ::std::string* ManualAuthAesReqData::mutable_iphonever() {
  set_has_iphonever();
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.IPhoneVer)
  return iphonever_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManualAuthAesReqData::release_iphonever() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.IPhoneVer)
  clear_has_iphonever();
  return iphonever_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManualAuthAesReqData::set_allocated_iphonever(::std::string* iphonever) {
  if (iphonever != NULL) {
    set_has_iphonever();
  } else {
    clear_has_iphonever();
  }
  iphonever_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iphonever);
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.IPhoneVer)
}

// required uint32 InputType = 22;
inline bool ManualAuthAesReqData::has_inputtype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ManualAuthAesReqData::set_has_inputtype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ManualAuthAesReqData::clear_has_inputtype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ManualAuthAesReqData::clear_inputtype() {
  inputtype_ = 0u;
  clear_has_inputtype();
}
inline ::google::protobuf::uint32 ManualAuthAesReqData::inputtype() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.InputType)
  return inputtype_;
}
inline void ManualAuthAesReqData::set_inputtype(::google::protobuf::uint32 value) {
  set_has_inputtype();
  inputtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.ManualAuthAesReqData.InputType)
}

// optional .micromsg.SKBuiltinBuffer_t Clientcheckdat = 23;
inline bool ManualAuthAesReqData::has_clientcheckdat() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ManualAuthAesReqData::set_has_clientcheckdat() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ManualAuthAesReqData::clear_has_clientcheckdat() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ManualAuthAesReqData::clear_clientcheckdat() {
  if (clientcheckdat_ != NULL) clientcheckdat_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_clientcheckdat();
}
inline const ::micromsg::SKBuiltinBuffer_t& ManualAuthAesReqData::clientcheckdat() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthAesReqData.Clientcheckdat)
  return clientcheckdat_ != NULL ? *clientcheckdat_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* ManualAuthAesReqData::mutable_clientcheckdat() {
  set_has_clientcheckdat();
  if (clientcheckdat_ == NULL) {
    clientcheckdat_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthAesReqData.Clientcheckdat)
  return clientcheckdat_;
}
inline ::micromsg::SKBuiltinBuffer_t* ManualAuthAesReqData::release_clientcheckdat() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthAesReqData.Clientcheckdat)
  clear_has_clientcheckdat();
  ::micromsg::SKBuiltinBuffer_t* temp = clientcheckdat_;
  clientcheckdat_ = NULL;
  return temp;
}
inline void ManualAuthAesReqData::set_allocated_clientcheckdat(::micromsg::SKBuiltinBuffer_t* clientcheckdat) {
  delete clientcheckdat_;
  clientcheckdat_ = clientcheckdat;
  if (clientcheckdat) {
    set_has_clientcheckdat();
  } else {
    clear_has_clientcheckdat();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthAesReqData.Clientcheckdat)
}

// -------------------------------------------------------------------

// ManualAuthRequest

// required .micromsg.ManualAuthRsaReqData RsaReqData = 1;
inline bool ManualAuthRequest::has_rsareqdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManualAuthRequest::set_has_rsareqdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManualAuthRequest::clear_has_rsareqdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManualAuthRequest::clear_rsareqdata() {
  if (rsareqdata_ != NULL) rsareqdata_->::micromsg::ManualAuthRsaReqData::Clear();
  clear_has_rsareqdata();
}
inline const ::micromsg::ManualAuthRsaReqData& ManualAuthRequest::rsareqdata() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthRequest.RsaReqData)
  return rsareqdata_ != NULL ? *rsareqdata_
                         : *::micromsg::ManualAuthRsaReqData::internal_default_instance();
}
inline ::micromsg::ManualAuthRsaReqData* ManualAuthRequest::mutable_rsareqdata() {
  set_has_rsareqdata();
  if (rsareqdata_ == NULL) {
    rsareqdata_ = new ::micromsg::ManualAuthRsaReqData;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthRequest.RsaReqData)
  return rsareqdata_;
}
inline ::micromsg::ManualAuthRsaReqData* ManualAuthRequest::release_rsareqdata() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthRequest.RsaReqData)
  clear_has_rsareqdata();
  ::micromsg::ManualAuthRsaReqData* temp = rsareqdata_;
  rsareqdata_ = NULL;
  return temp;
}
inline void ManualAuthRequest::set_allocated_rsareqdata(::micromsg::ManualAuthRsaReqData* rsareqdata) {
  delete rsareqdata_;
  rsareqdata_ = rsareqdata;
  if (rsareqdata) {
    set_has_rsareqdata();
  } else {
    clear_has_rsareqdata();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthRequest.RsaReqData)
}

// required .micromsg.ManualAuthAesReqData AesReqData = 2;
inline bool ManualAuthRequest::has_aesreqdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManualAuthRequest::set_has_aesreqdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManualAuthRequest::clear_has_aesreqdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManualAuthRequest::clear_aesreqdata() {
  if (aesreqdata_ != NULL) aesreqdata_->::micromsg::ManualAuthAesReqData::Clear();
  clear_has_aesreqdata();
}
inline const ::micromsg::ManualAuthAesReqData& ManualAuthRequest::aesreqdata() const {
  // @@protoc_insertion_point(field_get:micromsg.ManualAuthRequest.AesReqData)
  return aesreqdata_ != NULL ? *aesreqdata_
                         : *::micromsg::ManualAuthAesReqData::internal_default_instance();
}
inline ::micromsg::ManualAuthAesReqData* ManualAuthRequest::mutable_aesreqdata() {
  set_has_aesreqdata();
  if (aesreqdata_ == NULL) {
    aesreqdata_ = new ::micromsg::ManualAuthAesReqData;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.ManualAuthRequest.AesReqData)
  return aesreqdata_;
}
inline ::micromsg::ManualAuthAesReqData* ManualAuthRequest::release_aesreqdata() {
  // @@protoc_insertion_point(field_release:micromsg.ManualAuthRequest.AesReqData)
  clear_has_aesreqdata();
  ::micromsg::ManualAuthAesReqData* temp = aesreqdata_;
  aesreqdata_ = NULL;
  return temp;
}
inline void ManualAuthRequest::set_allocated_aesreqdata(::micromsg::ManualAuthAesReqData* aesreqdata) {
  delete aesreqdata_;
  aesreqdata_ = aesreqdata;
  if (aesreqdata) {
    set_has_aesreqdata();
  } else {
    clear_has_aesreqdata();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.ManualAuthRequest.AesReqData)
}

// -------------------------------------------------------------------

// AutoAuthRsaReqData

// required .micromsg.SKBuiltinBuffer_t AesEncryptKey = 2;
inline bool AutoAuthRsaReqData::has_aesencryptkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoAuthRsaReqData::set_has_aesencryptkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoAuthRsaReqData::clear_has_aesencryptkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoAuthRsaReqData::clear_aesencryptkey() {
  if (aesencryptkey_ != NULL) aesencryptkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_aesencryptkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& AutoAuthRsaReqData::aesencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthRsaReqData.AesEncryptKey)
  return aesencryptkey_ != NULL ? *aesencryptkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AutoAuthRsaReqData::mutable_aesencryptkey() {
  set_has_aesencryptkey();
  if (aesencryptkey_ == NULL) {
    aesencryptkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthRsaReqData.AesEncryptKey)
  return aesencryptkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* AutoAuthRsaReqData::release_aesencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthRsaReqData.AesEncryptKey)
  clear_has_aesencryptkey();
  ::micromsg::SKBuiltinBuffer_t* temp = aesencryptkey_;
  aesencryptkey_ = NULL;
  return temp;
}
inline void AutoAuthRsaReqData::set_allocated_aesencryptkey(::micromsg::SKBuiltinBuffer_t* aesencryptkey) {
  delete aesencryptkey_;
  aesencryptkey_ = aesencryptkey;
  if (aesencryptkey) {
    set_has_aesencryptkey();
  } else {
    clear_has_aesencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthRsaReqData.AesEncryptKey)
}

// optional .micromsg.ECDHKey CliPubECDHKey = 3;
inline bool AutoAuthRsaReqData::has_clipubecdhkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutoAuthRsaReqData::set_has_clipubecdhkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutoAuthRsaReqData::clear_has_clipubecdhkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutoAuthRsaReqData::clear_clipubecdhkey() {
  if (clipubecdhkey_ != NULL) clipubecdhkey_->::micromsg::ECDHKey::Clear();
  clear_has_clipubecdhkey();
}
inline const ::micromsg::ECDHKey& AutoAuthRsaReqData::clipubecdhkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthRsaReqData.CliPubECDHKey)
  return clipubecdhkey_ != NULL ? *clipubecdhkey_
                         : *::micromsg::ECDHKey::internal_default_instance();
}
inline ::micromsg::ECDHKey* AutoAuthRsaReqData::mutable_clipubecdhkey() {
  set_has_clipubecdhkey();
  if (clipubecdhkey_ == NULL) {
    clipubecdhkey_ = new ::micromsg::ECDHKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthRsaReqData.CliPubECDHKey)
  return clipubecdhkey_;
}
inline ::micromsg::ECDHKey* AutoAuthRsaReqData::release_clipubecdhkey() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthRsaReqData.CliPubECDHKey)
  clear_has_clipubecdhkey();
  ::micromsg::ECDHKey* temp = clipubecdhkey_;
  clipubecdhkey_ = NULL;
  return temp;
}
inline void AutoAuthRsaReqData::set_allocated_clipubecdhkey(::micromsg::ECDHKey* clipubecdhkey) {
  delete clipubecdhkey_;
  clipubecdhkey_ = clipubecdhkey;
  if (clipubecdhkey) {
    set_has_clipubecdhkey();
  } else {
    clear_has_clipubecdhkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthRsaReqData.CliPubECDHKey)
}

// -------------------------------------------------------------------

// AutoAuthKey

// required .micromsg.SKBuiltinBuffer_t EncryptKey = 1;
inline bool AutoAuthKey::has_encryptkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoAuthKey::set_has_encryptkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoAuthKey::clear_has_encryptkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoAuthKey::clear_encryptkey() {
  if (encryptkey_ != NULL) encryptkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_encryptkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& AutoAuthKey::encryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthKey.EncryptKey)
  return encryptkey_ != NULL ? *encryptkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AutoAuthKey::mutable_encryptkey() {
  set_has_encryptkey();
  if (encryptkey_ == NULL) {
    encryptkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthKey.EncryptKey)
  return encryptkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* AutoAuthKey::release_encryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthKey.EncryptKey)
  clear_has_encryptkey();
  ::micromsg::SKBuiltinBuffer_t* temp = encryptkey_;
  encryptkey_ = NULL;
  return temp;
}
inline void AutoAuthKey::set_allocated_encryptkey(::micromsg::SKBuiltinBuffer_t* encryptkey) {
  delete encryptkey_;
  encryptkey_ = encryptkey;
  if (encryptkey) {
    set_has_encryptkey();
  } else {
    clear_has_encryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthKey.EncryptKey)
}

// required .micromsg.SKBuiltinBuffer_t Key = 2;
inline bool AutoAuthKey::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutoAuthKey::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutoAuthKey::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutoAuthKey::clear_key() {
  if (key_ != NULL) key_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_key();
}
inline const ::micromsg::SKBuiltinBuffer_t& AutoAuthKey::key() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthKey.Key)
  return key_ != NULL ? *key_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AutoAuthKey::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    key_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthKey.Key)
  return key_;
}
inline ::micromsg::SKBuiltinBuffer_t* AutoAuthKey::release_key() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthKey.Key)
  clear_has_key();
  ::micromsg::SKBuiltinBuffer_t* temp = key_;
  key_ = NULL;
  return temp;
}
inline void AutoAuthKey::set_allocated_key(::micromsg::SKBuiltinBuffer_t* key) {
  delete key_;
  key_ = key;
  if (key) {
    set_has_key();
  } else {
    clear_has_key();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthKey.Key)
}

// -------------------------------------------------------------------

// AutoAuthAesReqData

// required .micromsg.BaseRequest BaseRequest = 1;
inline bool AutoAuthAesReqData::has_baserequest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AutoAuthAesReqData::set_has_baserequest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AutoAuthAesReqData::clear_has_baserequest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AutoAuthAesReqData::clear_baserequest() {
  if (baserequest_ != NULL) baserequest_->::micromsg::BaseRequest::Clear();
  clear_has_baserequest();
}
inline const ::micromsg::BaseRequest& AutoAuthAesReqData::baserequest() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.BaseRequest)
  return baserequest_ != NULL ? *baserequest_
                         : *::micromsg::BaseRequest::internal_default_instance();
}
inline ::micromsg::BaseRequest* AutoAuthAesReqData::mutable_baserequest() {
  set_has_baserequest();
  if (baserequest_ == NULL) {
    baserequest_ = new ::micromsg::BaseRequest;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.BaseRequest)
  return baserequest_;
}
inline ::micromsg::BaseRequest* AutoAuthAesReqData::release_baserequest() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.BaseRequest)
  clear_has_baserequest();
  ::micromsg::BaseRequest* temp = baserequest_;
  baserequest_ = NULL;
  return temp;
}
inline void AutoAuthAesReqData::set_allocated_baserequest(::micromsg::BaseRequest* baserequest) {
  delete baserequest_;
  baserequest_ = baserequest;
  if (baserequest) {
    set_has_baserequest();
  } else {
    clear_has_baserequest();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.BaseRequest)
}

// optional .micromsg.BaseAuthReqInfo BaseReqInfo = 2;
inline bool AutoAuthAesReqData::has_basereqinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AutoAuthAesReqData::set_has_basereqinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AutoAuthAesReqData::clear_has_basereqinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AutoAuthAesReqData::clear_basereqinfo() {
  if (basereqinfo_ != NULL) basereqinfo_->::micromsg::BaseAuthReqInfo::Clear();
  clear_has_basereqinfo();
}
inline const ::micromsg::BaseAuthReqInfo& AutoAuthAesReqData::basereqinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.BaseReqInfo)
  return basereqinfo_ != NULL ? *basereqinfo_
                         : *::micromsg::BaseAuthReqInfo::internal_default_instance();
}
inline ::micromsg::BaseAuthReqInfo* AutoAuthAesReqData::mutable_basereqinfo() {
  set_has_basereqinfo();
  if (basereqinfo_ == NULL) {
    basereqinfo_ = new ::micromsg::BaseAuthReqInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.BaseReqInfo)
  return basereqinfo_;
}
inline ::micromsg::BaseAuthReqInfo* AutoAuthAesReqData::release_basereqinfo() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.BaseReqInfo)
  clear_has_basereqinfo();
  ::micromsg::BaseAuthReqInfo* temp = basereqinfo_;
  basereqinfo_ = NULL;
  return temp;
}
inline void AutoAuthAesReqData::set_allocated_basereqinfo(::micromsg::BaseAuthReqInfo* basereqinfo) {
  delete basereqinfo_;
  basereqinfo_ = basereqinfo;
  if (basereqinfo) {
    set_has_basereqinfo();
  } else {
    clear_has_basereqinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.BaseReqInfo)
}

// required .micromsg.SKBuiltinBuffer_t AutoAuthKey = 3;
inline bool AutoAuthAesReqData::has_autoauthkey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AutoAuthAesReqData::set_has_autoauthkey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AutoAuthAesReqData::clear_has_autoauthkey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AutoAuthAesReqData::clear_autoauthkey() {
  if (autoauthkey_ != NULL) autoauthkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_autoauthkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& AutoAuthAesReqData::autoauthkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.AutoAuthKey)
  return autoauthkey_ != NULL ? *autoauthkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AutoAuthAesReqData::mutable_autoauthkey() {
  set_has_autoauthkey();
  if (autoauthkey_ == NULL) {
    autoauthkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.AutoAuthKey)
  return autoauthkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* AutoAuthAesReqData::release_autoauthkey() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.AutoAuthKey)
  clear_has_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* temp = autoauthkey_;
  autoauthkey_ = NULL;
  return temp;
}
inline void AutoAuthAesReqData::set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey) {
  delete autoauthkey_;
  autoauthkey_ = autoauthkey;
  if (autoauthkey) {
    set_has_autoauthkey();
  } else {
    clear_has_autoauthkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.AutoAuthKey)
}

// optional string IMEI = 4;
inline bool AutoAuthAesReqData::has_imei() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoAuthAesReqData::set_has_imei() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoAuthAesReqData::clear_has_imei() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoAuthAesReqData::clear_imei() {
  imei_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_imei();
}
inline const ::std::string& AutoAuthAesReqData::imei() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.IMEI)
  return imei_.GetNoArena();
}
inline void AutoAuthAesReqData::set_imei(const ::std::string& value) {
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AutoAuthAesReqData.IMEI)
}
#if LANG_CXX11
inline void AutoAuthAesReqData::set_imei(::std::string&& value) {
  set_has_imei();
  imei_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AutoAuthAesReqData.IMEI)
}
#endif
inline void AutoAuthAesReqData::set_imei(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AutoAuthAesReqData.IMEI)
}
inline void AutoAuthAesReqData::set_imei(const char* value, size_t size) {
  set_has_imei();
  imei_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AutoAuthAesReqData.IMEI)
}
inline ::std::string* AutoAuthAesReqData::mutable_imei() {
  set_has_imei();
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.IMEI)
  return imei_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutoAuthAesReqData::release_imei() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.IMEI)
  clear_has_imei();
  return imei_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoAuthAesReqData::set_allocated_imei(::std::string* imei) {
  if (imei != NULL) {
    set_has_imei();
  } else {
    clear_has_imei();
  }
  imei_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), imei);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.IMEI)
}

// optional string SoftType = 5;
inline bool AutoAuthAesReqData::has_softtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutoAuthAesReqData::set_has_softtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutoAuthAesReqData::clear_has_softtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutoAuthAesReqData::clear_softtype() {
  softtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_softtype();
}
inline const ::std::string& AutoAuthAesReqData::softtype() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.SoftType)
  return softtype_.GetNoArena();
}
inline void AutoAuthAesReqData::set_softtype(const ::std::string& value) {
  set_has_softtype();
  softtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AutoAuthAesReqData.SoftType)
}
#if LANG_CXX11
inline void AutoAuthAesReqData::set_softtype(::std::string&& value) {
  set_has_softtype();
  softtype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AutoAuthAesReqData.SoftType)
}
#endif
inline void AutoAuthAesReqData::set_softtype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_softtype();
  softtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AutoAuthAesReqData.SoftType)
}
inline void AutoAuthAesReqData::set_softtype(const char* value, size_t size) {
  set_has_softtype();
  softtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AutoAuthAesReqData.SoftType)
}
inline ::std::string* AutoAuthAesReqData::mutable_softtype() {
  set_has_softtype();
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.SoftType)
  return softtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutoAuthAesReqData::release_softtype() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.SoftType)
  clear_has_softtype();
  return softtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoAuthAesReqData::set_allocated_softtype(::std::string* softtype) {
  if (softtype != NULL) {
    set_has_softtype();
  } else {
    clear_has_softtype();
  }
  softtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), softtype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.SoftType)
}

// required uint32 BuiltinIPSeq = 6;
inline bool AutoAuthAesReqData::has_builtinipseq() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AutoAuthAesReqData::set_has_builtinipseq() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AutoAuthAesReqData::clear_has_builtinipseq() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AutoAuthAesReqData::clear_builtinipseq() {
  builtinipseq_ = 0u;
  clear_has_builtinipseq();
}
inline ::google::protobuf::uint32 AutoAuthAesReqData::builtinipseq() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.BuiltinIPSeq)
  return builtinipseq_;
}
inline void AutoAuthAesReqData::set_builtinipseq(::google::protobuf::uint32 value) {
  set_has_builtinipseq();
  builtinipseq_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AutoAuthAesReqData.BuiltinIPSeq)
}

// optional string ClientSeqID = 7;
inline bool AutoAuthAesReqData::has_clientseqid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutoAuthAesReqData::set_has_clientseqid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AutoAuthAesReqData::clear_has_clientseqid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AutoAuthAesReqData::clear_clientseqid() {
  clientseqid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_clientseqid();
}
inline const ::std::string& AutoAuthAesReqData::clientseqid() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.ClientSeqID)
  return clientseqid_.GetNoArena();
}
inline void AutoAuthAesReqData::set_clientseqid(const ::std::string& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AutoAuthAesReqData.ClientSeqID)
}
#if LANG_CXX11
inline void AutoAuthAesReqData::set_clientseqid(::std::string&& value) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AutoAuthAesReqData.ClientSeqID)
}
#endif
inline void AutoAuthAesReqData::set_clientseqid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AutoAuthAesReqData.ClientSeqID)
}
inline void AutoAuthAesReqData::set_clientseqid(const char* value, size_t size) {
  set_has_clientseqid();
  clientseqid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AutoAuthAesReqData.ClientSeqID)
}
inline ::std::string* AutoAuthAesReqData::mutable_clientseqid() {
  set_has_clientseqid();
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.ClientSeqID)
  return clientseqid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutoAuthAesReqData::release_clientseqid() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.ClientSeqID)
  clear_has_clientseqid();
  return clientseqid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoAuthAesReqData::set_allocated_clientseqid(::std::string* clientseqid) {
  if (clientseqid != NULL) {
    set_has_clientseqid();
  } else {
    clear_has_clientseqid();
  }
  clientseqid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), clientseqid);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.ClientSeqID)
}

// optional string Signature = 8;
inline bool AutoAuthAesReqData::has_signature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AutoAuthAesReqData::set_has_signature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AutoAuthAesReqData::clear_has_signature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AutoAuthAesReqData::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& AutoAuthAesReqData::signature() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.Signature)
  return signature_.GetNoArena();
}
inline void AutoAuthAesReqData::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AutoAuthAesReqData.Signature)
}
#if LANG_CXX11
inline void AutoAuthAesReqData::set_signature(::std::string&& value) {
  set_has_signature();
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AutoAuthAesReqData.Signature)
}
#endif
inline void AutoAuthAesReqData::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AutoAuthAesReqData.Signature)
}
inline void AutoAuthAesReqData::set_signature(const char* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AutoAuthAesReqData.Signature)
}
inline ::std::string* AutoAuthAesReqData::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.Signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutoAuthAesReqData::release_signature() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.Signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoAuthAesReqData::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.Signature)
}

// optional string DeviceName = 9;
inline bool AutoAuthAesReqData::has_devicename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AutoAuthAesReqData::set_has_devicename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AutoAuthAesReqData::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AutoAuthAesReqData::clear_devicename() {
  devicename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicename();
}
inline const ::std::string& AutoAuthAesReqData::devicename() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.DeviceName)
  return devicename_.GetNoArena();
}
inline void AutoAuthAesReqData::set_devicename(const ::std::string& value) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AutoAuthAesReqData.DeviceName)
}
#if LANG_CXX11
inline void AutoAuthAesReqData::set_devicename(::std::string&& value) {
  set_has_devicename();
  devicename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AutoAuthAesReqData.DeviceName)
}
#endif
inline void AutoAuthAesReqData::set_devicename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AutoAuthAesReqData.DeviceName)
}
inline void AutoAuthAesReqData::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  devicename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AutoAuthAesReqData.DeviceName)
}
inline ::std::string* AutoAuthAesReqData::mutable_devicename() {
  set_has_devicename();
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.DeviceName)
  return devicename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutoAuthAesReqData::release_devicename() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.DeviceName)
  clear_has_devicename();
  return devicename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoAuthAesReqData::set_allocated_devicename(::std::string* devicename) {
  if (devicename != NULL) {
    set_has_devicename();
  } else {
    clear_has_devicename();
  }
  devicename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicename);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.DeviceName)
}

// optional string DeviceType = 10;
inline bool AutoAuthAesReqData::has_devicetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AutoAuthAesReqData::set_has_devicetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AutoAuthAesReqData::clear_has_devicetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AutoAuthAesReqData::clear_devicetype() {
  devicetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_devicetype();
}
inline const ::std::string& AutoAuthAesReqData::devicetype() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.DeviceType)
  return devicetype_.GetNoArena();
}
inline void AutoAuthAesReqData::set_devicetype(const ::std::string& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AutoAuthAesReqData.DeviceType)
}
#if LANG_CXX11
inline void AutoAuthAesReqData::set_devicetype(::std::string&& value) {
  set_has_devicetype();
  devicetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AutoAuthAesReqData.DeviceType)
}
#endif
inline void AutoAuthAesReqData::set_devicetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AutoAuthAesReqData.DeviceType)
}
inline void AutoAuthAesReqData::set_devicetype(const char* value, size_t size) {
  set_has_devicetype();
  devicetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AutoAuthAesReqData.DeviceType)
}
inline ::std::string* AutoAuthAesReqData::mutable_devicetype() {
  set_has_devicetype();
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.DeviceType)
  return devicetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutoAuthAesReqData::release_devicetype() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.DeviceType)
  clear_has_devicetype();
  return devicetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoAuthAesReqData::set_allocated_devicetype(::std::string* devicetype) {
  if (devicetype != NULL) {
    set_has_devicetype();
  } else {
    clear_has_devicetype();
  }
  devicetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), devicetype);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.DeviceType)
}

// optional string Language = 11;
inline bool AutoAuthAesReqData::has_language() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AutoAuthAesReqData::set_has_language() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AutoAuthAesReqData::clear_has_language() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AutoAuthAesReqData::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& AutoAuthAesReqData::language() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.Language)
  return language_.GetNoArena();
}
inline void AutoAuthAesReqData::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AutoAuthAesReqData.Language)
}
#if LANG_CXX11
inline void AutoAuthAesReqData::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AutoAuthAesReqData.Language)
}
#endif
inline void AutoAuthAesReqData::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AutoAuthAesReqData.Language)
}
inline void AutoAuthAesReqData::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AutoAuthAesReqData.Language)
}
inline ::std::string* AutoAuthAesReqData::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.Language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutoAuthAesReqData::release_language() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.Language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoAuthAesReqData::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.Language)
}

// optional string TimeZone = 12;
inline bool AutoAuthAesReqData::has_timezone() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AutoAuthAesReqData::set_has_timezone() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AutoAuthAesReqData::clear_has_timezone() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AutoAuthAesReqData::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_timezone();
}
inline const ::std::string& AutoAuthAesReqData::timezone() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthAesReqData.TimeZone)
  return timezone_.GetNoArena();
}
inline void AutoAuthAesReqData::set_timezone(const ::std::string& value) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AutoAuthAesReqData.TimeZone)
}
#if LANG_CXX11
inline void AutoAuthAesReqData::set_timezone(::std::string&& value) {
  set_has_timezone();
  timezone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AutoAuthAesReqData.TimeZone)
}
#endif
inline void AutoAuthAesReqData::set_timezone(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AutoAuthAesReqData.TimeZone)
}
inline void AutoAuthAesReqData::set_timezone(const char* value, size_t size) {
  set_has_timezone();
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AutoAuthAesReqData.TimeZone)
}
inline ::std::string* AutoAuthAesReqData::mutable_timezone() {
  set_has_timezone();
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthAesReqData.TimeZone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutoAuthAesReqData::release_timezone() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthAesReqData.TimeZone)
  clear_has_timezone();
  return timezone_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoAuthAesReqData::set_allocated_timezone(::std::string* timezone) {
  if (timezone != NULL) {
    set_has_timezone();
  } else {
    clear_has_timezone();
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthAesReqData.TimeZone)
}

// -------------------------------------------------------------------

// AutoAuthRequest

// required .micromsg.AutoAuthRsaReqData RsaReqData = 1;
inline bool AutoAuthRequest::has_rsareqdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoAuthRequest::set_has_rsareqdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoAuthRequest::clear_has_rsareqdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoAuthRequest::clear_rsareqdata() {
  if (rsareqdata_ != NULL) rsareqdata_->::micromsg::AutoAuthRsaReqData::Clear();
  clear_has_rsareqdata();
}
inline const ::micromsg::AutoAuthRsaReqData& AutoAuthRequest::rsareqdata() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthRequest.RsaReqData)
  return rsareqdata_ != NULL ? *rsareqdata_
                         : *::micromsg::AutoAuthRsaReqData::internal_default_instance();
}
inline ::micromsg::AutoAuthRsaReqData* AutoAuthRequest::mutable_rsareqdata() {
  set_has_rsareqdata();
  if (rsareqdata_ == NULL) {
    rsareqdata_ = new ::micromsg::AutoAuthRsaReqData;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthRequest.RsaReqData)
  return rsareqdata_;
}
inline ::micromsg::AutoAuthRsaReqData* AutoAuthRequest::release_rsareqdata() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthRequest.RsaReqData)
  clear_has_rsareqdata();
  ::micromsg::AutoAuthRsaReqData* temp = rsareqdata_;
  rsareqdata_ = NULL;
  return temp;
}
inline void AutoAuthRequest::set_allocated_rsareqdata(::micromsg::AutoAuthRsaReqData* rsareqdata) {
  delete rsareqdata_;
  rsareqdata_ = rsareqdata;
  if (rsareqdata) {
    set_has_rsareqdata();
  } else {
    clear_has_rsareqdata();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthRequest.RsaReqData)
}

// required .micromsg.AutoAuthAesReqData AesReqData = 2;
inline bool AutoAuthRequest::has_aesreqdata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutoAuthRequest::set_has_aesreqdata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutoAuthRequest::clear_has_aesreqdata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutoAuthRequest::clear_aesreqdata() {
  if (aesreqdata_ != NULL) aesreqdata_->::micromsg::AutoAuthAesReqData::Clear();
  clear_has_aesreqdata();
}
inline const ::micromsg::AutoAuthAesReqData& AutoAuthRequest::aesreqdata() const {
  // @@protoc_insertion_point(field_get:micromsg.AutoAuthRequest.AesReqData)
  return aesreqdata_ != NULL ? *aesreqdata_
                         : *::micromsg::AutoAuthAesReqData::internal_default_instance();
}
inline ::micromsg::AutoAuthAesReqData* AutoAuthRequest::mutable_aesreqdata() {
  set_has_aesreqdata();
  if (aesreqdata_ == NULL) {
    aesreqdata_ = new ::micromsg::AutoAuthAesReqData;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AutoAuthRequest.AesReqData)
  return aesreqdata_;
}
inline ::micromsg::AutoAuthAesReqData* AutoAuthRequest::release_aesreqdata() {
  // @@protoc_insertion_point(field_release:micromsg.AutoAuthRequest.AesReqData)
  clear_has_aesreqdata();
  ::micromsg::AutoAuthAesReqData* temp = aesreqdata_;
  aesreqdata_ = NULL;
  return temp;
}
inline void AutoAuthRequest::set_allocated_aesreqdata(::micromsg::AutoAuthAesReqData* aesreqdata) {
  delete aesreqdata_;
  aesreqdata_ = aesreqdata;
  if (aesreqdata) {
    set_has_aesreqdata();
  } else {
    clear_has_aesreqdata();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AutoAuthRequest.AesReqData)
}

// -------------------------------------------------------------------

// NetworkSectResp

// optional .micromsg.HostList NewHostList = 1;
inline bool NetworkSectResp::has_newhostlist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkSectResp::set_has_newhostlist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkSectResp::clear_has_newhostlist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkSectResp::clear_newhostlist() {
  if (newhostlist_ != NULL) newhostlist_->::micromsg::HostList::Clear();
  clear_has_newhostlist();
}
inline const ::micromsg::HostList& NetworkSectResp::newhostlist() const {
  // @@protoc_insertion_point(field_get:micromsg.NetworkSectResp.NewHostList)
  return newhostlist_ != NULL ? *newhostlist_
                         : *::micromsg::HostList::internal_default_instance();
}
inline ::micromsg::HostList* NetworkSectResp::mutable_newhostlist() {
  set_has_newhostlist();
  if (newhostlist_ == NULL) {
    newhostlist_ = new ::micromsg::HostList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NetworkSectResp.NewHostList)
  return newhostlist_;
}
inline ::micromsg::HostList* NetworkSectResp::release_newhostlist() {
  // @@protoc_insertion_point(field_release:micromsg.NetworkSectResp.NewHostList)
  clear_has_newhostlist();
  ::micromsg::HostList* temp = newhostlist_;
  newhostlist_ = NULL;
  return temp;
}
inline void NetworkSectResp::set_allocated_newhostlist(::micromsg::HostList* newhostlist) {
  delete newhostlist_;
  newhostlist_ = newhostlist;
  if (newhostlist) {
    set_has_newhostlist();
  } else {
    clear_has_newhostlist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NetworkSectResp.NewHostList)
}

// optional .micromsg.NetworkControl NetworkControl = 2;
inline bool NetworkSectResp::has_networkcontrol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkSectResp::set_has_networkcontrol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkSectResp::clear_has_networkcontrol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkSectResp::clear_networkcontrol() {
  if (networkcontrol_ != NULL) networkcontrol_->::micromsg::NetworkControl::Clear();
  clear_has_networkcontrol();
}
inline const ::micromsg::NetworkControl& NetworkSectResp::networkcontrol() const {
  // @@protoc_insertion_point(field_get:micromsg.NetworkSectResp.NetworkControl)
  return networkcontrol_ != NULL ? *networkcontrol_
                         : *::micromsg::NetworkControl::internal_default_instance();
}
inline ::micromsg::NetworkControl* NetworkSectResp::mutable_networkcontrol() {
  set_has_networkcontrol();
  if (networkcontrol_ == NULL) {
    networkcontrol_ = new ::micromsg::NetworkControl;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NetworkSectResp.NetworkControl)
  return networkcontrol_;
}
inline ::micromsg::NetworkControl* NetworkSectResp::release_networkcontrol() {
  // @@protoc_insertion_point(field_release:micromsg.NetworkSectResp.NetworkControl)
  clear_has_networkcontrol();
  ::micromsg::NetworkControl* temp = networkcontrol_;
  networkcontrol_ = NULL;
  return temp;
}
inline void NetworkSectResp::set_allocated_networkcontrol(::micromsg::NetworkControl* networkcontrol) {
  delete networkcontrol_;
  networkcontrol_ = networkcontrol;
  if (networkcontrol) {
    set_has_networkcontrol();
  } else {
    clear_has_networkcontrol();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NetworkSectResp.NetworkControl)
}

// optional .micromsg.BuiltinIPList BuiltinIPList = 3;
inline bool NetworkSectResp::has_builtiniplist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkSectResp::set_has_builtiniplist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkSectResp::clear_has_builtiniplist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkSectResp::clear_builtiniplist() {
  if (builtiniplist_ != NULL) builtiniplist_->::micromsg::BuiltinIPList::Clear();
  clear_has_builtiniplist();
}
inline const ::micromsg::BuiltinIPList& NetworkSectResp::builtiniplist() const {
  // @@protoc_insertion_point(field_get:micromsg.NetworkSectResp.BuiltinIPList)
  return builtiniplist_ != NULL ? *builtiniplist_
                         : *::micromsg::BuiltinIPList::internal_default_instance();
}
inline ::micromsg::BuiltinIPList* NetworkSectResp::mutable_builtiniplist() {
  set_has_builtiniplist();
  if (builtiniplist_ == NULL) {
    builtiniplist_ = new ::micromsg::BuiltinIPList;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.NetworkSectResp.BuiltinIPList)
  return builtiniplist_;
}
inline ::micromsg::BuiltinIPList* NetworkSectResp::release_builtiniplist() {
  // @@protoc_insertion_point(field_release:micromsg.NetworkSectResp.BuiltinIPList)
  clear_has_builtiniplist();
  ::micromsg::BuiltinIPList* temp = builtiniplist_;
  builtiniplist_ = NULL;
  return temp;
}
inline void NetworkSectResp::set_allocated_builtiniplist(::micromsg::BuiltinIPList* builtiniplist) {
  delete builtiniplist_;
  builtiniplist_ = builtiniplist;
  if (builtiniplist) {
    set_has_builtiniplist();
  } else {
    clear_has_builtiniplist();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.NetworkSectResp.BuiltinIPList)
}

// -------------------------------------------------------------------

// AuthSectResp

// required uint32 Uin = 1;
inline bool AuthSectResp::has_uin() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AuthSectResp::set_has_uin() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AuthSectResp::clear_has_uin() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AuthSectResp::clear_uin() {
  uin_ = 0u;
  clear_has_uin();
}
inline ::google::protobuf::uint32 AuthSectResp::uin() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.Uin)
  return uin_;
}
inline void AuthSectResp::set_uin(::google::protobuf::uint32 value) {
  set_has_uin();
  uin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AuthSectResp.Uin)
}

// required .micromsg.ECDHKey SvrPubECDHKey = 2;
inline bool AuthSectResp::has_svrpubecdhkey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AuthSectResp::set_has_svrpubecdhkey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AuthSectResp::clear_has_svrpubecdhkey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AuthSectResp::clear_svrpubecdhkey() {
  if (svrpubecdhkey_ != NULL) svrpubecdhkey_->::micromsg::ECDHKey::Clear();
  clear_has_svrpubecdhkey();
}
inline const ::micromsg::ECDHKey& AuthSectResp::svrpubecdhkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.SvrPubECDHKey)
  return svrpubecdhkey_ != NULL ? *svrpubecdhkey_
                         : *::micromsg::ECDHKey::internal_default_instance();
}
inline ::micromsg::ECDHKey* AuthSectResp::mutable_svrpubecdhkey() {
  set_has_svrpubecdhkey();
  if (svrpubecdhkey_ == NULL) {
    svrpubecdhkey_ = new ::micromsg::ECDHKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.SvrPubECDHKey)
  return svrpubecdhkey_;
}
inline ::micromsg::ECDHKey* AuthSectResp::release_svrpubecdhkey() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.SvrPubECDHKey)
  clear_has_svrpubecdhkey();
  ::micromsg::ECDHKey* temp = svrpubecdhkey_;
  svrpubecdhkey_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_svrpubecdhkey(::micromsg::ECDHKey* svrpubecdhkey) {
  delete svrpubecdhkey_;
  svrpubecdhkey_ = svrpubecdhkey;
  if (svrpubecdhkey) {
    set_has_svrpubecdhkey();
  } else {
    clear_has_svrpubecdhkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.SvrPubECDHKey)
}

// required .micromsg.SKBuiltinBuffer_t SessionKey = 3;
inline bool AuthSectResp::has_sessionkey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AuthSectResp::set_has_sessionkey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AuthSectResp::clear_has_sessionkey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AuthSectResp::clear_sessionkey() {
  if (sessionkey_ != NULL) sessionkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_sessionkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& AuthSectResp::sessionkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.SessionKey)
  return sessionkey_ != NULL ? *sessionkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::mutable_sessionkey() {
  set_has_sessionkey();
  if (sessionkey_ == NULL) {
    sessionkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.SessionKey)
  return sessionkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::release_sessionkey() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.SessionKey)
  clear_has_sessionkey();
  ::micromsg::SKBuiltinBuffer_t* temp = sessionkey_;
  sessionkey_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_sessionkey(::micromsg::SKBuiltinBuffer_t* sessionkey) {
  delete sessionkey_;
  sessionkey_ = sessionkey;
  if (sessionkey) {
    set_has_sessionkey();
  } else {
    clear_has_sessionkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.SessionKey)
}

// required .micromsg.SKBuiltinBuffer_t AutoAuthKey = 4;
inline bool AuthSectResp::has_autoauthkey() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AuthSectResp::set_has_autoauthkey() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AuthSectResp::clear_has_autoauthkey() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AuthSectResp::clear_autoauthkey() {
  if (autoauthkey_ != NULL) autoauthkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_autoauthkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& AuthSectResp::autoauthkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.AutoAuthKey)
  return autoauthkey_ != NULL ? *autoauthkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::mutable_autoauthkey() {
  set_has_autoauthkey();
  if (autoauthkey_ == NULL) {
    autoauthkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.AutoAuthKey)
  return autoauthkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::release_autoauthkey() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.AutoAuthKey)
  clear_has_autoauthkey();
  ::micromsg::SKBuiltinBuffer_t* temp = autoauthkey_;
  autoauthkey_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_autoauthkey(::micromsg::SKBuiltinBuffer_t* autoauthkey) {
  delete autoauthkey_;
  autoauthkey_ = autoauthkey;
  if (autoauthkey) {
    set_has_autoauthkey();
  } else {
    clear_has_autoauthkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.AutoAuthKey)
}

// required uint32 WTLoginRspBuffFlag = 5;
inline bool AuthSectResp::has_wtloginrspbuffflag() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void AuthSectResp::set_has_wtloginrspbuffflag() {
  _has_bits_[0] |= 0x00008000u;
}
inline void AuthSectResp::clear_has_wtloginrspbuffflag() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void AuthSectResp::clear_wtloginrspbuffflag() {
  wtloginrspbuffflag_ = 0u;
  clear_has_wtloginrspbuffflag();
}
inline ::google::protobuf::uint32 AuthSectResp::wtloginrspbuffflag() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.WTLoginRspBuffFlag)
  return wtloginrspbuffflag_;
}
inline void AuthSectResp::set_wtloginrspbuffflag(::google::protobuf::uint32 value) {
  set_has_wtloginrspbuffflag();
  wtloginrspbuffflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AuthSectResp.WTLoginRspBuffFlag)
}

// optional .micromsg.SKBuiltinBuffer_t WTLoginRspBuff = 6;
inline bool AuthSectResp::has_wtloginrspbuff() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AuthSectResp::set_has_wtloginrspbuff() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AuthSectResp::clear_has_wtloginrspbuff() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AuthSectResp::clear_wtloginrspbuff() {
  if (wtloginrspbuff_ != NULL) wtloginrspbuff_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_wtloginrspbuff();
}
inline const ::micromsg::SKBuiltinBuffer_t& AuthSectResp::wtloginrspbuff() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.WTLoginRspBuff)
  return wtloginrspbuff_ != NULL ? *wtloginrspbuff_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::mutable_wtloginrspbuff() {
  set_has_wtloginrspbuff();
  if (wtloginrspbuff_ == NULL) {
    wtloginrspbuff_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.WTLoginRspBuff)
  return wtloginrspbuff_;
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::release_wtloginrspbuff() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.WTLoginRspBuff)
  clear_has_wtloginrspbuff();
  ::micromsg::SKBuiltinBuffer_t* temp = wtloginrspbuff_;
  wtloginrspbuff_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_wtloginrspbuff(::micromsg::SKBuiltinBuffer_t* wtloginrspbuff) {
  delete wtloginrspbuff_;
  wtloginrspbuff_ = wtloginrspbuff;
  if (wtloginrspbuff) {
    set_has_wtloginrspbuff();
  } else {
    clear_has_wtloginrspbuff();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.WTLoginRspBuff)
}

// optional .micromsg.WTLoginImgRespInfo WTLoginImgRespInfo = 7;
inline bool AuthSectResp::has_wtloginimgrespinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AuthSectResp::set_has_wtloginimgrespinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AuthSectResp::clear_has_wtloginimgrespinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AuthSectResp::clear_wtloginimgrespinfo() {
  if (wtloginimgrespinfo_ != NULL) wtloginimgrespinfo_->::micromsg::WTLoginImgRespInfo::Clear();
  clear_has_wtloginimgrespinfo();
}
inline const ::micromsg::WTLoginImgRespInfo& AuthSectResp::wtloginimgrespinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.WTLoginImgRespInfo)
  return wtloginimgrespinfo_ != NULL ? *wtloginimgrespinfo_
                         : *::micromsg::WTLoginImgRespInfo::internal_default_instance();
}
inline ::micromsg::WTLoginImgRespInfo* AuthSectResp::mutable_wtloginimgrespinfo() {
  set_has_wtloginimgrespinfo();
  if (wtloginimgrespinfo_ == NULL) {
    wtloginimgrespinfo_ = new ::micromsg::WTLoginImgRespInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.WTLoginImgRespInfo)
  return wtloginimgrespinfo_;
}
inline ::micromsg::WTLoginImgRespInfo* AuthSectResp::release_wtloginimgrespinfo() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.WTLoginImgRespInfo)
  clear_has_wtloginimgrespinfo();
  ::micromsg::WTLoginImgRespInfo* temp = wtloginimgrespinfo_;
  wtloginimgrespinfo_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_wtloginimgrespinfo(::micromsg::WTLoginImgRespInfo* wtloginimgrespinfo) {
  delete wtloginimgrespinfo_;
  wtloginimgrespinfo_ = wtloginimgrespinfo;
  if (wtloginimgrespinfo) {
    set_has_wtloginimgrespinfo();
  } else {
    clear_has_wtloginimgrespinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.WTLoginImgRespInfo)
}

// optional .micromsg.WxVerifyCodeRespInfo WxVerifyCodeRespInfo = 8;
inline bool AuthSectResp::has_wxverifycoderespinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AuthSectResp::set_has_wxverifycoderespinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AuthSectResp::clear_has_wxverifycoderespinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AuthSectResp::clear_wxverifycoderespinfo() {
  if (wxverifycoderespinfo_ != NULL) wxverifycoderespinfo_->::micromsg::WxVerifyCodeRespInfo::Clear();
  clear_has_wxverifycoderespinfo();
}
inline const ::micromsg::WxVerifyCodeRespInfo& AuthSectResp::wxverifycoderespinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.WxVerifyCodeRespInfo)
  return wxverifycoderespinfo_ != NULL ? *wxverifycoderespinfo_
                         : *::micromsg::WxVerifyCodeRespInfo::internal_default_instance();
}
inline ::micromsg::WxVerifyCodeRespInfo* AuthSectResp::mutable_wxverifycoderespinfo() {
  set_has_wxverifycoderespinfo();
  if (wxverifycoderespinfo_ == NULL) {
    wxverifycoderespinfo_ = new ::micromsg::WxVerifyCodeRespInfo;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.WxVerifyCodeRespInfo)
  return wxverifycoderespinfo_;
}
inline ::micromsg::WxVerifyCodeRespInfo* AuthSectResp::release_wxverifycoderespinfo() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.WxVerifyCodeRespInfo)
  clear_has_wxverifycoderespinfo();
  ::micromsg::WxVerifyCodeRespInfo* temp = wxverifycoderespinfo_;
  wxverifycoderespinfo_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_wxverifycoderespinfo(::micromsg::WxVerifyCodeRespInfo* wxverifycoderespinfo) {
  delete wxverifycoderespinfo_;
  wxverifycoderespinfo_ = wxverifycoderespinfo;
  if (wxverifycoderespinfo) {
    set_has_wxverifycoderespinfo();
  } else {
    clear_has_wxverifycoderespinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.WxVerifyCodeRespInfo)
}

// optional .micromsg.SKBuiltinBuffer_t CliDBEncryptKey = 9;
inline bool AuthSectResp::has_clidbencryptkey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AuthSectResp::set_has_clidbencryptkey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AuthSectResp::clear_has_clidbencryptkey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AuthSectResp::clear_clidbencryptkey() {
  if (clidbencryptkey_ != NULL) clidbencryptkey_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_clidbencryptkey();
}
inline const ::micromsg::SKBuiltinBuffer_t& AuthSectResp::clidbencryptkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.CliDBEncryptKey)
  return clidbencryptkey_ != NULL ? *clidbencryptkey_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::mutable_clidbencryptkey() {
  set_has_clidbencryptkey();
  if (clidbencryptkey_ == NULL) {
    clidbencryptkey_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.CliDBEncryptKey)
  return clidbencryptkey_;
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::release_clidbencryptkey() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.CliDBEncryptKey)
  clear_has_clidbencryptkey();
  ::micromsg::SKBuiltinBuffer_t* temp = clidbencryptkey_;
  clidbencryptkey_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_clidbencryptkey(::micromsg::SKBuiltinBuffer_t* clidbencryptkey) {
  delete clidbencryptkey_;
  clidbencryptkey_ = clidbencryptkey;
  if (clidbencryptkey) {
    set_has_clidbencryptkey();
  } else {
    clear_has_clidbencryptkey();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.CliDBEncryptKey)
}

// optional .micromsg.SKBuiltinBuffer_t CliDBEncryptInfo = 10;
inline bool AuthSectResp::has_clidbencryptinfo() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AuthSectResp::set_has_clidbencryptinfo() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AuthSectResp::clear_has_clidbencryptinfo() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AuthSectResp::clear_clidbencryptinfo() {
  if (clidbencryptinfo_ != NULL) clidbencryptinfo_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_clidbencryptinfo();
}
inline const ::micromsg::SKBuiltinBuffer_t& AuthSectResp::clidbencryptinfo() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.CliDBEncryptInfo)
  return clidbencryptinfo_ != NULL ? *clidbencryptinfo_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::mutable_clidbencryptinfo() {
  set_has_clidbencryptinfo();
  if (clidbencryptinfo_ == NULL) {
    clidbencryptinfo_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.CliDBEncryptInfo)
  return clidbencryptinfo_;
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::release_clidbencryptinfo() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.CliDBEncryptInfo)
  clear_has_clidbencryptinfo();
  ::micromsg::SKBuiltinBuffer_t* temp = clidbencryptinfo_;
  clidbencryptinfo_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_clidbencryptinfo(::micromsg::SKBuiltinBuffer_t* clidbencryptinfo) {
  delete clidbencryptinfo_;
  clidbencryptinfo_ = clidbencryptinfo;
  if (clidbencryptinfo) {
    set_has_clidbencryptinfo();
  } else {
    clear_has_clidbencryptinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.CliDBEncryptInfo)
}

// optional string AuthKey = 11;
inline bool AuthSectResp::has_authkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthSectResp::set_has_authkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthSectResp::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthSectResp::clear_authkey() {
  authkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authkey();
}
inline const ::std::string& AuthSectResp::authkey() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.AuthKey)
  return authkey_.GetNoArena();
}
inline void AuthSectResp::set_authkey(const ::std::string& value) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AuthSectResp.AuthKey)
}
#if LANG_CXX11
inline void AuthSectResp::set_authkey(::std::string&& value) {
  set_has_authkey();
  authkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AuthSectResp.AuthKey)
}
#endif
inline void AuthSectResp::set_authkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AuthSectResp.AuthKey)
}
inline void AuthSectResp::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  authkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AuthSectResp.AuthKey)
}
inline ::std::string* AuthSectResp::mutable_authkey() {
  set_has_authkey();
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.AuthKey)
  return authkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthSectResp::release_authkey() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.AuthKey)
  clear_has_authkey();
  return authkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthSectResp::set_allocated_authkey(::std::string* authkey) {
  if (authkey != NULL) {
    set_has_authkey();
  } else {
    clear_has_authkey();
  }
  authkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authkey);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.AuthKey)
}

// optional .micromsg.SKBuiltinBuffer_t A2Key = 12;
inline bool AuthSectResp::has_a2key() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AuthSectResp::set_has_a2key() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AuthSectResp::clear_has_a2key() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AuthSectResp::clear_a2key() {
  if (a2key_ != NULL) a2key_->::micromsg::SKBuiltinBuffer_t::Clear();
  clear_has_a2key();
}
inline const ::micromsg::SKBuiltinBuffer_t& AuthSectResp::a2key() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.A2Key)
  return a2key_ != NULL ? *a2key_
                         : *::micromsg::SKBuiltinBuffer_t::internal_default_instance();
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::mutable_a2key() {
  set_has_a2key();
  if (a2key_ == NULL) {
    a2key_ = new ::micromsg::SKBuiltinBuffer_t;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.A2Key)
  return a2key_;
}
inline ::micromsg::SKBuiltinBuffer_t* AuthSectResp::release_a2key() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.A2Key)
  clear_has_a2key();
  ::micromsg::SKBuiltinBuffer_t* temp = a2key_;
  a2key_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_a2key(::micromsg::SKBuiltinBuffer_t* a2key) {
  delete a2key_;
  a2key_ = a2key;
  if (a2key) {
    set_has_a2key();
  } else {
    clear_has_a2key();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.A2Key)
}

// optional string ApplyBetaUrl = 14;
inline bool AuthSectResp::has_applybetaurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthSectResp::set_has_applybetaurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthSectResp::clear_has_applybetaurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthSectResp::clear_applybetaurl() {
  applybetaurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_applybetaurl();
}
inline const ::std::string& AuthSectResp::applybetaurl() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.ApplyBetaUrl)
  return applybetaurl_.GetNoArena();
}
inline void AuthSectResp::set_applybetaurl(const ::std::string& value) {
  set_has_applybetaurl();
  applybetaurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AuthSectResp.ApplyBetaUrl)
}
#if LANG_CXX11
inline void AuthSectResp::set_applybetaurl(::std::string&& value) {
  set_has_applybetaurl();
  applybetaurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AuthSectResp.ApplyBetaUrl)
}
#endif
inline void AuthSectResp::set_applybetaurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_applybetaurl();
  applybetaurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AuthSectResp.ApplyBetaUrl)
}
inline void AuthSectResp::set_applybetaurl(const char* value, size_t size) {
  set_has_applybetaurl();
  applybetaurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AuthSectResp.ApplyBetaUrl)
}
inline ::std::string* AuthSectResp::mutable_applybetaurl() {
  set_has_applybetaurl();
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.ApplyBetaUrl)
  return applybetaurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthSectResp::release_applybetaurl() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.ApplyBetaUrl)
  clear_has_applybetaurl();
  return applybetaurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthSectResp::set_allocated_applybetaurl(::std::string* applybetaurl) {
  if (applybetaurl != NULL) {
    set_has_applybetaurl();
  } else {
    clear_has_applybetaurl();
  }
  applybetaurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), applybetaurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.ApplyBetaUrl)
}

// optional .micromsg.ShowStyleKey ShowStyle = 15;
inline bool AuthSectResp::has_showstyle() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AuthSectResp::set_has_showstyle() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AuthSectResp::clear_has_showstyle() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AuthSectResp::clear_showstyle() {
  if (showstyle_ != NULL) showstyle_->::micromsg::ShowStyleKey::Clear();
  clear_has_showstyle();
}
inline const ::micromsg::ShowStyleKey& AuthSectResp::showstyle() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.ShowStyle)
  return showstyle_ != NULL ? *showstyle_
                         : *::micromsg::ShowStyleKey::internal_default_instance();
}
inline ::micromsg::ShowStyleKey* AuthSectResp::mutable_showstyle() {
  set_has_showstyle();
  if (showstyle_ == NULL) {
    showstyle_ = new ::micromsg::ShowStyleKey;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.ShowStyle)
  return showstyle_;
}
inline ::micromsg::ShowStyleKey* AuthSectResp::release_showstyle() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.ShowStyle)
  clear_has_showstyle();
  ::micromsg::ShowStyleKey* temp = showstyle_;
  showstyle_ = NULL;
  return temp;
}
inline void AuthSectResp::set_allocated_showstyle(::micromsg::ShowStyleKey* showstyle) {
  delete showstyle_;
  showstyle_ = showstyle;
  if (showstyle) {
    set_has_showstyle();
  } else {
    clear_has_showstyle();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.ShowStyle)
}

// optional string AuthTicket = 16;
inline bool AuthSectResp::has_authticket() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthSectResp::set_has_authticket() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthSectResp::clear_has_authticket() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthSectResp::clear_authticket() {
  authticket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_authticket();
}
inline const ::std::string& AuthSectResp::authticket() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.AuthTicket)
  return authticket_.GetNoArena();
}
inline void AuthSectResp::set_authticket(const ::std::string& value) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AuthSectResp.AuthTicket)
}
#if LANG_CXX11
inline void AuthSectResp::set_authticket(::std::string&& value) {
  set_has_authticket();
  authticket_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AuthSectResp.AuthTicket)
}
#endif
inline void AuthSectResp::set_authticket(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AuthSectResp.AuthTicket)
}
inline void AuthSectResp::set_authticket(const char* value, size_t size) {
  set_has_authticket();
  authticket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AuthSectResp.AuthTicket)
}
inline ::std::string* AuthSectResp::mutable_authticket() {
  set_has_authticket();
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.AuthTicket)
  return authticket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthSectResp::release_authticket() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.AuthTicket)
  clear_has_authticket();
  return authticket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthSectResp::set_allocated_authticket(::std::string* authticket) {
  if (authticket != NULL) {
    set_has_authticket();
  } else {
    clear_has_authticket();
  }
  authticket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), authticket);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.AuthTicket)
}

// optional uint32 NewVersion = 17;
inline bool AuthSectResp::has_newversion() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void AuthSectResp::set_has_newversion() {
  _has_bits_[0] |= 0x00010000u;
}
inline void AuthSectResp::clear_has_newversion() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void AuthSectResp::clear_newversion() {
  newversion_ = 0u;
  clear_has_newversion();
}
inline ::google::protobuf::uint32 AuthSectResp::newversion() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.NewVersion)
  return newversion_;
}
inline void AuthSectResp::set_newversion(::google::protobuf::uint32 value) {
  set_has_newversion();
  newversion_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AuthSectResp.NewVersion)
}

// optional uint32 UpdateFlag = 18;
inline bool AuthSectResp::has_updateflag() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void AuthSectResp::set_has_updateflag() {
  _has_bits_[0] |= 0x00020000u;
}
inline void AuthSectResp::clear_has_updateflag() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void AuthSectResp::clear_updateflag() {
  updateflag_ = 0u;
  clear_has_updateflag();
}
inline ::google::protobuf::uint32 AuthSectResp::updateflag() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.UpdateFlag)
  return updateflag_;
}
inline void AuthSectResp::set_updateflag(::google::protobuf::uint32 value) {
  set_has_updateflag();
  updateflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AuthSectResp.UpdateFlag)
}

// optional uint32 AuthResultFlag = 19;
inline bool AuthSectResp::has_authresultflag() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void AuthSectResp::set_has_authresultflag() {
  _has_bits_[0] |= 0x00040000u;
}
inline void AuthSectResp::clear_has_authresultflag() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void AuthSectResp::clear_authresultflag() {
  authresultflag_ = 0u;
  clear_has_authresultflag();
}
inline ::google::protobuf::uint32 AuthSectResp::authresultflag() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.AuthResultFlag)
  return authresultflag_;
}
inline void AuthSectResp::set_authresultflag(::google::protobuf::uint32 value) {
  set_has_authresultflag();
  authresultflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AuthSectResp.AuthResultFlag)
}

// optional string FSURL = 20;
inline bool AuthSectResp::has_fsurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuthSectResp::set_has_fsurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuthSectResp::clear_has_fsurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuthSectResp::clear_fsurl() {
  fsurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fsurl();
}
inline const ::std::string& AuthSectResp::fsurl() const {
  // @@protoc_insertion_point(field_get:micromsg.AuthSectResp.FSURL)
  return fsurl_.GetNoArena();
}
inline void AuthSectResp::set_fsurl(const ::std::string& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AuthSectResp.FSURL)
}
#if LANG_CXX11
inline void AuthSectResp::set_fsurl(::std::string&& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AuthSectResp.FSURL)
}
#endif
inline void AuthSectResp::set_fsurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AuthSectResp.FSURL)
}
inline void AuthSectResp::set_fsurl(const char* value, size_t size) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AuthSectResp.FSURL)
}
inline ::std::string* AuthSectResp::mutable_fsurl() {
  set_has_fsurl();
  // @@protoc_insertion_point(field_mutable:micromsg.AuthSectResp.FSURL)
  return fsurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthSectResp::release_fsurl() {
  // @@protoc_insertion_point(field_release:micromsg.AuthSectResp.FSURL)
  clear_has_fsurl();
  return fsurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthSectResp::set_allocated_fsurl(::std::string* fsurl) {
  if (fsurl != NULL) {
    set_has_fsurl();
  } else {
    clear_has_fsurl();
  }
  fsurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fsurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AuthSectResp.FSURL)
}

// -------------------------------------------------------------------

// AcctSectResp

// optional string UserName = 1;
inline bool AcctSectResp::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcctSectResp::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcctSectResp::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcctSectResp::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& AcctSectResp::username() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.UserName)
  return username_.GetNoArena();
}
inline void AcctSectResp::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.UserName)
}
#if LANG_CXX11
inline void AcctSectResp::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AcctSectResp.UserName)
}
#endif
inline void AcctSectResp::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AcctSectResp.UserName)
}
inline void AcctSectResp::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AcctSectResp.UserName)
}
inline ::std::string* AcctSectResp::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:micromsg.AcctSectResp.UserName)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcctSectResp::release_username() {
  // @@protoc_insertion_point(field_release:micromsg.AcctSectResp.UserName)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcctSectResp::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AcctSectResp.UserName)
}

// optional string NickName = 2;
inline bool AcctSectResp::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcctSectResp::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcctSectResp::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcctSectResp::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& AcctSectResp::nickname() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.NickName)
  return nickname_.GetNoArena();
}
inline void AcctSectResp::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.NickName)
}
#if LANG_CXX11
inline void AcctSectResp::set_nickname(::std::string&& value) {
  set_has_nickname();
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AcctSectResp.NickName)
}
#endif
inline void AcctSectResp::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AcctSectResp.NickName)
}
inline void AcctSectResp::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AcctSectResp.NickName)
}
inline ::std::string* AcctSectResp::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:micromsg.AcctSectResp.NickName)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcctSectResp::release_nickname() {
  // @@protoc_insertion_point(field_release:micromsg.AcctSectResp.NickName)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcctSectResp::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AcctSectResp.NickName)
}

// required uint32 BindUin = 3;
inline bool AcctSectResp::has_binduin() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AcctSectResp::set_has_binduin() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AcctSectResp::clear_has_binduin() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AcctSectResp::clear_binduin() {
  binduin_ = 0u;
  clear_has_binduin();
}
inline ::google::protobuf::uint32 AcctSectResp::binduin() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.BindUin)
  return binduin_;
}
inline void AcctSectResp::set_binduin(::google::protobuf::uint32 value) {
  set_has_binduin();
  binduin_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.BindUin)
}

// optional string BindEmail = 4;
inline bool AcctSectResp::has_bindemail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AcctSectResp::set_has_bindemail() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AcctSectResp::clear_has_bindemail() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AcctSectResp::clear_bindemail() {
  bindemail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bindemail();
}
inline const ::std::string& AcctSectResp::bindemail() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.BindEmail)
  return bindemail_.GetNoArena();
}
inline void AcctSectResp::set_bindemail(const ::std::string& value) {
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.BindEmail)
}
#if LANG_CXX11
inline void AcctSectResp::set_bindemail(::std::string&& value) {
  set_has_bindemail();
  bindemail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AcctSectResp.BindEmail)
}
#endif
inline void AcctSectResp::set_bindemail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AcctSectResp.BindEmail)
}
inline void AcctSectResp::set_bindemail(const char* value, size_t size) {
  set_has_bindemail();
  bindemail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AcctSectResp.BindEmail)
}
inline ::std::string* AcctSectResp::mutable_bindemail() {
  set_has_bindemail();
  // @@protoc_insertion_point(field_mutable:micromsg.AcctSectResp.BindEmail)
  return bindemail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcctSectResp::release_bindemail() {
  // @@protoc_insertion_point(field_release:micromsg.AcctSectResp.BindEmail)
  clear_has_bindemail();
  return bindemail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcctSectResp::set_allocated_bindemail(::std::string* bindemail) {
  if (bindemail != NULL) {
    set_has_bindemail();
  } else {
    clear_has_bindemail();
  }
  bindemail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bindemail);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AcctSectResp.BindEmail)
}

// optional string BindMobile = 5;
inline bool AcctSectResp::has_bindmobile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AcctSectResp::set_has_bindmobile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AcctSectResp::clear_has_bindmobile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AcctSectResp::clear_bindmobile() {
  bindmobile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bindmobile();
}
inline const ::std::string& AcctSectResp::bindmobile() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.BindMobile)
  return bindmobile_.GetNoArena();
}
inline void AcctSectResp::set_bindmobile(const ::std::string& value) {
  set_has_bindmobile();
  bindmobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.BindMobile)
}
#if LANG_CXX11
inline void AcctSectResp::set_bindmobile(::std::string&& value) {
  set_has_bindmobile();
  bindmobile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AcctSectResp.BindMobile)
}
#endif
inline void AcctSectResp::set_bindmobile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bindmobile();
  bindmobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AcctSectResp.BindMobile)
}
inline void AcctSectResp::set_bindmobile(const char* value, size_t size) {
  set_has_bindmobile();
  bindmobile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AcctSectResp.BindMobile)
}
inline ::std::string* AcctSectResp::mutable_bindmobile() {
  set_has_bindmobile();
  // @@protoc_insertion_point(field_mutable:micromsg.AcctSectResp.BindMobile)
  return bindmobile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcctSectResp::release_bindmobile() {
  // @@protoc_insertion_point(field_release:micromsg.AcctSectResp.BindMobile)
  clear_has_bindmobile();
  return bindmobile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcctSectResp::set_allocated_bindmobile(::std::string* bindmobile) {
  if (bindmobile != NULL) {
    set_has_bindmobile();
  } else {
    clear_has_bindmobile();
  }
  bindmobile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bindmobile);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AcctSectResp.BindMobile)
}

// optional string Alias = 6;
inline bool AcctSectResp::has_alias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AcctSectResp::set_has_alias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AcctSectResp::clear_has_alias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AcctSectResp::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
inline const ::std::string& AcctSectResp::alias() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.Alias)
  return alias_.GetNoArena();
}
inline void AcctSectResp::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.Alias)
}
#if LANG_CXX11
inline void AcctSectResp::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AcctSectResp.Alias)
}
#endif
inline void AcctSectResp::set_alias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AcctSectResp.Alias)
}
inline void AcctSectResp::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AcctSectResp.Alias)
}
inline ::std::string* AcctSectResp::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:micromsg.AcctSectResp.Alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcctSectResp::release_alias() {
  // @@protoc_insertion_point(field_release:micromsg.AcctSectResp.Alias)
  clear_has_alias();
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcctSectResp::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AcctSectResp.Alias)
}

// required uint32 Status = 8;
inline bool AcctSectResp::has_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AcctSectResp::set_has_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AcctSectResp::clear_has_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AcctSectResp::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 AcctSectResp::status() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.Status)
  return status_;
}
inline void AcctSectResp::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.Status)
}

// optional uint32 PluginFlag = 9;
inline bool AcctSectResp::has_pluginflag() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AcctSectResp::set_has_pluginflag() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AcctSectResp::clear_has_pluginflag() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AcctSectResp::clear_pluginflag() {
  pluginflag_ = 0u;
  clear_has_pluginflag();
}
inline ::google::protobuf::uint32 AcctSectResp::pluginflag() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.PluginFlag)
  return pluginflag_;
}
inline void AcctSectResp::set_pluginflag(::google::protobuf::uint32 value) {
  set_has_pluginflag();
  pluginflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.PluginFlag)
}

// optional uint32 RegType = 10;
inline bool AcctSectResp::has_regtype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AcctSectResp::set_has_regtype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AcctSectResp::clear_has_regtype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AcctSectResp::clear_regtype() {
  regtype_ = 0u;
  clear_has_regtype();
}
inline ::google::protobuf::uint32 AcctSectResp::regtype() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.RegType)
  return regtype_;
}
inline void AcctSectResp::set_regtype(::google::protobuf::uint32 value) {
  set_has_regtype();
  regtype_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.RegType)
}

// optional string DeviceInfoXml = 11;
inline bool AcctSectResp::has_deviceinfoxml() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AcctSectResp::set_has_deviceinfoxml() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AcctSectResp::clear_has_deviceinfoxml() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AcctSectResp::clear_deviceinfoxml() {
  deviceinfoxml_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_deviceinfoxml();
}
inline const ::std::string& AcctSectResp::deviceinfoxml() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.DeviceInfoXml)
  return deviceinfoxml_.GetNoArena();
}
inline void AcctSectResp::set_deviceinfoxml(const ::std::string& value) {
  set_has_deviceinfoxml();
  deviceinfoxml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.DeviceInfoXml)
}
#if LANG_CXX11
inline void AcctSectResp::set_deviceinfoxml(::std::string&& value) {
  set_has_deviceinfoxml();
  deviceinfoxml_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AcctSectResp.DeviceInfoXml)
}
#endif
inline void AcctSectResp::set_deviceinfoxml(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_deviceinfoxml();
  deviceinfoxml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AcctSectResp.DeviceInfoXml)
}
inline void AcctSectResp::set_deviceinfoxml(const char* value, size_t size) {
  set_has_deviceinfoxml();
  deviceinfoxml_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AcctSectResp.DeviceInfoXml)
}
inline ::std::string* AcctSectResp::mutable_deviceinfoxml() {
  set_has_deviceinfoxml();
  // @@protoc_insertion_point(field_mutable:micromsg.AcctSectResp.DeviceInfoXml)
  return deviceinfoxml_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcctSectResp::release_deviceinfoxml() {
  // @@protoc_insertion_point(field_release:micromsg.AcctSectResp.DeviceInfoXml)
  clear_has_deviceinfoxml();
  return deviceinfoxml_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcctSectResp::set_allocated_deviceinfoxml(::std::string* deviceinfoxml) {
  if (deviceinfoxml != NULL) {
    set_has_deviceinfoxml();
  } else {
    clear_has_deviceinfoxml();
  }
  deviceinfoxml_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceinfoxml);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AcctSectResp.DeviceInfoXml)
}

// optional uint32 SafeDevice = 12;
inline bool AcctSectResp::has_safedevice() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void AcctSectResp::set_has_safedevice() {
  _has_bits_[0] |= 0x00002000u;
}
inline void AcctSectResp::clear_has_safedevice() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void AcctSectResp::clear_safedevice() {
  safedevice_ = 0u;
  clear_has_safedevice();
}
inline ::google::protobuf::uint32 AcctSectResp::safedevice() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.SafeDevice)
  return safedevice_;
}
inline void AcctSectResp::set_safedevice(::google::protobuf::uint32 value) {
  set_has_safedevice();
  safedevice_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.SafeDevice)
}

// optional string OfficialUserName = 13;
inline bool AcctSectResp::has_officialusername() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AcctSectResp::set_has_officialusername() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AcctSectResp::clear_has_officialusername() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AcctSectResp::clear_officialusername() {
  officialusername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_officialusername();
}
inline const ::std::string& AcctSectResp::officialusername() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.OfficialUserName)
  return officialusername_.GetNoArena();
}
inline void AcctSectResp::set_officialusername(const ::std::string& value) {
  set_has_officialusername();
  officialusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.OfficialUserName)
}
#if LANG_CXX11
inline void AcctSectResp::set_officialusername(::std::string&& value) {
  set_has_officialusername();
  officialusername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AcctSectResp.OfficialUserName)
}
#endif
inline void AcctSectResp::set_officialusername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_officialusername();
  officialusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AcctSectResp.OfficialUserName)
}
inline void AcctSectResp::set_officialusername(const char* value, size_t size) {
  set_has_officialusername();
  officialusername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AcctSectResp.OfficialUserName)
}
inline ::std::string* AcctSectResp::mutable_officialusername() {
  set_has_officialusername();
  // @@protoc_insertion_point(field_mutable:micromsg.AcctSectResp.OfficialUserName)
  return officialusername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcctSectResp::release_officialusername() {
  // @@protoc_insertion_point(field_release:micromsg.AcctSectResp.OfficialUserName)
  clear_has_officialusername();
  return officialusername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcctSectResp::set_allocated_officialusername(::std::string* officialusername) {
  if (officialusername != NULL) {
    set_has_officialusername();
  } else {
    clear_has_officialusername();
  }
  officialusername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), officialusername);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AcctSectResp.OfficialUserName)
}

// optional string OfficialNickName = 14;
inline bool AcctSectResp::has_officialnickname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AcctSectResp::set_has_officialnickname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AcctSectResp::clear_has_officialnickname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AcctSectResp::clear_officialnickname() {
  officialnickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_officialnickname();
}
inline const ::std::string& AcctSectResp::officialnickname() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.OfficialNickName)
  return officialnickname_.GetNoArena();
}
inline void AcctSectResp::set_officialnickname(const ::std::string& value) {
  set_has_officialnickname();
  officialnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.OfficialNickName)
}
#if LANG_CXX11
inline void AcctSectResp::set_officialnickname(::std::string&& value) {
  set_has_officialnickname();
  officialnickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AcctSectResp.OfficialNickName)
}
#endif
inline void AcctSectResp::set_officialnickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_officialnickname();
  officialnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AcctSectResp.OfficialNickName)
}
inline void AcctSectResp::set_officialnickname(const char* value, size_t size) {
  set_has_officialnickname();
  officialnickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AcctSectResp.OfficialNickName)
}
inline ::std::string* AcctSectResp::mutable_officialnickname() {
  set_has_officialnickname();
  // @@protoc_insertion_point(field_mutable:micromsg.AcctSectResp.OfficialNickName)
  return officialnickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcctSectResp::release_officialnickname() {
  // @@protoc_insertion_point(field_release:micromsg.AcctSectResp.OfficialNickName)
  clear_has_officialnickname();
  return officialnickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcctSectResp::set_allocated_officialnickname(::std::string* officialnickname) {
  if (officialnickname != NULL) {
    set_has_officialnickname();
  } else {
    clear_has_officialnickname();
  }
  officialnickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), officialnickname);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AcctSectResp.OfficialNickName)
}

// optional uint32 PushMailStatus = 15;
inline bool AcctSectResp::has_pushmailstatus() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AcctSectResp::set_has_pushmailstatus() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AcctSectResp::clear_has_pushmailstatus() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AcctSectResp::clear_pushmailstatus() {
  pushmailstatus_ = 0u;
  clear_has_pushmailstatus();
}
inline ::google::protobuf::uint32 AcctSectResp::pushmailstatus() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.PushMailStatus)
  return pushmailstatus_;
}
inline void AcctSectResp::set_pushmailstatus(::google::protobuf::uint32 value) {
  set_has_pushmailstatus();
  pushmailstatus_ = value;
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.PushMailStatus)
}

// optional string FSURL = 16;
inline bool AcctSectResp::has_fsurl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AcctSectResp::set_has_fsurl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AcctSectResp::clear_has_fsurl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AcctSectResp::clear_fsurl() {
  fsurl_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fsurl();
}
inline const ::std::string& AcctSectResp::fsurl() const {
  // @@protoc_insertion_point(field_get:micromsg.AcctSectResp.FSURL)
  return fsurl_.GetNoArena();
}
inline void AcctSectResp::set_fsurl(const ::std::string& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:micromsg.AcctSectResp.FSURL)
}
#if LANG_CXX11
inline void AcctSectResp::set_fsurl(::std::string&& value) {
  set_has_fsurl();
  fsurl_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:micromsg.AcctSectResp.FSURL)
}
#endif
inline void AcctSectResp::set_fsurl(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:micromsg.AcctSectResp.FSURL)
}
inline void AcctSectResp::set_fsurl(const char* value, size_t size) {
  set_has_fsurl();
  fsurl_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:micromsg.AcctSectResp.FSURL)
}
inline ::std::string* AcctSectResp::mutable_fsurl() {
  set_has_fsurl();
  // @@protoc_insertion_point(field_mutable:micromsg.AcctSectResp.FSURL)
  return fsurl_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AcctSectResp::release_fsurl() {
  // @@protoc_insertion_point(field_release:micromsg.AcctSectResp.FSURL)
  clear_has_fsurl();
  return fsurl_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AcctSectResp::set_allocated_fsurl(::std::string* fsurl) {
  if (fsurl != NULL) {
    set_has_fsurl();
  } else {
    clear_has_fsurl();
  }
  fsurl_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fsurl);
  // @@protoc_insertion_point(field_set_allocated:micromsg.AcctSectResp.FSURL)
}

// -------------------------------------------------------------------

// UnifyAuthResponse

// required .micromsg.BaseResponse BaseResponse = 1;
inline bool UnifyAuthResponse::has_baseresponse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnifyAuthResponse::set_has_baseresponse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnifyAuthResponse::clear_has_baseresponse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnifyAuthResponse::clear_baseresponse() {
  if (baseresponse_ != NULL) baseresponse_->::micromsg::BaseResponse::Clear();
  clear_has_baseresponse();
}
inline const ::micromsg::BaseResponse& UnifyAuthResponse::baseresponse() const {
  // @@protoc_insertion_point(field_get:micromsg.UnifyAuthResponse.BaseResponse)
  return baseresponse_ != NULL ? *baseresponse_
                         : *::micromsg::BaseResponse::internal_default_instance();
}
inline ::micromsg::BaseResponse* UnifyAuthResponse::mutable_baseresponse() {
  set_has_baseresponse();
  if (baseresponse_ == NULL) {
    baseresponse_ = new ::micromsg::BaseResponse;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UnifyAuthResponse.BaseResponse)
  return baseresponse_;
}
inline ::micromsg::BaseResponse* UnifyAuthResponse::release_baseresponse() {
  // @@protoc_insertion_point(field_release:micromsg.UnifyAuthResponse.BaseResponse)
  clear_has_baseresponse();
  ::micromsg::BaseResponse* temp = baseresponse_;
  baseresponse_ = NULL;
  return temp;
}
inline void UnifyAuthResponse::set_allocated_baseresponse(::micromsg::BaseResponse* baseresponse) {
  delete baseresponse_;
  baseresponse_ = baseresponse;
  if (baseresponse) {
    set_has_baseresponse();
  } else {
    clear_has_baseresponse();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UnifyAuthResponse.BaseResponse)
}

// optional uint32 UnifyAuthSectFlag = 2;
inline bool UnifyAuthResponse::has_unifyauthsectflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UnifyAuthResponse::set_has_unifyauthsectflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UnifyAuthResponse::clear_has_unifyauthsectflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UnifyAuthResponse::clear_unifyauthsectflag() {
  unifyauthsectflag_ = 0u;
  clear_has_unifyauthsectflag();
}
inline ::google::protobuf::uint32 UnifyAuthResponse::unifyauthsectflag() const {
  // @@protoc_insertion_point(field_get:micromsg.UnifyAuthResponse.UnifyAuthSectFlag)
  return unifyauthsectflag_;
}
inline void UnifyAuthResponse::set_unifyauthsectflag(::google::protobuf::uint32 value) {
  set_has_unifyauthsectflag();
  unifyauthsectflag_ = value;
  // @@protoc_insertion_point(field_set:micromsg.UnifyAuthResponse.UnifyAuthSectFlag)
}

// optional .micromsg.AuthSectResp AuthSectResp = 3;
inline bool UnifyAuthResponse::has_authsectresp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnifyAuthResponse::set_has_authsectresp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnifyAuthResponse::clear_has_authsectresp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnifyAuthResponse::clear_authsectresp() {
  if (authsectresp_ != NULL) authsectresp_->::micromsg::AuthSectResp::Clear();
  clear_has_authsectresp();
}
inline const ::micromsg::AuthSectResp& UnifyAuthResponse::authsectresp() const {
  // @@protoc_insertion_point(field_get:micromsg.UnifyAuthResponse.AuthSectResp)
  return authsectresp_ != NULL ? *authsectresp_
                         : *::micromsg::AuthSectResp::internal_default_instance();
}
inline ::micromsg::AuthSectResp* UnifyAuthResponse::mutable_authsectresp() {
  set_has_authsectresp();
  if (authsectresp_ == NULL) {
    authsectresp_ = new ::micromsg::AuthSectResp;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UnifyAuthResponse.AuthSectResp)
  return authsectresp_;
}
inline ::micromsg::AuthSectResp* UnifyAuthResponse::release_authsectresp() {
  // @@protoc_insertion_point(field_release:micromsg.UnifyAuthResponse.AuthSectResp)
  clear_has_authsectresp();
  ::micromsg::AuthSectResp* temp = authsectresp_;
  authsectresp_ = NULL;
  return temp;
}
inline void UnifyAuthResponse::set_allocated_authsectresp(::micromsg::AuthSectResp* authsectresp) {
  delete authsectresp_;
  authsectresp_ = authsectresp;
  if (authsectresp) {
    set_has_authsectresp();
  } else {
    clear_has_authsectresp();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UnifyAuthResponse.AuthSectResp)
}

// optional .micromsg.AcctSectResp AcctSectResp = 4;
inline bool UnifyAuthResponse::has_acctsectresp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnifyAuthResponse::set_has_acctsectresp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnifyAuthResponse::clear_has_acctsectresp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnifyAuthResponse::clear_acctsectresp() {
  if (acctsectresp_ != NULL) acctsectresp_->::micromsg::AcctSectResp::Clear();
  clear_has_acctsectresp();
}
inline const ::micromsg::AcctSectResp& UnifyAuthResponse::acctsectresp() const {
  // @@protoc_insertion_point(field_get:micromsg.UnifyAuthResponse.AcctSectResp)
  return acctsectresp_ != NULL ? *acctsectresp_
                         : *::micromsg::AcctSectResp::internal_default_instance();
}
inline ::micromsg::AcctSectResp* UnifyAuthResponse::mutable_acctsectresp() {
  set_has_acctsectresp();
  if (acctsectresp_ == NULL) {
    acctsectresp_ = new ::micromsg::AcctSectResp;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UnifyAuthResponse.AcctSectResp)
  return acctsectresp_;
}
inline ::micromsg::AcctSectResp* UnifyAuthResponse::release_acctsectresp() {
  // @@protoc_insertion_point(field_release:micromsg.UnifyAuthResponse.AcctSectResp)
  clear_has_acctsectresp();
  ::micromsg::AcctSectResp* temp = acctsectresp_;
  acctsectresp_ = NULL;
  return temp;
}
inline void UnifyAuthResponse::set_allocated_acctsectresp(::micromsg::AcctSectResp* acctsectresp) {
  delete acctsectresp_;
  acctsectresp_ = acctsectresp;
  if (acctsectresp) {
    set_has_acctsectresp();
  } else {
    clear_has_acctsectresp();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UnifyAuthResponse.AcctSectResp)
}

// optional .micromsg.NetworkSectResp NetworkSectResp = 5;
inline bool UnifyAuthResponse::has_networksectresp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnifyAuthResponse::set_has_networksectresp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnifyAuthResponse::clear_has_networksectresp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnifyAuthResponse::clear_networksectresp() {
  if (networksectresp_ != NULL) networksectresp_->::micromsg::NetworkSectResp::Clear();
  clear_has_networksectresp();
}
inline const ::micromsg::NetworkSectResp& UnifyAuthResponse::networksectresp() const {
  // @@protoc_insertion_point(field_get:micromsg.UnifyAuthResponse.NetworkSectResp)
  return networksectresp_ != NULL ? *networksectresp_
                         : *::micromsg::NetworkSectResp::internal_default_instance();
}
inline ::micromsg::NetworkSectResp* UnifyAuthResponse::mutable_networksectresp() {
  set_has_networksectresp();
  if (networksectresp_ == NULL) {
    networksectresp_ = new ::micromsg::NetworkSectResp;
  }
  // @@protoc_insertion_point(field_mutable:micromsg.UnifyAuthResponse.NetworkSectResp)
  return networksectresp_;
}
inline ::micromsg::NetworkSectResp* UnifyAuthResponse::release_networksectresp() {
  // @@protoc_insertion_point(field_release:micromsg.UnifyAuthResponse.NetworkSectResp)
  clear_has_networksectresp();
  ::micromsg::NetworkSectResp* temp = networksectresp_;
  networksectresp_ = NULL;
  return temp;
}
inline void UnifyAuthResponse::set_allocated_networksectresp(::micromsg::NetworkSectResp* networksectresp) {
  delete networksectresp_;
  networksectresp_ = networksectresp;
  if (networksectresp) {
    set_has_networksectresp();
  } else {
    clear_has_networksectresp();
  }
  // @@protoc_insertion_point(field_set_allocated:micromsg.UnifyAuthResponse.NetworkSectResp)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace micromsg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mmlogin_2eproto__INCLUDED
